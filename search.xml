<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>罗技遥控</title>
    <url>/blog/2021/11/03/Logitechcontrol/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_44793491/article/details/120494536?ops_request_misc=%7B%22request_id%22:%22163868705416780265496202%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163868705416780265496202&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-120494536.pc_search_mgc_flag&utm_term=%E7%BD%97%E6%8A%80f710%E6%89%8B%E6%9F%84+ubuntu%E9%A9%B1%E5%8A%A8&spm=1018.2226.3001.4187">罗技F310与F710游戏手柄驱动（附C++源码）_冬瓜-CSDN博客</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Logitech_controller.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define ----------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Logitech_DRIVER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Logitech_DRIVER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ---------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_A     0x001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_B     0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_X     0x201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_Y     0x301</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LB    0x401</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RB    0x501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_BACK  0x601</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_START 0x701</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_HOME  0x801</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LT 0x202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RT 0x502</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_X 0x602</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_Y 0x702</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LEFTSTICK_X 0x002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LEFTSTICK_Y 0x102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RIGHTSTICK_X 0x302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RIGHTSTICK_Y 0x402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_PRESS 0x001    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RELEASE 0x0    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_LOW_VALUE 0xffff8001 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_HIGH_VALUE 0x7fff   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logitech</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *dev;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Logitech(<span class="keyword">char</span>* device);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Keystate_map;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen_input</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_key_state</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//Logitech_DRIVER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Logitech_controller.c </span><br><span class="line">#include &quot;Logitech_controller.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Logitech::Logitech(char* device)</span><br><span class="line">&#123;</span><br><span class="line">    dev = device;</span><br><span class="line">    memset(buf, 0, sizeof buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Logitech::init()</span><br><span class="line">&#123;</span><br><span class="line">    fd = open(dev, O_RDONLY);</span><br><span class="line">    if (fd == -1) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Cannot open %s: %s.\n&quot;, dev, strerror(errno));</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    /*Key Status*/</span><br><span class="line"></span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_A] =0;</span><br><span class="line">    Keystate_map[JSKEY_B] =0;</span><br><span class="line">    Keystate_map[JSKEY_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_Y] =0;</span><br><span class="line"></span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_LB] =0;</span><br><span class="line">    Keystate_map[JSKEY_RB] =0;</span><br><span class="line">   </span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_BACK] =0;</span><br><span class="line">    Keystate_map[JSKEY_START] =0;</span><br><span class="line">    Keystate_map[JSKEY_HOME] =0;</span><br><span class="line">    </span><br><span class="line">    /*  0 is released */</span><br><span class="line">    /* -1 is the left or up button is pressed */</span><br><span class="line">    /*  1 is the right or down button is pressed*/</span><br><span class="line">    Keystate_map[JSKEY_CROSS_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_CROSS_Y] =0;</span><br><span class="line"></span><br><span class="line">    /* the result is the value of the key(0~99)*/</span><br><span class="line">    Keystate_map[JSKEY_LT] =0;</span><br><span class="line">    Keystate_map[JSKEY_RT] =0;</span><br><span class="line"></span><br><span class="line">    /* the result is the value of the key(-100~100)*/</span><br><span class="line">    Keystate_map[JSKEY_LEFTSTICK_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_LEFTSTICK_Y] =0;</span><br><span class="line">    Keystate_map[JSKEY_RIGHTSTICK_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_RIGHTSTICK_Y] =0;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logitech::listen_input()</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        memset(buf, 0, sizeof buf);</span><br><span class="line">        n = read(fd, &amp;buf, sizeof buf);</span><br><span class="line">        n = n / sizeof(int);</span><br><span class="line">        if (n == (ssize_t)-1) &#123;</span><br><span class="line">            if (errno == EINTR)</span><br><span class="line">                continue;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unsigned short btn = buf[1] &gt;&gt; 16;</span><br><span class="line">        short val = (short)(buf[1] &amp; 0xffff);</span><br><span class="line"></span><br><span class="line">         /*Test for button ID*/</span><br><span class="line">         //cout&lt;&lt;&quot;0x&quot;&lt;&lt;hex&lt;&lt;btn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if (btn == JSKEY_LT || btn == JSKEY_RT)</span><br><span class="line">        &#123;</span><br><span class="line">            unsigned short prs_val = val + 32768;</span><br><span class="line">            val = (unsigned short) (((long)prs_val)*100/65536);</span><br><span class="line">            Keystate_map[btn]= val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (btn == JSKEY_LEFTSTICK_X || btn == JSKEY_LEFTSTICK_Y ||</span><br><span class="line">                 btn == JSKEY_RIGHTSTICK_X || btn == JSKEY_RIGHTSTICK_Y)</span><br><span class="line">        &#123;</span><br><span class="line">            /* y-axis reverse */</span><br><span class="line">            if(btn==JSKEY_LEFTSTICK_Y||btn == JSKEY_RIGHTSTICK_Y)</span><br><span class="line">            &#123;val=(-1)*val;&#125;</span><br><span class="line">            val = val*100/32767;</span><br><span class="line">            Keystate_map[btn]= val;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            switch (val)</span><br><span class="line">            &#123;</span><br><span class="line">            case JSKEY_PRESS:</span><br><span class="line">                Keystate_map[btn]=1;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_RELEASE:</span><br><span class="line">                Keystate_map[btn]=0;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_CROSS_LOW_VALUE:</span><br><span class="line">                Keystate_map[btn]=-1;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_CROSS_HIGH_VALUE:</span><br><span class="line">                Keystate_map[btn]=1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            /* y-axis reverse */</span><br><span class="line">            if(btn==JSKEY_CROSS_Y)</span><br><span class="line">            &#123;Keystate_map[btn]=(-1)*Keystate_map[btn];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_key_state();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logitech::print_key_state()</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_A = &quot;&lt;&lt;Keystate_map[JSKEY_A]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_B = &quot;&lt;&lt;Keystate_map[JSKEY_B]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_X = &quot;&lt;&lt;Keystate_map[JSKEY_X]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_Y = &quot;&lt;&lt;Keystate_map[JSKEY_Y]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LB = &quot;&lt;&lt;Keystate_map[JSKEY_LB]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RB = &quot;&lt;&lt;Keystate_map[JSKEY_RB]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_BACK = &quot;&lt;&lt;Keystate_map[JSKEY_BACK]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_START = &quot;&lt;&lt;Keystate_map[JSKEY_START]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_HOME = &quot;&lt;&lt;Keystate_map[JSKEY_HOME]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LT = &quot;&lt;&lt;Keystate_map[JSKEY_LT]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RT = &quot;&lt;&lt;Keystate_map[JSKEY_RT]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_CROSS_X = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_X]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_CROSS_Y = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_Y]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LEFTSTICK_X  = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_X] &lt;&lt;&quot;     JSKEY_LEFTSTICK_Y   = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_Y]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RIGHTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_X]&lt;&lt;&quot;     JSKEY_RIGHTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_Y]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.cpp</span><br><span class="line">#include &quot;Logitech_controller.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char path[] = &quot;/dev/input/js0&quot;;</span><br><span class="line">    Logitech gamepad(path);</span><br><span class="line"></span><br><span class="line">    gamepad.init();</span><br><span class="line">    gamepad.listen_input();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>!注意:由于不同遥控对于io定义不同,所以需要改动一下**<code>Logitech_controller.h</code><strong>中的</strong><code>#define</code>**</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>0ohm电阻作用</title>
    <url>/blog/2021/12/11/0ohm%E7%94%B5%E9%98%BB%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<p>零欧姆电阻的主要作用有如下：</p>
<p>1,在电路中没有任何功能，只是在PCB上为了调试方便或兼容设计等原因。<br>2,可以做跳线用，如果某段线路不用，直接不贴该电阻即可（不影响外观）。<br>3,在匹配电路参数不确定的时候，以0欧姆代替，实际调试的时候，确定参数，再以具体数值的元件代替。<br>4,想测某部分电路的耗电流的时候，可以去掉0ohm电阻，接上电流表，这样方便测耗电流。<br>5,在布线时,如果实在布不过去了,也可以加一个0欧的电阻。<br>6,在高频信号下，充当电感或电容。（与外部电路特性有关）电感用，主要是解决EMC问题。如地与地，电源和IC Pin间。<br>7,单点接地（指保护接地、工作接地、直流接地在设备上相互分开,各自成为独立系统。）<br>8,熔丝作用；<br>9，单点接地，只要是地，最终都要接到一起，然后入大地。如果不接在一起就是”浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上有四种方法解决此问题：1、用磁珠连接；2、用电容连接；3、用电感连接；4、用0欧姆电阻连接。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。电容隔直通交，造成浮地。电感体积大，杂散参数多，不稳定。0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。<br>10，跨接时用于电流回路，当分割电地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。<br>11，配置电路，一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子。空置跳线在高频时相当于天线，用贴片电阻效果好。<br>12，其他用途，布线时跨线；调试/测试用；临时取代其他贴片器件；作为温度补偿器件；更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔）。</p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP服务</title>
    <url>/blog/2021/11/23/FTP/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ncut_wxj/article/details/106198896?ops_request_misc=%7B%22request_id%22:%22163767320116780264025266%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767320116780264025266&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-106198896.pc_search_mgc_flag&utm_term=ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85ftp&spm=1018.2226.3001.4187">在虚拟机的Ubuntu上部署FTP服务器_ncut_wxj的博客-CSDN博客</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example config file /etc/vsftpd.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># The default compiled in settings are fairly paranoid. This sample file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> loosens things up a bit, to make the ftp daemon more usable.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please see vsftpd.conf.5 <span class="keyword">for</span> all compiled <span class="keyword">in</span> defaults.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># READ THIS: This example file is NOT an exhaustive list of vsftpd options.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Please <span class="built_in">read</span> the vsftpd.conf.5 manual page to get a full idea of vsftpd<span class="string">&#x27;s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> capabilities.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Run standalone?  vsftpd can run either from an inetd or as a standalone</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> daemon started from an initscript.</span></span></span><br><span class="line">listen=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This directive enables listening on IPv6 sockets. By default, listening</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sockets. If you want that (perhaps because you want to listen on specific</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> addresses) then you must run two copies of vsftpd with two configuration</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> files.</span></span></span><br><span class="line">listen_ipv6=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Allow anonymous FTP? (Disabled by default).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">这个是设置是否允许匿名登录ftp服务器，不允许。</span></span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to allow local users to log in.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">是否允许本机用户登录</span></span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to enable any form of FTP write command.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">允许上传文件到ftp服务器</span></span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Default umask for local users is 077. You may wish to change this to 022,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> if your users expect that (022 is used by most other ftpd&#x27;</span>s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">local_umask=022</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Uncomment this to allow the anonymous FTP user to upload files. This only</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> has an effect <span class="keyword">if</span> the above global write <span class="built_in">enable</span> is activated. Also, you will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> obviously need to create a directory writable by the FTP user.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Uncomment this if you want the anonymous FTP user to be able to create</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> new directories.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Activate directory messages - messages given to remote users when they</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go into a certain directory.</span></span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If enabled, vsftpd will display directory listings with the time</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span>  your  <span class="built_in">local</span>  time  zone.  The default is to display GMT. The</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">times</span> returned by the MDTM FTP <span class="built_in">command</span> are also affected by this</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> option.</span></span><br><span class="line">use_localtime=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Activate logging of uploads/downloads.</span></span></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Make sure PORT transfer connections originate from port 20 (ftp-data).</span></span></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If you want, you can arrange for uploaded anonymous files to be owned by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a different user. Note! Using <span class="string">&quot;root&quot;</span> <span class="keyword">for</span> uploaded files is not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> recommended!</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown_username=whoever</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may override where the log file goes if you like. The default is shown</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> below.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">xferlog_file=/var/<span class="built_in">log</span>/vsftpd.log</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If you want, you can have your log file in standard ftpd xferlog format.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that the default <span class="built_in">log</span> file location is /var/<span class="built_in">log</span>/xferlog <span class="keyword">in</span> this <span class="keyword">case</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">xferlog_std_format=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may change the default value for timing out an idle session.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">idle_session_timeout=600</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may change the default value for timing out a data connection.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">data_connection_timeout=120</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># It is recommended that you define on your system a unique user which the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ftp server can use as a totally isolated and unprivileged user.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">nopriv_user=ftpsecure</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Enable this and the server will recognise asynchronous ABOR requests. Not</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> recommended <span class="keyword">for</span> security (the code is non-trivial). Not enabling it,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> however, may confuse older FTP clients.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">async_abor_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># By default the server will pretend to allow ASCII mode but in fact ignore</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the request. Turn on the below options to have the server actually <span class="keyword">do</span> ASCII</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mangling on files when <span class="keyword">in</span> ASCII mode.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Beware that on some FTP servers, ASCII support allows a denial of service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> attack (DoS) via the <span class="built_in">command</span> <span class="string">&quot;SIZE /big/file&quot;</span> <span class="keyword">in</span> ASCII mode. vsftpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> predicted this attack and has always been safe, reporting the size of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> raw file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ASCII mangling is a horrible feature of the protocol.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ascii_upload_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ascii_download_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may fully customise the login banner string:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ftpd_banner=Welcome to blah FTP service.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may specify a file of disallowed anonymous e-mail addresses. Apparently</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useful <span class="keyword">for</span> combatting certain DoS attacks.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deny_email_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (default follows)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">banned_email_file=/etc/vsftpd.banned_emails</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may restrict local users to their home directories.  See the FAQ for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the possible risks <span class="keyword">in</span> this before using chroot_local_user or</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chroot_list_enable below.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chroot_local_user=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may specify an explicit list of local users to chroot() to their home</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directory. If chroot_local_user is YES, <span class="keyword">then</span> this list becomes a list of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> users to NOT chroot().</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (Warning! chroot<span class="string">&#x27;ing can be very dangerous. If using chroot, make sure that</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> the user does not have write access to the top level directory within the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> chroot)</span></span></span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> (default follows) 允许chroot_list文件中配置的用户登录此ftp服务器。</span></span></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> default to avoid remote users being able to cause excessive I/O on large</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">ls_recurse_enable=YES</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Customization</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Some of vsftpd&#x27;</span>s settings don<span class="string">&#x27;t fit the filesystem layout by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> default.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This option should be the name of a directory which is empty.  Also, the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> directory should not be writable by the ftp user. This directory is used</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> as a secure chroot() jail at times vsftpd does not require filesystem</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> access.</span></span></span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This string is the name of the PAM service vsftpd will use.</span></span></span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This option specifies the location of the RSA certificate to use for SSL</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> encrypted connections.</span></span></span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">ssl_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to indicate that vsftpd use a utf8 filesystem.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">utf8_filesystem=YES</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">配置ftp服务器的上传下载文件所在的目录。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">这个地址中的 “/home/python” 是这个Ubuntu系统的用户主目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">它的用户名叫 “python”，文件夹 “ftpfile” 是后来创建的</span></span></span><br><span class="line">local_root=/home/python/ftpfile</span><br></pre></td></tr></table></figure>

<h1 id="给ftp服务器配置使用用户等信息"><a href="#给ftp服务器配置使用用户等信息" class="headerlink" title="给ftp服务器配置使用用户等信息"></a>给ftp服务器配置使用用户等信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">ftp_user</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="文件夹内输入"><a href="#文件夹内输入" class="headerlink" title="文件夹内输入"></a>文件夹内输入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp:/192.168.xx.xx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebooks</title>
    <url>/blog/2021/11/03/Jupyter/</url>
    <content><![CDATA[<h1 id="安装Jupyter"><a href="#安装Jupyter" class="headerlink" title="安装Jupyter"></a>安装Jupyter</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install jupyter # 或 pip install jupyter</span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu下使用jupyter"><a href="#Ubuntu下使用jupyter" class="headerlink" title="Ubuntu下使用jupyter"></a>Ubuntu下使用jupyter</h1><p><a href="https://blog.csdn.net/qq_31347869/article/details/88049014?ops_request_misc=%7B%22request_id%22:%22163767267616780264096453%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767267616780264096453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88049014.pc_search_mgc_flag&utm_term=ubuntu%E4%BD%BF%E7%94%A8jupyter&spm=1018.2226.3001.4187">Ubuntu 下 Jupyter 的使用_yaoyz105-CSDN博客</a></p>
<h1 id="Vscode使用jupyter"><a href="#Vscode使用jupyter" class="headerlink" title="Vscode使用jupyter"></a>Vscode使用jupyter</h1><p><a href="https://blog.csdn.net/mogoweb/article/details/103248829?ops_request_misc=%7B%22request_id%22:%22163767211116780269884950%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767211116780269884950&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-103248829.pc_search_mgc_flag&utm_term=vscode+jupyter&spm=1018.2226.3001.4187">在VS Code中编写Jupyter Notebook_云水木石-CSDN博客</a></p>
<h1 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h1><p><a href="https://blog.csdn.net/qq_33619378/article/details/83037106?ops_request_misc=%7B%22request_id%22:%22163678378316780265426611%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163678378316780265426611&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83037106.pc_search_mgc_flag&utm_term=jupyter&spm=1018.2226.3001.4187">Jupyter Notebooks的安装和使用介绍_LarsCheng’s Blog-CSDN博客</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>RTOS多任务访问同一个UART的操作方法</title>
    <url>/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q">RTOS多任务访问同一个UART的操作方法</a></p>
<p>在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。</p>
<p>处理“混乱”局面的方法比较多，下面基于<strong>FreeRTOS</strong>，以UART为例讲讲常见的<em><strong>互斥</strong></em>、<em><strong>队列</strong></em>这两种方法。</p>
<h3 id="互斥访问方法"><a href="#互斥访问方法" class="headerlink" title="互斥访问方法"></a><strong>互斥访问方法</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建互斥量资源</span></span><br><span class="line">SemaphoreHandle_t xSemaphore = <span class="literal">NULL</span>;</span><br><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//占用资源</span></span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xSemaphore, <span class="number">10</span> ) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//使用资源(发送数据)</span></span><br><span class="line">      USART_SendNByte();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      xSemaphoreGive(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>信号量与互斥量区别</strong>：</p>
<p><strong>信号量</strong>：多个任务同步使用某个资源；</p>
<p>一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作；</p>
<p><strong>互斥量</strong>：多任务互斥使用某个资源；</p>
<p>一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源；</p>
<h3 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a><strong>队列操作方法</strong></h3><p>队列操作方法就是FIFO，先入先出的原理。比如：<strong>任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t xQueue;</span><br><span class="line">xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);</span><br><span class="line"></span><br><span class="line">xTaskCreate(UART_Send_Task, <span class="string">&quot;UART_Send&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, TASK_PRIORITY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskA_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskB_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_Send_Task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//循环读取队列BUF</span></span><br><span class="line">    <span class="keyword">if</span>(xQueueReceive(xQueue, &amp;Buf, <span class="number">10</span>) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      USART_SendNByte(&amp;Buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>STL库</title>
    <url>/blog/2021/10/28/STL/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%7B%22request_id%22:%22163533629716780357269545%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163533629716780357269545&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81913729.pc_search_ecpm_flag&utm_term=c+++stl&spm=1018.2226.3001.4187">C++中STL用法超详细总结</a></p>
<p><a href="https://github.com/peitianyu/MyTinySTL.git">MyTinySTL</a></p>
<h2 id="STL中六大组件："><a href="#STL中六大组件：" class="headerlink" title="STL中六大组件："></a>STL中六大组件：</h2><p><strong>容器（Container）</strong>，是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p>
<p><strong>迭代器（Iterator）</strong>，提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；<br><strong>算法（Algorithm）</strong>，是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；<br><strong>仿函数（Functor</strong>）<br><strong>适配器（Adaptor）</strong><br><strong>分配器（allocator</strong>）</p>
<h3 id="2-1-容器"><a href="#2-1-容器" class="headerlink" title="2.1 容器"></a>2.1 容器</h3><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       <strong>Vector</strong>：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>Deque</strong>：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>List</strong>：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       <strong>Set/Multiset</strong>：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       <strong>Map/Multimap</strong>：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>容器类自动申请和释放内存，无需new和delete操作。</p>
<h3 id="2-2-STL迭代器"><a href="#2-2-STL迭代器" class="headerlink" title="2.2 STL迭代器"></a>2.2 STL迭代器</h3><p><strong>Iterator</strong>（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p><strong>迭代器的作用</strong>：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p>
<h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h3><h4 id="STL中算法大致分为四类："><a href="#STL中算法大致分为四类：" class="headerlink" title="STL中算法大致分为四类："></a>STL中算法大致分为四类：</h4><p><strong>非可变序列算法</strong>：指不直接修改其所操作的容器内容的算法。<br><strong>可变序列算法</strong>：指可以修改它们所操作的容器内容的算法。<br><strong>排序算法</strong>：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。<br><strong>数值算法</strong>：对容器内容进行数值计算。<br>以下对所有算法进行细致分类并标明功能：</p>
<h4 id="lt-一-gt-查找算法-13个-：判断容器中是否包含某个值"><a href="#lt-一-gt-查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值"></a>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</h4><p>adjacent_find:   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的                                                 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>count:                利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>count_if:            利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>equal_range:     功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。<br>find:                   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的                               一个InputIterator。<br>find_end:          在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一                            个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代                               替等于操作。<br>find_first_of:     在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使                             用了用户自定义操作符。<br>find_if:               使用输入的函数代替等于操作符执行find。<br>lower_bound:   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函                             数使用自定义比较操作。<br>upper_bound:  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志                               一个大于value的值。重载函数使用自定义比较操作。<br>search:              给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位                                 置，查找失败指向last1。重载版本使用自定义的比较操作。<br>search_n:          在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p>
<h4 id="lt-二-gt-排序和通用算法-14个-：提供元素排序策略"><a href="#lt-二-gt-排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="&lt;二&gt;排序和通用算法(14个)：提供元素排序策略"></a>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</h4><p>inplace_merge:      合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>merge:                    合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>nth_element:          将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重                                    载版本使用自定义的比较操作。<br>partial_sort:            对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>partition:                 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>random_shuffle:    对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>reverse:                  将指定范围内元素重新反序排序。<br>reverse_copy:        与reverse类似，不过将结果写入另一个容器。<br>rotate:                     将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>rotate_copy:           与rotate类似，不过将结果写入另一个容器。<br>sort:                         以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>stable_sort:            与sort类似，不过保留相等元素之间的顺序关系。<br>stable_partition:    与partition类似，不过不保证保留容器中的相对顺序。</p>
<h4 id="lt-三-gt-删除和替换算法-15个"><a href="#lt-三-gt-删除和替换算法-15个" class="headerlink" title="&lt;三&gt;删除和替换算法(15个)"></a>&lt;三&gt;删除和替换算法(15个)</h4><p>copy:                    复制序列<br>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>iter_swap:           交换两个ForwardIterator的值。<br>remove:               删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和                               remove_if函数。<br>remove_copy:     将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>remove_if:           删除指定范围内输入操作结果为true的所有元素。<br>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>replace:               将指定范围内所有等于vold的元素都用vnew代替。<br>replace_copy:     与replace类似，不过将结果写入另一个容器。<br>replace_if:           将指定范围内所有操作结果为true的元素用新值代替。<br>replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>swap:                   交换存储在两个对象中的值。<br>swap_range:       将指定范围内的元素与另一个序列元素值进行交换。<br>unique:                清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>unique_copy:      与unique类似，不过把结果输出到另一个容器。</p>
<h4 id="lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合"><a href="#lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合" class="headerlink" title="&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合"></a>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</h4><p>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p>
<h4 id="lt-五-gt-算术算法-4个"><a href="#lt-五-gt-算术算法-4个" class="headerlink" title="&lt;五&gt;算术算法(4个)"></a>&lt;五&gt;算术算法(4个)</h4><p>accumulate:               iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>partial_sum:               创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>inner_product:           对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p>
<h4 id="lt-六-gt-生成和异变算法-6个"><a href="#lt-六-gt-生成和异变算法-6个" class="headerlink" title="&lt;六&gt;生成和异变算法(6个)"></a>&lt;六&gt;生成和异变算法(6个)</h4><p>fill:                 将输入值赋给标志范围内的所有元素。<br>fill_n:            将输入值赋给first到first+n范围内的所有元素。<br>for_each:      用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>generate:      连续调用输入的函数来填充指定的范围。<br>generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>transform:    将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p>
<h4 id="lt-七-gt-关系算法-8个"><a href="#lt-七-gt-关系算法-8个" class="headerlink" title="&lt;七&gt;关系算法(8个)"></a>&lt;七&gt;关系算法(8个)</h4><p>equal:                                  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>includes:                             判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>max:                                     返回两个元素中较大一个。重载版本使用自定义比较操作。<br>max_element:                      返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>min:                                      返回两个元素中较小一个。重载版本使用自定义比较操作。<br>min_element:                       返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>mismatch:                            并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p>
<h4 id="lt-八-gt-集合算法-4个"><a href="#lt-八-gt-集合算法-4个" class="headerlink" title="&lt;八&gt;集合算法(4个)"></a>&lt;八&gt;集合算法(4个)</h4><p>set_union:                            构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>set_intersection:                 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>set_difference:                    构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用 自定义的比较操作。<br>set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</p>
<h4 id="lt-九-gt-堆算法-4个"><a href="#lt-九-gt-堆算法-4个" class="headerlink" title="&lt;九&gt;堆算法(4个)"></a>&lt;九&gt;堆算法(4个)</h4><p>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>pop_heap:   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>sort_heap:  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p>
<h3 id="2-4-仿函数"><a href="#2-4-仿函数" class="headerlink" title="2.4 仿函数"></a>2.4 仿函数</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><pre><code>    仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。
</code></pre>
<p>　　有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。</p>
<pre><code>   1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。

   2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。
</code></pre>
<h4 id="2-4-2-仿函数-functor-在编程语言中的应用"><a href="#2-4-2-仿函数-functor-在编程语言中的应用" class="headerlink" title="2.4.2 仿函数(functor)在编程语言中的应用"></a>2.4.2 仿函数(functor)在编程语言中的应用</h4><p>1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//int sort_function( const void *a, const void *b);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> list[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line">   <span class="built_in">qsort</span>((<span class="keyword">void</span> *)list, <span class="number">5</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(list[<span class="number">0</span>]), sort_function);<span class="comment">//起始地址，个数，元素大小，回调函数 </span></span><br><span class="line">   <span class="keyword">int</span>  x;</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, list[x]);</span><br><span class="line">			      </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	for_each(ia, ia + <span class="number">5</span>, display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-仿函数在STL中的定义"><a href="#2-4-3-仿函数在STL中的定义" class="headerlink" title="2.4.3 仿函数在STL中的定义"></a>2.4.3 仿函数在STL中的定义</h4><p>要使用STL内建的仿函数，必须包含<functional>头文件。而头文件中包含的仿函数分类包括</p>
<pre><code>1）算术类仿函数
    加：plus&lt;T&gt;
    减：minus&lt;T&gt;
    乘：multiplies&lt;T&gt;
    除：divides&lt;T&gt;
    模取：modulus&lt;T&gt;
    否定：negate&lt;T&gt;
</code></pre>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="comment">//120</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>, multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//15</span></span><br><span class="line">	cout &lt;&lt; multiplies&lt;<span class="keyword">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	modulus&lt;<span class="keyword">int</span>&gt;  modulusObj;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">modulusObj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2）关系运算类仿函数</p>
<pre><code>           等于：equal_to&lt;T&gt;

           不等于：not_equal_to&lt;T&gt;

           大于：greater&lt;T&gt;

           大于等于：greater_equal&lt;T&gt;

           小于：less&lt;T&gt;

           小于等于：less_equal&lt;T&gt;

          从大到小排序：
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">sort</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3）逻辑运算仿函数</p>
<pre><code>             逻辑与：logical_and&lt;T&gt;

             逻辑或：logical_or&lt;T&gt;

             逻辑否：logical_no&lt;T&gt;
</code></pre>
<p>除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结</p>
<h3 id="2-5-容器适配器"><a href="#2-5-容器适配器" class="headerlink" title="2.5 容器适配器"></a>2.5 容器适配器</h3><p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p>
<p>什么是容器适配器<br>   ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例        如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出      了栈的行为）。</p>
<p>容器适配器<br>   要使用适配器，需要加入一下头文件：</p>
<pre><code>#include &lt;stack&gt;        //stack
#include&lt;queue&gt;       //queue、priority_queue
</code></pre>
<p>种类    默认顺序容器    可用顺序容器    说明<br>stack    deque    vector、list、deque<br>queue    deque    list、deque    基础容器必须提供push_front()运算<br>priority_queue    vector    vector、deque    基础容器必须提供随机访问功能<br>定义适配器<br>  1、初始化</p>
<pre><code>    stack&lt;int&gt; stk(dep);
</code></pre>
<p>  2、覆盖默认容器类型</p>
<pre><code>   stack&lt;int,vector&lt;int&gt; &gt; stk;
</code></pre>
<p>使用适配器</p>
<h4 id="2-5-1-stack"><a href="#2-5-1-stack" class="headerlink" title="2.5.1 stack"></a>2.5.1 stack</h4><p>stack<int> s;<br>stack&lt; int, vector<int> &gt; stk;  //覆盖基础容器类型，使用vector实现stk<br>s.empty();  //判断stack是否为空，为空返回true，否则返回false<br>s.size();   //返回stack中元素的个数<br>s.pop();    //删除栈顶元素，但不返回其值<br>s.top();    //返回栈顶元素的值，但不删除此元素<br>s.push(item);   //在栈顶压入新元素item<br>实例：括号匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	stack&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s)  <span class="comment">//C++11新标准，即遍历一次字符串s</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ss.<span class="built_in">push</span>(c);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; ss.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;					</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; <span class="string">&quot;Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;Not Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-queue-amp-priority-queue"><a href="#2-5-2-queue-amp-priority-queue" class="headerlink" title="2.5.2 queue &amp; priority_queue"></a>2.5.2 queue &amp; priority_queue</h4><p>queue<int> q; //priority_queue<int> q;<br>q.empty();  //判断队列是否为空<br>q.size();   //返回队列长度<br>q.push(item);   //对于queue，在队尾压入一个新元素<br>               //对于priority_queue，在基于优先级的适当位置插入新元素</p>
<p>//queue only:<br>q.front();  //返回队首元素的值，但不删除该元素<br>q.back();   //返回队尾元素的值，但不删除该元素</p>
<p>//priority_queue only:<br>q.top();    //返回具有最高优先级的元素值，但不删除该元素</p>
<h2 id="常用容器用法介绍"><a href="#常用容器用法介绍" class="headerlink" title="常用容器用法介绍"></a>常用容器用法介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h5><p>vector():创建一个空vector<br>vector(int nSize):创建一个vector,元素个数为nSize<br>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>vector(const vector&amp;):复制构造函数<br>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p>
<h5 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h5><p>void push_back(const T&amp; x):向量尾部增加一个元素X<br>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>
<h5 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h5><p>iterator erase(iterator it):删除向量中迭代器指向元素<br>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>void pop_back():删除向量中最后一个元素<br>void clear():清空向量中所有元素</p>
<h5 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h5><p>reference at(int pos):返回pos位置元素的引用<br>reference front():返回首元素的引用<br>reference back():返回尾元素的引用<br>iterator begin():返回向量头指针，指向第一个元素<br>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p>
<h5 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h5><p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p>
<h5 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h5><p>int size() const:返回向量中元素的个数<br>int capacity() const:返回当前向量张红所能容纳的最大元素值<br>int max_size() const:返回最大可允许的vector元素数量值</p>
<h5 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h5><p>void swap(vector&amp;):交换两个同类型向量的数据<br>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
<h5 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h5><p>1.push_back 在数组的最后添加一个数据</p>
<p>2.pop_back 去掉数组的最后一个数据</p>
<p>3.at 得到编号位置的数据</p>
<p>4.begin 得到数组头的指针</p>
<p>5.end 得到数组的最后一个单元+1的指针</p>
<p>6．front 得到数组头的引用</p>
<p>7.back 得到数组的最后一个单元的引用</p>
<p>8.max_size 得到vector最大可以是多大</p>
<p>9.capacity 当前vector分配的大小</p>
<p>10.size 当前使用数据的大小</p>
<p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p>
<p>12.reserve 改变当前vecotr所分配空间的大小</p>
<p>13.erase 删除指针指向的数据项</p>
<p>14.clear 清空当前的vector</p>
<p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p>
<p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p>
<p>17.empty 判断vector是否为空</p>
<p>18.swap 与另一个vector交换数据</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>#include &lt; vector&gt;<br>using namespace std;</p>
<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>Vector&lt;类型&gt;标识符<br>Vector&lt;类型&gt;标识符(最大容量)<br>Vector&lt;类型&gt;标识符(最大容量,初始所有值)<br>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值<br>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a>3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//去掉数组最后一个数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)<span class="comment">//size()容器中实际数据个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br><span class="line"></span><br><span class="line">0,1,2,3,4,</span><br></pre></td></tr></table></figure>

<h5 id="clear-清除容器中所有数据"><a href="#clear-清除容器中所有数据" class="headerlink" title="clear()清除容器中所有数据"></a>clear()清除容器中所有数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">clear</span>();<span class="comment">//清除容器中所以数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sort</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从小到大</span></span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从小到大:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从大到小:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从大到小 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从小到大:</span><br><span class="line">0,1,3,</span><br><span class="line"></span><br><span class="line">从大到小:</span><br><span class="line">3,1,0,</span><br></pre></td></tr></table></figure>

<p>1.注意 sort 需要头文件 #include <algorithm></p>
<p>2.如果想 sort 来降序，可重写 sort</p>
<p>bool compare(int a,int b)<br>{<br>    return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序<br>}<br>int a[20]={2,4,1,23,5,76,0,43,24,65},i;<br>for(i=0;i&lt;20;i++)<br>    cout&lt;&lt; a[i]&lt;&lt; endl;<br>sort(a,a+20,compare);</p>
<h5 id="访问（直接数组访问-amp-迭代器访问）"><a href="#访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="访问（直接数组访问&amp;迭代器访问）"></a>访问（直接数组访问&amp;迭代器访问）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序访问</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);   </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;直接利用数组：&quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//方法一 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;利用迭代器：&quot;</span> ;</span><br><span class="line">    <span class="comment">//方法二，使用迭代器将容器中数据输出 </span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.<span class="built_in">begin</span>();it!=obj.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接利用数组：0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">利用迭代器：0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h5 id="二维数组两种定义方法（结果一样）"><a href="#二维数组两种定义方法（结果一样）" class="headerlink" title="二维数组两种定义方法（结果一样）"></a>二维数组两种定义方法（结果一样）</h5><p>方法一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N, vector&lt;<span class="keyword">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">3.2 deque</span><br></pre></td></tr></table></figure>

<p>所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 </p>
<p>Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 </p>
<p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 </p>
<p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>#include<deque>  // 头文件<br>deque<type> deq;  // 声明一个元素类型为type的双端队列que<br>deque<type> deq(size);  // 声明一个类型为type、含有size个默认值初始化元素的的双端队列que<br>deque<type> deq(size, value);  // 声明一个元素类型为type、含有size个value元素的双端队列que<br>deque<type> deq(mydeque);  // deq是mydeque的一个副本<br>deque<type> deq(first, last);  // 使用迭代器first、last范围内的元素初始化deq</p>
<h4 id="deque的常用成员函数"><a href="#deque的常用成员函数" class="headerlink" title="deque的常用成员函数"></a>deque的常用成员函数</h4><p>deque<int> deq;<br>deq[ ]：用来访问双向队列中单个的元素。<br>deq.front()：返回第一个元素的引用。<br>deq.back()：返回最后一个元素的引用。<br>deq.push_front(x)：把元素x插入到双向队列的头部。<br>deq.pop_front()：弹出双向队列的第一个元素。<br>deq.push_back(x)：把元素x插入到双向队列的尾部。<br>deq.pop_back()：弹出双向队列的最后一个元素。</p>
<h4 id="deque的一些特点"><a href="#deque的一些特点" class="headerlink" title="deque的一些特点"></a>deque的一些特点</h4><p>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。<br>可以在内部进行插入和删除操作，但性能不及list。<br>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。<br>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。<br>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。<br>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。<br>deque不支持对容量和内存分配时机的控制。<br>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。<br>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。<br>deque不提供容量操作：capacity()和reverse()，但是vector可以。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;                                  <span class="comment">/*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/</span></span><br><span class="line">	q.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">front</span>());    <span class="comment">/*清除第一个元素后输出第一个(6)*/</span></span><br><span class="line">	q.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">back</span>());     <span class="comment">/*清除最后一个元素后输出最后一个(7)*/</span></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = q.<span class="built_in">begin</span>(); it != q.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="list定义"><a href="#list定义" class="headerlink" title="list定义"></a>list定义</h4><p>List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件</p>
<p>#include <list></p>
<h4 id="list定义和初始化"><a href="#list定义和初始化" class="headerlink" title="list定义和初始化"></a>list定义和初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;int&gt;lst1;          //创建空list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lst2(5);       //创建含有5个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst3(3,2);  //创建含有3个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst4(lst2);    //使用lst2初始化lst4</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst5(lst2.begin(),lst2.end());  //同lst4</span><br></pre></td></tr></table></figure>

<h4 id="list常用操作函数"><a href="#list常用操作函数" class="headerlink" title="list常用操作函数"></a>list常用操作函数</h4><p>Lst1.assign() 给list赋值<br>Lst1.back() 返回最后一个元素<br>Lst1.begin() 返回指向第一个元素的迭代器<br>Lst1.clear() 删除所有元素<br>Lst1.empty() 如果list是空的则返回true<br>Lst1.end() 返回末尾的迭代器<br>Lst1.erase() 删除一个元素<br>Lst1.front() 返回第一个元素<br>Lst1.get_allocator() 返回list的配置器<br>Lst1.insert() 插入一个元素到list中<br>Lst1.max_size() 返回list能容纳的最大元素数量<br>Lst1.merge() 合并两个list<br>Lst1.pop_back() 删除最后一个元素<br>Lst1.pop_front() 删除第一个元素<br>Lst1.push_back() 在list的末尾添加一个元素<br>Lst1.push_front() 在list的头部添加一个元素<br>Lst1.rbegin() 返回指向第一个元素的逆向迭代器<br>Lst1.remove() 从list删除元素<br>Lst1.remove_if() 按指定条件删除元素<br>Lst1.rend() 指向list末尾的逆向迭代器<br>Lst1.resize() 改变list的大小<br>Lst1.reverse() 把list的元素倒转<br>Lst1.size() 返回list中的元素个数<br>Lst1.sort() 给list排序<br>Lst1.splice() 合并两个list<br>Lst1.swap() 交换两个list<br>Lst1.unique() 删除list中相邻重复的元素</p>
<h4 id="List使用实例"><a href="#List使用实例" class="headerlink" title="List使用实例"></a>List使用实例</h4><h5 id="迭代器遍历list"><a href="#迭代器遍历list" class="headerlink" title="迭代器遍历list"></a>迭代器遍历list</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++)</span><br><span class="line">   &#123;</span><br><span class="line">     cout&lt;&lt;*iter;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h5 id="综合实例1"><a href="#综合实例1" class="headerlink" title="综合实例1"></a>综合实例1</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTINT;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTCHAR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//用LISTINT创建一个list对象</span></span><br><span class="line">	LISTINT listOne;</span><br><span class="line">	<span class="comment">//声明i为迭代器</span></span><br><span class="line">	LISTINT::iterator i;</span><br><span class="line"></span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">	 </span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listOne.begin()--- listOne.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (i = listOne.<span class="built_in">begin</span>(); i != listOne.<span class="built_in">end</span>(); ++i)</span><br><span class="line">		cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	LISTINT::reverse_iterator ir;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listOne.rbegin()---listOne.rend():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (ir = listOne.<span class="built_in">rbegin</span>(); ir != listOne.<span class="built_in">rend</span>(); ir++) &#123;</span><br><span class="line">		cout &lt;&lt; *ir &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">accumulate</span>(listOne.<span class="built_in">begin</span>(), listOne.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sum=&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//用LISTCHAR创建一个list对象</span></span><br><span class="line">	LISTCHAR listTwo;</span><br><span class="line">	<span class="comment">//声明i为迭代器</span></span><br><span class="line">	LISTCHAR::iterator j;</span><br><span class="line">	 </span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	 </span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listTwo.begin()---listTwo.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = listTwo.<span class="built_in">begin</span>(); j != listTwo.<span class="built_in">end</span>(); ++j)</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	j = <span class="built_in">max_element</span>(listTwo.<span class="built_in">begin</span>(), listTwo.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The maximum element in listTwo is: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<h5 id="综合实例2"><a href="#综合实例2" class="headerlink" title="综合实例2"></a>综合实例2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; INTLIST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前向后显示list队列的全部元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_list</span><span class="params">(INTLIST list, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INTLIST::iterator plist;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The contents of &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (plist = list.<span class="built_in">begin</span>(); plist != list.<span class="built_in">end</span>(); plist++)</span><br><span class="line">		cout &lt;&lt; *plist &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试list容器的功能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//list1对象初始为空 </span></span><br><span class="line">	INTLIST list1;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list2</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list3</span><span class="params">(list2.begin(), --list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//声明一个名为i的双向迭代器 </span></span><br><span class="line">	INTLIST::iterator i;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	list1.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.push_back(7) and list1.push_back(8):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">	list1.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.push_front(6) and list1.push_front(5):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">insert</span>(++list1.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.insert(list1.begin()+1,3,9):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//测试引用类函数 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.front()=&quot;</span> &lt;&lt; list1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.back()=&quot;</span> &lt;&lt; list1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">pop_front</span>();</span><br><span class="line">	list1.<span class="built_in">pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.pop_front() and list1.pop_back():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">erase</span>(++list1.<span class="built_in">begin</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.erase(++list1.begin()):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list2.<span class="built_in">assign</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list2.assign(8,1):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.max_size(): &quot;</span> &lt;&lt; list1.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.size(): &quot;</span> &lt;&lt; list1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.empty(): &quot;</span> &lt;&lt; list1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1&gt;list3: &quot;</span> &lt;&lt; (list1 &gt; list3) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1&lt;list3: &quot;</span> &lt;&lt; (list1 &lt; list3) &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">sort</span>();</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">splice</span>(++list1.<span class="built_in">begin</span>(), list3);</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。</p>
<p>C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。</p>
<p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p>
<h4 id="基本操作函数"><a href="#基本操作函数" class="headerlink" title="基本操作函数"></a>基本操作函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin()         返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素</span><br><span class="line"></span><br><span class="line">find()          查找一个元素</span><br><span class="line"></span><br><span class="line">get_allocator() 返回map的配置器</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()          返回map中元素的个数</span><br><span class="line"></span><br><span class="line">swap()           交换两个map</span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头文件</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; ID_Name;</span><br></pre></td></tr></table></figure>

<p>// 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; 2015, &quot;Jim&quot; &#125;,</span><br><span class="line">                &#123; 2016, &quot;Tom&quot; &#125;,</span><br><span class="line">                &#123; 2017, &quot;Bob&quot; &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。</p>
<p>二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt;::iterator it;</span><br><span class="line">map&lt;int,int&gt; mmap;</span><br><span class="line">const map&lt;int,int&gt; const_mmap;</span><br><span class="line"></span><br><span class="line">it = mmap.begin(); //iterator</span><br><span class="line">mmap.cbegin(); //const_iterator</span><br><span class="line"></span><br><span class="line">const_mmap.begin(); //const_iterator</span><br><span class="line">const_mmap.cbegin(); //const_iterator</span><br></pre></td></tr></table></figure>

<p>返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h5 id="用insert插入pair数据"><a href="#用insert插入pair数据" class="headerlink" title="用insert插入pair数据"></a>用insert插入pair数据</h5><p>//数据的插入–第一种：用insert函数插入pair数据  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用insert函数插入value-type数据"><a href="#用insert函数插入value-type数据" class="headerlink" title="用insert函数插入value_type数据"></a>用insert函数插入value_type数据</h5><p>//第二种：用insert函数插入value_type数据，下面举例说明  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用insert函数进行多个插入"><a href="#用insert函数进行多个插入" class="headerlink" title="用insert函数进行多个插入"></a>用insert函数进行多个插入</h5><p>insert共有4个重载函数：</p>
<p>// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败<br>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</p>
<p>//在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排<br>iterator insert (const_iterator position, const value_type&amp; val);</p>
<p>// 插入多个<br>void insert (InputIterator first, InputIterator last);</p>
<p>//c++11开始支持，使用列表插入多个<br>void insert (initializer_list<value_type> il);<br>下面是具体使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入单个值</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">200</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回插入位置以及是否插入成功</span></span><br><span class="line">    std::pair&lt;std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;element &#x27;z&#x27; already existed&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; with a value of &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">300</span>));  <span class="comment">//效率更高</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>, <span class="number">400</span>));  <span class="comment">//效率非最高</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//范围多值插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; anothermap;</span><br><span class="line">    anothermap.<span class="built_in">insert</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 列表形式插入</span></span><br><span class="line">    anothermap.<span class="built_in">insert</span>(&#123; &#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">100</span> &#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">200</span>&#125; &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用数组方式插入数据"><a href="#用数组方式插入数据" class="headerlink" title="用数组方式插入数据"></a>用数组方式插入数据</h5><p>//第三种：用数组方式插入数据，下面举例说明  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[1] = &quot;student_one&quot;;   </span><br><span class="line">    mapStudent[2] = &quot;student_two&quot;;    </span><br><span class="line">    mapStudent[3] = &quot;student_three&quot;;    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br><span class="line"></span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;));</span><br></pre></td></tr></table></figure>

<p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br></pre></td></tr></table></figure>

<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>
<p>下面给出完成代码，演示插入成功与否问题</p>
<p>//验证插入函数的作用效果  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;   </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> 大家可以用如下程序，看下用数组插入在数据覆盖上的效果</p>
<p>//验证数组形式插入数据的效果   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_two&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_three&quot;</span>;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="查找、删除、交换"><a href="#查找、删除、交换" class="headerlink" title="查找、删除、交换"></a>查找、删除、交换</h4><p><strong>查找</strong></p>
<p>// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器<br>// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator<br>iterator find (const key_type&amp; k);<br>const_iterator find (const key_type&amp; k) const;<br> <strong>删除</strong></p>
<p>// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器<br>iterator erase( iterator pos )</p>
<p>// 删除一定范围内的元素，并返回一个指向下一元素的迭代器<br>iterator erase( const_iterator first, const_iterator last );</p>
<p>// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1<br>size_t erase( const key_type&amp; key );</p>
<p>// 清空map，清空后的size为0<br>void clear();<br><strong>交换</strong> </p>
<p>// 就是两个map的内容互换<br>void swap( map&amp; other );</p>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>// 查询map是否为空<br>bool empty();</p>
<p>// 查询map中键值对的数量<br>size_t size();</p>
<p>// 查询map所能包含的最大键值对数量，和系统和应用库有关。<br>// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了<br>size_t max_size();</p>
<p>// 查询关键字为key的元素的个数，在map里结果非0即1<br>size_t count( const Key&amp; key ) const; //</p>
<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p>
<p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。</p>
<h5 id="小于号-lt-重载"><a href="#小于号-lt-重载" class="headerlink" title="小于号 &lt; 重载"></a>小于号 &lt; 重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (tagStudentinfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></span><br><span class="line">	&#123;     <span class="comment">//这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </span></span><br><span class="line">		<span class="keyword">if</span> (niD &lt; _A.niD) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (niD == _A.niD)</span><br><span class="line">			<span class="keyword">return</span> strName.<span class="built_in">compare</span>(_A.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nSize;   <span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="仿函数的应用，这个时候结构体中没有直接的小于号重载"><a href="#仿函数的应用，这个时候结构体中没有直接的小于号重载" class="headerlink" title="仿函数的应用，这个时候结构体中没有直接的小于号重载"></a>仿函数的应用，这个时候结构体中没有直接的小于号重载</h5><p>//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Studentinfo <span class="keyword">const</span> &amp;_A, Studentinfo <span class="keyword">const</span> &amp;_B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD &lt; _B.niD)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD == _B.niD)</span><br><span class="line">			<span class="keyword">return</span> _A.strName.<span class="built_in">compare</span>(_B.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>, sort&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？</p>
<p>   map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。</p>
<p>   unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。</p>
<p>   还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。</p>
<p>   最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。</p>
<p>至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。</p>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>std::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。</p>
<p>set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p>
<p>由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。</p>
<p>　　multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p>
<p>　　set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。</p>
<h4 id="set常用成员函数"><a href="#set常用成员函数" class="headerlink" title="set常用成员函数"></a>set常用成员函数</h4><ol>
<li><p>begin()–返回指向第一个元素的迭代器</p>
</li>
<li><p>clear()–清除所有元素</p>
</li>
<li><p>count()–返回某个值元素的个数</p>
</li>
<li><p>empty()–如果集合为空，返回true</p>
</li>
<li><p>end()–返回指向最后一个元素的迭代器</p>
</li>
<li><p>equal_range()–返回集合中与给定值相等的上下限的两个迭代器</p>
</li>
<li><p>erase()–删除集合中的元素</p>
</li>
<li><p>find()–返回一个指向被查找到元素的迭代器</p>
</li>
<li><p>get_allocator()–返回集合的分配器</p>
</li>
<li><p>insert()–在集合中插入元素</p>
</li>
<li><p>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器</p>
</li>
<li><p>key_comp()–返回一个用于元素间值比较的函数</p>
</li>
<li><p>max_size()–返回集合能容纳的元素的最大限值</p>
</li>
<li><p>rbegin()–返回指向集合中最后一个元素的反向迭代器</p>
</li>
<li><p>rend()–返回指向集合中第一个元素的反向迭代器</p>
</li>
<li><p>size()–集合中元素的数目</p>
</li>
<li><p>swap()–交换两个集合变量</p>
</li>
<li><p>upper_bound()–返回大于某个值元素的迭代器</p>
</li>
<li><p>value_comp()–返回一个用于比较元素间的值的函数</p>
</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p> 以下代码涉及的内容：<br>1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？</p>
<p>2、set容器中，如何让元素类型为自定义类型？</p>
<p>3、set容器的insert函数的返回值为什么类型？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数CompareSet，在test02使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="comment">//bool operator()(int v1, int v2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    return v1 &lt; v2;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person类，用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; person.mName &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数ComparePerson,用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//名字大的在前面，如果名字相同，年龄大的排前面</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.mName == p2.mName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.mName &gt; p2.mName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//set容器默认从小到大排序</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:10 20 30</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* set的insert函数返回值为一个对组(pair)。</span></span><br><span class="line"><span class="comment">       对组的第一个值first为set类型的迭代器：</span></span><br><span class="line"><span class="comment">       1、若插入成功，迭代器指向该元素。</span></span><br><span class="line"><span class="comment">       2、若插入失败，迭代器指向之前已经存在的元素</span></span><br><span class="line"><span class="comment">       对组的第二个值seconde为bool类型：</span></span><br><span class="line"><span class="comment">       1、若插入成功，bool值为true</span></span><br><span class="line"><span class="comment">       2、若插入失败，bool值为false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == ret.second)</span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果想让set容器从大到小排序，需要给set容</span></span><br><span class="line"><span class="comment">       器提供一个仿函数,本例的仿函数为CompareSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, CompareSet&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:30,20,10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* set元素类型为Person，当set元素类型为自定义类型的时候</span></span><br><span class="line"><span class="comment">       必须给set提供一个仿函数，用于比较自定义类型的大小，</span></span><br><span class="line"><span class="comment">       否则无法通过编译 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;Person,ComparePerson&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Marry&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">36</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multiset容器的insert函数返回值为什么？ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印multiset</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* multiset的insert函数返回值为multiset类型的迭代器，</span></span><br><span class="line"><span class="comment">       指向新插入的元素。multiset允许插入相同的值，因此</span></span><br><span class="line"><span class="comment">       插入一定成功，因此不需要返回bool类型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator iter = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><p>C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。</p>
<pre><code>    unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:
</code></pre>
<p> 使用unordered_set需要包含#include<unordered_set>头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。</p>
<p>除此之外unordered_multiset也是一种可选的容器。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>amcl原理分析</title>
    <url>/blog/2021/11/25/amcl%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/p942005405/article/details/108569970?ops_request_misc=%7B%22request_id%22:%22163486681116780264091671%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163486681116780264091671&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-108569970.pc_search_ecpm_flag&utm_term=amcl&spm=1018.2226.3001.4187">slam 学习之 AMCL 概念与原理分析_学之知之的博客-CSDN博客_amcl定位原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/126199044">机器人定位技术：AMCL的参数你真的会调了吗？(一） - 知乎 (zhihu.com)</a></p>
<p>改写amcl</p>
<p><a href="https://zhuanlan.zhihu.com/p/28137335">ROS导航包源码学习2 — 定位 - 知乎 (zhihu.com)</a></p>
<h1 id="概念算法"><a href="#概念算法" class="headerlink" title="概念算法"></a>概念算法</h1><ul>
<li>运动模型(里程计模型)</li>
<li>测量模型(波束模型与似然域模型)</li>
<li>采样算法(KLD采样)</li>
<li>蒙特卡洛算法</li>
<li>自适应蒙特卡洛算法</li>
</ul>
<h1 id="运动模型"><a href="#运动模型" class="headerlink" title="运动模型"></a>运动模型</h1><p>关于<code>速度模型</code>与<code>里程计模型</code> ,主要采取<code>采样模型</code></p>
<p><a href="https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/">概率机器人</a></p>
<p>这里主要使用里程计模型</p>
<h1 id="测量模型"><a href="#测量模型" class="headerlink" title="测量模型"></a>测量模型</h1><p><code>波束模型</code>主要调整六个参数:<img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bhit%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bshort%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Brand%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bmax%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> （ <img src="https://www.zhihu.com/equation?tex=P_%7Bhit%7D" alt="[公式]"> 的方差）和λ（动态障碍物的影响力度)</p>
<p><img src="https://pic4.zhimg.com/80/v2-d036db5bb440afe522b644db5bf3324f_720w.jpg" alt="img"></p>
<p>似然域模型主要调整两个参数<img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bhit%7D" alt="[公式]">  <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Brand%7D" alt="[公式]"> 。</p>
<p><img src="https://pic1.zhimg.com/80/v2-107260979458a0bffb5a1ba9e22d2168_720w.jpg" alt="img"></p>
<h1 id="KLD采样"><a href="#KLD采样" class="headerlink" title="KLD采样"></a>KLD采样</h1><p><strong>目的</strong>:<strong>将估计的概率分布转化为真实的概率分布。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190720103418660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUzMDIzOQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h1>]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>USBCAN/CANalyst-II</title>
    <url>/blog/2021/11/11/USBCAN/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/muyoufansem/article/details/117955581?ops_request_misc=&request_id=&biz_id=102&utm_term=canalyst&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117955581.pc_search_mgc_flag&spm=1018.2226.3001.4187">(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动</a></p>
<p><a href="https://blog.csdn.net/qq_38766896/article/details/109404097?ops_request_misc=%7B%22request_id%22:%22163642380516780264058809%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163642380516780264058809&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109404097.pc_search_mgc_flag&utm_term=canalyst-ii+linux&spm=1018.2226.3001.4187">Ubuntu16.04 （ROS）下通过CAN分析仪（USBCAN/CANalyst-II）调试无人车助力转向电机（1）_秋名山的过客-CSDN博客</a></p>
<p><a href="http://www.gcgd.net/newsinfo_726.html">USBCAN在Linux系统下使用说明 (gcgd.net)</a></p>
<p><a href="https://blog.csdn.net/qq_41545537/article/details/106714246?ops_request_misc=%7B%22request_id%22:%22163607238916780271515211%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163607238916780271515211&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-106714246.pc_search_mgc_flag&utm_term=ubuntucan%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">ubuntu下研华工控机CAN卡驱动的安装与测试_星辰和大海都需要门票的博客-CSDN博客</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>介绍两款使用过的<code>usb</code>转<code>can</code>的使用方法</p>
<p>一款是广成科技的<code>USBCAN-I PRO</code><a href="http://www.gcgd.net/tecrjlist.html">资料下载 (gcgd.net)</a></p>
<p>一款是创芯科技的<code>CANalyst</code><a href="https://www.zhcxgd.com/ZLXZ.html">珠海创芯科技有限公司 - 珠海创芯科技 (zhcxgd.com)</a></p>
<h1 id="软件安装与使用"><a href="#软件安装与使用" class="headerlink" title="软件安装与使用"></a>软件安装与使用</h1><h2 id="USBCAN"><a href="#USBCAN" class="headerlink" title="USBCAN:"></a>USBCAN:</h2><p><a href="http://www.gcgd.net/newsinfo_388.html">沈阳广成科技USBCAN系列产品驱动安装及ECANTools软件使用方法 (gcgd.net)</a></p>
<p><a href="https://pan.baidu.com/s/10R7zou8yxzarjlwlJkeN1A#list/path=%2FGC-USBCAN-----%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%B9%E9%80%89%E6%8B%A9%E9%9C%80%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6">GC-USBCAN—–点击进入文件夹选择需要下载的文件_免费高速下载|百度网盘-分享无限制 (baidu.com)</a></p>
<h2 id="CANalyst"><a href="#CANalyst" class="headerlink" title="CANalyst:"></a>CANalyst:</h2><p><a href="https://blog.csdn.net/muyoufansem/article/details/117955581?ops_request_misc=&request_id=&biz_id=102&utm_term=canalyst&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117955581.pc_search_mgc_flag&spm=1018.2226.3001.4187">(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动</a></p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="建议采用官方例程至少不会出错"><a href="#建议采用官方例程至少不会出错" class="headerlink" title="!建议采用官方例程至少不会出错"></a>!建议采用官方例程至少不会出错</h2><h2 id="这里推荐两个例程可以验证学习"><a href="#这里推荐两个例程可以验证学习" class="headerlink" title="这里推荐两个例程可以验证学习"></a>这里推荐两个例程可以验证学习</h2><p><a href="https://github.com/VincentCheungM/ESR_canalyst_ros">VincentCheungM/ESR_canalyst_ros: A warped ROS driver for CANalyst-II and ESR Radar (github.com)</a></p>
<p><a href="https://github.com/Andy-jg/RaspberryCanalyst-2">Andy-jg/RaspberryCanalyst-2: linux use the canalyst-2 (github.com)</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="!注意"></a>!注意</h1><p>由于can驱动使用时每次都需要<code>sudo</code>,可以加配置,这样就不需要每次都<code>sudo</code>了</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/udev/rules.d/99-myusb.rules</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;,</span><br><span class="line">GROUP=&quot;users&quot;, MODE=&quot;0777&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>amcl简单使用</title>
    <url>/blog/2021/11/25/amcl%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zx3517288/article/details/78454196">AMCL介绍及参数说明_走过_冬天的博客-CSDN博客_amcl参数配置</a></p>
<p><a href="https://blog.csdn.net/qq_34672671/article/details/105729458?ops_request_misc=%7B%22request_id%22:%22163540823116780274178002%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163540823116780274178002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-29-105729458.pc_search_ecpm_flag&utm_term=amcl&spm=1018.2226.3001.4187">深入AMCL(三):AMCL手动初始化后如何自动定位_yuanguobin01的博客-CSDN博客</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>amcl_demo.launch</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- r2000驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find pepperl_fuchs_r2000)/launch/gui_example.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map server --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布map.yaml,其中包含了pgm文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;map_file&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find run)/map/mymap.yaml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(arg map_file)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Localization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find run)/launch/amcl.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 获取odom数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于采用的是里程计模型,注意里程计的位置输出尤为关键 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;node name=&quot;tcp_server&quot; pkg=&quot;tcp_server&quot; type=&quot;tcp_server&quot; /&gt; --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注意坐标转换:map-&gt;odom-&gt;base_link-&gt;laser_link --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果转换多了,会报错,多转换可能会报laserscan超时,少了,rviz会报没有上级坐标系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;map_to_odom_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0  /map /odom 100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_to_laser_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 /base_link /laser_link 100&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find run)/rviz/hector_map.rviz&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>amcl.launch</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_map_topic&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;scan_topic&quot;</span>      <span class="attr">default</span>=<span class="string">&quot;scan&quot;</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_x&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_y&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_a&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame_id&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;base_frame_id&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;global_frame_id&quot;</span> <span class="attr">default</span>=<span class="string">&quot;map&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">type</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amcl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_map_topic&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg use_map_topic)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Publish scans from best pose at a max of 10 Hz --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 差分模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_model_type&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;diff&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 速度模型参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha5&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;gui_publish_rate&quot;</span>          <span class="attr">value</span>=<span class="string">&quot;10.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_beams&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;810&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_range&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;-1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;min_particles&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;500&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_particles&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_err&quot;</span>                   <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_z&quot;</span>                     <span class="attr">value</span>=<span class="string">&quot;0.99&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 里程计模型调节超参 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha1&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha2&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha3&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha4&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 一般情况而言,高斯误差会比较大,可以设置大一些 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_hit&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.95&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_short&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_rand&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_sigma_hit&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_lambda_short&quot;</span>        <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_model_type&quot;</span>          <span class="attr">value</span>=<span class="string">&quot;likelihood_field&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_likelihood_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_d&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_a&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame_id&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg odom_frame_id)&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame_id&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg base_frame_id)&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;global_frame_id&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;$(arg global_frame_id)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;resample_interval&quot;</span>         <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Increase tolerance because the computer can get quite busy --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;transform_tolerance&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 快慢指针,一般slow会小一些,良好的值可能为0.001,fast可能为0.01 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_slow&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_fast&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 初始位姿 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_x&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_x)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_y&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_y)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_a&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_a)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span>                      <span class="attr">to</span>=<span class="string">&quot;$(arg scan_topic)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>boost安装与测试</title>
    <url>/blog/2021/11/25/boost%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zhangxiao93/article/details/51077933?ops_request_misc=%7B%22request_id%22:%22163782562316780255241172%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163782562316780255241172&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51077933.pc_search_mgc_flag&utm_term=ubuntu+boost%E5%BA%93%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Ubuntu下安装boost库_上善若水-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/yhrun/article/details/8099630">在Ubuntu上安装boost库_一点一滴-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_41722524/article/details/114322697?ops_request_misc=%7B%22request_id%22:%22163782562316780255241172%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163782562316780255241172&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-114322697.pc_search_mgc_flag&utm_term=ubuntu+boost%E5%BA%93%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Ubuntu20.04安装boost库_vanyongqi-CSDN博客_ubuntu 安装boost</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libboost-dev</span><br></pre></td></tr></table></figure>

<h2 id="build安装"><a href="#build安装" class="headerlink" title="build安装"></a>build安装</h2><ul>
<li>下载boost库:<a href="https://www.boost.org/">Boost C++ Libraries</a></li>
<li>解压: <code>tar -xzvf boost_1_xx_xx.tar.gz</code></li>
<li>进入解压目录,执行脚本,<code>sudo ./bootstrap.sh</code></li>
<li>安装, <code>sudo ./b2 install</code></li>
<li>测试环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾添加</span></span><br><span class="line">export CPLUS_INCLUDE_PATH=/usr/local/include/boost:$CPLUS_INCLUDE_PATH</span><br><span class="line">export LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano test.cpp</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="number">1</span>;<span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;boost::<span class="built_in">bind</span>(fun,_1,_2)(m,n)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>

<h1 id="cmake使用boost库"><a href="#cmake使用boost库" class="headerlink" title="cmake使用boost库"></a>cmake使用boost库</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">// CMakeLists.txt</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(boost_test)</span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED COMPONENTS system thread)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(boost_test boost_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(boost_test <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boost_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="number">1</span>;<span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;boost::<span class="built_in">bind</span>(fun,_1,_2)(m,n)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>boost_thread</title>
    <url>/blog/2021/11/25/boost_thread/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>了解boost</p>
<p><a href="https://zhuanlan.zhihu.com/p/66486828">C++ Boost库分类总结（个人收藏） - 知乎 (zhihu.com)</a></p>
<p>boost教程</p>
<p><a href="http://zh.highscore.de/cpp/boost/multithreading.html">Highscore - Boost C++ 库 - 多线程</a></p>
<h1 id="boost多线程同步简单使用"><a href="#boost多线程同步简单使用" class="headerlink" title="boost多线程同步简单使用"></a>boost多线程同步简单使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  boost::this_thread::<span class="built_in">sleep</span>(boost::posix_time::<span class="built_in">seconds</span>(seconds)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">boost::mutex mutex; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">1</span>); </span><br><span class="line">    mutex.<span class="built_in">lock</span>(); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">    mutex.<span class="built_in">unlock</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">boost::thread <span class="title">t1</span><span class="params">(thread)</span></span>; </span><br><span class="line">  <span class="function">boost::thread <span class="title">t2</span><span class="params">(thread)</span></span>; </span><br><span class="line">  t1.<span class="built_in">join</span>(); </span><br><span class="line">  t2.<span class="built_in">join</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cjson精度丢失</title>
    <url>/blog/2021/11/24/cjson%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_33858485/article/details/93953963?ops_request_misc=&request_id=&biz_id=102&utm_term=cjson%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-93953963.pc_search_mgc_flag&spm=1018.2226.3001.4187">(80条消息) cJSON精度丢失问题_weixin_33858485的博客-CSDN博客</a></p>
<p>在<code>cJSON.c</code>中的<code>print_number</code>函数中的<code>sprintf((char*)number_buffer, &quot;%1.17g&quot;, d);</code>更改为</p>
<p><code>sprintf((char*)number_buffer, &quot;%1.4g&quot;, d);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Render the number nicely from the given item into a string. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> cJSON_bool <span class="title">print_number</span><span class="params">(<span class="keyword">const</span> cJSON * <span class="keyword">const</span> item, printbuffer * <span class="keyword">const</span> output_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">double</span> d = item-&gt;valuedouble;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> number_buffer[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* temporary buffer to print the number into */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> decimal_point = get_decimal_point();</span><br><span class="line">    <span class="keyword">double</span> test = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This checks for NaN and Infinity */</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(d) || isinf(d))</span><br><span class="line">    &#123;</span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */</span></span><br><span class="line">        <span class="comment">// 更改这里的1.4,这里指的是保留4位小数</span></span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%1.4g&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check whether the original double can be recovered */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">sscanf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%lg&quot;</span>, &amp;test) != <span class="number">1</span>) || !compare_double((<span class="keyword">double</span>)test, d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* If not, print with 17 decimal places of precision */</span></span><br><span class="line">            <span class="comment">// 更改这里的1.4,这里指的是保留4位小数</span></span><br><span class="line">            length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%1.4g&quot;</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sprintf failed or buffer overrun occurred */</span></span><br><span class="line">    <span class="keyword">if</span> ((length &lt; <span class="number">0</span>) || (length &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(number_buffer) - <span class="number">1</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve appropriate space in the output */</span></span><br><span class="line">    output_pointer = ensure(output_buffer, (<span class="keyword">size_t</span>)length + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the printed number to the output and replace locale</span></span><br><span class="line"><span class="comment">     * dependent decimal point with &#x27;.&#x27; */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((<span class="keyword">size_t</span>)length); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number_buffer[i] == decimal_point)</span><br><span class="line">        &#123;</span><br><span class="line">            output_pointer[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output_pointer[i] = number_buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    output_pointer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    output_buffer-&gt;offset += (<span class="keyword">size_t</span>)length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cJSON</title>
    <url>/blog/2021/11/10/cJSON/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/Mculover666/article/details/103796256?ops_request_misc=%7B%22request_id%22:%22163610505416780261970843%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163610505416780261970843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-103796256.pc_search_mgc_flag&utm_term=cjson&spm=1018.2226.3001.4187">(65条消息) cJSON使用详细教程 | 一个轻量级C语言JSON解析器_Mculover666的博客（嵌入式_)</a></p>
<p> <a href="https://github.com/DaveGamble/cJSON.git">cJSON-github</a></p>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* cjson_test = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_skill = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个JSON数据对象(链表头结点) */</span></span><br><span class="line">    cjson_test = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条字符串类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddStringToObject(cjson_test, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;mculover666&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条整数类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddNumberToObject(cjson_test, <span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条浮点类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddNumberToObject(cjson_test, <span class="string">&quot;weight&quot;</span>, <span class="number">55.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个嵌套的JSON数据（添加一个链表节点） */</span></span><br><span class="line">    cjson_address = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddStringToObject(cjson_address, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;China&quot;</span>);</span><br><span class="line">    cJSON_AddNumberToObject(cjson_address, <span class="string">&quot;zip-code&quot;</span>, <span class="number">111111</span>);</span><br><span class="line">    cJSON_AddItemToObject(cjson_test, <span class="string">&quot;address&quot;</span>, cjson_address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个数组类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cjson_skill = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;C&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;Java&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;Python&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToObject(cjson_test, <span class="string">&quot;skill&quot;</span>, cjson_skill);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddFalseToObject(cjson_test, <span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印JSON对象(整条链表)的所有数据 */</span></span><br><span class="line">    str = cJSON_Print(cjson_test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = </span><br><span class="line"><span class="string">&quot;&#123;                              \</span></span><br><span class="line"><span class="string">    \&quot;name\&quot;:\&quot;mculover666\&quot;,   \</span></span><br><span class="line"><span class="string">    \&quot;age\&quot;: 22,                \</span></span><br><span class="line"><span class="string">    \&quot;weight\&quot;: 55.5,           \</span></span><br><span class="line"><span class="string">    \&quot;address\&quot;:                \</span></span><br><span class="line"><span class="string">        &#123;                       \</span></span><br><span class="line"><span class="string">            \&quot;country\&quot;: \&quot;China\&quot;,\</span></span><br><span class="line"><span class="string">            \&quot;zip-code\&quot;: 111111\</span></span><br><span class="line"><span class="string">        &#125;,                      \</span></span><br><span class="line"><span class="string">    \&quot;skill\&quot;: [\&quot;c\&quot;, \&quot;Java\&quot;, \&quot;Python\&quot;],\</span></span><br><span class="line"><span class="string">    \&quot;student\&quot;: false          \</span></span><br><span class="line"><span class="string">&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* cjson_test = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_name = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_age = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_weight = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address_country = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address_zipcode = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_skill = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_student = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>    skill_array_size = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    cJSON* cjson_skill_item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析整段JSO数据 */</span></span><br><span class="line">    cjson_test = cJSON_Parse(message);</span><br><span class="line">    <span class="keyword">if</span>(cjson_test == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse fail.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 依次根据名称提取JSON数据（键值对） */</span></span><br><span class="line">    cjson_name = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    cjson_age = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    cjson_weight = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;weight&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, cjson_name-&gt;valuestring);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age:%d\n&quot;</span>, cjson_age-&gt;valueint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;weight:%.1f\n&quot;</span>, cjson_weight-&gt;valuedouble);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析嵌套json数据 */</span></span><br><span class="line">    cjson_address = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;address&quot;</span>);</span><br><span class="line">    cjson_address_country = cJSON_GetObjectItem(cjson_address, <span class="string">&quot;country&quot;</span>);</span><br><span class="line">    cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, <span class="string">&quot;zip-code&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address-country:%s\naddress-zipcode:%d\n&quot;</span>, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析数组 */</span></span><br><span class="line">    cjson_skill = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;skill&quot;</span>);</span><br><span class="line">    skill_array_size = cJSON_GetArraySize(cjson_skill);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;skill:[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; skill_array_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s,&quot;</span>, cjson_skill_item-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\b]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析布尔型数据 */</span></span><br><span class="line">    cjson_student = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;student&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(cjson_student-&gt;valueint == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student: false\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student:error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关-JSMN-仅解析"><a href="#相关-JSMN-仅解析" class="headerlink" title="相关 - JSMN(仅解析)"></a>相关 - JSMN(仅解析)</h1><p><a href="https://blog.csdn.net/aa1319594154/article/details/118934166?ops_request_misc=%7B%22request_id%22:%22163663425616780271531802%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163663425616780271531802&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118934166.pc_search_mgc_flag&utm_term=jsmn&spm=1018.2226.3001.4187">JSMN介绍和使用_心飞的博客-CSDN博客</a></p>
<p><a href="https://zserge.com/jsmn/">The most simple JSON parser in C for small systems (zserge.com)</a></p>
<p><a href="https://github.com/zserge/jsmn">zserge/jsmn: Jsmn is a world fastest JSON parser/tokenizer. This is the official repo replacing the old one at Bitbucket (github.com)</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake实现多文件编译</title>
    <url>/blog/2021/12/03/cmake%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h3 id="Cmake文件结构"><a href="#Cmake文件结构" class="headerlink" title="Cmake文件结构"></a>Cmake文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/cmake# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── Queue</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── QUE.cpp</span><br><span class="line">    │       ├── QUE.h</span><br><span class="line">    │       └── main.cpp</span><br><span class="line">    └── canalyst_test</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        ├── lib</span><br><span class="line">        │   └── libcontrolcan.so</span><br><span class="line">        └── src</span><br><span class="line">            ├── Tongyi_Driver.cpp</span><br><span class="line">            ├── Tongyi_Driver.h</span><br><span class="line">            ├── controlcan.cpp</span><br><span class="line">            ├── controlcan.h</span><br><span class="line">            └── main.cpp</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译</span></span><br><span class="line">cd .. &amp;&amp; cd build &amp;&amp; cmake ../src &amp;&amp; make -j </span><br></pre></td></tr></table></figure>

<h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(Cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加下层cmake</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(canalyst_test)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(Queue)</span><br></pre></td></tr></table></figure>

<h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build &amp;&amp; bin/./queue</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake配置模板</title>
    <url>/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="Cmake教程"><a href="#Cmake教程" class="headerlink" title="Cmake教程"></a>Cmake教程</h3><h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://www.hahack.com/codes/cmake/">CMake 入门实战 | HaHack</a></p>
<h3 id="Cmake文件结构"><a href="#Cmake文件结构" class="headerlink" title="Cmake文件结构"></a>Cmake文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/cmake# tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── include</span><br><span class="line">│   └── func.h</span><br><span class="line">└── src</span><br><span class="line">    ├── func.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── shell.sh</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译</span></span><br><span class="line">cd .. &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(canalyst)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake的c++设置</span></span><br><span class="line"><span class="comment"># 告知當前使用的是交叉編譯方式，必須配置</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="string">&quot;gcc&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"><span class="comment"># 执行路径设置</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH ../bin)</span><br><span class="line"><span class="comment"># 设置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -Wall -pthread -std=c++11 -fPIC &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.h文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.cpp文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src  SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib)</span><br><span class="line"><span class="keyword">set</span>(LIB_LIST</span><br><span class="line">    libcontrolcan.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="comment"># message(&quot;src :$&#123;SRC_LIST&#125; &quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC_LIST&#125;</span> )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;LIB_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在src文件夹下运行shell.sh</span></span><br><span class="line">./shell</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp学习</title>
    <url>/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/gyshgx868/cpp-tutorial">C++ 教程 (github.com)</a></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a></p>
<h1 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h1><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>声明指定类型的常量,此类型不会发生变化.</p>
<p>比如常用的字符串<code>const char* str</code>,例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>当然也会有常数,常指针等.只需要记住它修饰的是它后边的那个.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str #值不能改</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *str #值不能改</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> str #修饰的是常数指针,该指针不能修改</span><br></pre></td></tr></table></figure>

<h2 id="static修饰"><a href="#static修饰" class="headerlink" title="static修饰"></a>static修饰</h2><p>静态变量,在程序的生命周期内保持局部变量的存在,用于保存上一次运行数据,比如计数等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>预处理器,例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7070</span></span><br></pre></td></tr></table></figure>

<h2 id="extern储存类"><a href="#extern储存类" class="headerlink" title="extern储存类"></a>extern储存类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// support.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个文件之间传递参数.</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p>寄存器局部变量,用于快速访问.因此也意味着最大尺寸只有寄存器尺寸.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>量在创建线程时创建，并在销毁线程时销毁。可以将 thread_local <code>仅应用于数据声明和定义</code>，thread_local <code>不能用于函数声明或定义</code>。thread_local 说明符可以与 static 或 extern 合并。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first_name[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125; emp;</span><br></pre></td></tr></table></figure>

<h3 id="（-）点运算符"><a href="#（-）点运算符" class="headerlink" title="（.）点运算符"></a>（.）点运算符</h3><p>下面的代码把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcpy(emp.first_name, &quot;zara&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="（-gt-）箭头运算符"><a href="#（-gt-）箭头运算符" class="headerlink" title="（-&gt;）箭头运算符"></a>（-&gt;）箭头运算符</h3><p>如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员，需要编写如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(p_emp-&gt;first_name, <span class="string">&quot;zara&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符 ? :"></a>条件运算符 ? :</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y &lt; <span class="number">10</span>)&#123; </span><br><span class="line">   var = <span class="number">30</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   var = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可写为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var = (y &lt; <span class="number">10</span>) ? <span class="number">30</span> : <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span> (data type)</span><br></pre></td></tr></table></figure>

<h2 id="指针运算符（-amp-和-）"><a href="#指针运算符（-amp-和-）" class="headerlink" title="指针运算符（&amp; 和 *）"></a>指针运算符（&amp; 和 *）</h2><h3 id="取地址运算符-amp-间接寻址运算符"><a href="#取地址运算符-amp-间接寻址运算符" class="headerlink" title="取地址运算符 &amp; 间接寻址运算符 *"></a>取地址运算符 &amp; 间接寻址运算符 *</h3><p>顾名思义,挺形象的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var;</span><br><span class="line">   <span class="keyword">int</span>  *ptr;</span><br><span class="line">   <span class="keyword">int</span>  val;</span><br><span class="line">   var = <span class="number">3000</span>;</span><br><span class="line">   <span class="comment">// 获取 var 的地址</span></span><br><span class="line">   ptr = &amp;var;</span><br><span class="line">   <span class="comment">// 获取 ptr 的值</span></span><br><span class="line">   val = *ptr;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of var :&quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of ptr :&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of val :&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传参三种方式"><a href="#传参三种方式" class="headerlink" title="传参三种方式"></a>传参三种方式</h2><h3 id="传值、传址、传引用"><a href="#传值、传址、传引用" class="headerlink" title="传值、传址、传引用"></a><strong>传值、传址、传引用</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a*a</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">man</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function">    a</span>=a*a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function">    *a</span>=*a * *a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">uint8_t</span>* *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    *buffer = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>,number=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fun1</span>(a)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">man</span>(b);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cubeByReference</span>(&amp;number);</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是<code>this</code>指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>

<h2 id="数学运算-include-lt-cmath"><a href="#数学运算-include-lt-cmath" class="headerlink" title="数学运算 #include &lt;cmath"></a>数学运算 #include &lt;cmath</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 数字定义</span></span><br><span class="line">   <span class="keyword">short</span>  s = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span>    i = <span class="number">-1000</span>;</span><br><span class="line">   <span class="keyword">long</span>   l = <span class="number">100000</span>;</span><br><span class="line">   <span class="keyword">float</span>  f = <span class="number">230.47</span>;</span><br><span class="line">   <span class="keyword">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 数学运算</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sin(d) :&quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;floor(d) :&quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过time实现的伪随机数"><a href="#通过time实现的伪随机数" class="headerlink" title="通过time实现的伪随机数"></a>通过time实现的伪随机数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="keyword">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setw-函数"><a href="#setw-函数" class="headerlink" title="setw() 函数"></a>setw() 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::setw;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>( <span class="number">7</span> )&lt;&lt; j &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class="line"># 结果</span><br><span class="line">Element        Value</span><br><span class="line">      <span class="number">0</span>          <span class="number">100</span></span><br><span class="line">      <span class="number">1</span>          <span class="number">101</span></span><br><span class="line">      <span class="number">2</span>          <span class="number">102</span></span><br><span class="line">      <span class="number">3</span>          <span class="number">103</span></span><br><span class="line">      <span class="number">4</span>          <span class="number">104</span></span><br><span class="line">      <span class="number">5</span>          <span class="number">105</span></span><br><span class="line">      <span class="number">6</span>          <span class="number">106</span></span><br><span class="line">      <span class="number">7</span>          <span class="number">107</span></span><br><span class="line">      <span class="number">8</span>          <span class="number">108</span></span><br><span class="line">      <span class="number">9</span>          <span class="number">109</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串操作-include-lt-string"><a href="#字符串操作-include-lt-string" class="headerlink" title="字符串操作 #include &lt;string"></a>字符串操作 #include &lt;string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, s2); <span class="comment">// s2复制到s1</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2); <span class="comment">// s2拼接到s1后边,类似于:string str = str1 + str2;</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);     <span class="comment">// 字符串长度</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2); <span class="comment">// 比较两字符串,相同回0,s1&lt;s2返回小于0,反之,大于0</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch); <span class="comment">// 返回字符ch第一次在s1中出现得位置指针</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2); <span class="comment">// 返回字符串s2在s1中出现的位姿指针</span></span><br><span class="line"><span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">	str3 = str1;</span><br><span class="line"><span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   	str3 = str1 + str2;</span><br><span class="line"><span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   	len = str3.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h2 id="时间-include-lt-ctime"><a href="#时间-include-lt-ctime" class="headerlink" title="时间 #include &lt;ctime"></a>时间 #include &lt;ctime</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *time)</span></span>; 						<span class="comment">// 返回当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 				<span class="comment">// 返回 day month year hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 		<span class="comment">// 返回tm时间结构体</span></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">clock</span><span class="params">(<span class="keyword">void</span>)</span></span>;                			<span class="comment">// 该函数返回程序执行起,处理器时钟所使用的时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">asctime</span> <span class="params">( <span class="keyword">const</span> struct tm * time )</span></span>;		<span class="comment">// 返回 day month date hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 			<span class="comment">// 用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *time)</span></span>;					<span class="comment">// 该函数返回日历时间</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span> <span class="params">( <span class="keyword">time_t</span> time2, <span class="keyword">time_t</span> time1 )</span></span>; <span class="comment">// 该函数返回 time1 和 time2 之间相差的秒数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">()</span></span>;								<span class="comment">// 该函数可用于格式化日期和时间为指定的格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="keyword">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cin、cout、cerr-和-clog-标准输入输出"><a href="#cin、cout、cerr-和-clog-标准输入输出" class="headerlink" title="cin、cout、cerr 和 clog 标准输入输出"></a><strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 标准输入输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin :一个istream对象,用来从标准输入读取数据。</span><br><span class="line">cout:一个ostream对象，经过缓冲区而直接输出.</span><br><span class="line">cerr:一个ostream对象,写到cerr数据是不缓冲</span><br><span class="line">clog:一个ostream对象,被缓冲的</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="comment">// 使用 Books Book;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 books Book;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;books;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取别名 pin32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> pint32;</span><br><span class="line">pint32 x, y, z;</span><br></pre></td></tr></table></figure>

<p>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line"><span class="comment">// 取地址</span></span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line"><span class="comment">// 访问成员</span></span><br><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="c-对象"><a href="#c-对象" class="headerlink" title="c++对象"></a>c++对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 访问修饰符</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 类成员函数 </span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   				<span class="comment">// 构造函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="keyword">const</span> Line &amp;obj); 	<span class="comment">//拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  				<span class="comment">// 析构函数声明</span></span><br><span class="line"> 	</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个<code>空间代价换时间的节省</code>。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神:</p>
<ul>
<li>1.在内联函数内不允许使用循环语句和开关语句；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.类结构中所在的类说明内部定义的函数是内联函数。</li>
</ul>
<p>结论: 一个较为合理的经验准则是, <strong>不要内联超过 10 行的函数</strong>. <strong>谨慎对待析构函数</strong>, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (20,10): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (0,200): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (100,1010): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p>
<p><strong>this</strong> 指针的类型可理解为 <strong>Box*</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 实际上就是指针引用结构体成员</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>类内重调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">         box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">         <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">算术运算符</th>
<th align="center">+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关系运算符</td>
<td align="center">==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center">||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td align="center">单目运算符</td>
<td align="center">+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td align="center">自增自减运算符</td>
<td align="center">++(自增)，–(自减)</td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center">| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td align="center">赋值运算符</td>
<td align="center">=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td align="center">空间申请与释放</td>
<td align="center">new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td align="center">其他运算符</td>
<td align="center"><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td>
</tr>
</tbody></table>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 纯虚数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>头文件:<strong>iostream</strong> 和 <strong>fstream</strong></p>
<h3 id="读写文件模板"><a href="#读写文件模板" class="headerlink" title="读写文件模板"></a>读写文件模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h3 id="变量动态内存"><a href="#变量动态内存" class="headerlink" title="变量动态内存"></a>变量动态内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="数组动态内存"><a href="#数组动态内存" class="headerlink" title="数组动态内存"></a>数组动态内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pvalue[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] pvalue; </span><br></pre></td></tr></table></figure>

<h3 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> [] myBoxArray; <span class="comment">// Delete array</span></span><br></pre></td></tr></table></figure>

<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">   pvalue  = new double;   // 为变量请求内存</span><br><span class="line"> </span><br><span class="line">   *pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">   cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   delete pvalue;         // 释放内存</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br><span class="line">name::<span class="built_in">func</span>();  <span class="comment">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>

<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">//全特化，由于是全特化，参数都指定了，参数列表故为空。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">int</span> ,<span class="keyword">char</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i,<span class="keyword">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="comment">//由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">char</span>,T2&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">char</span> i,T2 j):<span class="built_in">a</span>(j),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;个数偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; <span class="comment">//这是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1*,T2*&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1* i,T2* j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;指针偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1* a;</span><br><span class="line">    T2* b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;<span class="comment">//同理这也是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1 <span class="keyword">const</span>,T2 <span class="keyword">const</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;const偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">0.1</span>,<span class="number">0.2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; <span class="title">t3</span><span class="params">(<span class="string">&#x27;A&#x27;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>*,<span class="keyword">int</span>*&gt; <span class="title">t4</span><span class="params">(&amp;a,&amp;a)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">int</span>&gt; <span class="title">t5</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)</span></span><br></pre></td></tr></table></figure>

<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 将x转换为字符串</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line">## 将x,y连接</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT( x, y )  x ## y</span></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br></pre></td></tr></table></figure>

<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl; <span class="comment">//当前行号</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl; <span class="comment">//当前文件名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl; <span class="comment">//当前年月日</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl; <span class="comment">//当前时分秒</span></span><br></pre></td></tr></table></figure>

<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalHandler</span><span class="params">( <span class="keyword">int</span> signum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序 </span></span><br><span class="line">   <span class="built_in">exit</span>(signum);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line">    <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">if</span>( i == <span class="number">3</span> )&#123;</span><br><span class="line">          <span class="comment">// 信号抬起</span></span><br><span class="line">          <span class="built_in">raise</span>( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_create</span> (thread, attr, start_routine, arg) </span><br><span class="line"><span class="comment">// 参数:线程指针,线程属性,线程函数,函数参数</span></span><br><span class="line"><span class="comment">// 线程显性退出</span></span><br><span class="line"><span class="built_in">pthread_exit</span> (<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<h3 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  thread_id;</span><br><span class="line">   <span class="keyword">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">td</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line">rc = <span class="built_in">pthread_create</span>(threadid, <span class="literal">NULL</span>,PrintHello, (<span class="keyword">void</span> *)&amp;td[i]);</span><br></pre></td></tr></table></figure>

<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span> (threadid, status) </span><br><span class="line"><span class="built_in">pthread_detach</span> (threadid) </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">    </span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="keyword">void</span> *status;</span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">   <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="keyword">void</span> *)i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线程</span></span><br><span class="line">   <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = <span class="built_in">pthread_join</span>(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector与iterator"><a href="#vector与iterator" class="headerlink" title="vector与iterator"></a>vector与iterator</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言的三种传参方式</title>
    <url>/blog/2021/12/15/c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">man</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=a*a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a * *a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">uint8_t</span>* *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    *buffer = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>,number=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fun1(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    man(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    cubeByReference(&amp;number);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *buf;</span><br><span class="line">    fun2(&amp;buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 10; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, buf[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序注意点</title>
    <url>/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A">https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A</a></p>
<h3 id="意想不到的八进制"><a href="#意想不到的八进制" class="headerlink" title="意想不到的八进制"></a>意想不到的八进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b为八进制</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">34</span>, b=<span class="number">034</span>; </span><br></pre></td></tr></table></figure>

<h3 id="指针加减运算"><a href="#指针加减运算" class="headerlink" title="指针加减运算"></a>指针加减运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="number">0x00001000</span>;  </span><br><span class="line">a=a+<span class="number">1</span>;  </span><br><span class="line">p=p+<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 这里的p是指针,</span></span><br><span class="line"><span class="comment">// p+1实际上是按照公式p+1*sizeof(int)来计算的。</span></span><br></pre></td></tr></table></figure>

<p>比如RAM初始化零操作,如下,只有4字节空间被初始化为零</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *pRAMaddr;         <span class="comment">//定义地址指针变量  </span></span><br><span class="line"><span class="comment">// pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节</span></span><br><span class="line"><span class="keyword">for</span>(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=<span class="number">4</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">     *pRAMaddr=<span class="number">0x00000000</span>;   <span class="comment">//指定RAM地址清零  </span></span><br><span class="line">    <span class="comment">// 这里清除了四个字节</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="关键字sizeof"><a href="#关键字sizeof" class="headerlink" title="关键字sizeof"></a>关键字sizeof</h3><p><strong>sizeof</strong>是一个关键字,需要注意的是,<strong>使用sizeof获取数组长度时，不要对指针应用sizeof操作符</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearRAM</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);i++) <span class="comment">//这里用法错误，array实际上是指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">array</span>[i]=<span class="number">0x00</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> Fle[<span class="number">20</span>];  </span><br><span class="line">      </span><br><span class="line">    ClearRAM(Fle);          <span class="comment">//只能清除数组Fle中的前四个元素  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="结构体填充"><a href="#结构体填充" class="headerlink" title="结构体填充"></a>结构体填充</h3><p>结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体：</p>
<p>第一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">short</span> s；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">&#125;str_test1; </span><br></pre></td></tr></table></figure>

<p>第二个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">    <span class="keyword">short</span> s；      </span><br><span class="line">&#125;str_test2;</span><br></pre></td></tr></table></figure>

<p>这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？</p>
<p>其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下<strong>第一个结构体变量占用8个字节</strong>，<strong>第二个结构体占用12个字节</strong>，差别很大。第一个结构体变量在内存中的存储格式如图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1~4字节  cc填充SSSS</span><br><span class="line">5~8字节  XXXXXXXX</span><br></pre></td></tr></table></figure>

<p>第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1~4字节   cc填充</span><br><span class="line">5~8字节   XXXXXXXX</span><br><span class="line">9~12字节  ssss填充</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>easy_logger</title>
    <url>/blog/2021/11/26/easy_log/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/armink/EasyLogger">一款超轻量级(ROM&lt;1.6K, RAM&lt;0.3k)、高性能的 C/C++ 日志库 </a></p>
<h1 id="移植到linux"><a href="#移植到linux" class="headerlink" title="移植到linux"></a>移植到linux</h1><p><a href="https://github.com/peitianyu/easy_log">peitianyu/easy_log (github.com)</a></p>
<p>注意修改log文件保存路径,在<code>easy_log/include/elog_file_cfg.h</code>中</p>
<p>一款更加轻量化的log工具,可以自行更改函数,实现功能</p>
<p><a href="https://github.com/peitianyu/light_log/blob/main/README.md"> peitianyu/light_log (github.com)</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/blog/2021/10/19/git/</url>
    <content><![CDATA[<h3 id="推送新创建git"><a href="#推送新创建git" class="headerlink" title="推送新创建git"></a>推送新创建git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入本地文件夹</span></span><br><span class="line">cd tool</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line">echo &quot;# tool&quot; &gt;&gt; README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化git</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add -A 上传全部</span></span><br><span class="line">git add README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释</span></span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加分支</span></span><br><span class="line">git branch -M main</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加默认远程库</span></span><br><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="推送已存在的库"><a href="#推送已存在的库" class="headerlink" title="推送已存在的库"></a>推送已存在的库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="git删除远程库文件"><a href="#git删除远程库文件" class="headerlink" title="git删除远程库文件"></a>git删除远程库文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --help # 帮助命令</span><br><span class="line">git pull origin master # 将远程仓库里面的项目拉下来</span><br><span class="line">dir # 查看有哪些文件夹</span><br><span class="line">git rm -r --cached yun_app # 删除yun_app文件夹</span><br><span class="line">git commit -m ‘删除了yun_app’ # 提交,添加操作说明</span><br><span class="line">git push -u origin master # 将本次更改更新到github项目上去</span><br></pre></td></tr></table></figure>

<h3 id="git删除远程分支"><a href="#git删除远程分支" class="headerlink" title="git删除远程分支"></a>git删除远程分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速创建分支并切换分支 (dev 分支)</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支 ： 如分支名为dev</span></span><br><span class="line">git branch -d dev 会在删除前检查merge状态（其与上游分支或者与head）。</span><br><span class="line">git branch -D dev 它会直接删除,不检查</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git push origin --delete dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理本地不存在的远程分支，如别人删除了dev,但是你本地查看还有，就可以执行该条命令</span></span><br><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>

<h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 查看分支：git branch</span><br><span class="line"></span><br><span class="line">* 创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-clone文件代理"><a href="#git-clone文件代理" class="headerlink" title="git clone文件代理"></a>git clone文件代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git clone https://ghproxy.com/https://github.com/stilleshan/ServerStatus</span><br><span class="line"></span><br><span class="line">wget &amp; curl</span><br><span class="line">wget https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">wget https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br><span class="line">curl -O https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">curl -O https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>hector基础使用</title>
    <url>/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_41459903/article/details/102795148">思岚A1激光雷达hector_mapping建图与定位_欧俊岑的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_44785456/article/details/116789296?ops_request_misc=%7B%22request_id%22:%22163453792216780255277807%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163453792216780255277807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116789296.pc_search_ecpm_flag&utm_term=r2000+hector&spm=1018.2226.3001.4187">tx2+r2000激光雷达 hector建图_大家安静啊的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_36170626/article/details/98316545?ops_request_misc=%7B%22request_id%22:%22163454144916780262550313%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163454144916780262550313&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-98316545.pc_search_ecpm_flag&utm_term=hector_slam%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187">hectorslam之EAI雷达(ydlidar_x2l)配置过程_sunshine-CSDN博客</a></p>
<p><a href="https://github.com/NickL77/RPLidar_Hector_SLAM">NickL77/RPLidar_Hector_SLAM: Hector SLAM without odometry data on ROS with the RPLidar A1 (github.com)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hector是纯粹基于laserscan数据的算法,只需要提供scan数据即可,这里使用r2000做实验.因此第一步应该发布scan数据.</p>
<h1 id="Scan激光数据发布"><a href="#Scan激光数据发布" class="headerlink" title="Scan激光数据发布"></a>Scan激光数据发布</h1><p>r2000提供了ros发布的驱动文件,因此只需要修改些配置即可.</p>
<p>驱动网址:</p>
<p><a href="https://github.com/dillenberger/pepperl_fuchs">dillenberger/pepperl_fuchs: Pepperl+Fuchs R2000 Driver (github.com)</a></p>
<p>修改一下配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pepperl_fuchs_r2000&quot;</span> <span class="attr">type</span>=<span class="string">&quot;r2000_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;r2000_driver_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scanner_ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.1.19&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;frame_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;laser_link&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_frequency&quot;</span> <span class="attr">value</span>=<span class="string">&quot;35&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;samples_per_scan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;remap from=&quot;/r2000_driver_node/scan&quot; to=&quot;scan&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;node pkg=&quot;dummy_slam_broadcaster&quot; type=&quot;dummy_slam_broadcaster_node&quot; name=&quot;dummy_slam_broadcaster&quot;/&gt;</span></span><br><span class="line"><span class="comment">  &lt;node name=&quot;rvizLocal&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; respawn=&quot;false&quot; output=&quot;screen&quot; args=&quot;-d $(find pepperl_fuchs_r2000)/rviz/test.rviz&quot; required=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanner_ip       r2000的配置激光ip地址</span><br><span class="line">frame_id         发布出去的框架id(用于tf转换)</span><br><span class="line">scan_frequency   扫描频率</span><br><span class="line">samples_per_scan 每圈的扫描数</span><br><span class="line"># 值得注意的是这里r2000发不出去的scan节点为/r2000_driver_node/scan</span><br><span class="line"># 可以通过remap重定义为/scan</span><br><span class="line">最后通过rviz显示</span><br></pre></td></tr></table></figure>

<p>ros执行命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br></pre></td></tr></table></figure>

<h1 id="使用hector-mapping建图并定位"><a href="#使用hector-mapping建图并定位" class="headerlink" title="使用hector_mapping建图并定位"></a>使用hector_mapping建图并定位</h1><p>这里可以直接在系统中安装hector,并新建<code>hector_mapping.launch</code>文件,指令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-hector-slam</span><br><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_create_pkg run_launch # 因为内部都是launch文件并不需要依赖包</span><br><span class="line">cd run_launch &amp;&amp; sudo mkdir launch &amp;&amp; cd launch</span><br><span class="line">sudo nano hector_mapping.launch</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Frame names --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定map-&gt; odom转换是否应该由系统发布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_odom_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坐标系id,hector会将map与车体做tf连接到一块,而车体与激光之间的连接需要我们自己做 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;map&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于没有使用里程计,改为base_link即可 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Tf use --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_scan_transformation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_pose_start_estimate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map size / start point --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_resolution&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 地图尺寸需要注意一下,如果地图太小,可能导致激光范围过大,超出地图,这样匹配坐标会很挫 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;512&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_min_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;-1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_multi_res_levels&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_pub_period&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_min_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 激光扫描距离要适中,如果太小也会出现建图建的很挫的现象 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_timing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定scanmatcher到map的转换是否发布到TF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_scanmatch_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布的坐标名 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map update parameters --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_free&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_occupied&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.7&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_distance_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_angle_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.06&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Advertising config --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;advertise_map_service&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描订阅器的队列大小 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_subscriber_queue_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里更改一下scan_topic 如果我们做了重定向,需要改为/scan--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_topic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/r2000_driver_node/scan&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- !注意:这一步需要将车体坐标系与激光坐标系进行tf转换连接起来 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_to_laser_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0.105 0 0 0 /base_link /laser_link 100&quot;</span>/&gt;</span>_</span><br><span class="line">	<span class="comment">&lt;!-- 这里使用的是hector自带的rviz配置,我们也可以在他的基础上增减功能,另存到我们自己的文件src/run_launch/rviz/map/hector_map.rviz --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行步骤:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发布scan数据</span></span><br><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动hector_mapping</span></span><br><span class="line">roslaunch run_launch hector_mapping.launch</span><br></pre></td></tr></table></figure>

<h1 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h1><p><img src="https://img-blog.csdnimg.cn/20210514140914724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210514140924770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.订阅/scan不要出错</p>
<p>2.tf转换尤为需要注意,map-&gt;base_link-&gt;laser_link</p>
<p>3.激光距离与地图大小需要注意一下,这里设不好容易崩</p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>hector源码理解</title>
    <url>/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>大佬的分析,包含代码注释解析与源码重写,论文翻译</p>
<p><a href="https://blog.csdn.net/qq_36355662/article/details/90349302">Hector_slam源码框架分析_翎风的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/cyberniklee/p/8484104.html">Hector SLAM解读（1）原文翻译 - cyberniklee - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/scomup/p/7075296.html">HectorSLAM论文解析・代码重写（2） - scomup - 博客园 (cnblogs.com)</a></p>
<p><a href="https://github.com/zhangwenxiao/HectorSlamWithoutROS">zhangwenxiao/HectorSlamWithoutROS: 脱离ROS的hector slam算法 (github.com)</a></p>
<h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>该开源系统的主要代码在hector_mapping文件夹中，文件夹里有src文件夹和include文件夹，包含了算法所有的核心代码。<br>通过对源码的梳理，整理出了如下流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190520100840536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU1NjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>大佬的图非常清晰的可以看到,整个代码分为<code>地图匹配</code>与<code>地图更新</code></p>
<h1 id="地图匹配"><a href="#地图匹配" class="headerlink" title="地图匹配"></a>地图匹配</h1><p>主要采用<strong>非线性优化</strong>—-<strong>高斯牛顿法</strong>,实际上就是通过激光数据与现有地图的差距(双线性插补),通过最小二乘法,计算概率,从而更新位移增量,计算出机器人最可能存在位置</p>
<h2 id="双线性插值计算栅格概率"><a href="#双线性插值计算栅格概率" class="headerlink" title="双线性插值计算栅格概率"></a>双线性插值计算栅格概率</h2><p><a href="https://zhuanlan.zhihu.com/p/110754637">一篇文章为你讲透双线性插值 - 知乎 (zhihu.com)</a></p>
<p>通过双线性插补得到一个位置,然后通过最小二乘法,更新位移增量</p>
<h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1b441177kr?from=search&seid=5703864891923353812&spm_id_from=333.337.0.0">【泡泡机器人公开课】第三十课：非线性优化与g2o-高翔_哔哩哔哩_bilibili</a></p>
<h1 id="地图更新"><a href="#地图更新" class="headerlink" title="地图更新"></a>地图更新</h1><p>用bresenham<code>划线</code>算法计算激光途经栅格</p>
<p><a href="https://blog.csdn.net/yzh1994414/article/details/82860187">(60条消息) Bresenham 算法原理_yzh1994414的博客-CSDN博客_bresenham</a></p>
<p><a href="https://blog.csdn.net/datase/article/details/83620338">画线算法-Bresenham算法_天才樱木-CSDN博客_bresenham画线算法</a></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><p>（1）不需要使用里程计，可以用于地面不平坦区域及空中飞行器。<br>（2）使用多分辨率地图能避免局部最小值。</p>
<h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h4><p>（1）要求雷达更新频率较高，测量噪声小；或者机器人运动速度低。<br>（2）无法利用精确的里程计信息。</p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo安装</title>
    <url>/blog/2021/12/17/hexo%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.no_search_link&spm=1001.2101.3001.4242.1">(91条消息) hexo史上最全搭建教程_Fangzh的技术博客-CSDN博客_hexo</a> </p>
<p> <a href="https://blog.csdn.net/guzhao593/article/details/81712016?ops_request_misc=%7B%22request_id%22:%22164057576416780357213843%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164057576416780357213843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81712016.pc_search_insert_es_download&utm_term=%E5%8D%87%E7%BA%A7node%E7%89%88%E6%9C%AC&spm=1018.2226.3001.4187">(91条消息) node版本如何升级_赵天铭的博客-CSDN博客_升级node版本</a> </p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装git</span></span><br><span class="line">sudo apt-get install git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装nodejs</span></span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h1 id="nodejs问题"><a href="#nodejs问题" class="headerlink" title="nodejs问题"></a>nodejs问题</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g n</span><br><span class="line">npm i -g n --force</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级版本号</span></span><br><span class="line">n 版本号 如 n 10.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级最新</span></span><br><span class="line">n latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级最近稳定</span></span><br><span class="line">n stable</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hex解析</title>
    <url>/blog/2022/01/03/hex%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/a1037488611/article/details/43340055?ops_request_misc=%7B%22request_id%22:%22164121480016780269824327%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164121480016780269824327&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-43340055.nonecase&utm_term=hex%E8%A7%A3%E6%9E%90&spm=1018.2226.3001.4450">(94条消息) HEX文件格式解析_a1037488611的专栏-CSDN博客_hex文件格式解析</a> </p>
<h1 id="格式如下"><a href="#格式如下" class="headerlink" title="格式如下"></a>格式如下</h1><p><img src="https://s2.loli.net/2022/01/03/UjoEasnlNmLwYtZ.png" alt="1641215282358.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">：(冒号)每个Intel HEX 记录 都由冒 号开头 ；</span><br><span class="line">LL 是 数 据 长 度域, 它 代表 记录当 中 数 据字 节 (dd) 的 数量 ；</span><br><span class="line">aaaa 是地址域, 它代表 记录当 中 数据的起始地址；</span><br><span class="line">TT是代表HEX 记录类 型的域 , 它 可能是以下 数 据 当 中的一 个：</span><br><span class="line">    00 – 数 据 记录（Data Record）</span><br><span class="line">    01 – 文件结 束 记录（End of FileRecord）</span><br><span class="line">    02 – 扩展段地址 记录（ExtendedSegment Address Record）</span><br><span class="line">	03 – 开始段地址 记录（Start Segment Address Record）</span><br><span class="line">    04 – 扩展 线 性地址 记录（Extended Linear Address Record）</span><br><span class="line">	05 – 开始线性地址 记录（Extended Segment Address Record）</span><br><span class="line">dd 是数 据域 , 它 代表一 个 字 节 的 数 据. 一 个记录 可以有 许 多 数 据字 节 . 记录当 中 数 据字 节 的 数 量必 须 和数 据 长 度域(ll) 中指定的 数字相符.</span><br><span class="line">cc 是校验 和域 , 它 表示 这个记录 的校 验 和. 校 验 和的 计 算是通 过将记录当 中所有十六 进 制 编码数 字 对 的 值相加, 以256 为 模 进 行以下 补 足.</span><br><span class="line"></span><br><span class="line">表示为：“：[1字节长度][2字节地址][1字节记录类型][n字节段][1字节校验和] ”</span><br></pre></td></tr></table></figure>

<h1 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10 2462 00 464C5549442050524F46494C4500464C33</span><br><span class="line">：[10个数据长度][字节地址为:0x2462][记录类型为:00 数据记录][n字节段数据][crc校验:0x33]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>hugo配置</title>
    <url>/blog/2021/10/19/hugo/</url>
    <content><![CDATA[<h3 id="git安装与配置"><a href="#git安装与配置" class="headerlink" title="git安装与配置"></a>git安装与配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install git </span><br><span class="line"><span class="meta">#</span><span class="bash">git配置</span></span><br><span class="line">git config --global user.name &quot;zoey&quot;</span><br><span class="line">git config --global user.email &quot;zoey686@163.com&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看设置用户名与密码</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="hugo安装"><a href="#hugo安装" class="headerlink" title="hugo安装"></a>hugo安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo apt install hugo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动安装</span></span><br><span class="line">wget https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.deb</span><br><span class="line">sudo dpkg -i hugo_0.54.0_Linux-64bit.deb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">hugo --help</span><br><span class="line">hugo version</span><br></pre></td></tr></table></figure>

<h4 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h4><p>新建git文件夹用以git模板等，并在文件夹下新建myblog，用来存放博客页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建git文件夹并git初始化</span></span><br><span class="line">mkdir gitFile  </span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建myblog文件夹用来存放博客页面</span></span><br><span class="line">hugo new site myblog</span><br></pre></td></tr></table></figure>

<p>myblog下面就会有以下几个文件夹自动生成</p>
<table>
<thead>
<tr>
<th align="center">文件夹名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">archetypes</td>
<td align="center">文章开头形式</td>
</tr>
<tr>
<td align="center">content</td>
<td align="center">内容</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">自定义模板</td>
</tr>
<tr>
<td align="center">layouts</td>
<td align="center">网页模板文件</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">存储图片一些其他的资源</td>
</tr>
<tr>
<td align="center">themes</td>
<td align="center">主题</td>
</tr>
<tr>
<td align="center">config.toml</td>
<td align="center">配置文件</td>
</tr>
</tbody></table>
<h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>在（<a href="https://themes.gohugo.io/%EF%BC%89%E4%B8%AD%E6%8C%91%E9%80%89%E4%B8%BB%E9%A2%98,%E8%BF%99%E9%87%8C%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFdiary%E4%B8%BB%E9%A2%98%EF%BC%88[Diary">https://themes.gohugo.io/）中挑选主题,这里选择的是diary主题（[Diary</a> | Hugo Themes (gohugo.io)](<a href="https://themes.gohugo.io/themes/hugo-theme-diary/)%EF%BC%89">https://themes.gohugo.io/themes/hugo-theme-diary/)）</a></p>
<p>例子：（<a href="https://sunua.gitee.io/simonblog/">浅蓝色 (gitee.io)</a>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载diary主题到themes文件夹下并重命名为diary</span></span><br><span class="line">git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置config.toml文件</span></span><br><span class="line">nano config.toml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baseURL = &quot;https://peitianyu.github.io/pty_blog.github.io&quot;</span><br><span class="line">DefaultContentLanguage = &quot;zh&quot; # Theme&#x27;s display language, supports: en, fr, zh, zh-hant</span><br><span class="line">languageCode = &quot;zh-hant&quot;</span><br><span class="line">title = &quot;武装带你&quot;</span><br><span class="line">copyright = &quot;This is a customized copyright.&quot;</span><br><span class="line">theme = &quot;diary&quot;</span><br><span class="line"></span><br><span class="line">[markup]</span><br><span class="line">  [markup.highlight]</span><br><span class="line">    codeFences = true</span><br><span class="line">    guessSyntax = false</span><br><span class="line">    hl_Lines = &quot;&quot;</span><br><span class="line">    lineNoStart = 1</span><br><span class="line">    lineNos = false</span><br><span class="line">    lineNumbersInTable = true</span><br><span class="line">    noClasses = true</span><br><span class="line">    style = &quot;perldoc&quot;</span><br><span class="line">    tabWidth = 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enableOpenGraph = true</span><br><span class="line">enableTwitterCards = true</span><br><span class="line">title = &quot;My Blog&quot; </span><br><span class="line">description = &quot;My HomePage Description&quot;  </span><br><span class="line"></span><br><span class="line">[taxonomies]</span><br><span class="line">   ros = &quot;Ros&quot;</span><br><span class="line">   blog = &quot;Blog&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/blog&quot;</span><br><span class="line">name = &quot;Blog&quot;</span><br><span class="line">weight = 1</span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/ros&quot;</span><br><span class="line">name = &quot;Ros&quot;</span><br><span class="line">weight = 2</span><br></pre></td></tr></table></figure>

<h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><p>默认主目录文章在content/post下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建文章</span><br><span class="line">hugo new post/my_first_blog.md</span><br><span class="line">#创建文章在需要目录(Archive)下</span><br><span class="line">hugo new posts/my_first_blog.md</span><br><span class="line">cd content/post</span><br><span class="line">nano my_first_blog.md</span><br><span class="line"># 注意将draft参数改为false，否则跳过草稿文件，无法预览</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;my_first_blog&quot;</span><br><span class="line">date: 2021-10-12T10:49:31+08:00</span><br><span class="line">draft : false</span><br><span class="line">---</span><br><span class="line">文本内容</span><br></pre></td></tr></table></figure>

<p>本地调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hugo server --theme=blackburn --buildDrafts</span><br></pre></td></tr></table></figure>

<p>其中 –theme 选项可以指定主题，–buildDrafts 包括标记为草稿<br>然后在浏览器里打开： <a href="http://localhost:1313/">http://localhost:1313</a> 即可访问到你的博客</p>
<h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>如果你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：<code>pty_blog.github.io</code> （<strong>pty_blog替换为你的github用户名的小写</strong>）</p>
<p>进入仓库，点击<strong>Settings</strong>进入，找到<strong>GitHub Pages</strong>并点击<strong>Check it out here!<strong>，配置</strong>Source</strong>并<strong>save</strong>，会发现绿色框中显现 <code>Your site is published at https://peitianyu.github.io/pty_blog.github.io/</code></p>
<p>此处<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E4%B9%9F%E6%98%AFconfig.toml%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E8%AE%BE%E7%BD%AEhugo%E7%99%BB%E9%99%86%E7%BD%91%E5%9D%80">https://peitianyu.github.io/pty_blog.github.io/就是我们的网址，也是config.toml文件中设置的网址，设置hugo登陆网址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里的 –baseUrl 一定是https://（Hugo中文文档里为http://），不然你部署后的博客会没有样式！</p>
<p>可看到根目录下多出 /public文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。然后继续在你的站点根目录执行git 命令，添加远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd public</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:peitianyu/pty_blog.github.io.git</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>然后浏览器里访问：<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9A%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82">https://peitianyu.github.io/pty_blog.github.io/即可看到刚刚搭建的博客。</a></p>
<p>发布博客并更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建博客markdown文件，并编辑博客内容(文件名为 **.md )</span><br><span class="line">hugo new post/newBlog.md</span><br><span class="line"># 生成静态页面</span><br><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br><span class="line"># 发布</span><br><span class="line">cd public</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;new blog added&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>k60_can_bootloader</title>
    <url>/blog/2021/12/10/k60_can_bootloader/</url>
    <content><![CDATA[<h3 id="参考demo"><a href="#参考demo" class="headerlink" title="参考demo:"></a>参考demo:</h3><p><a href="https://github.com/peitianyu/k60_bootloader">peitianyu/k60_bootloader (github.com)</a></p>
<h3 id="main-c文件配置"><a href="#main-c文件配置" class="headerlink" title="main.c文件配置"></a>main.c文件配置</h3><h4 id="进入mian-c文件加入头文件并引用bootloader-entry-函数"><a href="#进入mian-c文件加入头文件并引用bootloader-entry-函数" class="headerlink" title="进入mian.c文件加入头文件并引用bootloader_entry()函数"></a>进入mian.c文件加入头文件并引用bootloader_entry()函数</h4><p><img src="https://s2.loli.net/2021/12/10/ywEp53mGsnHMbYc.png" alt="1.PNG"></p>
<h4 id="使用ID-0x10发送06-00-00-00-00-00-00-00，表示已经进入app"><a href="#使用ID-0x10发送06-00-00-00-00-00-00-00，表示已经进入app" class="headerlink" title="使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app"></a>使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app</h4><p><img src="https://s2.loli.net/2021/12/10/SvE7taw8y9ozPbh.png" alt="2.png"></p>
<h4 id="判断bootflag是否制一，若是，进入boot模式"><a href="#判断bootflag是否制一，若是，进入boot模式" class="headerlink" title="判断bootflag是否制一，若是，进入boot模式"></a>判断bootflag是否制一，若是，进入boot模式</h4><p><img src="https://s2.loli.net/2021/12/10/7pd6cl9bwtKPzFT.png" alt="3.png"></p>
<h3 id="canbus-c文件配置"><a href="#canbus-c文件配置" class="headerlink" title="canbus.c文件配置"></a>canbus.c文件配置</h3><h4 id="在canbus-c文件中引用头文件，并判断是否0x25发来数据，若有且data-data-0-1-则bootflag-1"><a href="#在canbus-c文件中引用头文件，并判断是否0x25发来数据，若有且data-data-0-1-则bootflag-1" class="headerlink" title="在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1"></a>在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1</h4><p><img src="https://s2.loli.net/2021/12/10/1nd3eMiXpUtBlAr.png" alt="4.png"></p>
<h3 id="keil配置"><a href="#keil配置" class="headerlink" title="keil配置"></a>keil配置</h3><h4 id="将hex烧录地址改为从0x6000开始"><a href="#将hex烧录地址改为从0x6000开始" class="headerlink" title="将hex烧录地址改为从0x6000开始"></a>将hex烧录地址改为从0x6000开始</h4><p><img src="https://s2.loli.net/2021/12/10/UhGvZDBPQqSeM9Y.png" alt="5.png"></p>
<h3 id="树莓派使用"><a href="#树莓派使用" class="headerlink" title="树莓派使用"></a>树莓派使用</h3><h4 id="bootloader-can0-xx-hex"><a href="#bootloader-can0-xx-hex" class="headerlink" title="./bootloader can0 xx.hex"></a>./bootloader can0 xx.hex</h4><p><img src="https://s2.loli.net/2021/12/10/wkOHJ3reb8AXVyT.png" alt="7.PNG"></p>
<h3 id="挂载win10"><a href="#挂载win10" class="headerlink" title="挂载win10"></a>挂载win10</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.2.101/2021.04/CH-K-Lib/Project/1/bootloader/MDK/mk60d10/flash /k60 -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>jetson_nano 踩坑</title>
    <url>/blog/2021/10/19/jetson_nano/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/166464566">玩转智能硬件之Jetson Nano(一)安装篇 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/Ay_yzx/article/details/113779544">Jetson Nano-配置环境_Ay_yzx的博客-CSDN博客</a></p>
<h4 id="预先下载"><a href="#预先下载" class="headerlink" title="预先下载:"></a>预先下载:</h4><p><code>balenaEtcher</code></p>
<p><a href="https://www.balena.io/etcher/">balenaEtcher - Flash OS images to SD cards &amp; USB drives</a></p>
<p><code>系统下载</code></p>
<p>官方默认系统:</p>
<p><a href="https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw">https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw</a></p>
<p>Ubuntu18.04:</p>
<p><a href="https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig">https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig</a> 密码 : tun3</p>
<p><code>sd卡格式化工具</code></p>
<p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">SD Memory Card Formatter for Windows Download | SD Association (sdcard.org)</a></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.格式化sd卡</span><br><span class="line">2.使用balenaEtcher烧录下载好的系统</span><br><span class="line">3.插上卡后做初始化设置</span><br></pre></td></tr></table></figure>

<h3 id="jetson三种供电方式"><a href="#jetson三种供电方式" class="headerlink" title="jetson三种供电方式:"></a>jetson三种供电方式:</h3><h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/weixin_44350337/article/details/111674531?ops_request_misc=%7B%22request_id%22:%22163456105816780262525022%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163456105816780262525022&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111674531.pc_search_ecpm_flag&utm_term=jetson+%E4%BE%9B%E7%94%B5&spm=1018.2226.3001.4187">Jetson nano 的三种供电方式_Dunkle.T的博客-CSDN博客_jetson nano供电</a></p>
<h4 id="分别为"><a href="#分别为" class="headerlink" title="分别为:"></a>分别为:</h4><ul>
<li>USB供电(默认5v2a 仅低功率),使用时拔去条线帽</li>
<li>使用 DC 供电(默认5v 4A),使用时插上跳线帽</li>
<li>使用引脚供电(5v3a 无所谓跳线帽)</li>
</ul>
<h4 id="查看cuda配置"><a href="#查看cuda配置" class="headerlink" title="查看cuda配置"></a>查看cuda配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install jetson-stats</span><br><span class="line">sudo jtop</span><br></pre></td></tr></table></figure>

<h3 id="关于ros安装"><a href="#关于ros安装" class="headerlink" title="关于ros安装"></a>关于ros安装</h3><h4 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://peitianyu.github.io/pty_blog.github.io/ros/ros%E5%AE%89%E8%A3%85/">ROS_安装 (peitianyu.github.io)</a></p>
<h4 id="其他部分按ros安装教程来即可"><a href="#其他部分按ros安装教程来即可" class="headerlink" title="其他部分按ros安装教程来即可"></a>其他部分按ros安装教程来即可</h4><p>比较实用的方案是先按照我的步骤安装ros,之后再通过<code>fishros一行代码</code>解决rosdep问题</p>
<h3 id="远程连接nano"><a href="#远程连接nano" class="headerlink" title="远程连接nano"></a>远程连接nano</h3><p><code>ssh.exe usrname@192.168.xxx.xxx</code></p>
<h3 id="jetson-nano初始化配置"><a href="#jetson-nano初始化配置" class="headerlink" title="jetson nano初始化配置"></a>jetson nano初始化配置</h3><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><code>静态ip设置</code>:<a href="https://www.cnblogs.com/blueyunchao0618/p/11394640.html">Ubuntu 18.04配置静态IP地址)</a></p>
<h4 id="root免密登录"><a href="#root免密登录" class="headerlink" title="root免密登录"></a>root免密登录</h4><p><code>参考网址</code>:<a href="https://blog.csdn.net/qq_44673299/article/details/108658078?ops_request_misc=%7B%22request_id%22:%22163463123116780271513740%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163463123116780271513740&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-108658078.pc_search_ecpm_flag&utm_term=Ubuntu18+root%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95&spm=1018.2226.3001.4187">ubuntu设置root免密登陆</a></p>
<h3 id="vscode连接jetson-nano"><a href="#vscode连接jetson-nano" class="headerlink" title="vscode连接jetson nano"></a>vscode连接jetson nano</h3><h4 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/sqlquan/article/details/111918019?ops_request_misc=%7B%22request_id%22:%22163463106616780264095126%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163463106616780264095126&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111918019.pc_search_ecpm_flag&utm_term=vscode+ssh&spm=1018.2226.3001.4187">vscode设置ssh进行远程编辑_Quan的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_shell</title>
    <url>/blog/2021/12/09/linux_shell/</url>
    <content><![CDATA[<h1 id="删除除某文件以外其他文件"><a href="#删除除某文件以外其他文件" class="headerlink" title="删除除某文件以外其他文件"></a>删除除某文件以外其他文件</h1><h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://www.cnblogs.com/blueskycc/p/5139902.html">linux删除指定文件夹中某个文件除外的其他文件 - He元素 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shopt -s extglob</span><br><span class="line">rm -fr !(file1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是多个要排除的，可以这样：</span></span><br><span class="line">rm -rf !(file1|file2)</span><br></pre></td></tr></table></figure>

<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址"></a>参考网址</h2><p><a href="https://www.cnblogs.com/windchen/p/6236299.html">ubuntu 挂载windows共享目录的方法 - Supper阿欣 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fzzfh/p/10330014.html">linux挂载文件报错mount error(13): Permission denied - 风中追风h - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.zhihu.com/question/41745930/answer/510335896">win10 家庭版 cmd运行gpedit.msc找不到文件？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://langbin.blog.csdn.net/article/details/78929045">(2条消息) ubuntu挂载Windows共享文件夹_深藏功与名-CSDN博客_ubuntu挂载windows共享目录</a></p>
<h2 id="pi挂载Ubuntu"><a href="#pi挂载Ubuntu" class="headerlink" title="pi挂载Ubuntu"></a>pi挂载Ubuntu</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount 192.168.2.111:/home/pty/nfs/ /mnt  </span><br></pre></td></tr></table></figure>

<h2 id="pi挂载win"><a href="#pi挂载win" class="headerlink" title="pi挂载win"></a>pi挂载win</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.10.1/d  /mnt -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw,dir_mode=0777,file_mode=0777</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>io扩展</title>
    <url>/blog/2021/11/11/io%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u012388993/article/details/106386381?ops_request_misc=%7B%22request_id%22:%22163650486016780366540586%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=163650486016780366540586&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-19-106386381.pc_v2_rank_blog_default&utm_term=%E6%89%A9%E5%B1%95io&spm=1018.2226.3001.4450">IO口不够了？基于I2C的 IO扩展芯片驱动和开发_arenascat的博客-CSDN博客_io扩展芯片</a></p>
<p><a href="https://blog.csdn.net/zhengqijun_/article/details/53011409?ops_request_misc=%7B%22request_id%22:%22163650477816780265471235%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163650477816780265471235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-53011409.pc_search_mgc_flag&utm_term=%E6%89%A9%E5%B1%95io&spm=1018.2226.3001.4187">单片机扩展IO口_我的博客-CSDN博客</a></p>
<h1 id="74HC164-三八译码器-矩阵键盘"><a href="#74HC164-三八译码器-矩阵键盘" class="headerlink" title="74HC164(三八译码器),矩阵键盘"></a>74HC164(三八译码器),矩阵键盘</h1><p>这种方式可以实现简单的io扩展,但不可以保持,也就是说,治理只是三位二进制转为八个数,虽然也可以通过加快频率的方式实现.仅用于对时序要求不高的电路,比如led流水灯,而尤其是通讯不太适用的.</p>
<h1 id="采用可编程I-O接口扩展芯片"><a href="#采用可编程I-O接口扩展芯片" class="headerlink" title="采用可编程I/O接口扩展芯片"></a>采用可编程I/O接口扩展芯片</h1><p>这种方式可以实现io扩展,不过需要一定的编程经验.</p>
<p>采用芯片有 <code>8255a</code> 与 <code>MCP23016</code></p>
<p><a href="https://so.szlcsc.com/global.html?k=i/o%E6%89%A9%E5%B1%95%E8%8A%AF%E7%89%87&hot-key=MB85RC16PNF-G-JNERE1">i/o扩展芯片_i/o扩展芯片采购信息-立创电子元器件商城 (szlcsc.com)</a></p>
<h1 id="采用A-D获取按键的位置"><a href="#采用A-D获取按键的位置" class="headerlink" title="采用A/D获取按键的位置"></a>采用A/D获取按键的位置</h1><p>通过不同电压对应不通按键,挺不错的思路</p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_gpio</title>
    <url>/blog/2021/11/23/linux_gpio/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/lell3538/article/details/51277870?ops_request_misc=%7B%22request_id%22:%22163767480816780261986595%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767480816780261986595&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51277870.pc_search_mgc_flag&utm_term=linux%E6%93%8D%E4%BD%9Cgpio&spm=1018.2226.3001.4187">Linux操作GPIO（文件IO方式）_Leon-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/u010299133/article/details/82286700?ops_request_misc=%7B%22request_id%22:%22163767480816780261986595%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767480816780261986595&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82286700.pc_search_mgc_flag&utm_term=linux%E6%93%8D%E4%BD%9Cgpio&spm=1018.2226.3001.4187">在Linux 中的应用层操作gpio的方法_仗劍走天涯-CSDN博客</a></p>
<h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><p><code>控制GPIO</code>的目录位于<code>/sys/class/gpio</code></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 导出</span><br><span class="line">/sys/class/gpio# echo 44 &gt; export</span><br><span class="line">2. 设置方向</span><br><span class="line">/sys/class/gpio/gpio44# echo out &gt; direction</span><br><span class="line">3. 查看方向</span><br><span class="line">/sys/class/gpio/gpio44# cat direction</span><br><span class="line">4. 设置输出</span><br><span class="line">/sys/class/gpio/gpio44# echo 1 &gt; value</span><br><span class="line">5. 查看输出值</span><br><span class="line">/sys/class/gpio/gpio44# cat value</span><br><span class="line">6. 取消导出</span><br><span class="line">/sys/class/gpio# echo 44 &gt; unexport</span><br></pre></td></tr></table></figure>

<p> 以<strong>echo</strong>的形式调用<strong>system</strong>函数进行操作，这种形式编程比较简单，结构比较清晰，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gpio64_low</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 64 &gt; /sys/class/gpio/export&quot;</span>);  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo out &gt; /sys/class/gpio/gpio64/direction&quot;</span>);  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 0 &gt; /sys/class/gpio/gpio64/value&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> 通过<strong>文件</strong>的形式来调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>   <span class="comment">//define O_WRONLY and O_RDONLY</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGpio</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp =<span class="built_in">fopen</span>(<span class="string">&quot;/sys/class/gpio/export&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;export open filed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;   <span class="comment">//create gpio file</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGpioDirection</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> *direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(path,<span class="string">&quot;/sys/class/gpio/gpio%d/direction&quot;</span>,n);</span><br><span class="line">    FILE * fp =<span class="built_in">fopen</span>(path,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;direction open filed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,direction);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;   <span class="comment">//set gpio &quot;in&quot; or &quot;out&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGpioValue</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> value_str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="built_in"><span class="keyword">sizeof</span></span>(path), <span class="string">&quot;/sys/class/gpio/gpio%d/value&quot;</span>, n);</span><br><span class="line">    fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open gpio value for reading!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd, value_str, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to read value!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">atoi</span>(value_str));</span><br><span class="line">&#125;   <span class="comment">//get gpio(n)&#x27;s value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGpioValue</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> value_str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="built_in"><span class="keyword">sizeof</span></span>(path), <span class="string">&quot;/sys/class/gpio/gpio%d/value&quot;</span>, n);</span><br><span class="line">    fd = <span class="built_in">open</span>(path, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open gpio value for writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">        <span class="built_in">strcpy</span>(value_str,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strcpy</span>(value_str,<span class="string">&quot;0&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, value_str, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to write value!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;   <span class="comment">//set gpio(n)&#x27;s value</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initGpio</span>(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">setGpioDirection</span>(<span class="number">18</span>,(<span class="keyword">char</span>*)<span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setGpioValue</span>(<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getGpioValue</span>(<span class="number">18</span>));<span class="comment">//每隔1s输出一次gpio18的值</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">setGpioValue</span>(<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getGpioValue</span>(<span class="number">18</span>));<span class="comment">//每隔1s输出一次gpio18的值</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux定时器</title>
    <url>/blog/2021/12/10/linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_34358365/article/details/94217782?ops_request_misc=%7B%22request_id%22:%22163914549216780255279840%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163914549216780255279840&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-94217782.nonecase&utm_term=linux%E5%AE%9A%E6%97%B6%E5%99%A8&spm=1018.2226.3001.4187">LInux下几种定时器的比较和使用_weixin_34358365的博客-CSDN博客</a></p>
<h1 id="1、sleep，usleep和nanosleep"><a href="#1、sleep，usleep和nanosleep" class="headerlink" title="1、sleep，usleep和nanosleep"></a>1、<a href="http://www.jb51.net/LINUXjishu/109403.html">sleep，usleep和nanosleep</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION 1000000L</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">slptm</span>;</span></span><br><span class="line">    <span class="keyword">long</span>   tdif;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tend</span>, <span class="title">tstart</span>;</span> </span><br><span class="line">    slptm.tv_sec = <span class="number">0</span>;</span><br><span class="line">    slptm.tv_nsec = <span class="number">1000</span>;      <span class="comment">//1000 ns = 1 us</span></span><br><span class="line">    <span class="comment">//struct sched_param param;    </span></span><br><span class="line">    <span class="comment">//param.sched_priority = 0;</span></span><br><span class="line">    <span class="comment">//sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);</span></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tstart, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get start time\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosleep(&amp;slptm, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to nanosleep&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tend, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get end time\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tdif = MILLION * (tend.tv_sec - tstart.tv_sec) + (tend.tv_usec - tstart.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nanosleep() time is %ld us\n&quot;</span>, tdif/COUNT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、使用信号量SIGALRM-alarm-只能秒级"><a href="#2、使用信号量SIGALRM-alarm-只能秒级" class="headerlink" title="2、使用信号量SIGALRM + alarm(),只能秒级"></a>2、使用信号量SIGALRM + alarm(),只能秒级</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIGALRM == sig)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;timer\n&quot;</span>);</span><br><span class="line">                alarm(<span class="number">1</span>);       <span class="comment">//重新继续定时1s</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        signal(SIGALRM, timer); <span class="comment">//注册安装信号</span></span><br><span class="line">        alarm(<span class="number">1</span>);       <span class="comment">//触发定时器</span></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、使用RTC-系统硬件提供的RTC，精度可调"><a href="#3、使用RTC-系统硬件提供的RTC，精度可调" class="headerlink" title="3、使用RTC(系统硬件提供的RTC，精度可调)"></a>3、使用RTC(系统硬件提供的RTC，精度可调)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> data = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fd = open (<span class="string">&quot;/dev/rtc&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*Set the freq as 4Hz*/</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(fd, RTC_IRQP_SET, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;ioctl(RTC_IRQP_SET)&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Enable periodic interrupts */</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(fd, RTC_PIE_ON, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;ioctl(RTC_PIE_ON)&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(read(fd, &amp;data, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        close(fd);</span><br><span class="line">                        <span class="built_in">exit</span>(errno);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;timer\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Disable periodic interrupts */</span></span><br><span class="line">        ioctl(fd, RTC_PIE_OFF, <span class="number">0</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、使用select"><a href="#4、使用select" class="headerlink" title="4、使用select()"></a>4、使用select()</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, this is Callback_1: x = %d \n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimer</span><span class="params">(<span class="keyword">int</span> seconds, <span class="keyword">int</span> mseconds,T arg,<span class="keyword">int</span> (*callback)(T))</span> <span class="comment">// Set Timer</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">temp</span>;</span></span><br><span class="line">        temp.tv_sec = seconds;</span><br><span class="line">        temp.tv_usec = mseconds;</span><br><span class="line">        select(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;temp);</span><br><span class="line">        callback(arg);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> last_time;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_diff_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">float</span> time = tv.tv_sec%<span class="number">10</span> + tv.tv_usec / <span class="number">1000000.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; last_time)</span><br><span class="line">                time += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> time_diff = time - last_time;</span><br><span class="line">        last_time = time;</span><br><span class="line">        <span class="keyword">return</span> time_diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> time_diff = get_diff_time();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time_diff = %f \n&quot;</span>, time_diff);</span><br><span class="line">        setTimer(<span class="number">1</span>, <span class="number">0</span>, a, Callback_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux报错</title>
    <url>/blog/2022/01/15/linux%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/JIEJINQUANIL/article/details/106414938">(99条消息) 编译警告：warning: Clock skew detected. Your build may be incomplete._竭尽全力的专栏-CSDN博客</a> </p>
<h1 id="warning-Clock-skew-detected"><a href="#warning-Clock-skew-detected" class="headerlink" title="warning: Clock skew detected"></a>warning: Clock skew detected</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f | xargs -n 5 touch</span><br></pre></td></tr></table></figure>

<h1 id="apt-upgdate-失败"><a href="#apt-upgdate-失败" class="headerlink" title="apt upgdate 失败"></a>apt upgdate 失败</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br><span class="line">sudo dpkg --configure -a </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux解压</title>
    <url>/blog/2021/11/11/linux%E8%A7%A3%E5%8E%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/scanf_linux/article/details/90382491?ops_request_misc=%7B%22request_id%22:%22163644518016780271536349%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163644518016780271536349&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90382491.pc_search_mgc_flag&utm_term=linux%E8%A7%A3%E5%8E%8Btar.gz&spm=1018.2226.3001.4187">Linux解压.tgz，.tar.gz文件（tar详细参数使用介绍）_echo-CSDN博客_linux解压.tar.gz文件</a></p>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar </span><br><span class="line">tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line">tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span><br><span class="line">tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]</span><br><span class="line">tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载 rar for linux</span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载 zip for linux</span><br></pre></td></tr></table></figure>

<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">tar -xZvf file.tar.Z   //解压tar.Z</span><br><span class="line">tar -Jxvf file.tar.xz</span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line">unzip file.zip //解压zip</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*.tar 用 tar -xvf 解压</span><br><span class="line">*.gz 用 gzip -d或者gunzip 解压</span><br><span class="line">*.tar.gz和*.tgz 用 tar -xzf 解压</span><br><span class="line">*.bz2 用 bzip2 -d或者用bunzip2 解压</span><br><span class="line">*.tar.bz2用tar -xjf 解压</span><br><span class="line">*.Z 用 uncompress 解压</span><br><span class="line">*.tar.Z 用tar -xZf 解压</span><br><span class="line">*.rar 用 unrar e解压</span><br><span class="line">*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>make配置模板</title>
    <url>/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="make文件目录"><a href="#make文件目录" class="headerlink" title="make文件目录"></a>make文件目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/make# tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── conf.sh</span><br><span class="line">├── main.cpp</span><br><span class="line">└── shell.sh</span><br></pre></td></tr></table></figure>

<p>这里使用了shell脚本来实现对于make的编译，由于使用的是<code>wsl</code>在windows下操作导致编码格式含有<code>\r\n</code>，以此有两个shell脚本。</p>
<h3 id="conf-sh"><a href="#conf-sh" class="headerlink" title="conf.sh"></a>conf.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现对于make的编译与运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [[ $1 == clean ]]; then</span><br><span class="line">        make clean</span><br><span class="line">elif [[ $1 == all ]]; then</span><br><span class="line">        make clean &amp;&amp; make -j8 &amp;&amp; ./main</span><br><span class="line">else</span><br><span class="line">        make -j8 &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现将conf.sh的dos编码转化为unix编码，并执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">dos2unix  conf.sh &amp;&amp; ./conf.sh</span><br></pre></td></tr></table></figure>

<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动捕捉符合c/c++编译</span></span><br><span class="line"><span class="comment">#指定编译工具</span></span><br><span class="line">CC = gcc</span><br><span class="line">CPP = g++</span><br><span class="line">LINK = g++</span><br><span class="line"></span><br><span class="line">LIBS = -lsqlite3 -lpthread</span><br><span class="line"><span class="comment">#编译.so 必须添加 -fPIC 和 -shared 选项</span></span><br><span class="line">CCFLAGS = -c -g -fPIC</span><br><span class="line">CPPFLAGS = -c -g -fPIC</span><br><span class="line"></span><br><span class="line"><span class="comment">#期望得到的执行文件或动态库.so</span></span><br><span class="line"><span class="comment">#TARGET=libxx.so</span></span><br><span class="line">TARGET=main</span><br><span class="line"></span><br><span class="line">INCLUDES = -I. <span class="comment">#-I../../</span></span><br><span class="line"></span><br><span class="line">CPPFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.cpp文件</span></span><br><span class="line">CFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.c文件</span></span><br><span class="line"></span><br><span class="line">OBJFILE = $(CFILES:.c=.o) $(CPPFILES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJFILE)</span></span><br><span class="line"><span class="comment"># 编译得到 .so 文件用下面的代码</span></span><br><span class="line"><span class="comment">#   $(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@</span></span><br><span class="line"><span class="comment"># 编译得到可执行文件用下面的代码</span></span><br><span class="line">        <span class="variable">$(LINK)</span> <span class="variable">$^</span> <span class="variable">$(LIBS)</span> -Wall -O2 -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(CCFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">        <span class="variable">$(CPP)</span> -o <span class="variable">$@</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJFILE)</span></span><br></pre></td></tr></table></figure>

<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./shell</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>map_server</title>
    <url>/blog/2021/11/05/map_server/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/datase/article/details/82495600">(60条消息) map server 功能和作用_天才樱木-CSDN博客_map_server</a></p>
<h1 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun map_server map_saver -f mymap</span><br></pre></td></tr></table></figure>

<p>我们会得到两个文件,<code>mymap.pgm</code>,<code>mymap.yaml</code></p>
<p><code>mymap.pgm</code>为0到1的灰度图</p>
<p><code>mymap.yaml</code>为配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">image: testmap.png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分辨率</span></span><br><span class="line">resolution: 0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始点</span></span><br><span class="line">origin: [0.0, 0.0, 0.0]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 占用阈值</span></span><br><span class="line">occupied_thresh: 0.65</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为自由阈值</span></span><br><span class="line">free_thresh: 0.196</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否应该颠倒白/黑 自由/被占用的语义(阈值的解释不受影响)</span></span><br><span class="line">negate: 0</span><br></pre></td></tr></table></figure>

<h1 id="发布节点"><a href="#发布节点" class="headerlink" title="发布节点"></a>发布节点</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun map_server map_server mymap.yaml</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><strong>map_metadata</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html">nav_msgs/MapMetaData</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这包含了关于占领网格特征的基本信息</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图加载的时间</span></span><br><span class="line">time map_load_time</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的分辨率 [m/cell]</span></span><br><span class="line">float32 resolution</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map width [cells]</span></span><br><span class="line">uint32 width</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map height [cells]</span></span><br><span class="line">uint32 height</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的原点[m, m, rad]。这是地图中单元格(0,0)的真实姿态。</span></span><br><span class="line">geometry_msgs/Pose origin</span><br></pre></td></tr></table></figure>

<p><strong>map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html">nav_msgs/OccupancyGrid</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这代表了一个二维网格地图，其中每个单元格代表占用概率。</span></span><br><span class="line"></span><br><span class="line">Header header </span><br><span class="line"><span class="meta">#</span><span class="bash"> uint32 seq</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> time stamp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> string frame_id</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">地图的元数据</span></span><br><span class="line">MapMetaData info</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射数据，按行主顺序，从(0,0)开始。占用概率在[0,100]范围内。未知是1。</span></span><br><span class="line">int8[] data</span><br></pre></td></tr></table></figure>

<p><strong>static_map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html">nav_msgs/GetMap</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Get the map as a nav_msgs/OccupancyGrid</span></span><br><span class="line">---</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>mpg处理</title>
    <url>/blog/2021/10/19/mpg%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://blog.csdn.net/qq_44343584/article/details/119992961">(47条消息) ROS开发实践（十三）——ROS中SLAM地图（.pgm格式）编辑软件的安装与使用_Ehang_Maker的博客-CSDN博客</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="http://gimp.baisheng999.com/">Gimp中文网 (baisheng999.com)</a></p>
<h4 id="windows安装流程"><a href="#windows安装流程" class="headerlink" title="windows安装流程:"></a>windows安装流程:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意选择安装路径,其他下一步即可</span><br></pre></td></tr></table></figure>

<h3 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.选择使用笔刷工具</span><br><span class="line">2.设置笔刷大小,硬度为100,力度为100,线型为直线</span><br><span class="line">3.按住Ctrl选择颜色</span><br><span class="line">4.释放后刷刷刷</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>nano操作</title>
    <url>/blog/2021/10/19/nano%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><a href="https://blog.csdn.net/weixin_39591031/article/details/114236749?ops_request_misc=%7B%22request_id%22:%22163464180216780269866385%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163464180216780269866385&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-114236749.pc_search_ecpm_flag&utm_term=nano%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">nano使用技巧大全_Xav Pun的博客-CSDN博客_nano使用教程</a></li>
</ul>
<h3 id="便捷快捷键"><a href="#便捷快捷键" class="headerlink" title="便捷快捷键"></a>便捷快捷键</h3><p>注意前缀键<code>Ctrl+b</code>按完后松开，再按下其他键。</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>Alt+x</em></td>
<td align="center">切换帮助栏</td>
</tr>
<tr>
<td align="center"><em>ALT-#</em></td>
<td align="center">显示行号</td>
</tr>
<tr>
<td align="center"><em>CTRL-K</em></td>
<td align="center">剪切到行末</td>
</tr>
<tr>
<td align="center">ALT+6</td>
<td align="center">复制</td>
</tr>
<tr>
<td align="center">SHIFT+方向</td>
<td align="center">选择</td>
</tr>
<tr>
<td align="center">CTRL+u</td>
<td align="center">粘贴</td>
</tr>
<tr>
<td align="center">Alt + u</td>
<td align="center">撤销</td>
</tr>
<tr>
<td align="center">Alt + e</td>
<td align="center">重复</td>
</tr>
<tr>
<td align="center">ALT+&lt;</td>
<td align="center"><em>切换到上一个文件</em></td>
</tr>
<tr>
<td align="center">ALT+&gt; / alt +</td>
<td align="center"><em>切换到下一个文件</em></td>
</tr>
<tr>
<td align="center">CTRL+X</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">CTRL+R CTRL+T</td>
<td align="center">文件浏览器</td>
</tr>
<tr>
<td align="center">CTRL+C</td>
<td align="center">退出文件选择界面</td>
</tr>
<tr>
<td align="center">CTRL+S</td>
<td align="center">保存</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>简单pid控制</title>
    <url>/blog/2021/12/16/pid%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>[P、I、D参数分析及倒立摆心得_一念之间、-CSDN博客_pid 倒立摆](<a href="https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p%E8%A1%A8%E7%A4%BA">https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p表示</a> i表示 d表示&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-8-75249145.pc_search_em_sort&amp;spm=1018.2226.3001.4187)</p>
<p><a href="https://blog.csdn.net/qq_18454025/article/details/103443771?ops_request_misc=%7B%22request_id%22:%22163961834316780274185698%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163961834316780274185698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-3-103443771.pc_search_em_sort&utm_term=pid&spm=1018.2226.3001.4187">PID控制算法的C语言实现_我的博客-CSDN博客_pid算法c程序</a></p>
<h1 id="PID作用"><a href="#PID作用" class="headerlink" title="PID作用"></a>PID作用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P-------作用是提高系统响应速度,过大会出现震荡---------------------------快速性</span><br><span class="line"></span><br><span class="line">I-------作用是消除静差----------------------------------------------准确性</span><br><span class="line"></span><br><span class="line">D-------作用是抑制震荡----------------------------------------------稳定性/预测性</span><br></pre></td></tr></table></figure>

<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pid控制测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P:响应 I:稳差 D:预判</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> kp;</span><br><span class="line">    <span class="keyword">float</span> ki;</span><br><span class="line">    <span class="keyword">float</span> kd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">pos_pid_control</span><span class="params">(<span class="keyword">float</span> target, <span class="keyword">float</span> current, struct PID_CTRL pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> err_last;</span><br><span class="line">    <span class="keyword">float</span> out,err_sum=<span class="number">0</span>,err_d,err;</span><br><span class="line">    err = target - current;</span><br><span class="line">    err_sum += err;</span><br><span class="line">    err_d = err - err_last;</span><br><span class="line">    out = pid.kp * err + pid.ki * err_sum + pid.kd * err_d;</span><br><span class="line">    err_last = err;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gain_pid_control</span><span class="params">(<span class="keyword">float</span> target, <span class="keyword">float</span> current, struct PID_CTRL pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> err_last;</span><br><span class="line">    <span class="keyword">float</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> err = target - current;</span><br><span class="line">    out += pid.kp * (err-err_last) + pid.ki * err;</span><br><span class="line">    err_last = err;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pos_pid_control</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span> <span class="title">pid</span>&#123;</span><span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">    pid.kp = <span class="number">0.5</span>;</span><br><span class="line">    pid.ki = <span class="number">0.2</span>;</span><br><span class="line">    pid.kd = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> target = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> current = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current += <span class="number">0.1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;target: %f, current: %f, out: %f\n&quot;</span>, target, current, <span class="built_in">pos_pid_control</span>(target, current, pid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_gain_pid_control</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span> <span class="title">pid</span>&#123;</span><span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">    pid.kp = <span class="number">0.5</span>;</span><br><span class="line">    pid.ki = <span class="number">0.2</span>;</span><br><span class="line">    pid.kd = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> target = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> current = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current += <span class="number">0.1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;target: %f, current: %f, out: %f\n&quot;</span>, target, current, <span class="built_in">gain_pid_control</span>(target, current, pid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_pos_pid_control</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">test_gain_pid_control</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread_mutex使用</title>
    <url>/blog/2021/12/17/pthread_mutex%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/networkhunter/article/details/100218945?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-100218945.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">pthread详解_networkhunter的博客-CSDN博客_phread</a></p>
<p><a href="https://blog.csdn.net/z_muyangren/article/details/105398871?ops_request_misc=%7B%22request_id%22:%22163970180516780271917732%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970180516780271917732&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-105398871.pc_search_em_sort&utm_term=pthread_mutex_lock&spm=1018.2226.3001.4187">关于pthread_mutex_lock使用_无专精则不能成，无涉猎则不能通-CSDN博客_pthread_mutex_timedlock</a></p>
<p><a href="https://blog.csdn.net/a6333230/article/details/113654694?ops_request_misc=%7B%22request_id%22:%22163970180516780264024377%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163970180516780264024377&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-113654694.pc_search_em_sort&utm_term=pthread_mutex_lock&spm=1018.2226.3001.4187">linux读写锁 pthread_rwlock/互斥锁pthread_mutex_三眼二郎-CSDN博客_pthread_mutex_t pthread_rwlock_t</a></p>
<h1 id="常用pthread-mutex-lock"><a href="#常用pthread-mutex-lock" class="headerlink" title="常用pthread_mutex_lock"></a>常用pthread_mutex_lock</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="comment">// 初始化互斥量</span></span><br><span class="line"><span class="comment">// 第二个参数为 NULL，互斥锁的属性会设置为默认属性</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mtx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 阻塞调用</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line"><span class="comment">// 非堵塞调用</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">pthread_mutex_trylock</span>(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != err) &#123;</span><br><span class="line">    <span class="keyword">if</span>(EBUSY == err) &#123;</span><br><span class="line">        <span class="comment">//The mutex could not be acquired because it was already locked.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 超时调用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">abs_timeout</span>;</span></span><br><span class="line">abs_timeout.tv_sec = <span class="built_in">time</span>(<span class="literal">NULL</span>) + <span class="number">1</span>;</span><br><span class="line">abs_timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">pthread_mutex_timedlock</span>(&amp;mtx, &amp;abs_timeout);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != err) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ETIMEDOUT == err) &#123;</span><br><span class="line">        <span class="comment">//The mutex could not be locked before the specified timeout expired.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放互斥锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line"><span class="comment">// 销毁线程锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mtx)</span><br></pre></td></tr></table></figure>

<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">/*初始化互斥锁*/</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;<span class="comment">//init cond</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//global</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_a;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_b;<span class="comment">//two thread</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t_a,<span class="literal">NULL</span>,thread2,(<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t_b,<span class="literal">NULL</span>,thread1,(<span class="keyword">void</span>*)<span class="literal">NULL</span>);<span class="comment">//Create thread</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t_a:0x%x, t_b:0x%x:&quot;</span>, t_a, t_b);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t_b,<span class="literal">NULL</span>);<span class="comment">//wait a_b thread end</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *junk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">//互斥锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call thread1 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;cond); <span class="comment">//send sianal to t_b</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread1:******i=%d\n&quot;</span>, i);</span><br><span class="line">        	&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread1: %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1: sleep i=%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1: sleep i=%d******end\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span>*junk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call thread2 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex); <span class="comment">//wait</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2: %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2: sleep i=%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2: sleep i=%d******end\n&quot;</span>, i);		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>pip</title>
    <url>/blog/2021/12/11/pip/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_43146445/article/details/85078685?ops_request_misc=%7B%22request_id%22:%22162487776816780265445855%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162487776816780265445855&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-85078685.pc_search_result_control_group&utm_term=pip%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">(8条消息) pip安装镜像_转载_qq_2711624322-CSDN博客_pip安装镜像</a></p>
<p><a href="https://blog.csdn.net/SimpleLikeMe/article/details/104480017?ops_request_misc=%7B%22request_id%22:%22162761016016780265417243%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162761016016780265417243&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104480017.first_rank_v2_pc_rank_v29&utm_term=pip%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%95%9C%E5%83%8F%E6%BA%90&spm=1018.2226.3001.4187">设pip默认镜像源_SimpleLikeMe的博客-CSDN博客</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">临时使用</span></span><br><span class="line">pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple package</span><br><span class="line"><span class="meta">#</span><span class="bash">配置成固定镜像</span></span><br><span class="line">pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ros2安装</title>
    <url>/blog/2021/12/10/ros2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_44717317/article/details/104547474">Ubuntu18.04 安装ROS Melodic &amp;&amp; Ros2 Dashing踩坑笔记_LukeyAlvin的博客-CSDN博客_ubuntu18安装ros2</a></p>
<p><a href="http://fishros.com/#/fish_home">鱼香ROS (fishros.com)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于ros2很多并不完善,所以采用ros1+ros2的方式实现,这里采用常规+fishros的方式实现安装.最后采用在初始化使用shell脚本选择使用ros版本</p>
<h1 id="Ros1安装"><a href="#Ros1安装" class="headerlink" title="Ros1安装"></a>Ros1安装</h1><p><a href="https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/">ros安装 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<h1 id="Ros2安装"><a href="#Ros2安装" class="headerlink" title="Ros2安装"></a>Ros2安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置UTF-8编码</span></span><br><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新软件源</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-release</span><br><span class="line">curl http://repo.ros2.org/repos.key | sudo apt-key add -</span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过如下命令添加到.bashrc(注意这里如果需要使用两个版本,这一步不需要设置)</span></span><br><span class="line">echo &quot;source /opt/ros/dashing/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> RWM功能</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-dashing-rmw-opensplice-cpp # for OpenSplice</span><br><span class="line">sudo apt install ros-dashing-rmw-connext-cpp # for RTI Connext (requires license agreement)</span><br><span class="line"><span class="meta">#</span><span class="bash"> ros1与ros2通信</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-dashing-ros1-bridge</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装编译工具</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y \</span><br><span class="line">build-essential \</span><br><span class="line">cmake \</span><br><span class="line">git \</span><br><span class="line">python3-colcon-common-extensions \</span><br><span class="line">python3-pip \</span><br><span class="line">python-rosdep \</span><br><span class="line">python3-vcstool \</span><br><span class="line">wget</span><br><span class="line"><span class="meta">#</span><span class="bash"> install some pip packages needed <span class="keyword">for</span> testing</span></span><br><span class="line">sudo -H python3 -m pip install -U \</span><br><span class="line">argcomplete \</span><br><span class="line">flake8 \</span><br><span class="line">flake8-blind-except \</span><br><span class="line">flake8-builtins \</span><br><span class="line">flake8-class-newline \</span><br><span class="line">flake8-comprehensions \</span><br><span class="line">flake8-deprecated \</span><br><span class="line">flake8-docstrings \</span><br><span class="line">flake8-import-order \</span><br><span class="line">flake8-quotes \</span><br><span class="line">pytest-repeat \</span><br><span class="line">pytest-rerunfailures</span><br><span class="line"><span class="meta">#</span><span class="bash"> [Ubuntu 16.04] install extra packages not available or recent enough on Xenial</span></span><br><span class="line">python3 -m pip install -U \</span><br><span class="line">pytest \</span><br><span class="line">pytest-cov \</span><br><span class="line">pytest-runner \</span><br><span class="line">setuptools</span><br><span class="line"><span class="meta">#</span><span class="bash"> install Fast-RTPS dependencies</span></span><br><span class="line">sudo apt install --no-install-recommends -y \</span><br><span class="line">libasio-dev \</span><br><span class="line">libtinyxml2-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">mkdir  ~/ros2_ws</span><br><span class="line">cd /ros2_ws</span><br><span class="line">git clone  https://ghproxy.com/https://github.com/zhangrelay/ros2_tutorials</span><br><span class="line">cd ros2_tutorials</span><br><span class="line">colcon build</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量(也可以将之放入.bashrc中)</span></span><br><span class="line">source /install/setup.sh </span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个终端</span></span><br><span class="line">cd /ros_ws/ros2_tutorials/install</span><br><span class="line">ros2 run demo_nodes_cpp listener</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个终端</span></span><br><span class="line">ros2 run demo_nodes_cpp talker</span><br></pre></td></tr></table></figure>

<h1 id="使用多个ros版本"><a href="#使用多个ros版本" class="headerlink" title="使用多个ros版本"></a>使用多个ros版本</h1><h2 id="保存一个脚本文件-使用前运行"><a href="#保存一个脚本文件-使用前运行" class="headerlink" title="保存一个脚本文件,使用前运行"></a>保存一个脚本文件,使用前运行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span> /opt/ros/melodic/setup.bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span> /opt/ros/dashing/setup.bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ROS 1.0 melodic or ROS 2.0 Dashing</span></span><br><span class="line">echo Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing </span><br><span class="line">read ROS</span><br><span class="line">if (($ROS==1));then</span><br><span class="line">source /opt/ros/melodic/setup.bash</span><br><span class="line">echo &quot;Melodic&quot;</span><br><span class="line">elif (($ROS==2));then</span><br><span class="line">source /opt/ros/dashing/setup.bash</span><br><span class="line">echo &quot;Dashing&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;Non-ROS&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="注意-由于使用不通ros-因此安装时注意将之前保存在-bashrc中的"><a href="#注意-由于使用不通ros-因此安装时注意将之前保存在-bashrc中的" class="headerlink" title="!注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的"></a>!注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的</h2><h2 id="source-opt-ros-melodic-setup-bash"><a href="#source-opt-ros-melodic-setup-bash" class="headerlink" title="# source /opt/ros/melodic/setup.bash"></a><code># source /opt/ros/melodic/setup.bash</code></h2><p><code># source /opt/ros/dashing/setup.bash</code>注释掉</p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread简单使用</title>
    <url>/blog/2021/12/17/pthread%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/chenwh_cn/article/details/117225053?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-117225053.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">pthread 线程基本函数_chenwh_cn的博客-CSDN博客_pthread函数</a></p>
<p><a href="https://blog.csdn.net/u013457167/article/details/83691039?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83691039.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">Pthread线程基础学习_我的梦-CSDN博客_pthread教程</a></p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = *((<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int the new thread: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_fun, (<span class="keyword">void</span> *)&amp;test);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ret = <span class="number">5</span>; <span class="comment">// thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr]</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="keyword">void</span>*)&amp;ret);</span><br><span class="line">    <span class="comment">//return (void*)&amp;ret;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待线程结束并回收线程资源，此函数会阻塞，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, *((<span class="keyword">int</span>*)ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread is runing\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>)) <span class="comment">// 立即返回，调用失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;join not working\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after join\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;master is leaving\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ret = <span class="number">5</span>; <span class="comment">// thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr]</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="keyword">void</span>*)&amp;ret);</span><br><span class="line">    <span class="comment">//return (void*)&amp;ret;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, *((<span class="keyword">int</span>*)ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread start \n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">        <span class="comment">// 调用pthread_testcancel，让内核去检测是否需要取消当前线程。</span></span><br><span class="line">		<span class="built_in">pthread_testcancel</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> iret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pthread_cancel</span>(tid);<span class="comment">//取消线程</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code %d\n&quot;</span>, (<span class="keyword">int</span>)ret);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>ros_rosbag</title>
    <url>/blog/2021/11/02/rosbag/</url>
    <content><![CDATA[<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://blog.csdn.net/qiqiqiqi0000/article/details/114767249?ops_request_misc=%7B%22request_id%22:%22163582490616780261970410%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582490616780261970410&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-114767249.pc_search_ecpm_flag&utm_term=rosbag&spm=1018.2226.3001.4187">(59条消息) Rosbag详细操作_Sun的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/newbeixue/article/details/110082489?ops_request_misc=%7B%22request_id%22:%22163582694116780271519523%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582694116780271519523&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-110082489.pc_search_ecpm_flag&utm_term=rosbag+play+--clock&spm=1018.2226.3001.4187">rosbag –clock_newbeixue的博客-CSDN博客</a></p>
<h2 id="Rosbag基础使用"><a href="#Rosbag基础使用" class="headerlink" title="Rosbag基础使用"></a>Rosbag基础使用</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存所有topic</span></span><br><span class="line">rosbag record -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只记录某些感兴趣的 topic</span></span><br><span class="line">rosbag record /topic_name1 /topic_name2 /topic_name3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定生成数据包的名字，则用-O /-o 参数</span></span><br><span class="line">rosbag record -O filename.bag /topic_name1</span><br><span class="line"><span class="meta">#</span><span class="bash"> launch 文件中使用 rosbag record 命令</span></span><br><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure>

<h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag info filename.bag</span><br><span class="line">rosbag info -y filename.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">xiaohu@xiaohu:~/bagfiles$  rosbag info -y 1.bag</span><br><span class="line">path: 1.bag</span><br><span class="line">version: 2.0</span><br><span class="line">duration: 3.295966</span><br><span class="line">start: 1566653873.351150</span><br><span class="line">end: 1566653876.647117</span><br><span class="line">size: 8103</span><br><span class="line">messages: 20</span><br><span class="line">indexed: True</span><br><span class="line">compression: none</span><br><span class="line">types:</span><br><span class="line">    - type: geometry_msgs/Twist</span><br><span class="line">      md5: 9f195f881246fdfa2798d1d3eebca84a</span><br><span class="line">topics:</span><br><span class="line">    - topic: /turtle1/cmd_vel</span><br><span class="line">      type: geometry_msgs/Twist</span><br><span class="line">      messages: 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rosbag-play"><a href="#rosbag-play" class="headerlink" title="rosbag play"></a>rosbag play</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 简单播放</span></span><br><span class="line">rosbag play &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 2 表示2倍速播放</span></span><br><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环播放</span></span><br><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只播放一部分topic</span></span><br><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始播放立刻暂停，按空格继续</span></span><br><span class="line">rosbag play --pause record.bag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rosbag-–clock"><a href="#rosbag-–clock" class="headerlink" title="rosbag –clock"></a>rosbag –clock</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag play --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -k， --keep-alive</span></span><br><span class="line">rosbag play -k  --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r FACTOR, --rate=FACTOR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。</span></span><br><span class="line">rosbag play -r 0.1 --clock recorded1.bag</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosparam set /use_sim_time true</span><br><span class="line">rosbag play --pause  --clock -k scan_odom.bag --topic /topic1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros安装</title>
    <url>/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu18.04</span><br><span class="line">ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list.d/ros-latest.list</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic main</span><br><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install ros-melodic-desktop-full</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line">sudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="一行代码安装ros（包含问题处理）"><a href="#一行代码安装ros（包含问题处理）" class="headerlink" title="一行代码安装ros（包含问题处理）"></a>一行代码安装ros（包含问题处理）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<p>参考视频：</p>
<p><a href="https://mp.weixin.qq.com/s/8hTrKL0N5y9i6s9ujhp0UA">玩着游戏听着歌，就把ROS装好了！一行代码搞定系列！ (qq.com)</a></p>
<h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><p><code>rosdep init</code>不成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove --purge ros-melodic</span><br><span class="line"><span class="meta">#</span><span class="bash"> 先卸载包</span></span><br><span class="line">sudo apt-get purge ros-*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后删除依赖，配置</span></span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd ~/catkin_ws/</span><br><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>打开新窗口执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>

<p>出现小乌龟则安装完成。</p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros_cmake配置模板</title>
    <url>/blog/2021/10/19/ros_cmake/</url>
    <content><![CDATA[<h3 id="简易CmakeLists-txt"><a href="#简易CmakeLists-txt" class="headerlink" title="简易CmakeLists.txt"></a>简易CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(hmi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持编译</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  pcl_ros</span><br><span class="line">  perception_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># catkin库</span></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line">  CATKIN_DEPENDS roscpp sensor_msgs pcl_ros</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件库</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"> <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件夹</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node src/hmi_node.cpp src/hmi_core.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖包</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node perception_msgs_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="详细CmakeLists-txt"><a href="#详细CmakeLists-txt" class="headerlink" title="详细CmakeLists.txt"></a>详细CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>()  <span class="comment">#CMake的版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>()         <span class="comment">#项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>()        <span class="comment">#找到编译需要的其他CMake/Catkin  package </span></span><br><span class="line"></span><br><span class="line">catkin_python_setup()   <span class="comment">#catkin新加宏，打开catkin的Python Module的支持</span></span><br><span class="line"></span><br><span class="line">add_message_files()     <span class="comment">#catkin新加宏，添加自定义Message文件 </span></span><br><span class="line"></span><br><span class="line">add_service_files()         <span class="comment">#catkin新加宏，添加自定义Service文件 </span></span><br><span class="line"></span><br><span class="line">add_action_files()          <span class="comment">#catkin新加宏，添加自定义Action文件 </span></span><br><span class="line"></span><br><span class="line">generate_message()      <span class="comment">#catkin新加宏，生成不同语言版本的msg/srv/action接口 </span></span><br><span class="line"></span><br><span class="line">catkin_package()      <span class="comment">#catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>()       <span class="comment">#生成库 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>()      <span class="comment">#生成可执行二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_dependencies</span>()      <span class="comment">#定义目标文件依赖于其他目标文件，确保其他目标已被构建 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>()   <span class="comment">#链接</span></span><br><span class="line"></span><br><span class="line">catkin_add_gtest()      <span class="comment">#catkin新加宏，生成测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>()         <span class="comment">#安装至本机</span></span><br></pre></td></tr></table></figure>

<h3 id="对照实例"><a href="#对照实例" class="headerlink" title="对照实例"></a>对照实例</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)    <span class="comment"># catkin至少需要3.0.2版本以上的Cmake</span></span><br><span class="line"><span class="comment">#通过project()这个函数指定包的名字，在CMake中指定后，你可在其他地方通过使用变量$&#123;PROJECT_NAME&#125;来引用它</span></span><br><span class="line"><span class="keyword">project</span>(ultrasonic_data) </span><br><span class="line"></span><br><span class="line"><span class="comment">## Compile as C++11, supported in ROS Kinetic and newer</span></span><br><span class="line"><span class="comment"># add_compile_options(-std=c++11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package(）  </span></span><br><span class="line"><span class="comment">##find_package(catkin REQUIRED COMPONENTS xyz) 被用于找其他依赖的功能包</span></span><br><span class="line"><span class="comment">##这里指明构建这个package需要依赖的package，我们使用catkin_make的编译方式，至少需要catkin这个包。</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  message_generation</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">  visualization_msgs</span><br><span class="line">  can_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 系统依赖关系是通过CMake的约定找到的</span></span><br><span class="line"><span class="comment"># find_package(Boost REQUIRED COMPONENTS system)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##启动Python模块支持：catkin_python_package()</span></span><br><span class="line"><span class="comment">##如果功能包中提供了一些Python模块.这个宏定义可以确保包中声明的模块和全局脚本被安装</span></span><br><span class="line"><span class="comment">## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html</span></span><br><span class="line"><span class="comment"># catkin_python_setup()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment">## 声明ROS消息、服务和动作 ##</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()</span></span><br><span class="line"><span class="comment">##当我们需要使用.msg.srv.action形式的文件时，我们需要特殊的预处理器把他们转化为系统可以识别特定编程语言（.h.cpp）。</span></span><br><span class="line"><span class="comment">##注意：这些宏必须在catkin_package() 宏前面</span></span><br><span class="line"><span class="comment">##请执行以下步骤：</span></span><br><span class="line"><span class="comment">## * 在package.xml中:</span></span><br><span class="line"><span class="comment">## *1.添加&quot;message_generation&quot;在build_depend标记中</span></span><br><span class="line"><span class="comment">## *2.添加&quot;message_runtime&quot;在exec_depend标记中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## * 在CMakeLists.txt中:</span></span><br><span class="line"><span class="comment">## *1、在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;message_generation&quot; </span></span><br><span class="line"><span class="comment">## *2、在catkin_package(CATKIN_DEPENDS ...)添加&quot;message_runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##   根据需要取消下面“add_######_files”部分的注释</span></span><br><span class="line"><span class="comment">##   * 取消下面的generate_messages(DEPENDENCIES...注释</span></span><br><span class="line"><span class="comment">##   * add every package  to generate_messages(DEPENDENCIES ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##  在&#x27;msg&#x27; 文件夹生成消息</span></span><br><span class="line"> add_message_files(</span><br><span class="line">   FILES</span><br><span class="line">   Ultrasonic.msg</span><br><span class="line"><span class="comment">#   Message2.msg</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="comment">##在 &#x27;srv&#x27; 文件夹生成服务</span></span><br><span class="line"><span class="comment"># add_service_files(</span></span><br><span class="line"><span class="comment">#   FILES</span></span><br><span class="line"><span class="comment">#   Service1.srv</span></span><br><span class="line"><span class="comment">#   Service2.srv</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 &#x27;action&#x27; 文件夹生成动作</span></span><br><span class="line"><span class="comment"># add_action_files(</span></span><br><span class="line"><span class="comment">#   FILES</span></span><br><span class="line"><span class="comment">#   Action1.action</span></span><br><span class="line"><span class="comment">#   Action2.action</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在此处列出的任何添加的消息和服务生成的依赖项</span></span><br><span class="line"><span class="comment">##调用消息/服务/操作生成：generate_messages()</span></span><br><span class="line"> generate_messages(</span><br><span class="line">   DEPENDENCIES</span><br><span class="line"><span class="comment">#   sensor_msgs</span></span><br><span class="line">     std_msgs</span><br><span class="line"><span class="comment">#   visualization_msgs</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"><span class="comment">##声明ROS动态配置参数 ##</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 声明和生成动态重新配置参数包:遵循以下步骤</span></span><br><span class="line"><span class="comment">## * 在package.xml中:</span></span><br><span class="line"><span class="comment">## *添加&quot;dynamic_reconfigure&quot;在build_depend和exec_depend标记中</span></span><br><span class="line"><span class="comment">## * 在CMakeLists.txt中:</span></span><br><span class="line"><span class="comment">## *在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;dynamic_reconfigure&quot; </span></span><br><span class="line"><span class="comment">## * 取消下面 &quot;generate_dynamic_reconfigure_options&quot; 的注释</span></span><br><span class="line"><span class="comment">## 列出要处理的每个.cfg文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Generate dynamic reconfigure parameters in the &#x27;cfg&#x27; folder</span></span><br><span class="line"><span class="comment"># generate_dynamic_reconfigure_options(</span></span><br><span class="line"><span class="comment">#   cfg/DynReconf1.cfg</span></span><br><span class="line"><span class="comment">#   cfg/DynReconf2.cfg</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###################################</span></span><br><span class="line"><span class="comment">## catkin 特定的配置 ##</span></span><br><span class="line"><span class="comment">###################################</span></span><br><span class="line"><span class="comment">##  catkin_package为包生成cmake配置文件  这是一个catkin提供的cmake宏，当我们要给构建系统指定catkin的特定的信息时就需要了</span></span><br><span class="line"><span class="comment">##  或者反过来利用他产生pkg-config和CMake文件。</span></span><br><span class="line"><span class="comment">##指定包编译信息导出：catkin_package()</span></span><br><span class="line"><span class="comment">## 该函数必须在使用 add_library()或add_executable()声明任何targets之前调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## INCLUDE_DIRS: 如果包包含头文件，请取消对INCLUDE_DIRS的注释</span></span><br><span class="line"><span class="comment">## LIBRARIES: 此项目中创建的依赖项目需要的库LIBRARIES</span></span><br><span class="line"><span class="comment">## CATKIN_DEPENDS: catkin_packages依赖的项目</span></span><br><span class="line"><span class="comment">## DEPENDS:  依赖项目需要的系统依赖项</span></span><br><span class="line">catkin_package(</span><br><span class="line">    INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line"><span class="comment">#  LIBRARIES ultrasonic_data</span></span><br><span class="line">    CATKIN_DEPENDS </span><br><span class="line">    message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment">## Build ##</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## include_directories用来设置头文件的相对路径</span></span><br><span class="line"><span class="comment">##include_directories的参数是通过find_package产生的*_INCLUDE_DIRS变量和其他所有额外的头文件路径</span></span><br><span class="line"><span class="comment">##这里&quot;include&quot;表示你的pacakge里面的include这个路径也包含在里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">##添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()##</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">## add_library()用来指定编译产生的库。默认的catkin编译产生共享库：</span></span><br><span class="line"><span class="comment"># add_library($&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   src/$&#123;PROJECT_NAME&#125;/ultrasonic_data.cpp</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## add_dependencies用于设置依赖</span></span><br><span class="line"><span class="comment">##如果你有一个包编译.msg .srv，并且可执行文件要使用他们，那么你就需要创建一个显式的依赖项，</span></span><br><span class="line"><span class="comment">## 我们定义的语言无关的消息类型，消息类型会在编译过程中产生相应的语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要</span></span><br><span class="line"><span class="comment">## 使用add_dependencies($&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br><span class="line"><span class="comment">## add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## add_executable用于设置需要编译的代码和生成的可执行文件</span></span><br><span class="line"><span class="comment">##第一个参数为期望生成的可执行文件名称；后面的参数为参与编译的源文件（cpp),如果需要多个代码文件，用空格区分开</span></span><br><span class="line"><span class="comment">## 推荐的前缀可以确保跨包的目标名称不会冲突</span></span><br><span class="line"><span class="comment"># add_executable($&#123;PROJECT_NAME&#125;_node src/ultrasonic_data_node.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重命名C++无前缀可执行文件</span></span><br><span class="line"><span class="comment">## 利用set_target_properties()函数将这个target进行重命名，在catkin中target的名字必须是唯一的</span></span><br><span class="line"><span class="comment"># set_target_properties($&#123;PROJECT_NAME&#125;_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加可执行文件的cmake目标依赖项</span></span><br><span class="line"><span class="comment">## same as for the library above与上面的库相同</span></span><br><span class="line"><span class="comment"># add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##target_link_libraries用于设置链接库</span></span><br><span class="line"><span class="comment"># target_link_libraries($&#123;PROJECT_NAME&#125;_node</span></span><br><span class="line"><span class="comment">#   $&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(ultrasonic_activate_node</span><br><span class="line">  src/ultrasonic_activate_node.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(ultrasonic_activate_node <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ultrasonic_activate_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(ultrasonic_node</span><br><span class="line">  src/ultrasonic_node.cpp</span><br><span class="line">  src/ultrasonic_filter.cpp</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(ultrasonic_node <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ultrasonic_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment">###安装至本机 ##</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有安装目标都应该使用catkin目标变量</span></span><br><span class="line"><span class="comment"># See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##安装Python可执行脚本</span></span><br><span class="line"><span class="comment"># catkin_install_python(PROGRAMS</span></span><br><span class="line"><span class="comment">#   scripts/my_python_script</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装的可执行文件</span></span><br><span class="line"><span class="comment">## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html</span></span><br><span class="line"><span class="comment"># install(TARGETS $&#123;PROJECT_NAME&#125;_node</span></span><br><span class="line"><span class="comment">#   RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 要安装的库</span></span><br><span class="line"><span class="comment">##编译完成后，目标被放入catkin工作空间下的devel目录。一般希望将目标安装到系统上，以使其他用户使用，</span></span><br><span class="line"><span class="comment">##或者安装到本地目录来测试系统级别的安装。也就是说，如果希望能够对代码进行make install，就需要明确目标结束的位置。</span></span><br><span class="line"><span class="comment">##上述过程可以使用CMake的 install()函数实现。</span></span><br><span class="line"><span class="comment">##该函数的参数有</span></span><br><span class="line"><span class="comment">##TARGETS：要安装的目标</span></span><br><span class="line"><span class="comment">##ARCHIVE DESTINATION：静态库和动态链接库DLL(Windows).lib存根</span></span><br><span class="line"><span class="comment">##LIBRARY DESTINATION：非DLL共享库和模块</span></span><br><span class="line"><span class="comment">##RUNTIME DESTINATION：可执行目标和DLL(Windows)模式共享库</span></span><br><span class="line"><span class="comment">## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html</span></span><br><span class="line"><span class="comment"># install(TARGETS $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   RUNTIME DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装头文件</span></span><br><span class="line"><span class="comment">##头文件必须安装到include目录下，这通常通过安装整个文件夹的文件来完成（可以根据文件名模式进行过滤，并排除SVN子文件夹）</span></span><br><span class="line"><span class="comment">##可以通过以下安装规则实现：</span></span><br><span class="line"><span class="comment"># install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   FILES_MATCHING PATTERN &quot;*.h&quot;</span></span><br><span class="line"><span class="comment">#   PATTERN &quot;.svn&quot; EXCLUDE</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装roslaunch文件或其他源</span></span><br><span class="line"><span class="comment">##其他像launchfiles的资源可以安装到 $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># install(FILES</span></span><br><span class="line"><span class="comment">#   # myfile1</span></span><br><span class="line"><span class="comment">#   # myfile2</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"><span class="comment">## 测试编译：catkin_add_gtest()##</span></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 基于gtest测试目标和链接库</span></span><br><span class="line"><span class="comment"># catkin_add_gtest($&#123;PROJECT_NAME&#125;-test test/test_ultrasonic_data.cpp)</span></span><br><span class="line"><span class="comment"># if(TARGET $&#123;PROJECT_NAME&#125;-test)</span></span><br><span class="line"><span class="comment">#   target_link_libraries($&#123;PROJECT_NAME&#125;-test $&#123;PROJECT_NAME&#125;)</span></span><br><span class="line"><span class="comment"># endif()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加要由python osetests运行的文件夹</span></span><br><span class="line"><span class="comment"># catkin_add_nosetests(test)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具体可参考网址"><a href="#具体可参考网址" class="headerlink" title="具体可参考网址"></a>具体可参考网址</h3><p><a href="https://blog.csdn.net/yangtao420902/article/details/110873333?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-110873333.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS中的CMake List详解_yangtao420902的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/CipherPolzz/article/details/118963390?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-118963390.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS下CmakeLists.txt模板_CipherPolzz的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_43877080/article/details/110953533?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-110953533.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS新建程序包CmakeLists和package详解_JayLee719的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_32761549/article/details/104535989?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-104535989.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">(46条消息) ROS中CMakeLists.txt文件 使用 讲解与总结_月照银海似蛟龙的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros教程</title>
    <url>/blog/2021/11/13/ros%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><strong>古月居21讲</strong></p>
<p><a href="https://www.guyuehome.com/blog/index">博客 - 古月居 (guyuehome.com)</a></p>
<p><strong>创客智造</strong></p>
<p><a href="https://www.ncnynl.com/archives/201608/496.html">ROS入门教程-目录 - 创客智造 (ncnynl.com)</a></p>
<p><a href="https://blog.csdn.net/wuzhishiwo/category_10362422.html">(70条消息) ros机器人_wuzhishiwo的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/zhangjiali12011/article/details/91885148?ops_request_misc=%7B%22request_id%22:%22162976489016780269870400%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162976489016780269870400&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-27-91885148.pc_search_similar&utm_term=%E5%8F%A4%E6%9C%88%E5%B1%85ros%E8%AF%BE%E7%A8%8B&spm=1018.2226.3001.4187">ROS资源整理-学习ROS用得到的一些资料（持续更新）_Jiali Zhang的博客-CSDN博客</a></p>
<p><strong>国外教程(需要科学上网)</strong>,可在线模拟,有开源代码</p>
<p><a href="https://app.theconstructsim.com/en/signup/#/LearningPaths">Learn Robotics from Zero - Robotics &amp; ROS Online Courses (theconstructsim.com)</a></p>
<p><strong>很现成的模拟</strong>舒爽</p>
<p><a href="https://www.icourse163.org/course/NUDT-1205969803">智能机器人系统_国防科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>
<p><strong>外文教程</strong></p>
<p><a href="https://cyberbotics.com/doc/guide/tutorial-8-using-ros">Webots: tutorial- (cyberbotics.com)</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>通过<code>WSL</code>+<code>melodic</code>+<code>vscode</code>+<code>xlaunch</code>实现<code>ros</code>环境模拟</p>
<p><code>wsl安装</code>:<a href="https://peitianyu.github.io/blog/2021/10/19/wsl/">wsl安装与使用 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>melodic安装</code>:<a href="https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/">ros安装 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>vscode安装</code>:<a href="https://peitianyu.github.io/blog/2021/11/13/vscode/">vscode | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>vscode配置ros:</code>安装<em>C/C++<em>，</em>CMake</em>，<em>CMake Tools</em>，<em>Code Runner</em>，<em>ROS</em>，<em>Chinese</em> 这些插件</p>
<p><a href="https://blog.csdn.net/qq_42688495/article/details/107750466?ops_request_misc=%7B%22request_id%22:%22163676717216780274154447%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676717216780274154447&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107750466.pc_search_mgc_flag&utm_term=vscode+ros&spm=1018.2226.3001.4187">使用VScode搭建ROS开发环境_白鸟无言的博客-CSDN博客</a></p>
<p><code>xlaunch安装</code>:<a href="https://blog.csdn.net/beyond9305/article/details/95494863?ops_request_misc=%7B%22request_id%22:%22163676668916780255220278%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163676668916780255220278&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-95494863.pc_search_mgc_flag&utm_term=xlaunch&spm=1018.2226.3001.4187">(https://windows.podnova.com/software/3151375.htm)</a></p>
<p>下载好之后,配置<code>~/.bashrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入编辑文件,在最后添加上</span></span><br><span class="line">export DISPLAY=localhost:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> CTRL+S + CTRL+X保存退出</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h1><h2 id="古月居二十一讲"><a href="#古月居二十一讲" class="headerlink" title="古月居二十一讲"></a>古月居二十一讲</h2><p>这一步需要每一个实验都过一遍,编译一遍,不必要太过详尽,重在了解ros流程,之后回来重新复习</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1L44y167ox?p=3">古月居二十一讲视频</a></li>
<li><a href="https://blog.csdn.net/weixin_48395629/article/details/109022916?ops_request_misc=%7B%22request_id%22:%22162968965016780255230305%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162968965016780255230305&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109022916.pc_search_similar&utm_term=%E5%8F%A4%E6%9C%88%E5%B1%85ros%E5%85%A5%E9%97%A821%E8%AE%B2&spm=1018.2226.3001.4187">古月居二十一讲笔记</a></li>
<li><a href="https://pan.baidu.com/s/1E5jvjjGtjhaeT7ivmySfAg">古月居二十一讲讲义与代码</a> 密码:4n76</li>
<li><a href="https://www.guyuehome.com/blog/index/category/11">ROS探索总结 - 古月居 </a></li>
</ul>
<h2 id="ROS-Academy-for-Beginners"><a href="#ROS-Academy-for-Beginners" class="headerlink" title="ROS-Academy-for-Beginners"></a>ROS-Academy-for-Beginners</h2><ul>
<li><p><a href="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/">中国大学MOOC《机器人操作系统入门》讲义</a></p>
</li>
<li><p><a href="https://github.com/DroidAITech/ROS-Academy-for-Beginners">中国大学MOOC《机器人操作系统入门》课程代码示例</a></p>
</li>
</ul>
<p>注意下载自<code>己需要的版本</code>,别下错了,然后有显示的问题,可以试试</p>
<p><code>rosdep install --from-paths src --ignore-src --rosdistro=melodic -y</code></p>
<h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><ul>
<li><p><a href="https://www.zhihu.com/column/ros-nav">ros navigation stack源码学习 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://github.com/meiqua/navigation"> ROS Navigation stack源码</a></p>
</li>
</ul>
<h2 id="激光slam"><a href="#激光slam" class="headerlink" title="激光slam"></a>激光slam</h2><p>根据以下的几种尝试看源码</p>
<ul>
<li><a href="https://www.cnblogs.com/li-yao7758258/p/8213578.html">对比几种在ROS中常用的几种SLAM算法</a></li>
<li><a href="https://blog.csdn.net/m0_37604894/article/details/89207705?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%BF%80%E5%85%89SLAM&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-89207705.pc_search_insert_js_new&spm=1018.2226.3001.4187"> 激光SLAM学习</a></li>
<li><a href="https://blog.csdn.net/m0_37340621/category_9607656.html"> 移动机器人_少磊的博客</a></li>
</ul>
<h2 id="路径参考"><a href="#路径参考" class="headerlink" title="路径参考"></a>路径参考</h2><p><a href="https://mp.weixin.qq.com/s/-UHXkgg_CjaPW0yXzE4VuA">记得收藏丨ROS开发工程师学习指南 (qq.com)</a></p>
<h1 id="几款适合copy的源码"><a href="#几款适合copy的源码" class="headerlink" title="几款适合copy的源码"></a>几款适合copy的源码</h1><p><a href="https://github.com/ros/ros_tutorials">ros_tutorials</a></p>
<p><a href="https://github.com/ROBOTIS-GIT/ros_tutorials">ros_tutorials: ROS Tutorials for beginner</a></p>
<p><a href="https://github.com/guyuehome/ros_basic_tutorials">ros_basic_tutorials</a></p>
<p><a href="https://github.com/guyuehome/ros_advanced_tutorials">ROS进阶攻略系列视频课程</a></p>
<p><a href="https://github.com/ros-planning/navigation_tutorials">Tutorials about using the ROS Navigation stack</a></p>
<p><a href="https://github.com/RobotnikAutomation/agvs_sim">Agvs robot simulation packages for ROS </a></p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros错误集锦</title>
    <url>/blog/2021/10/19/ros%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="“cv-bridge“解决办法"><a href="#“cv-bridge“解决办法" class="headerlink" title="“cv_bridge“解决办法"></a>“cv_bridge“解决办法</h2><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题:"></a>出现问题:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package):</span><br><span class="line">Could not find a package configuration file provided by “cv_bridge” with</span><br><span class="line">any of the following names:</span><br><span class="line"></span><br><span class="line">cv_bridgeConfig.cmake</span><br><span class="line">cv_bridge-config.cmake</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><p><a href="https://www.it610.com/article/1282152021410988032.htm">CMake Error ：Could not find a package configuration file provided by “cv_bridge“解决办法</a></p>
<h2 id="WSL-Ubuntu18-03环境下gazebo9视图黑屏问题的解决"><a href="#WSL-Ubuntu18-03环境下gazebo9视图黑屏问题的解决" class="headerlink" title="WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决"></a>WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 卸载gazebo与ros</span><br><span class="line">sudo apt-get remove gazebo11 gazebo11-*</span><br><span class="line">sudo apt-get purge ros-*</span><br><span class="line">sudo apt-get install ros-melodic-desktop-full</span><br><span class="line"># 卸载gazebo9</span><br><span class="line">sudo apt-get remove gazebo9 gazebo9-common gazebo9-plugin-base libgazebo9:amd64 libgazebo9-dev:amd64 ros-melodic-gazebo-*  </span><br><span class="line"># 查看</span><br><span class="line">dpkg -l | grep gazebo</span><br><span class="line"># 清楚残余包</span><br><span class="line">sudo dpkg --purge gazebo9</span><br><span class="line"># 安装gazebo11</span><br><span class="line">sudo apt-get install gazebo11 -y</span><br><span class="line">sudo apt-get install libgazebo11-dev</span><br><span class="line">gazebo</span><br></pre></td></tr></table></figure>

<p>通过重新安装的方式绕过</p>
<p><a href="https://blog.csdn.net/weixin_53266173/article/details/110817750?ops_request_misc=%7B%22request_id%22:%22162985238916780261959221%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162985238916780261959221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-12-110817750.pc_search_similar&utm_term=gazebo%E9%BB%91%E5%B1%8F&spm=1018.2226.3001.4187">WSL折腾记录之三：WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决与升级安装gazebo11</a></p>
<h3 id="rosdep-init不成功"><a href="#rosdep-init不成功" class="headerlink" title="rosdep init不成功"></a>rosdep init不成功</h3><p>命令行输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<h2 id="Could-not-find-a-package-configuration-file-provided-by-“xxxx”"><a href="#Could-not-find-a-package-configuration-file-provided-by-“xxxx”" class="headerlink" title="Could not find a package configuration file provided by “xxxx”"></a>Could not find a package configuration file provided by “xxxx”</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-xxxx </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>shm</title>
    <url>/blog/2021/11/23/shm/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ypt523/article/details/79958188?ops_request_misc=%7B%22request_id%22:%22163767553616780274114023%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767553616780274114023&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79958188.pc_search_mgc_flag&utm_term=%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98+%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1&spm=1018.2226.3001.4187">进程间通信——共享内存（Shared Memory）_ypt-CSDN博客_共享内存</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//comm.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMM_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 0x6666</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateShm</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//comm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CommShm</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">key_t</span> key = ftok(PATHNAME,PROJ_ID);</span><br><span class="line">	<span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> shmid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key,size,flags)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateShm</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CommShm(size,IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CommShm(size,IPC_CREAT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获得共享内存的id</span></span><br><span class="line">	<span class="keyword">int</span> shmid = GetShm(<span class="number">4096</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 将共享内存映射到本进程的地址空间</span></span><br><span class="line">	<span class="keyword">char</span> *addr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">26</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		addr[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">		i++;</span><br><span class="line">		addr[i] = <span class="number">0</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存从本进程的地址空间中卸载</span></span><br><span class="line">	shmdt(addr);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建并获得共享内存的id</span></span><br><span class="line">	<span class="keyword">int</span> shmid = CreateShm(<span class="number">4096</span>);</span><br><span class="line">	<span class="comment">// 将共享内存映射到本进程的地址空间</span></span><br><span class="line">	<span class="keyword">char</span> *addr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i++ &lt; <span class="number">26</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;client# %s\n&quot;</span>,addr);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存从本进程的地址空间中卸载</span></span><br><span class="line">	shmdt(addr);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 删除共享内存</span></span><br><span class="line">	DestroyShm(shmid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">//Makefile</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:server client</span></span><br><span class="line"> </span><br><span class="line"><span class="section">client:client.c comm.c</span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">server:server.c comm.c</span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f client server</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程</title>
    <url>/blog/2021/10/20/socket/</url>
    <content><![CDATA[<h3 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h3><p><a href="https://github.com/peitianyu/TcpIpBook">peitianyu/TcpIpBook: TCP/IP网络编程 (github.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV1eg411G7pW?from=search&seid=9546660162554024003&spm_id_from=333.337.0.0">TCP/IP网络通信之Socket编程入门_哔哩哔哩_bilibili</a></p>
<h3 id="套接字操作"><a href="#套接字操作" class="headerlink" title="套接字操作"></a>套接字操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"># 创建套接字</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 分配地址信息</span><br><span class="line">int bind(int sockfd, struct sockaddr* pSockAddr, socklen_t addrLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 设置监听</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 受理连接</span><br><span class="line">int accept(int sockfd, struct sockaddr* pSockAddr, socklen_t* pAddrLen);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 请求连接</span><br><span class="line">int connect(in sockfd, struct sockaddr* pSockAddr, socklen_t sockLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int open(const char* path, int flag);</span><br><span class="line">//成功时返回文件描述符， 失败时返回-1</span><br><span class="line"># 关闭文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 写入文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int sockfd, const void* buf, size_t nBytes);</span><br><span class="line">//成功时返回写入的字节数，失败时返回-1</span><br><span class="line"># 读取文件</span><br><span class="line">ssize_t read(int sockfd, void* buf, size_t nBytes);</span><br><span class="line">//成功时返回读到的字节数（若遇到文件结尾则返回0），失败时返回-1</span><br><span class="line"></span><br><span class="line">#include&lt;sys/uio.h&gt;</span><br><span class="line"># 写文件</span><br><span class="line">ssize_t writev(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"># 读文件</span><br><span class="line">ssize_t readv(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"></span><br><span class="line">// TCP</span><br><span class="line">// 发送文件</span><br><span class="line">ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line">// 接收文件</span><br><span class="line">ssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1</span><br><span class="line">// UDP接收发送</span><br><span class="line">ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">	           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">ssize_t recvfrom(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">	           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回接收的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">struct iovec</span><br><span class="line">&#123;</span><br><span class="line">    void* iov_base; //缓冲地址</span><br><span class="line">    size_t iov_len; //缓冲大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 断开连接</span><br><span class="line">int shutdown(int sock, int howto);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure>

<h3 id="套接字的可选项和IO缓冲大小"><a href="#套接字的可选项和IO缓冲大小" class="headerlink" title="套接字的可选项和IO缓冲大小"></a>套接字的可选项和IO缓冲大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">int getsockopt(int sock, int level, int optname,void* optval,socklen_t* optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br><span class="line">int setsockopt(int sock, int level, int optname, void* optval,socklen_t optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sock = socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">int optval;</span><br><span class="line">socklen_t optlen;</span><br><span class="line">int state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,(void*)&amp;optval, &amp;optlen);</span><br><span class="line"></span><br><span class="line">optval = 1024*3;</span><br><span class="line">optlen = sizeof(optval);</span><br><span class="line">state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,(void*)&amp;optval,optlen);</span><br></pre></td></tr></table></figure>

<h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><ul>
<li><code>FD_ZERO(fd_set* fdset)</code>: 将fdset变量的所有位初始化位0</li>
<li><code>FD_SET(int fd, fd_set* fdset)</code>: 向fdset变量中注册文件描述符fd</li>
<li><code>FD_CLR(int fd, fd_set* fdset)</code>: 清除fdset变量中的文件描述符fd</li>
<li><code>FD_ISSET(int fd, fd_set* fdset)</code>: fdset变量中是否存在fd文件描述符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置监视范围及超时</span><br><span class="line">#include&lt;sys/select.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int maxfd, fd_set* readset, </span><br><span class="line">            fd_set* writeset,fd_set* exceptset, </span><br><span class="line">            const struct timeval* timeout</span><br><span class="line">            );</span><br><span class="line">//失败时返回-1，超时返回0，成功时返回发生事件的文件描述符数量</span><br><span class="line"></span><br><span class="line">struct timeval</span><br><span class="line">&#123;</span><br><span class="line">    long tv_sec;</span><br><span class="line">    long tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>maxfd: 监视的文件描述符数量（最大的文件描述符+1）</li>
<li>readset: 将关注“是否存在待读取数据”的文件描述符存放在readset变量中</li>
<li>writeset: 将关注”是否可写“的文件描述符存放在writeset变量中</li>
<li>exceptset: 将关注”是否有异常“的文件描述符放在exceptset变量中 -timeout: 为了防止调用select函数后陷入无限阻塞状态，可以传递超时信息</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Mk60+shell_letter</title>
    <url>/blog/2021/11/26/shell_letter/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/Mculover666/article/details/105141286?ops_request_misc=%7B%22request_id%22:%22163790121416780357282944%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163790121416780357282944&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-105141286.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8Fshell&spm=1018.2226.3001.4187">letter-shell | 一个功能强大的嵌入式shell_Mculover666的博客（嵌入式）-CSDN博客_letter shell</a></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell_port.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief	shell移植到STM32L431时的接口实现</span></span><br><span class="line"><span class="comment"> * @author	mculover666</span></span><br><span class="line"><span class="comment"> * @date	2020/03/27 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 创建shell对象，开辟shell缓冲区 */</span></span><br><span class="line">Shell shell;</span><br><span class="line"><span class="keyword">char</span> shell_buffer[<span class="number">512</span>];</span><br><span class="line"><span class="comment">/* 2. 自己实现shell写函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shell写函数原型：typedef void (*shellWrite)(const char);</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用户shell写</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param data 数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return short 实际写入的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">userShellWrite</span><span class="params">(<span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">short</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				UART_WriteByte(HW_UART0, data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 编写初始化函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">User_Shell_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册自己实现的写函数</span></span><br><span class="line">    shell.write = userShellWrite;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用shell初始化函数</span></span><br><span class="line">    shellInit(&amp;shell, shell_buffer, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shell_port.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SHELL_PORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	_SHELL_PORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将shell定义为外部变量，在串口中断回调函数中还要使用 */</span></span><br><span class="line"><span class="keyword">extern</span> Shell shell;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明自己编写的初始化函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">User_Shell_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _SHELL_PORT_H_ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cpuidy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> recv_buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> ch, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input int: %d, char: %c, string: %s\r\n&quot;</span>, i, ch, str);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UART_RX_ISR</span><span class="params">(<span class="keyword">uint16_t</span> byteReceived)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//调用shell处理数据的接口</span></span><br><span class="line">		recv_buf = byteReceived;</span><br><span class="line">		shellHandler(&amp;shell, recv_buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    <span class="keyword">uint32_t</span> instance = GPIO_QuickInit(HW_GPIOE, <span class="number">0</span>, kGPIO_Mode_OPP);</span><br><span class="line">    UART_QuickInit(UART0_RX_PA01_TX_PA02, <span class="number">115200</span>);</span><br><span class="line">    <span class="comment">/*  配置UART 中断配置 打开接收中断 安装中断回调函数 */</span></span><br><span class="line">    UART_CallbackRxInstall(HW_UART0, UART_RX_ISR);</span><br><span class="line">    <span class="comment">/* 打开串口接收中断功能 IT 就是中断的意思*/</span></span><br><span class="line">    UART_ITDMAConfig(HW_UART0, kUART_IT_Rx, <span class="literal">true</span>);</span><br><span class="line">    User_Shell_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 闪烁小灯 */</span></span><br><span class="line">        GPIO_ToggleBit(HW_GPIOE, <span class="number">0</span>);</span><br><span class="line">        DelayMs(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出到命令列表里</span></span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), test, test, test);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/blog/2021/10/19/ssh/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%7B%22request_id%22:%22163464883116780261940241%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163464883116780261940241&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82810342.pc_search_ecpm_flag&utm_term=ssh&spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法_德prince-CSDN博客_ssh</a></li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-client </span><br><span class="line">sudo apt-get install openssh-server </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动情况</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 停止 重启</span></span><br><span class="line">sudo /etc/init.d/ssh start </span><br><span class="line">sudo /etc/init.d/ssh stop  #server停止ssh服务 </span><br><span class="line">sudo /etc/init.d/ssh restart  #server重启ssh服务</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基础登录</span></span><br><span class="line">ssh ldz@192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用图形界面</span></span><br><span class="line">ssh -X ldz@192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果客户机的用户名和服务器的用户名相同，登录时可以省略用户名。</span></span><br><span class="line">ssh 192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> -p修改端口,默认22端口</span></span><br><span class="line">ssh -p 1234 ldz@192.168.0.1</span><br></pre></td></tr></table></figure>

<p>第一次连时需要确认连接,选yes,即可成功</p>
<p>遇到问题:</p>
<p><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOT</code></p>
<p>bug解决:</p>
<p>ssh-keygen -R 192.168.0.1</p>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p><code>Ctrl+d</code>或者<code>exit</code></p>
<h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><h5 id="在本机生成密钥对"><a href="#在本机生成密钥对" class="headerlink" title="在本机生成密钥对"></a>在本机生成密钥对</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa   #-t表示类型选项，这里采用rsa加密算法</span><br></pre></td></tr></table></figure>

<h5 id="将公钥复制到远程主机"><a href="#将公钥复制到远程主机" class="headerlink" title="将公钥复制到远程主机"></a>将公钥复制到远程主机</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id ldz@192.168.0.1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux使用</title>
    <url>/blog/2021/10/19/tmux/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
</li>
<li><p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></p>
</li>
<li><p><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></p>
</li>
<li><p><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></p>
</li>
</ul>
<h3 id="便捷快捷键"><a href="#便捷快捷键" class="headerlink" title="便捷快捷键"></a>便捷快捷键</h3><p>注意前缀键<code>Ctrl+b</code>按完后松开，再按下其他键。</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl+d</td>
<td align="center">退出</td>
</tr>
<tr>
<td align="center">Ctrl+b s</td>
<td align="center">列出所有会话</td>
</tr>
<tr>
<td align="center">Ctrl+b %</td>
<td align="center">划分左右两个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b “</td>
<td align="center">划分上下两个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b o</td>
<td align="center">切换到下一个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b x</td>
<td align="center">关闭当前窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b c</td>
<td align="center">创建一个新窗口</td>
</tr>
<tr>
<td align="center">Ctrl+b n</td>
<td align="center">切换到下一个窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>几款terminal</title>
    <url>/blog/2021/10/19/terminal/</url>
    <content><![CDATA[<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><code>Powershell</code>,<code>Windows terminal</code>,<code>wsl-terminal</code>,<code>fluent terminal</code>,<code>xshell</code>,<code>Mobaxterm</code>,<code>putty</code></p>
<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>最基础的远程终端,只需要通过ssh指令连接远程终端即可.如,<code>ssh.exe pty@192.168.30.100</code></p>
<h3 id="Windows-terminal"><a href="#Windows-terminal" class="headerlink" title="Windows terminal"></a>Windows terminal</h3><p>同样可以用指令打开,同时也可以配置,打开wsl,ssh都比较方便,点击即用.但有些丑.当然也可以配置网上教程挺多,再次不做过多介绍.</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># powershell输入</span></span><br><span class="line">winget install --id=Microsoft.WindowsTerminal -e</span><br><span class="line"><span class="comment"># 通过Chocolatey</span></span><br><span class="line">choco upgrade microsoft-windows-terminal</span><br></pre></td></tr></table></figure>

<h4 id="右键打开windows-terimnal-未测试"><a href="#右键打开windows-terimnal-未测试" class="headerlink" title="右键打开windows terimnal(未测试)"></a>右键打开windows terimnal(未测试)</h4><p>保存为<code>install.bat</code>文件打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Windows Terminal]</span><br><span class="line">; 右键菜单中显示的名称</span><br><span class="line">@=<span class="string">&quot;Windows Terminal&quot;</span></span><br><span class="line">; 右键菜单中显示的图标</span><br><span class="line"><span class="string">&quot;Icon&quot;</span>=<span class="string">&quot;C:\\Toolkits\\Icons\\App\\WindowsTerminal.ico&quot;</span></span><br><span class="line">; 仅支持在按住Shift+右键的时候才显示</span><br><span class="line"><span class="string">&quot;Extended&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">; </span><br><span class="line"><span class="string">&quot;NoWorkingDirectory&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">; 在菜单中显示或隐藏</span><br><span class="line"><span class="string">&quot;ShowBasedOnVelocityId&quot;</span>=dword:00639bc8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Windows Terminal\Command]</span><br><span class="line">@=<span class="string">&quot;C:\\Users\\xyz\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -d \&quot;%V\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="fluent-terminal"><a href="#fluent-terminal" class="headerlink" title="fluent terminal"></a>fluent terminal</h3><p>好看但没有<code>windows terminal</code>那么方便,不过可以设置快捷键,也还行.</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install fluent-terminal</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载zip文件解压安装</span></span><br><span class="line">https://github.com/felixse/FluentTerminal/releases</span><br></pre></td></tr></table></figure>

<p>下载完毕后解压，选择 <code>Install.ps1</code> 文件，右键使用 powershell 运行。</p>
<h4 id="右键打开"><a href="#右键打开" class="headerlink" title="右键打开"></a>右键打开</h4><p>保存为<code>install.bat</code>文件打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\Directory\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%1\&quot;&quot; /f</span><br><span class="line"></span><br><span class="line">reg add &quot;HKCU\Software\Classes\Directory\Background\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%V\&quot;&quot; /f</span><br><span class="line"></span><br><span class="line">reg add &quot;HKCU\Software\Classes\LibraryFolder\Background\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%V\&quot;&quot; /f</span><br></pre></td></tr></table></figure>

<h4 id="右键关闭"><a href="#右键关闭" class="headerlink" title="右键关闭"></a>右键关闭</h4><p>保存为<code>Uninstall.bat</code>文件打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKCU\Software\Classes\Directory\shell\Open Fluent Terminal here&quot; /f</span><br><span class="line"></span><br><span class="line">reg delete &quot;HKCU\Software\Classes\Directory\Background\shell\Open Fluent Terminal here&quot; /f</span><br><span class="line">reg delete &quot;HKCU\Software\Classes\LibraryFolder\Background\shell\Open Fluent Terminal here&quot; /f</span><br></pre></td></tr></table></figure>

<h3 id="wsl-terminal"><a href="#wsl-terminal" class="headerlink" title="wsl-terminal"></a>wsl-terminal</h3><p>加u个人使用而言,如果多个wsl,则没那么舒爽.当然也可以像powershell那样<code>wsl -d Ubuntu</code>这样切换版本</p>
<h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/ly50247/article/details/80131656?ops_request_misc=%7B%22request_id%22:%22163481452216780366511110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481452216780366511110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-80131656.pc_search_ecpm_flag&utm_term=open-wsl&spm=1018.2226.3001.4187">使用 wsl-terminal 更好地体验 Win 10 WSL 终端环境</a></p>
<p>写的比较详细就不具体赘述了</p>
<h3 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h3><p>是一款集合ssh,串口的远程软件,但每次都需要开启后配置参数,对于懒人不友好.</p>
<h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/weixin_40705360/article/details/104008419?ops_request_misc=%7B%22request_id%22:%22163481518116780366579230%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481518116780366579230&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104008419.pc_search_ecpm_flag&utm_term=putty%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">putty使用教程(总结)</a></p>
<h3 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h3><p>具有putty相似的功能,同时还有<strong>stfp</strong>文件传输,只需点击即可使用.但对于需要调试gui程序而言,需要购买正式版,嗯…………大佬随意.</p>
<h4 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/hxy1625309592/article/details/110356421?ops_request_misc=%7B%22request_id%22:%22163481523916780269886657%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481523916780269886657&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-110356421.pc_search_ecpm_flag&utm_term=xhsell&spm=1018.2226.3001.4187">Xshell使用基础教程_</a></p>
<h3 id="Mobaxterm"><a href="#Mobaxterm" class="headerlink" title="Mobaxterm"></a>Mobaxterm</h3><p>集百家之长于一身,因此使用起来没那么方便,但使用后非常舒爽.值得一提的是,远程文件是可以根据终端实时更新的,同时<strong>支持拖拽文件,新建文件,文件夹,本地编辑文件</strong>,这就很爽了.</p>
<h4 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/qq_28721869/article/details/114652520?ops_request_misc=%7B%22request_id%22:%22163481551616780269883117%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481551616780269883117&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114652520.pc_search_ecpm_flag&utm_term=Mobaxterm&spm=1018.2226.3001.4187">全能终端神器mobaxterm入坑指南</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>strcpy重写</title>
    <url>/blog/2021/11/25/strcpy%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/m0_57304511/article/details/121503898">什么？面试官让我写strcpy()函数_m0_57304511的博客-CSDN博客</a></p>
<h1 id="strpy"><a href="#strpy" class="headerlink" title="strpy"></a>strpy</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"><span class="comment">//const可以防止源字符串被改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用断言避免传入空指针</span></span><br><span class="line">	<span class="built_in">assert</span>( dest &amp;&amp; src );</span><br><span class="line">	<span class="keyword">char</span>* ret = dest;</span><br><span class="line">    <span class="comment">// 按地址复制,直到为空</span></span><br><span class="line">	<span class="keyword">while</span>(*dest++ = *src++)</span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> arr1[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> arr2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">my_strcpy</span>(arr1, arr2));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mempy"><a href="#mempy" class="headerlink" title="mempy"></a>mempy</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> ((src == <span class="literal">NULL</span>) || (dest == <span class="literal">NULL</span>))  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (count--)  </span><br><span class="line">        *dest++ = *src++;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">return</span> dest;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18源</title>
    <url>/blog/2021/10/19/ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    <content><![CDATA[<h4 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h4><p>参考网址：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563">Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源</a></p>
<h5 id="阿里源-（Ubuntu-18-04）"><a href="#阿里源-（Ubuntu-18-04）" class="headerlink" title="阿里源 （Ubuntu 18.04）"></a>阿里源 （Ubuntu 18.04）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h5 id="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"><a href="#西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）" class="headerlink" title="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"></a>西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="网易源"><a href="#网易源" class="headerlink" title="网易源"></a>网易源</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##中科大源</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="树莓派更换国内源"><a href="#树莓派更换国内源" class="headerlink" title="树莓派更换国内源"></a>树莓派更换国内源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加入,Ctrl+s保存,Ctrl+X退出.</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改系统更新源</span></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sud apt upgrade</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu18换回原来源"><a href="#Ubuntu18换回原来源" class="headerlink" title="Ubuntu18换回原来源"></a>Ubuntu18换回原来源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to use the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide useful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#x27;s</span><br><span class="line">## &#x27;partner&#x27; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu users.</span><br><span class="line"># deb http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"># deb-src http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"></span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu14</title>
    <url>/blog/2021/11/23/ubuntu14/</url>
    <content><![CDATA[<h1 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装服务</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ssh服务是否启动</span></span><br><span class="line">sudo ps -e |grep ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ssh服务</span></span><br><span class="line">sudo service ssh start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置服务</span></span><br><span class="line">sudo gedit /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面相关配置：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin prohibit-password</span><br><span class="line">StrictModes yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">更改为：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line"><span class="meta">#</span><span class="bash">PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh</span></span><br><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak </span><br><span class="line">sudo nano /etc/apt/sources.list </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h1 id="右键没有terminal"><a href="#右键没有terminal" class="headerlink" title="右键没有terminal"></a>右键没有terminal</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nautilus-open-terminal </span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装与使用</title>
    <url>/blog/2021/10/19/wsl/</url>
    <content><![CDATA[<h3 id="wsl安装"><a href="#wsl安装" class="headerlink" title="wsl安装"></a>wsl安装</h3><p>参考网址：</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/terminal/get-started">Windows 终端安装 | Microsoft Docs</a></p>
<p><a href="https://hengyumo.blog.csdn.net/article/details/102544521">玩转Linux(1)——安装Windows亲儿子Linux系统之WSL之最全攻略之最佳体验之究极无敌舒服_衡与墨的博客-CSDN博客</a></p>
<p>管理员身份运行Powershell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br><span class="line"> wsl --install -d Ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="wsl使用"><a href="#wsl使用" class="headerlink" title="wsl使用"></a>wsl使用</h3><ul>
<li><h4 id="进入linux系统"><a href="#进入linux系统" class="headerlink" title="进入linux系统"></a>进入linux系统</h4></li>
</ul>
<p>命令行输入<code>wsl</code>或者<code>bash</code>，进入linux系统</p>
<ul>
<li><h4 id="linux初始配置"><a href="#linux初始配置" class="headerlink" title="linux初始配置"></a>linux初始配置</h4></li>
</ul>
<h5 id="添加sudo，这样就不用输密码了"><a href="#添加sudo，这样就不用输密码了" class="headerlink" title="添加sudo，这样就不用输密码了"></a>添加sudo，这样就不用输密码了</h5><p><img src="https://img-blog.csdnimg.cn/20191014120116452.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191014142719338.png" alt="在这里插入图片描述"></p>
<p>修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">sudo ALL=(ALL:ALL) ALL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改为</span></span><br><span class="line"><span class="meta">%</span><span class="bash">sudo ALL=(ALL:ALL) NOPASSWD:ALL</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4></li>
</ul>
<p>参考网址：</p>
<p><a href="https://blog.csdn.net/Alisebeast/article/details/106680267">WSL2运行图像应用或图形界面_Alisebeast的博客-CSDN博客_wsl2 图形界面</a></p>
<p><a href="https://blog.csdn.net/qq_45036130/article/details/105623451">在WSL中打开与显示图片的简单方法_neetneves的博客-CSDN博客</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;export DISPLAY=localhost:0&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>测试查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $DISPLAY</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">xclock</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h4></li>
</ul>
<p>参考网址：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563">Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源</a></p>
<ul>
<li><h4 id="wsl命令详解"><a href="#wsl命令详解" class="headerlink" title="wsl命令详解"></a>wsl命令详解</h4></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wsl或bash</td>
<td align="center">打开默认子系统</td>
</tr>
<tr>
<td align="center">wsl -d Ubuntu18</td>
<td align="center">打开Ubuntu18子系统</td>
</tr>
<tr>
<td align="center">wsl -l -o</td>
<td align="center">可安装的有效分发的列表</td>
</tr>
<tr>
<td align="center">wsl –install -d Ubuntu</td>
<td align="center">安装默认Ubuntu</td>
</tr>
<tr>
<td align="center">wsl –shutdown</td>
<td align="center">关闭子系统</td>
</tr>
<tr>
<td align="center">wsl –import Ubuntu-20.04 e:\ubuntu d:\ubuntu20.04.tar –version 2</td>
<td align="center">导入已存的操作系统</td>
</tr>
<tr>
<td align="center">wsl –export Ubuntu-20.04 e:\ubuntu20.04.tar</td>
<td align="center">导出操作子系统</td>
</tr>
<tr>
<td align="center">wsl -l -v</td>
<td align="center">显示所有子系统</td>
</tr>
<tr>
<td align="center">wsl -s Ubuntu-20.04</td>
<td align="center">将分发版设置为默认值</td>
</tr>
<tr>
<td align="center">bash -c “ls”</td>
<td align="center">windows命令提示符</td>
</tr>
<tr>
<td align="center">wsl –unregister Ubuntu-20.04</td>
<td align="center">注销分发版</td>
</tr>
<tr>
<td align="center">wslconfig /s Ubuntu-18.04</td>
<td align="center">修改默认子系统</td>
</tr>
</tbody></table>
<ul>
<li><h4 id="wsl-terminal"><a href="#wsl-terminal" class="headerlink" title="wsl-terminal"></a><em>wsl</em>-terminal</h4></li>
</ul>
<p>参考网址：</p>
<p><a href="https://github.com/mskyaxl/wsl-terminal">mskyaxl/wsl-terminal: Terminal emulator for Windows Subsystem for Linux (WSL) (github.com)</a></p>
<p>最常用的依旧是<code>Windows Terminal</code>参考网址</p>
<p>[Windows Terminal配置_人间世-CSDN博客](<a href="https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows">https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows</a> terminal&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-111354738.pc_search_ecpm_flag&amp;spm=1018.2226.3001.4187)</p>
<p><a href="https://blog.csdn.net/c13232906050/article/details/90698772?ops_request_misc=%7B%22request_id%22:%22163439638216780261990702%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163439638216780261990702&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-90698772.pc_search_ecpm_flag&utm_term=windows+terminal%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载</a></p>
<h5 id="Windows-Terminal安装"><a href="#Windows-Terminal安装" class="headerlink" title="Windows Terminal安装"></a>Windows Terminal安装</h5><p>方式一：</p>
<p>微软商店安装</p>
<p><a href="https://www.microsoft.com/zh-cn/p/windows-terminal/9n0dx20hk701?rtc=1&activetab=pivot:overviewtab">购买 Windows Terminal - Microsoft Store zh-CN</a></p>
<p>方式二：</p>
<p><a href="https://blog.csdn.net/c13232906050/article/details/90698772?ops_request_misc=%7B%22request_id%22:%22163439638216780261990702%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163439638216780261990702&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-90698772.pc_search_ecpm_flag&utm_term=windows+terminal%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载</a></p>
<p>方式三：</p>
<p><a href="https://github.com/microsoft/Terminal">https://github.com/microsoft/Terminal</a> </p>
<p>使用Visual Studio打开构建运行</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode</title>
    <url>/blog/2021/11/13/vscode/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_48468423/article/details/118950592?ops_request_misc=%7B%22request_id%22:%22163676464916780262571699%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676464916780262571699&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118950592.pc_search_mgc_flag&utm_term=vscode&spm=1018.2226.3001.4187">VsCode安装和配置c/c++环境（超完整，小白专用）_黄化的多多-CSDN博客_vscode配置c++环境</a></p>
<p><a href="https://blog.csdn.net/iceboy314159/article/details/107886801?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107886801.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">vscode 与 WSL 进行linux开发_从零开始-CSDN博客_vscode wsl</a></p>
<p><a href="https://blog.csdn.net/reeeeein/article/details/104628415?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104628415.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">在WSL中安装并配置VSCode_reeeeein的博客-CSDN博客_wsl安装vscode</a></p>
<p><a href="https://blog.csdn.net/weixin_43876113/article/details/105261577?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-105261577.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">WIN10安装WSL并使用VScode连接WSL_作业君的博客-CSDN博客_vscode wsl</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>vscode</code>配置<code>wsl</code></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="下载安装vscode"><a href="#下载安装vscode" class="headerlink" title="下载安装vscode:"></a>下载安装<code>vscode</code>:</h2><p><a href="https://code.visualstudio.com/Download">Download Visual Studio Code - Mac, Linux, Windows</a></p>
<p>安装<code>win</code>版,一直下一步,注意改一下安装位置</p>
<h2 id="连接wsl"><a href="#连接wsl" class="headerlink" title="连接wsl"></a>连接<code>wsl</code></h2><p><code>ctrl + shift + x</code>打开应用商店,输入<code>Remote - WSL</code>安装由于事先安装好<code>wsl</code>了</p>
<p>打开左侧小电脑图标,点击进入即可进入<code>wsl</code>终端,可以通过点击左下角⚪,▲进入终端命令行</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>win自启动程序</title>
    <url>/blog/2021/10/19/win%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="记事本写入脚本"><a href="#记事本写入脚本" class="headerlink" title="记事本写入脚本"></a>记事本写入脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time  /t  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>  %username%  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>  %computername%  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br></pre></td></tr></table></figure>

<p>另存为<code>start.bat</code>，无人见类型为所有类型</p>
<h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><p>点击<code>运行</code>，输入<code>gpedit.msc</code>,具体操作如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190304120752202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h3><p>可以发现，脚本运行了</p>
<p><img src="https://img-blog.csdnimg.cn/20190304120752279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl使用串口</title>
    <url>/blog/2021/12/01/wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/chentuo2000/article/details/116447956?ops_request_misc=&request_id=&biz_id=102&utm_term=wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-116447956.pc_search_mgc_flag&spm=1018.2226.3001.4187">Win10的Linux子系统Ubuntu使用串口_晨之清风-CSDN博客</a></p>
<p><a href="https://www.scivision.dev/usb-tty-windows-subsystem-for-linux/">WSL | 上的 USB 到串行适配器科学计算|科学视讯 (scivision.dev)</a></p>
<p>由于本人技术原因usb转串行没成功</p>
<p><a href="https://blog.csdn.net/yanhuan136675/article/details/82766466?ops_request_misc=%7B%22request_id%22:%22163832358116780269848091%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163832358116780269848091&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-82766466.pc_search_mgc_flag&utm_term=linux%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1&spm=1018.2226.3001.4187">Linux下串口收发通信_颜言研的博客-CSDN博客_linux串口通信</a></p>
<h1 id="minicom使用"><a href="#minicom使用" class="headerlink" title="minicom使用"></a>minicom使用</h1><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装minicom</span></span><br><span class="line">sudo apt-get install minicom</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置串口,主要该串口号ttyS1,以及将硬件流改为no</span></span><br><span class="line">sudo minicom -s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存</span></span><br><span class="line">Save setup as df1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">sudo minicom</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+A E:回显</span><br><span class="line">Ctrl+A W：当显示的内容超过一行之后自动换行</span><br><span class="line">Ctrl+A C：清屏</span><br><span class="line">Ctrl+A O：打开配置选项</span><br><span class="line">Ctrl+A X：退出minicom</span><br></pre></td></tr></table></figure>

<h1 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usart.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  _USART_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _USART_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//串口相关的头文件    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">/*标准输入输出定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">/*标准函数库定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">/*Unix 标准函数定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>      <span class="comment">/*文件控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;termios.h&gt;</span>    <span class="comment">/*PPSIX 终端控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">/*错误号定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>    </span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//宏定义    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE  -1    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE   0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Open</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>*port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART0_Close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Set</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Init</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Recv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *rcv_buf,<span class="keyword">int</span> data_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *send_buf,<span class="keyword">int</span> data_len)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usart.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Open  </span></span><br><span class="line"><span class="comment">*功能：             打开串口并返回串口设备文件描述  </span></span><br><span class="line"><span class="comment">*入口参数：         fd      文件描述符</span></span><br><span class="line"><span class="comment">                    port    串口号(ttyS0,ttyS1,ttyS2)  </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Open</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>*port)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    fd = open( port, O_RDWR|O_NOCTTY|O_NDELAY);    </span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;Can&#x27;t Open Serial Port&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//恢复串口为阻塞状态                                   </span></span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, <span class="number">0</span>) &lt; <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl failed!\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl=%d\n&quot;</span>,fcntl(fd, F_SETFL,<span class="number">0</span>));    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//测试是否为终端设备        </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == isatty(STDIN_FILENO))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;standard input is not a terminal device\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;isatty success!\n&quot;</span>);    </span><br><span class="line">    &#125;                  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd-&gt;open=%d\n&quot;</span>,fd);    </span><br><span class="line">    <span class="keyword">return</span> fd;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Close  </span></span><br><span class="line"><span class="comment">*功能：             关闭串口并返回串口设备文件描述  </span></span><br><span class="line"><span class="comment">*入口参数：         fd          文件描述符   </span></span><br><span class="line"><span class="comment">                    port        串口号(ttyS0,ttyS1,ttyS2)  </span></span><br><span class="line"><span class="comment">*出口参数：void  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART0_Close</span><span class="params">(<span class="keyword">int</span> fd)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    close(fd);    </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Set  </span></span><br><span class="line"><span class="comment">*功能：             设置串口数据位，停止位和效验位  </span></span><br><span class="line"><span class="comment">*入口参数：         fd          串口文件描述符</span></span><br><span class="line"><span class="comment">*                   speed       串口速度  </span></span><br><span class="line"><span class="comment">*                   flow_ctrl   数据流控制  </span></span><br><span class="line"><span class="comment">*                   databits    数据位   取值为 7 或者8  </span></span><br><span class="line"><span class="comment">*                   stopbits    停止位   取值为 1 或者2  </span></span><br><span class="line"><span class="comment">*                   parity      效验类型 取值为N,E,O,,S  </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Set</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">int</span>   i;    </span><br><span class="line">    <span class="keyword">int</span>   status;    </span><br><span class="line">    <span class="keyword">int</span>   speed_arr[] = &#123; B115200, B19200, B9600, B4800, B2400, B1200, B300&#125;;    </span><br><span class="line">    <span class="keyword">int</span>   name_arr[] = &#123;<span class="number">115200</span>,  <span class="number">19200</span>,  <span class="number">9600</span>,  <span class="number">4800</span>,  <span class="number">2400</span>,  <span class="number">1200</span>,  <span class="number">300</span>&#125;;    </span><br><span class="line">             </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">options</span>;</span>    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">/*  tcgetattr(fd,&amp;options)得到与fd指向对象的相关参数，并将它们保存于options,该函数还可以测试配置是否正确，</span></span><br><span class="line"><span class="comment">        该串口是否可用等。若调用成功，函数返回值为0，若调用失败，函数返回值为1.  */</span>    </span><br><span class="line">    <span class="keyword">if</span>( tcgetattr( fd,&amp;options)  !=  <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;SetupSerial 1&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span>(FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设置串口输入波特率和输出波特率    </span></span><br><span class="line">    <span class="keyword">for</span> ( i= <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(speed_arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);  i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>  (speed == name_arr[i])    </span><br><span class="line">        &#123;                 </span><br><span class="line">            cfsetispeed(&amp;options, speed_arr[i]);     </span><br><span class="line">            cfsetospeed(&amp;options, speed_arr[i]);      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;         </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//修改控制模式，保证程序不会占用串口    </span></span><br><span class="line">    options.c_cflag |= CLOCAL;    </span><br><span class="line">    <span class="comment">//修改控制模式，使得能够从串口中读取输入数据    </span></span><br><span class="line">    options.c_cflag |= CREAD;    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设置数据流控制    </span></span><br><span class="line">    <span class="keyword">switch</span>(flow_ctrl)    </span><br><span class="line">    &#123;    </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :<span class="comment">//不使用流控制    </span></span><br><span class="line">              options.c_cflag &amp;= ~CRTSCTS;    </span><br><span class="line">              <span class="keyword">break</span>;       </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :<span class="comment">//使用硬件流控制    </span></span><br><span class="line">              options.c_cflag |= CRTSCTS;    </span><br><span class="line">              <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> :<span class="comment">//使用软件流控制    </span></span><br><span class="line">              options.c_cflag |= IXON | IXOFF | IXANY;    </span><br><span class="line">              <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//设置数据位    </span></span><br><span class="line">    <span class="comment">//屏蔽其他标志位    </span></span><br><span class="line">    options.c_cflag &amp;= ~CSIZE;    </span><br><span class="line">    <span class="keyword">switch</span> (databits)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>    :    </span><br><span class="line">                     options.c_cflag |= CS5;    </span><br><span class="line">                     <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>    :    </span><br><span class="line">                     options.c_cflag |= CS6;    </span><br><span class="line">                     <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>    :        </span><br><span class="line">                 options.c_cflag |= CS7;    </span><br><span class="line">                 <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:        </span><br><span class="line">                 options.c_cflag |= CS8;    </span><br><span class="line">                 <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:       </span><br><span class="line">                 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported data size\n&quot;</span>);    </span><br><span class="line">                 <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//设置校验位    </span></span><br><span class="line">    <span class="keyword">switch</span> (parity)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">//无奇偶校验位。    </span></span><br><span class="line">                 options.c_cflag &amp;= ~PARENB;     </span><br><span class="line">                 options.c_iflag &amp;= ~INPCK;        </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:      </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:<span class="comment">//设置为奇校验        </span></span><br><span class="line">                 options.c_cflag |= (PARODD | PARENB);     </span><br><span class="line">                 options.c_iflag |= INPCK;                 </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:<span class="comment">//设置为偶校验      </span></span><br><span class="line">                 options.c_cflag |= PARENB;           </span><br><span class="line">                 options.c_cflag &amp;= ~PARODD;           </span><br><span class="line">                 options.c_iflag |= INPCK;          </span><br><span class="line">                 <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">//设置为空格     </span></span><br><span class="line">                 options.c_cflag &amp;= ~PARENB;    </span><br><span class="line">                 options.c_cflag &amp;= ~CSTOPB;    </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">default</span>:      </span><br><span class="line">                 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported parity\n&quot;</span>);        </span><br><span class="line">                 <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">// 设置停止位     </span></span><br><span class="line">    <span class="keyword">switch</span> (stopbits)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:       </span><br><span class="line">                 options.c_cflag &amp;= ~CSTOPB; <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:       </span><br><span class="line">                 options.c_cflag |= CSTOPB; <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">default</span>:       </span><br><span class="line">                       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported stop bits\n&quot;</span>);     </span><br><span class="line">                       <span class="keyword">return</span> (FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//修改输出模式，原始数据输出    </span></span><br><span class="line">    options.c_oflag &amp;= ~OPOST;    </span><br><span class="line">      </span><br><span class="line">    options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);    </span><br><span class="line">    <span class="comment">//options.c_lflag &amp;= ~(ISIG | ICANON);    </span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">//设置等待时间和最小接收字符    </span></span><br><span class="line">    options.c_cc[VTIME] = <span class="number">1</span>; <span class="comment">/* 读取一个字符等待1*(1/10)s */</span>      </span><br><span class="line">    options.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">/* 读取字符的最少个数为1 */</span>    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//如果发生数据溢出，接收数据，但是不再读取 刷新收到的数据但是不读    </span></span><br><span class="line">    tcflush(fd,TCIFLUSH);    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//激活配置 (将修改后的termios数据设置到串口中）    </span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd,TCSANOW,&amp;options) != <span class="number">0</span>)      </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;com set error!\n&quot;</span>);      </span><br><span class="line">        <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> (TRUE);     </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：                UART0_Init()  </span></span><br><span class="line"><span class="comment">*功能：                串口初始化  </span></span><br><span class="line"><span class="comment">*入口参数：            fd         文件描述符    </span></span><br><span class="line"><span class="comment">*                      speed      串口速度  </span></span><br><span class="line"><span class="comment">*                      flow_ctrl  数据流控制  </span></span><br><span class="line"><span class="comment">*                      databits   数据位   取值为 7 或者8  </span></span><br><span class="line"><span class="comment">*                      stopbits   停止位   取值为 1 或者2  </span></span><br><span class="line"><span class="comment">*                      parity     效验类型 取值为N,E,O,,S  </span></span><br><span class="line"><span class="comment">*                        </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Init</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err;    </span><br><span class="line">    <span class="comment">//设置串口数据帧格式    </span></span><br><span class="line">    <span class="keyword">if</span> (UART0_Set(fd,<span class="number">115200</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>) == FALSE)    </span><br><span class="line">    &#123;                                                             </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span>  TRUE;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">* 名称：            UART0_Recv  </span></span><br><span class="line"><span class="comment">* 功能：            接收串口数据  </span></span><br><span class="line"><span class="comment">* 入口参数：        fd         文件描述符      </span></span><br><span class="line"><span class="comment">*                   rcv_buf    接收串口中数据存入rcv_buf缓冲区中  </span></span><br><span class="line"><span class="comment">*                   data_len   一帧数据的长度  </span></span><br><span class="line"><span class="comment">* 出口参数：        正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Recv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *rcv_buf,<span class="keyword">int</span> data_len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len,fs_sel;    </span><br><span class="line">    fd_set fs_read;    </span><br><span class="line">       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    </span><br><span class="line">       </span><br><span class="line">    FD_ZERO(&amp;fs_read);    </span><br><span class="line">    FD_SET(fd,&amp;fs_read);    </span><br><span class="line">       </span><br><span class="line">    time.tv_sec = <span class="number">10</span>;    </span><br><span class="line">    time.tv_usec = <span class="number">0</span>;    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//使用select实现串口的多路通信    </span></span><br><span class="line">    fs_sel = select(fd+<span class="number">1</span>,&amp;fs_read,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;time);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs_sel = %d\n&quot;</span>,fs_sel);    </span><br><span class="line">    <span class="keyword">if</span>(fs_sel)    </span><br><span class="line">    &#123;    </span><br><span class="line">        len = read(fd,rcv_buf,data_len);    </span><br><span class="line">        <span class="keyword">return</span> len;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/********************************************************************  </span></span><br><span class="line"><span class="comment">* 名称：            UART0_Send  </span></span><br><span class="line"><span class="comment">* 功能：            发送数据  </span></span><br><span class="line"><span class="comment">* 入口参数：        fd           文件描述符      </span></span><br><span class="line"><span class="comment">*                   send_buf     存放串口发送数据  </span></span><br><span class="line"><span class="comment">*                   data_len     一帧数据的个数  </span></span><br><span class="line"><span class="comment">* 出口参数：        正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *send_buf,<span class="keyword">int</span> data_len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;    </span><br><span class="line">       </span><br><span class="line">    len = write(fd,send_buf,data_len);    </span><br><span class="line">    <span class="keyword">if</span> (len == data_len )    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send data is %s\n&quot;</span>,send_buf);  </span><br><span class="line">        <span class="keyword">return</span> len;    </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">else</span>       </span><br><span class="line">    &#123;    </span><br><span class="line">                   </span><br><span class="line">        tcflush(fd,TCOFLUSH);    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">/*标准输入输出定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">/*标准函数库定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">/*Unix 标准函数定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>      <span class="comment">/*文件控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;termios.h&gt;</span>    <span class="comment">/*PPSIX 终端控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">/*错误号定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;           <span class="comment">//文件描述符，先定义一个与程序无关的值，防止fd为任意值导致程序出bug    </span></span><br><span class="line">    <span class="keyword">int</span> err;               <span class="comment">//返回调用函数的状态    </span></span><br><span class="line">    <span class="keyword">int</span> len;                            </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> rcv_buf[<span class="number">256</span>];             </span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">     fd = UART0_Open(fd,<span class="string">&quot;ttyS1&quot;</span>); <span class="comment">//打开串口，返回文件描述符   </span></span><br><span class="line">     <span class="keyword">do</span>  </span><br><span class="line">    &#123;    </span><br><span class="line">        err = UART0_Init(fd,<span class="number">115200</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>);    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set Port Exactly!\n&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);   </span><br><span class="line">    &#125;<span class="keyword">while</span>(FALSE == err || FALSE == fd);    </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>)    <span class="comment">//开发板向pc发送数据的模式</span></span><br><span class="line">    &#123;   </span><br><span class="line">        send_buf = (<span class="keyword">char</span>*) <span class="string">&quot;hello world!&quot;</span>; </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">        &#123;    </span><br><span class="line">            len = UART0_Send(fd,send_buf,<span class="number">40</span>);    </span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send data successful\n&quot;</span>);   </span><br><span class="line">            sleep(<span class="number">1</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">        UART0_Close(fd);                 </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">//开发板收到pc发送的数据的模式                 </span></span><br><span class="line">    &#123;                                          </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//循环读取数据    </span></span><br><span class="line">        &#123;   </span><br><span class="line">            len = UART0_Recv(fd, rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));    </span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>)    </span><br><span class="line">            &#123;    </span><br><span class="line">                rcv_buf[len] = <span class="string">&#x27;\0&#x27;</span>;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;receive data is %s\n&quot;</span>,rcv_buf);    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cannot receive data\n&quot;</span>);    </span><br><span class="line">            &#125;    </span><br><span class="line">            sleep(<span class="number">1</span>);    </span><br><span class="line">        &#125;                </span><br><span class="line">        UART0_Close(fd);     </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tool</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>一种嵌入式设计模式</title>
    <url>/blog/2021/12/22/%E4%B8%80%E7%A7%8D%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用<code>set</code>与<code>get</code>方式实现的金字塔型架构,最下层仅提供函数调用,例如tcp,udp,uart,gpio等,第二层是模块层,这一层通过pthread线程实现自循环式模块实现,通过get与set对模块数据进行获取与设置.最后是逻辑层,仅对下层数据进行逻辑操作,不做模块实现.</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcontrolcan.so</span><br><span class="line">└── src</span><br><span class="line">    ├── GROUND_PANEL</span><br><span class="line">    │   ├── Driver</span><br><span class="line">    │   │   ├── Driver.h</span><br><span class="line">    │   │   ├── Driver_utils.cpp</span><br><span class="line">    │   │   ├── Driver_utils.h</span><br><span class="line">    │   │   ├── Gpio.cpp</span><br><span class="line">    │   │   ├── Gpio.h</span><br><span class="line">    │   │   ├── controlcan.cpp</span><br><span class="line">    │   │   ├── controlcan.h</span><br><span class="line">    │   │   ├── socketCAN.cpp</span><br><span class="line">    │   │   ├── socketCAN.h</span><br><span class="line">    │   │   ├── tcp_cilent.cpp</span><br><span class="line">    │   │   ├── tcp_cilent.h</span><br><span class="line">    │   │   ├── usart.cpp</span><br><span class="line">    │   │   └── usart.h</span><br><span class="line">    │   ├── Math</span><br><span class="line">    │   │   ├── Math.h</span><br><span class="line">    │   │   ├── pid_control.cpp</span><br><span class="line">    │   │   └── pid_control.h</span><br><span class="line">    │   ├── ThirdParts</span><br><span class="line">    │   │   ├── CFG_ini.cpp</span><br><span class="line">    │   │   ├── CFG_ini.h</span><br><span class="line">    │   │   ├── ModBUS</span><br><span class="line">    │   │   │   ├── ascii</span><br><span class="line">    │   │   │   │   ├── mbascii.c</span><br><span class="line">    │   │   │   │   └── mbascii.h</span><br><span class="line">    │   │   │   ├── functions</span><br><span class="line">    │   │   │   │   ├── mbfunccoils.c</span><br><span class="line">    │   │   │   │   ├── mbfuncdiag.c</span><br><span class="line">    │   │   │   │   ├── mbfuncdisc.c</span><br><span class="line">    │   │   │   │   ├── mbfuncholding.c</span><br><span class="line">    │   │   │   │   ├── mbfuncinput.c</span><br><span class="line">    │   │   │   │   ├── mbfuncother.c</span><br><span class="line">    │   │   │   │   └── mbutils.c</span><br><span class="line">    │   │   │   ├── include</span><br><span class="line">    │   │   │   │   ├── mb.h</span><br><span class="line">    │   │   │   │   ├── mbconfig.h</span><br><span class="line">    │   │   │   │   ├── mbframe.h</span><br><span class="line">    │   │   │   │   ├── mbfunc.h</span><br><span class="line">    │   │   │   │   ├── mbport.h</span><br><span class="line">    │   │   │   │   ├── mbproto.h</span><br><span class="line">    │   │   │   │   └── mbutils.h</span><br><span class="line">    │   │   │   ├── mb.c</span><br><span class="line">    │   │   │   ├── port</span><br><span class="line">    │   │   │   │   ├── port.h</span><br><span class="line">    │   │   │   │   ├── portevent.c</span><br><span class="line">    │   │   │   │   ├── portother.c</span><br><span class="line">    │   │   │   │   ├── portserial.c</span><br><span class="line">    │   │   │   │   └── porttimer.c</span><br><span class="line">    │   │   │   ├── rtu</span><br><span class="line">    │   │   │   │   ├── mbcrc.c</span><br><span class="line">    │   │   │   │   ├── mbcrc.h</span><br><span class="line">    │   │   │   │   ├── mbrtu.c</span><br><span class="line">    │   │   │   │   └── mbrtu.h</span><br><span class="line">    │   │   │   └── tcp</span><br><span class="line">    │   │   │       ├── mbtcp.c</span><br><span class="line">    │   │   │       └── mbtcp.h</span><br><span class="line">    │   │   ├── cJSON.c</span><br><span class="line">    │   │   ├── cJSON.h</span><br><span class="line">    │   │   ├── tinyxml2.cpp</span><br><span class="line">    │   │   └── tinyxml2.h</span><br><span class="line">    │   └── param</span><br><span class="line">    │       ├── AGVParameter.h</span><br><span class="line">    │       ├── CFG.c</span><br><span class="line">    │       ├── CFG.h</span><br><span class="line">    │       ├── env_configure.c</span><br><span class="line">    │       └── env_configure.h</span><br><span class="line">    ├── Module</span><br><span class="line">    │   ├── ActionCTRL</span><br><span class="line">    │   │   ├── ActionCTRL.cpp</span><br><span class="line">    │   │   ├── ActionCTRL.h</span><br><span class="line">    │   │   └── ActionCTRLData.h</span><br><span class="line">    │   ├── Battery</span><br><span class="line">    │   │   ├── Battery.cpp</span><br><span class="line">    │   │   ├── Battery.h</span><br><span class="line">    │   │   ├── BatteryData.h</span><br><span class="line">    │   │   ├── EIKTO_battery.cpp</span><br><span class="line">    │   │   ├── EIKTO_battery.h</span><br><span class="line">    │   │   ├── FR_battery.cpp</span><br><span class="line">    │   │   └── FR_battery.h</span><br><span class="line">    │   ├── CommWithPC</span><br><span class="line">    │   │   ├── CommWithPC.cpp</span><br><span class="line">    │   │   ├── CommWithPC.h</span><br><span class="line">    │   │   └── CommWithPCData.h</span><br><span class="line">    │   ├── Encoder</span><br><span class="line">    │   │   ├── Encoder.cpp</span><br><span class="line">    │   │   ├── Encoder.h</span><br><span class="line">    │   │   ├── EncoderData.h</span><br><span class="line">    │   │   ├── TOFI_encoder.cpp</span><br><span class="line">    │   │   └── TOFI_encoder.h</span><br><span class="line">    │   ├── HandShank</span><br><span class="line">    │   │   ├── HandShank.cpp</span><br><span class="line">    │   │   ├── HandShank.h</span><br><span class="line">    │   │   ├── HandShankData.h</span><br><span class="line">    │   │   ├── Logitech_controller.cpp</span><br><span class="line">    │   │   └── Logitech_controller.h</span><br><span class="line">    │   ├── IoBoard</span><br><span class="line">    │   │   ├── IoBoard.cpp</span><br><span class="line">    │   │   ├── IoBoard.h</span><br><span class="line">    │   │   └── IoBoardData.h</span><br><span class="line">    │   ├── Location</span><br><span class="line">    │   │   ├── Location.cpp</span><br><span class="line">    │   │   ├── Location.h</span><br><span class="line">    │   │   └── LocationData.h</span><br><span class="line">    │   ├── Map</span><br><span class="line">    │   │   ├── LaserMAP.cpp</span><br><span class="line">    │   │   ├── LaserMAP.h</span><br><span class="line">    │   │   ├── Map.cpp</span><br><span class="line">    │   │   ├── Map.h</span><br><span class="line">    │   │   └── MapData.h</span><br><span class="line">    │   ├── Module.cpp</span><br><span class="line">    │   ├── Module.h</span><br><span class="line">    │   ├── MoveCTRL</span><br><span class="line">    │   │   ├── Kunhou</span><br><span class="line">    │   │   │   ├── Kunhou_cJSON.cpp</span><br><span class="line">    │   │   │   └── Kunhou_cJSON.h</span><br><span class="line">    │   │   ├── MoveCTRL.cpp</span><br><span class="line">    │   │   ├── MoveCTRL.h</span><br><span class="line">    │   │   ├── MoveCtrlData.h</span><br><span class="line">    │   │   └── Tongyi_Diff_Drive</span><br><span class="line">    │   │       ├── Tongyi_Driver.cpp</span><br><span class="line">    │   │       ├── Tongyi_Driver.h</span><br><span class="line">    │   │       ├── diff_control.cpp</span><br><span class="line">    │   │       └── diff_control.h</span><br><span class="line">    │   ├── log.cpp</span><br><span class="line">    │   └── log.h</span><br><span class="line">    ├── Task</span><br><span class="line">    │   ├── ModbusHMI.cpp</span><br><span class="line">    │   ├── ModbusHMI.h</span><br><span class="line">    │   ├── Music_Led.cpp</span><br><span class="line">    │   ├── Music_Led.h</span><br><span class="line">    │   ├── Safety.cpp</span><br><span class="line">    │   ├── Safety.h</span><br><span class="line">    │   ├── Task.cpp</span><br><span class="line">    │   ├── Task.h</span><br><span class="line">    │   ├── autoCtrl.cpp</span><br><span class="line">    │   ├── autoCtrl.h</span><br><span class="line">    │   ├── manualCtrl.cpp</span><br><span class="line">    │   └── manualCtrl.h</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>需要注意的一点是每个特定模块又三个对外文件,<code>module.cpp</code> <code>module.h</code> <code>moduleData.h</code></p>
<p>模块使用,只有使用时初始化线程,如果不使用则注释掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;HandShank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_HandShank</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Logitech_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发中各种开发模型的优缺点</title>
    <url>/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/57187282">软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com)</a></p>
<p>可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。</p>
<p>但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。</p>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191209214003673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0MDY2Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。</li>
<li>比较适用于前期的软件开发与小型软件系统的开发中。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>无法评估项目进度。因为不知道哪个阶段会造成项目的延期</li>
<li>无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果</li>
</ul>
<h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzNzQwMDAxNWZjYTAyNjgwMzU0LmpwZw?x-oss-process=image/format,png" alt="http://img2.mukewang.com/5d78b37400015fca02680354.jpg"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>解决需求不明确带来的风险，适用于不能提前确定项目需求的项目</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不利于开发人员对产品进行扩展</li>
</ul>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzN2MwMDAxZTFlMjAzOTEwMTcxLmpwZw?x-oss-process=image/format,png" alt="http://img4.mukewang.com/5d78b37c0001e1e203910171.jpg"></p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>第一个可交付版本的软件所需的成本与时间较小</li>
<li>能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。</li>
<li>最终集成各个组件时，可能会出现集成失败的风险。</li>
</ul>
<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzODUwMDAxOTYwOTAyNTcwMjI5LmpwZw?x-oss-process=image/format,png" alt="img"></p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul>
<li>支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。</li>
</ul>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。</li>
<li>大量开发人员不利于项目的管理。</li>
<li>该模型需要严格管理文档，会增加审核的难度增大。</li>
</ul>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。<br>螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示：</p>
<p><img src="http://hiphotos.baidu.com/wlclass/pic/item/aad0ca9597169740d0135e27.jpg" alt="img"></p>
<p>该模型共有四个象限，每个象限的含义如下：</p>
<ul>
<li>制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</li>
<li>风险分析:评价所制订的实施方案，识别风险并消除风险。</li>
<li>实施工程:开发产品并进行验证。</li>
<li>客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</li>
</ul>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul>
<li>螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
<h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。<br>敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。<br>软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。<br>该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。</p>
<h5 id="敏捷开发模型的价值与原则"><a href="#敏捷开发模型的价值与原则" class="headerlink" title="敏捷开发模型的价值与原则"></a>敏捷开发模型的价值与原则</h5><ul>
<li>个体和交互重于过程和工具</li>
<li>可用软件重于完备文档</li>
<li>客户协作重于合同谈判</li>
<li>响应变化重于遵循计划</li>
</ul>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul>
<li>用户很快可以看到一个基线架构版的产品</li>
<li>敏捷注重市场快速反应能力，客户前期满意度高。</li>
</ul>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>注重人员的沟通</li>
<li>忽略文档的重要性</li>
<li>如果项目人员流动大太，会增加项目维护难度</li>
<li>软件之前版本的可重现性、可回溯性较低</li>
<li>对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。</li>
</ul>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>三维空间内旋转</title>
    <url>/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ahelloyou/article/details/108903506?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108903506.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">旋转矩阵_ahelloyou的博客-CSDN博客_旋转矩阵</a></p>
<p><a href="https://blog.csdn.net/u012424737/article/details/106269229?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-106269229.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">机器人运动学基础——旋转矩阵_太初有泪的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/hongbin_xu/article/details/78929006?ops_request_misc=%7B%22request_id%22:%22163585334816780366567178%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585334816780366567178&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78929006.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F&spm=1018.2226.3001.4187">三维重建学习(1)：基础知识：旋转矩阵与旋转向量_hongbin_xu的博客-CSDN博客_旋转向量</a></p>
<h1 id="简记"><a href="#简记" class="headerlink" title="简记"></a>简记</h1><p><img src="https://i.loli.net/2021/11/02/dxrQGvqahi5YN2I.jpg" alt="三位空间内的旋转"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>变量初始化多种操作</title>
    <url>/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ">嵌入式C语言编程时，变量、数组、指针初始化的多种操作</a></p>
<h1 id="数值初始化"><a href="#数值初始化" class="headerlink" title="数值初始化"></a>数值初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>    inum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span>  fnum = <span class="number">0.00f</span>;</span><br><span class="line"><span class="keyword">double</span> dnum = <span class="number">0.00</span>;</span><br></pre></td></tr></table></figure>

<h1 id="字符初始化"><a href="#字符初始化" class="headerlink" title="字符初始化"></a>字符初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>; </span><br></pre></td></tr></table></figure>

<h1 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h1><p>实际上就是将字符数组中的字符都初始化为<code>&#39;\0&#39;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用&quot;&quot;实现</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 使用memset</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line"><span class="comment">//使用循环</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般使用<code>memset</code>最合适,一般采用<code>+1</code>的方式参考:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> year[<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(year, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(year));</span><br><span class="line"><span class="built_in">strcpy</span>(year,<span class="string">&quot;2018&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><p>需要使用<code>malloc</code>申请动态内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;  </span><br><span class="line">p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory Allocated at: %x\n&quot;</span>,p);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not Enough Memory!\n&quot;</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>;   <span class="comment">//这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题</span></span><br></pre></td></tr></table></figure>

<h1 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU stu1;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1));</span><br><span class="line"><span class="comment">//  struct tm * tmp_time;</span></span><br><span class="line"><span class="comment">// memset(tmp_time, 0, sizeof(struct tm));</span></span><br><span class="line"><span class="comment">// task_send_data task_data;</span></span><br><span class="line"><span class="comment">// task_rcv_data rcv_data;</span></span><br><span class="line"><span class="comment">// memset(&amp;task_data, 0, sizeof(task_data));</span></span><br><span class="line"><span class="comment">// memset(&amp;rcv_data, 0, sizeof(rcv_data));</span></span><br></pre></td></tr></table></figure>

<p>注意初始化结构体数组时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STU stus[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stus)); <span class="comment">//正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU));  <span class="comment">//错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU)*<span class="number">10</span>);  <span class="comment">//正确，效果与第一个是一样的</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0x00</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1)); <span class="comment">//正确,效果与第一个是一样的</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数</title>
    <url>/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/baidu_38172402/article/details/95119014?ops_request_misc=%7B%22request_id%22:%22163409375616780261926822%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163409375616780261926822&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-95119014.pc_search_ecpm_flag&utm_term=c%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">c语言回调函数</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 函数指针结构体</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OP</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_add)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_sub)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_mul)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_div)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">&#125; OP; </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 加减乘除函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADD</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SUB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MUL</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">DIV</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 初始化函数指针</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_op</span><span class="params">(OP *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op-&gt;p_add = ADD;</span><br><span class="line">    op-&gt;p_sub = SUB;</span><br><span class="line">    op-&gt;p_mul = &amp;MUL;</span><br><span class="line">    op-&gt;p_div = &amp;DIV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 库函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_sub_mul_div</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> (*op_func)(<span class="keyword">float</span>, <span class="keyword">float</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*op_func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OP *op = (OP *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(OP)); </span><br><span class="line">    <span class="built_in">init_op</span>(op);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 直接使用函数指针调用函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, (op-&gt;p_add)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_sub)(<span class="number">1.3</span>, <span class="number">2.2</span>), </span><br><span class="line">            (op-&gt;p_mul)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_div)(<span class="number">1.3</span>, <span class="number">2.2</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 调用回调函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, ADD), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, SUB), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, MUL), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, DIV));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>局部全局坐标转换</title>
    <url>/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="局部全局坐标转换"><a href="#局部全局坐标转换" class="headerlink" title="局部全局坐标转换"></a>局部全局坐标转换</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="https://i.loli.net/2021/10/29/QfTymrLqs7AG6a2.png" alt="image-20211029181117606.png"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h2><p><img src="https://i.loli.net/2021/10/29/7ht1yaPc3E26zBF.png" alt="image-20211029180943040.png"></p>
<h2 id="ROS-中里程计的计算代码理解"><a href="#ROS-中里程计的计算代码理解" class="headerlink" title="ROS 中里程计的计算代码理解"></a>ROS 中里程计的计算代码理解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dt = (current_time - last_time).<span class="built_in">toSec</span>();</span><br><span class="line"><span class="keyword">double</span> delta_x = (vx * <span class="built_in">cos</span>(th) - vy * <span class="built_in">sin</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_y = (vx * <span class="built_in">sin</span>(th) + vy * <span class="built_in">cos</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_th = vth * dt;</span><br><span class="line"></span><br><span class="line">x += delta_x;</span><br><span class="line">y += delta_y;</span><br><span class="line">th += delta_th;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式业务逻辑</title>
    <url>/blog/2021/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/aa120515692/article/details/104990729?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-104990729.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">嵌入式架构到底有多重要？看完惊呆了_连志安-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/aa120515692/article/details/104274547?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-21-104274547.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">史上最详细！嵌入式系统知识和接口技术总结_连志安-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ybhuangfugui/article/details/115388269?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-26-115388269.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">嵌入式开发中为什么很少用设计模式？_strongerHuang-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/nh5431313/article/details/104922035?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-104922035.pc_search_mgc_flag&spm=1018.2226.3001.4187">嵌入式架构_分享嵌入式,移动端,智能应用,数据库等专业板块,记录知识碎片！！！-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ITLearnHall/article/details/82985480?ops_request_misc=%7B%22request_id%22:%22163586126216780265434712%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163586126216780265434712&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82985480.pc_search_mgc_flag&utm_term=%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84&spm=1018.2226.3001.4187">应用架构、业务架构、技术架构和业务流程图详解_代码帮-CSDN博客_业务架构</a></p>
<p><a href="https://www.eet-china.com/mp/a69844.html">提高RTOS应用程序稳定可靠的几点技巧-面包板社区 (eet-china.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_42616791/article/details/108548128?ops_request_misc=%7B%22request_id%22:%22163576619116780366553575%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163576619116780366553575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-108548128.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">RTOS 是如何进行任务划分的？_wenzi嵌入式软件的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_35021496/article/details/81035750?ops_request_misc=%7B%22request_id%22:%22163576619116780271563446%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163576619116780271563446&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81035750.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">UCOS 等 RTOS的任务划分原则（转载整理）_Dr树树的博客-CSDN博客</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TmhxU21PQkpDd1dOMkZDT2ljdW5XNnk3STFsd3BZR2Y1NFNUSkYwejNKaWJUNzFYTXdNQjh5TktESjZ3ZFNiTTRWM0VDWmZVYWU2ZzdnLzY0MA?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TmhxU21PQkpDd1dOMkZDT2ljdW5XNnl6TFhzQlNJUzY3cDJKZ0hkNEdSUUVpY0c4UWF0aWIzUFJtTDNMajBrMGx0b1dXQ1ZFeGh5N0x5QS82NDA?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TkJjaWFpYmRoaWNOcmg3OEJmcFdKM3JaOFFyUHFPVzBlVk12UzdoWDZMMGtiWGdNdXlzNEFKaWNUb1pkQVZ5S3dySldVQ1A1TFUzbUExWXcvNjQw?x-oss-process=image/format,png" alt="img"><img src="https://img-blog.csdnimg.cn/2021010409370574.gif" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180115133844637?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><img src="https://i.loli.net/2021/11/23/7UcLHNskClj6Y12.png" alt="image-20211123223940120.png"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式相关的开源项目</title>
    <url>/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw">https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw</a></p>
<h2 id="1-Avem"><a href="#1-Avem" class="headerlink" title="1.Avem"></a>1.<a href="https://github.com/avem-labs/Avem">Avem</a></h2><p>这是一个轻量级无人机飞控项目。</p>
<h1 id="2-Awesome-Embedded"><a href="#2-Awesome-Embedded" class="headerlink" title="2.Awesome-Embedded"></a>2.<a href="https://github.com/nhivp/Awesome-Embedded">Awesome-Embedded</a></h1><p>这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源：</p>
<h1 id="3-soft-and-hard"><a href="#3-soft-and-hard" class="headerlink" title="3.soft-and-hard"></a>3.<a href="https://github.com/alwxkxk/soft-and-hard">soft-and-hard</a></h1><p>这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。</p>
<h1 id="4-FreeModbus"><a href="#4-FreeModbus" class="headerlink" title="4.FreeModbus"></a>4.<a href="https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32">FreeModbus</a></h1><p>FreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要<strong>收费</strong>的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。</p>
<h1 id="5-EmbedSummary"><a href="#5-EmbedSummary" class="headerlink" title="5. EmbedSummary"></a>5.<strong><a href="https://github.com/zhengnianli/EmbedSummary"> EmbedSummary</a></strong></h1><p>精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式分层</title>
    <url>/blog/2022/01/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/wxg_wuchujie88/article/details/85992064">(94条消息) 例解嵌入式系统分层结构_和风化雨-CSDN博客_嵌入式系统分层</a> </p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p> 分层的目的主要:1,是降低系统开发难度；2,是为了复用。 </p>
<h1 id="两层结构-硬件层-软件层"><a href="#两层结构-硬件层-软件层" class="headerlink" title="两层结构[硬件层, 软件层]"></a>两层结构[硬件层, 软件层]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      P1_1=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">      P1_1=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三层结构-硬件层，-驱动层，应用层"><a href="#三层结构-硬件层，-驱动层，应用层" class="headerlink" title="三层结构[ 硬件层， 驱动层，应用层 ]"></a>三层结构[ 硬件层， 驱动层，应用层 ]</h1><p>虽然简单但很有逻辑,可以参考</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************驱动头文件 driver.h***********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_on</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_off</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*******************驱动源文件 driver.c************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;driver.h&quot;</span></span></span><br><span class="line"><span class="comment">/*延时函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_on</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   P1_1=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_off</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   P1_1=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************应用系统****************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>“../driver/driver.h”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123; </span><br><span class="line">       led_on();</span><br><span class="line">       delay();</span><br><span class="line">       led_off();</span><br><span class="line">       delay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四层结构-硬件层，驱动层，操作系统层，应用层"><a href="#四层结构-硬件层，驱动层，操作系统层，应用层" class="headerlink" title="四层结构[ 硬件层，驱动层，操作系统层，应用层 ]"></a>四层结构[ 硬件层，驱动层，操作系统层，应用层 ]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************驱动****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kerel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm/h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_cleanup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_open</span><span class="params">(struct inode *,struct file*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_release</span><span class="params">(struct inode *,struct file*)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> device _write(struct file*,<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">size_t</span>,<span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_model</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_ops</span>=</span>&#123;</span><br><span class="line">.owner=THIS_MODULE,</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> led_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> led_cleanup()</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> device_open(struct inode * inode ,struct file* file)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> device_release(struct inode *inode,struct file* file)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> device _write(struct file *file,<span class="keyword">const</span> <span class="keyword">char</span> * buffer,<span class="keyword">size_t</span> length,<span class="keyword">loff_t</span> *offset)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line"><span class="keyword">int</span> init_model(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line">modele_init(led_init);</span><br><span class="line">module_exit(led_cleanup);</span><br><span class="line">MODULE_LICENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="comment">/******************************应用****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED  <span class="meta-string">&quot;/dev/led&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    File *fp=fopen(LED,RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ioctl(fp,<span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        ioctl(fp,<span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>查看程序使用情况</title>
    <url>/blog/2021/12/01/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a href="https://blog.csdn.net/mayue_web/article/details/105388617">Linux下查看某个进程所占用的资源_mayue_web的博客-CSDN博客_查看进程占用资源</a></p>
<h1 id="shell例程"><a href="#shell例程" class="headerlink" title="shell例程"></a>shell例程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改这里的./Tungray运行程序,用于查看pid</span></span><br><span class="line">ps -aux | grep ./Tungray &gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取第一行,并解析pid</span></span><br><span class="line">pid=`awk &#x27;NR==1&#123;print $2&#125;&#x27; pid`</span><br><span class="line"></span><br><span class="line">cat /proc/$pid/status &gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取第一行,并解析pid</span></span><br><span class="line">state=`awk &#x27;NR==2&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;state:&quot;$state`awk &#x27;NR==2&#123;print $3&#125;&#x27; pid`</span><br><span class="line">VmSize=`awk &#x27;NR==12&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;VmSize:&quot;$VmSize`awk &#x27;NR==12&#123;print $3&#125;&#x27; pid`</span><br><span class="line">VmRSS=`awk &#x27;NR==15&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;VmRSS:&quot;$VmRSS`awk &#x27;NR==15&#123;print $3&#125;&#x27; pid`</span><br><span class="line">Threads=`awk &#x27;NR==21&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;Threads:&quot;$Threads</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Name 应用程序或命令的名字 </span><br><span class="line">State 任务的状态，运行/睡眠/僵死/ </span><br><span class="line">SleepAVG 任务的平均等待时间(以nanosecond为单位)，交互式任务因为休眠次数多、时间长，它们的 sleep_avg 也会相应地更大一些，所以计算出来的优先级也会相应高一些。 </span><br><span class="line">Tgid 线程组号 </span><br><span class="line">Pid 任务ID </span><br><span class="line">Ppid 父进程ID </span><br><span class="line">TracerPid 接收跟踪该进程信息的进程的ID号 </span><br><span class="line">Uid Uid euid suid fsuid </span><br><span class="line">Gid Gid egid sgid fsgid </span><br><span class="line">FDSize 文件描述符的最大个数，file-&gt;fds </span><br><span class="line">Groups </span><br><span class="line">VmSize(KB) 任务虚拟地址空间的大小 (total_vm-reserved_vm)，其中total_vm为进程的地址空间的大小，reserved_vm：进程在预留或特殊的内存间的物理页 </span><br><span class="line">VmLck(KB) 任务已经锁住的物理内存的大小。锁住的物理内存不能交换到硬盘 (locked_vm) </span><br><span class="line">VmRSS(KB) 应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss) </span><br><span class="line">VmData(KB) 程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据； (total_vm-shared_vm-stack_vm) </span><br><span class="line">VmStk(KB) 任务在用户态的栈的大小 (stack_vm) </span><br><span class="line">VmExe(KB) 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库 (end_code-start_code) </span><br><span class="line">VmLib(KB) 被映像到任务的虚拟内存空间的库的大小 (exec_lib) </span><br><span class="line">VmPTE 该进程的所有页表的大小，单位：kb </span><br><span class="line">Threads 共享使用该信号描述符的任务的个数，在POSIX多线程序应用程序中，线程组中的所有线程使用同一个信号描述符。 </span><br><span class="line">SigQ 待处理信号的个数 </span><br><span class="line">SigPnd 屏蔽位，存储了该线程的待处理信号 </span><br><span class="line">ShdPnd 屏蔽位，存储了该线程组的待处理信号 </span><br><span class="line">SigBlk 存放被阻塞的信号 </span><br><span class="line">SigIgn 存放被忽略的信号 </span><br><span class="line">SigCgt 存放被俘获到的信号 </span><br><span class="line">CapInh Inheritable，能被当前进程执行的程序的继承的能力 </span><br><span class="line">CapPrm Permitted，进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的，CapEff是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性 </span><br><span class="line">CapEff Effective，进程的有效能力 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>时间触发嵌入式系统设计模式</title>
    <url>/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/wowocpp/article/details/82887244">时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式</a></p>
<p><a href="https://github.com/yzhong52/SimpleTimer">SimpleTimer</a></p>
<p>[Linux下C实现的自定义定时器](<a href="https://github.com/voidAspire/Timer">voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)</a>)</p>
<p>[CppTimer](<a href="https://github.com/berndporr/cppTimer">berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)</a>)</p>
<p>[simple-timer-for-c-language](<a href="https://github.com/ielife/simple-timer-for-c-language">ielife/simple-timer-for-c-language: high performance timer for linux (github.com)</a>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// GPIO_LED : GPIO output to control an on-board red LED</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// EVB : Nu-LB-NUC140</span></span><br><span class="line"><span class="comment">// MCU : NUC140VE3CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// low-active output control by GPC12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NUC100Series.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MCU_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SYS_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	SCH_Update();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSysTickClk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	SCH_Init();</span><br><span class="line">    </span><br><span class="line">	SysTick-&gt;LOAD = <span class="number">1000</span> *CyclesPerUs <span class="number">-1</span>;</span><br><span class="line">	SysTick-&gt;VAL  = (<span class="number">0x00</span>);</span><br><span class="line">	</span><br><span class="line">	NVIC_EnableIRQ(SysTick_IRQn);</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_Update</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_TOGGLE(PC14);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_UpdateD</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_TOGGLE(PC12);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYS_Init(); 	 </span><br><span class="line">		UART_Open(UART0, <span class="number">115200</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello World \r\n&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">        GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);</span><br><span class="line">		GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);</span><br><span class="line">		GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);</span><br><span class="line">			</span><br><span class="line">		InitSysTickClk();</span><br><span class="line">        SCH_Add_Task(LED_Flash_Update, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">		SCH_Add_Task(LED_Flash_UpdateD, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      SCH_Dispatch_Tasks();</span><br><span class="line">   &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scheduler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SCHEDULER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SCHEDULER_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的函数原型 -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器内核函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (*) (<span class="keyword">void</span>), <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的常数 -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间任一时刻请求的任务最大数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间</span></span><br><span class="line"><span class="comment">// 每个新建项目都必须调整</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCH_MAX_TASKS   (3)   </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scheduler.c</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   SCH51.C (v1.00) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   /// 这里是调度器内核函数 ///</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 这里是调度器内核函数 ***</span></span><br><span class="line"><span class="comment">   --- 这些函数可以用于所有 8051 芯片 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** hSCH_MAX_TASKS 必须由用户设置 ***</span></span><br><span class="line"><span class="comment">   --- 参见 &quot;Sch51.h&quot; ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 包括省电模式***</span></span><br><span class="line"><span class="comment">   --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----）</span></span><br><span class="line"><span class="comment">   --- 诸如 c515c, c509,等等才需要 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> tByte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  tWord;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tLong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_TOO_MANY_TASKS (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CANNOT_DELETE_TASK (2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_LOST_SLAVE (5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CAN_BUS_ERROR (6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE (10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE (11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE_AT24C64 (12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE_AT24C64 (13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_DS1621 (14)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_TI (21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_WRITE_CHAR (22)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_X25_TIMEOUT (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_MAX1110_TIMEOUT (33)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_ADC_MAX150_TIMEOUT (44)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_NORMAL  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ERROR   1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用变量定义 ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用数据类型声明 ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果可能的话，存储在 DATA 区, 以供快速存取  </span></span><br><span class="line"><span class="comment">// 每个任务的存储器总和是 7个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数)</span></span><br><span class="line">   <span class="keyword">void</span> (* pTask)(<span class="keyword">void</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//延迟 (时标) 直到函数将 (下一次) 运行</span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task()</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  Delay;       </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在连续的运行之间的间隔 (时标) </span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task() </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> Period;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当任务需要运行时 (由调度器) 加1</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> RunMe;  </span><br><span class="line">	</span><br><span class="line">&#125; sTask; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line">sTask SCH_tasks_G[SCH_MAX_TASKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来显示错误代码</span></span><br><span class="line"><span class="comment">// 错误代码的详细资料参见 Main.H </span></span><br><span class="line"><span class="comment">// 关于错误端口的详细资料参见 Port.H </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Error_code_G = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有函数原型  ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有变量 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟踪自从上一次记录错误以来的时间 (见下文)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  Error_tick_count_G;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上次的错误代码 (在1分钟之后复位)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Last_error_code_G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Dispatch_Tasks()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这是“调度”函数.  当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它.</span></span><br><span class="line"><span class="comment">  这个函数必须被主循环 (重复)调用.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调度 (运行) 下一个任务 (如果有任务就绪)</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line">		 <span class="keyword">if</span> (SCH_tasks_G[Index].RunMe &gt; <span class="number">0</span>) </span><br><span class="line">      &#123;</span><br><span class="line">         (*SCH_tasks_G[Index].pTask)();  <span class="comment">// 运行任务</span></span><br><span class="line"></span><br><span class="line">         SCH_tasks_G[Index].RunMe -= <span class="number">1</span>;   <span class="comment">//  RunMe 标志复位/减1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性的任务将自动的再次运行</span></span><br><span class="line">         <span class="comment">// - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除</span></span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Period == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            SCH_Delete_Task(Index);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 报告系统状况</span></span><br><span class="line">   SCH_Report_Status();  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里调度器进行空闲模式  </span></span><br><span class="line">   SCH_Go_To_Sleep();          </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Add_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  Fn_P  - 将被调度的函数的名称.</span></span><br><span class="line"><span class="comment">          注意: 所有被调度的函数必须是 &#x27;void, void&#x27; -</span></span><br><span class="line"><span class="comment">          即函数没有参数, 并且返回类型为 void </span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">  DELAY   - 在任务第一次被运行之前的间隔（时标）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  PERIOD   -  &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次.</span></span><br><span class="line"><span class="comment">              &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些）</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  //PERIOD</span></span><br><span class="line"><span class="comment">  返回值 :   返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中</span></span><br><span class="line"><span class="comment">           (空间不够).  如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          注意: 如果以后要删除任务, 将需要这个返回值，参见  SCH_Delete_Task().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  例子:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,1000,0,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 在1000 个调度器时标之后运行一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,0,1000,1);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个调度器时标运行一次</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,300,1000,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标，</span></span><br><span class="line"><span class="comment">   2300个时标 ，等等            </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (* pFunction)(), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DELAY, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> PERIOD)</span>    </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 首先在队列中找到一个空隙(如果有的话)</span></span><br><span class="line">   <span class="keyword">while</span> ((SCH_tasks_G[Index].pTask != <span class="number">0</span>) &amp;&amp; (Index &lt; SCH_MAX_TASKS))</span><br><span class="line">      &#123;</span><br><span class="line">      Index++;</span><br><span class="line">      &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 是否已经到达队列的结尾 ？？   </span></span><br><span class="line">   <span class="keyword">if</span> (Index == SCH_MAX_TASKS)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 任务队列已满</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_TOO_MANY_TASKS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同时返回错误代码</span></span><br><span class="line">      <span class="keyword">return</span> SCH_MAX_TASKS;  </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 如果能运行到这里，说明任务队列中有空间</span></span><br><span class="line">   SCH_tasks_G[Index].pTask  = pFunction;</span><br><span class="line">     </span><br><span class="line">   SCH_tasks_G[Index].Delay  = DELAY;</span><br><span class="line">   SCH_tasks_G[Index].Period = PERIOD;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[Index].RunMe  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Index; <span class="comment">// 返回任务的位置 (以便以后删除)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Delete_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  从调度器删除任务.  注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 </span></span><br><span class="line"><span class="comment">  参数:   TASK_INDEX - 任务索引.  由 SCH_Add_Task()提供. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回值:  RETURN_ERROR or RETURN_NORMAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>  <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> tByte TASK_INDEX)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Return_code;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SCH_tasks_G[TASK_INDEX].pTask == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 这里没有任务</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ...同时返回错误代码</span></span><br><span class="line">      Return_code = RETURN_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      Return_code = RETURN_NORMAL;</span><br><span class="line">      &#125;      </span><br><span class="line">   </span><br><span class="line">   SCH_tasks_G[TASK_INDEX].pTask   = <span class="number">0x0000</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Delay   = <span class="number">0</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Period  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[TASK_INDEX].RunMe   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Return_code;       <span class="comment">// 返回状态</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Report_Status()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  用来显示错误代码的简单的函数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个版本将在连接到端口的LED上显示错误代码，</span></span><br><span class="line"><span class="comment">  如果需要的话，可以修改为通过串行连接等方式报告错误。</span></span><br><span class="line"><span class="comment">  错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。).</span></span><br><span class="line"><span class="comment">  此后错误代码被复位为0. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  更加详尽的资料参见第10章。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SCH_REPORT_ERRORS</span></span><br><span class="line">   <span class="comment">// 只在需要报告错误时适用</span></span><br><span class="line">   <span class="comment">// 检查新的错误代码</span></span><br><span class="line">   <span class="keyword">if</span> (Error_code_G != Last_error_code_G)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 假定LED采用负逻辑</span></span><br><span class="line">      Error_port = <span class="number">255</span> - Error_code_G;</span><br><span class="line">      </span><br><span class="line">      Last_error_code_G = Error_code_G;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Error_code_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">60000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> (Error_tick_count_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">if</span> (--Error_tick_count_G == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            Error_code_G = <span class="number">0</span>; <span class="comment">// 复位错误代码</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Go_To_Sleep()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。</span></span><br><span class="line"><span class="comment">  注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。</span></span><br><span class="line"><span class="comment">  然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计</span></span><br><span class="line"><span class="comment">  调度器的性能。这方面的例子参见第14章。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 如果使用看门狗的话，可能需要禁止这个功能 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 根据硬件的需要修改 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Update  中断调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   这是调度器的中断服务程序.  初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。</span></span><br><span class="line"><span class="comment">   这个版本由定时器1中断触发</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   tByte Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重装定时器</span></span><br><span class="line">   <span class="comment">// 注意：计算单位为“时标”（不是毫秒）</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 检测这里是否有任务</span></span><br><span class="line">      <span class="keyword">if</span> (SCH_tasks_G[Index].pTask)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Delay == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">// 任务需要运行</span></span><br><span class="line">            SCH_tasks_G[Index].RunMe += <span class="number">1</span>;  <span class="comment">//  &#x27;RunMe&#x27; 标志加1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SCH_tasks_G[Index].Period)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调度定期的任务再次运行</span></span><br><span class="line">               SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//还没有准备好运行，延迟减 1</span></span><br><span class="line">            SCH_tasks_G[Index].Delay -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;         </span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"> &#125; 	 </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">		 <span class="keyword">unsigned</span> <span class="keyword">char</span>  i;</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SCH_MAX_TASKS; i++) </span><br><span class="line">		 &#123;</span><br><span class="line">				SCH_Delete_Task(i);	</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">// 复位全局错误变量</span></span><br><span class="line">		 <span class="comment">// - SCH_Delete_Task() 将产生一个错误代码 </span></span><br><span class="line">		 <span class="comment">//   (因为任务队列是空的)</span></span><br><span class="line">		 Error_code_G = <span class="number">0</span>;</span><br><span class="line">		 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派串口通信</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/benchuspx/article/details/112571880?ops_request_misc=%7B%22request_id%22:%22163054521616780274150518%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163054521616780274150518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-112571880.pc_search_insert_download&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEubuntu+20%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF%E8%B0%83%E8%AF%95&spm=1018.2226.3001.4187">树莓派4b ubuntu系统开启串口_benchuspx的博客-CSDN博客</a></p>
<p><a href="https://www.pianshen.com/article/3825828971/">树莓派4B如何使用串口与外部进行通信 - 程序员大本营 (pianshen.com)</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>树莓派原本的抽是用于<strong>串口控制台</strong>的,即<code>/ttyAMA0</code>,且此硬件串口也与蓝牙连接到一块,因此需要将<strong>控制台</strong>与<strong>蓝牙</strong>关闭才能使用</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>/boot/firmware/nobtcmd.tx</code>t里删除<code>console = /ttyAMA 921600</code>从而禁用串口控制台.这个<code>txt文件</code>也可以用读卡器把sd卡插到windows系统里在<code>system-boot</code>里找到</p>
</li>
<li><p><code>/boot/firmware/config.txt</code> 里设置<code>enable_uart=1</code>（默认就是）.如果=0表示启用minicom串口，而不是这个硬件串口.</p>
</li>
<li><p><code>/boot/firmware/config.txt</code> 里加入一行<code>dtoverlay=disable-bt</code>从而禁用蓝牙.</p>
</li>
<li><p><code>sudo systemctl disable bluetooth</code>…… 禁用掉和蓝牙有关的开机启动项.直到桌面不再显示蓝牙标志，但是还有<code>/ttyAMA0</code>存在.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派GPIO</title>
    <url>/blog/2021/12/06/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/hu7850/article/details/51785560">树莓派GPIO控制–C语言篇_hu7850的博客-CSDN博客_树莓派c语言控制gpio</a></p>
<h1 id="IO表示"><a href="#IO表示" class="headerlink" title="IO表示"></a>IO表示</h1><p><img src="https://s2.loli.net/2021/12/10/wLfgq9kbRzoZD2a.png" alt="image-20211210165211671.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~/Cmake/build$ gpio readall</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |</span><br><span class="line"> |   2 |   8 |   SDA.1 | ALT0 | 1 |  3 || 4  |   |      | 5v      |     |     |</span><br><span class="line"> |   3 |   9 |   SCL.1 | ALT0 | 1 |  5 || 6  |   |      | 0v      |     |     |</span><br><span class="line"> |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | ALT5 | TxD     | 15  | 14  |</span><br><span class="line"> |     |     |      0v |      |   |  9 || 10 | 1 | ALT5 | RxD     | 16  | 15  |</span><br><span class="line"> |  17 |   0 | GPIO. 0 |   IN | 1 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |</span><br><span class="line"> |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |</span><br><span class="line"> |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |</span><br><span class="line"> |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |</span><br><span class="line"> |  10 |  12 |    MOSI | ALT0 | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line"> |   9 |  13 |    MISO | ALT0 | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line"> |  11 |  14 |    SCLK | ALT0 | 0 | 23 || 24 | 1 | OUT  | CE0     | 10  | 8   |</span><br><span class="line"> |     |     |      0v |      |   | 25 || 26 | 1 | OUT  | CE1     | 11  | 7   |</span><br><span class="line"> |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |</span><br><span class="line"> |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |</span><br><span class="line"> |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |</span><br><span class="line"> |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |</span><br><span class="line"> |  19 |  24 | GPIO.24 |   IN | 1 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |</span><br><span class="line"> |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |</span><br><span class="line"> |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+</span><br></pre></td></tr></table></figure>

<h1 id="wiringpi"><a href="#wiringpi" class="headerlink" title="wiringpi"></a><code>wiringpi</code></h1><h2 id="安装wiring"><a href="#安装wiring" class="headerlink" title="安装wiring"></a>安装wiring</h2><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://git.drogon.net/wiringPi</span><br><span class="line">cd wiringPi</span><br><span class="line">./build</span><br><span class="line">build脚本会帮助你编译和安装wiringPi</span><br></pre></td></tr></table></figure>

<p>或者通过此[下载](<a href="https://github.com/WiringPi/WiringPi">WiringPi/WiringPi: Gordon’s Arduino wiring-like WiringPi Library for the Raspberry Pi (Unofficial Mirror for WiringPi bindings) (github.com)</a>)安装</p>
<h3 id="raspbian上安装"><a href="#raspbian上安装" class="headerlink" title="raspbian上安装"></a>raspbian上安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wiringpi</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>github</strong>上有<strong>examples</strong>可以测试</p>
<h2 id="cmake使用wiringpi库"><a href="#cmake使用wiringpi库" class="headerlink" title="cmake使用wiringpi库"></a><strong>cmake使用wiringpi</strong>库</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(display)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(WIRINGPI_LIBRARIES NAMES wiringPi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(display display.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(display <span class="variable">$&#123;WIRINGPI_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://code.google.com/p/raspberry-gpio-python/</span><br></pre></td></tr></table></figure>

<h1 id="BCM2835-C-Library"><a href="#BCM2835-C-Library" class="headerlink" title="BCM2835 C Library"></a>BCM2835 C Library</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.35.tar.gz</span><br><span class="line">tar xvzf bcm2835-1.35.tar.gz</span><br><span class="line">cd bcm2835-1.35</span><br><span class="line">./configure make</span><br><span class="line">sudo make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><strong>可以使用examples测试</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派备份</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://zhuanlan.zhihu.com/p/299844978?utm_source=wechat_session">收藏！最简单的树莓派系统备份方法！ - 知乎 (zhihu.com)</a></p>
<p><a href="https://post.smzdm.com/p/apzkgne7/">树莓派学习笔记 篇四：树莓派4B 的系统备份方法大全（全卡+压缩备份）_其他智能设备_什么值得买 (smzdm.com)</a></p>
<p><a href="https://blog.csdn.net/sinat_16643223/article/details/109006150">烧写之前备份过的树莓派镜像到SD卡，证明这样备份恢复是可行的！！！！！！！_TYINY的博客-CSDN博客</a></p>
<h1 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h1><p><code>win10</code>下新建一个<code>.img</code>格式文件,通过<code>Win32DiskImager</code>,<code>read</code>插入卡的系统,<code>read</code>完就备份好了</p>
<p><img src="https://qnam.smzdm.com/201912/08/5ded02bcc031f2090.jpg_e1080.jpg" alt="树莓派4B 的系统备份方法大全（全卡+压缩备份）"></p>
<h1 id="脚本方式-推荐"><a href="#脚本方式-推荐" class="headerlink" title="脚本方式(推荐)"></a>脚本方式(推荐)</h1><p><a href="https://github.com/BigBubbleGum/RaspberryBackup"> 在Linux系统中一键备份树莓派系统SD卡的脚本 (github.com)</a></p>
<ul>
<li>下载下来脚本<code>rpi-backup.sh</code>放入到<code>Linux</code>系统</li>
<li>插入需备份的树莓派系统,用<code>df -h</code>命令查询SD卡设备名</li>
<li>运行<code>sudo chmod +x rpi-backup.sh</code>后,运行<code>./rpi-backup.sh /dev/sdb1 /dev/sdb2</code></li>
<li>注意第一个参数是树莓派SD卡<code>/boot</code>分区的设备名：/dev/sdb1，第二个参数是<code>/</code>分区的设备名：/dev/sdb2，视情况修改）</li>
<li>终 img 文件会生成在<code>~/backupimg/</code>文件夹下</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派CAN</title>
    <url>/blog/2021/12/10/%E6%A0%91%E8%8E%93%E6%B4%BECAN/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/j353838430/article/details/119486631?ops_request_misc=%7B%22request_id%22:%22163877530616780271559996%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163877530616780271559996&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-119486631.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEmcp2515&spm=1018.2226.3001.4187">树莓派CAN通讯教程 - MCP2515_j353838430的博客-CSDN博客_树莓派can通信</a></p>
<p><a href="https://blog.csdn.net/csshuke/article/details/113186248?ops_request_misc=&request_id=&biz_id=102&utm_term=mcp2515%E5%8E%9F%E7%90%86%E5%9B%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-113186248.pc_search_mgc_flag&spm=1018.2226.3001.4187">(86条消息) SPI协议、MCP2515裸机驱动详解—-主流SPI总线接口原理_csshuke的专栏-CSDN博客_mcp2515 spi极性</a></p>
<p>mcp2515模块资料:<a href="http://pan.baidu.com/s/1hsi3I4k">http://pan.baidu.com/s/1hsi3I4k</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用mcp2515实现的spi转can通信</p>
<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://s2.loli.net/2021/12/10/UYg8ehqIX3EOAkb.png" alt="image-20211210213025816.png"></p>
<p>需要注意的是这里的片选,也就是说可以通过片选CS信号实现一个spi转多个can通信,INT引脚用于中断缓存数据,当接收到数据时会将数据先放入缓冲区</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装cantools</span></span><br><span class="line">sudo apt install can-utils</span><br><span class="line">pip3 install cantools</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测挂载</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否进入<span class="built_in">read</span>状态</span></span><br><span class="line">sudo ip -s -d link show can0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使能树莓派SPI并加载MCP2515内核驱动</span></span><br><span class="line">dtparam=spi=on</span><br><span class="line">dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25</span><br><span class="line">dtoverlay=spi1-1cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">sudo reboot -h now</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭can0</span></span><br><span class="line">sudo ip link set can0 down</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置波特率</span></span><br><span class="line">sudo ip link set can0 type can bitrate 1000000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启can0</span></span><br><span class="line">sudo ip link set can0 up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">sudo ip -s -d link show can0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收报文</span></span><br><span class="line">candump any,0:0,#FFFFFFFF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤</span></span><br><span class="line">candump can0,620:1fffffff,255:7ff</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送报文</span></span><br><span class="line">cansend can0 123#1122334455667788</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置回环 波特率 250K ,用于测试can通路,在没有其它硬件连接测试的情况下，可以设定成回环，自发自收</span></span><br><span class="line">sudo ip link set can0 type can bitrate 500000 loopback on</span><br></pre></td></tr></table></figure>

<h1 id="C语言使用"><a href="#C语言使用" class="headerlink" title="C语言使用"></a>C语言使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> command <span class="meta-string">&quot;ip link set can0 type can bitrate 1000000&quot;</span><span class="comment">//将CAN0波特率设置为500K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up <span class="meta-string">&quot;ifconfig can0 up&quot;</span><span class="comment">//打开CAN0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> down <span class="meta-string">&quot;ifconfig can0 down&quot;</span><span class="comment">//关闭CAN0</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//关闭CAN设备，设置波特率后，重新打开CAN设备</span></span><br><span class="line">    <span class="built_in">system</span>(down);</span><br><span class="line">    <span class="built_in">system</span>(command);</span><br><span class="line">    <span class="built_in">system</span>(up);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_send</span><span class="params">(can_frame frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, nbytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span> );</span><br><span class="line">    <span class="comment">//指定 can0 设备</span></span><br><span class="line">    <span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr); </span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="comment">//将套接字与 can0 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(s, (struct sockaddr *)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">    <span class="comment">//发送 frame[0]</span></span><br><span class="line">    nbytes = <span class="built_in">write</span>(s, &amp;frame, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="keyword">if</span>(nbytes != <span class="built_in"><span class="keyword">sizeof</span></span>(frame))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Send Error frame[0]\n!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_receive</span><span class="params">(struct can_frame * r_frame,<span class="keyword">unsigned</span> <span class="keyword">int</span> filter_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, nbytes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> <span class="title">rfilter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initial fram</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span> );</span><br><span class="line">    <span class="comment">//指定 can0 设备</span></span><br><span class="line">    <span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr); </span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="comment">//将套接字与 can0 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(s, (struct sockaddr *)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">    <span class="comment">//设置过滤规则，取消当前注释为禁用过滤规则，即不接收所有报文，</span></span><br><span class="line">    <span class="comment">// 不设置此项（即如当前代码被注释）为接收所有ID的报文。</span></span><br><span class="line">    <span class="keyword">if</span> (filter_id != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rfilter.can_id   = <span class="number">0x123</span>;</span><br><span class="line">        <span class="comment">// CAN_EFF_MASK | CAN_SFF_MASK</span></span><br><span class="line">        rfilter.can_mask = CAN_SFF_MASK;</span><br><span class="line">        <span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, <span class="built_in"><span class="keyword">sizeof</span></span>(rfilter));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//接收总线上的报文保存在frame中</span></span><br><span class="line">        nbytes = <span class="built_in">read</span>(s, &amp;frame, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    &#125;</span><br><span class="line">    *r_frame = frame;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MSG_DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the nbytes:%d\n&quot;</span>, nbytes);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length:%d&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID=0x%X DLC=%d\n&quot;</span>, frame.can_id, frame.can_dlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data0=0x%02x\n&quot;</span>,frame.data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1=0x%02x\n&quot;</span>,frame.data[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2=0x%02x\n&quot;</span>,frame.data[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data3=0x%02x\n&quot;</span>,frame.data[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data4=0x%02x\n&quot;</span>,frame.data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data5=0x%02x\n&quot;</span>,frame.data[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data6=0x%02x\n&quot;</span>,frame.data[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data7=0x%02x\n&quot;</span>,frame.data[<span class="number">7</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_ctl_on</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    frame.can_id = <span class="number">0x101</span>;</span><br><span class="line">    frame.can_dlc = <span class="number">8</span>;</span><br><span class="line">    frame.data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">can_send</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_ctl_off</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    frame.can_id = <span class="number">0x101</span>;</span><br><span class="line">    frame.can_dlc = <span class="number">8</span>;</span><br><span class="line">    frame.data[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">can_send</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">can_get_vol</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> vol_vle = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    <span class="comment">// wait until can frame 100 received</span></span><br><span class="line">    <span class="built_in">can_receive</span>(&amp;frame,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;###############################\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length:%d&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID=0x%X DLC=%d\n&quot;</span>, frame.can_id, frame.can_dlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data0=0x%02x\n&quot;</span>,frame.data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1=0x%02x\n&quot;</span>,frame.data[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2=0x%02x\n&quot;</span>,frame.data[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data3=0x%02x\n&quot;</span>,frame.data[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data4=0x%02x\n&quot;</span>,frame.data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data5=0x%02x\n&quot;</span>,frame.data[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data6=0x%02x\n&quot;</span>,frame.data[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data7=0x%02x\n&quot;</span>,frame.data[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    vol_vle = (<span class="keyword">float</span>)frame.data[<span class="number">0</span>]/<span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span> vol_vle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> control_str[<span class="number">15</span>]; </span><br><span class="line">    <span class="keyword">float</span> vol_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can_control service_type\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    example: ./can_control led_off/led_on/get_vol\n&quot;</span></span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(control_str,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Argc : %d\n&quot;</span>,argc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Argv : %s\n , %s\n&quot;</span>,argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// can_init();</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;led_off&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">led_ctl_off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;led_on&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">led_ctl_on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;get_vol&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vol_val = <span class="built_in">can_get_vol</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Voltage is : %5.2f V\n&quot;</span>, vol_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Do nothing */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派入门</title>
    <url>/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="树莓派入门"><a href="#树莓派入门" class="headerlink" title="树莓派入门"></a>树莓派入门</h2><h3 id="1、树莓派安装"><a href="#1、树莓派安装" class="headerlink" title="1、树莓派安装"></a>1、树莓派安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">教程网站：https://blog.csdn.net/bhniunan/article/details/104783321</span><br><span class="line">    	https://blog.csdn.net/W17330937835/article/details/105351273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603417716780255273810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161603417716780255273810&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-105351273.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b</span><br><span class="line">		</span><br><span class="line">https://ubuntu-mate.org/</span><br><span class="line">noobs安装系统：https://blog.csdn.net/diandianxiyu_geek/article/details/78949393</span><br><span class="line"></span><br><span class="line">https://shumeipai.nxez.com/download</span><br><span class="line">https://make.quwj.com/member/2/bookmarks?category=36</span><br></pre></td></tr></table></figure>

<h3 id="2、汉化Raspbian操作系统"><a href="#2、汉化Raspbian操作系统" class="headerlink" title="2、汉化Raspbian操作系统"></a>2、汉化Raspbian操作系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/bhniunan/article/details/104842773</span><br><span class="line">中文输入法：https://blog.csdn.net/qq_33475105/article/details/113488707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161605416616780261948746%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161605416616780261948746&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-113488707.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95</span><br></pre></td></tr></table></figure>

<h3 id="3、树莓派gpio控制"><a href="#3、树莓派gpio控制" class="headerlink" title="3、树莓派gpio控制"></a>3、树莓派gpio控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wiki.jikexueyuan.com/project/raspberry-pi/gpio.html</span><br></pre></td></tr></table></figure>

<h3 id="4、树莓派命令行连接wifi"><a href="#4、树莓派命令行连接wifi" class="headerlink" title="4、树莓派命令行连接wifi"></a>4、树莓派命令行连接wifi</h3><p><a href="https://blog.csdn.net/u010875635/article/details/70170145">https://blog.csdn.net/u010875635/article/details/70170145</a></p>
<h3 id="5、树莓派用rc-local设置开机启动"><a href="#5、树莓派用rc-local设置开机启动" class="headerlink" title="5、树莓派用rc.local设置开机启动"></a>5、树莓派用rc.local设置开机启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入etc/rc.local</span><br><span class="line">编辑需要打开的设置，直接编辑命令</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装Ubuntu18_server</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_36628778/article/details/105056549?ops_request_misc=%7B%22request_id%22:%22163048418216780264057617%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163048418216780264057617&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-105056549.pc_search_insert_download&utm_term=ubuntu18.04+server+wlan0&spm=1018.2226.3001.4187">树莓派raspberry 安装ubuntu18.04 server + desktop + ros1_越来越胖了_mengleijin的博客-CSDN博客</a></p>
<p><a href="https://www.freesion.com/article/3758800537/">树莓派4b安装带桌面的ubuntu18.04 server和ROS melodic系统 - 灰信网（软件开发博客聚合） (freesion.com)</a></p>
<p><a href="https://blog.csdn.net/m0_52364631/article/details/112439570?ops_request_misc=%7B%22request_id%22:%22163867892516780261940219%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163867892516780261940219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-112439570.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu18&spm=1018.2226.3001.4187">树莓派4B安装Ubuntu18.04 + vnc远程桌面_我是大一菜鸡-CSDN博客</a></p>
<h1 id="img镜像下载"><a href="#img镜像下载" class="headerlink" title="img镜像下载"></a>img镜像下载</h1><p>pi烧录软件:<a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">https://downloads.raspberrypi.org/imager/imager_latest.exe</a></p>
<p><a href="https://www.lxx1.com/3779">树莓派操作系统镜像下载地址</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/releases/bionic/release/ubuntu-18.04.5-preinstalled-server-arm64%2Braspi4.img.xz">ubuntu18_server</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/</a></p>
<h1 id="将系统烧入SD卡"><a href="#将系统烧入SD卡" class="headerlink" title="将系统烧入SD卡"></a>将系统烧入SD卡</h1><p>使用<strong>win32diskimager</strong>或者<strong>balenaetcher</strong>烧录进去</p>
<p><img src="https://img-blog.csdnimg.cn/20210507104309422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTcwMDI1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200603191826555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDU4NDYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="启动树莓派"><a href="#启动树莓派" class="headerlink" title="启动树莓派"></a>启动树莓派</h1><p>将SD卡插入树莓派，并为树莓派连接好电源，显示器，鼠标，键盘，网线。启动树莓派，默认用户名密码都是<code>ubuntu</code>，之后需要马上修改密码，按提示操作即可。</p>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="打开-system-boot-磁盘下根目录的-network-config-文件"><a href="#打开-system-boot-磁盘下根目录的-network-config-文件" class="headerlink" title="打开 system-boot 磁盘下根目录的 network-config 文件"></a>打开 <code>system-boot</code> 磁盘下根目录的 <code>network-config</code> 文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file contains a netplan-compatible configuration <span class="built_in">which</span> cloud-init</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will apply on first-boot. Please refer to the cloud-init documentation and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the netplan reference <span class="keyword">for</span> full details:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># https://cloudinit.readthedocs.io/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://netplan.io/reference</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Some additional examples are commented out below</span></span></span><br><span class="line"></span><br><span class="line">version: 2</span><br><span class="line">ethernets:</span><br><span class="line">  eth0:</span><br><span class="line">    dhcp4: false</span><br><span class="line">    addresses: [192.168.30.110/24]</span><br><span class="line">wifis:</span><br><span class="line">  wlan0:</span><br><span class="line">    access-points:</span><br><span class="line">      HUAWEI_PTY:</span><br><span class="line">        password: pty123456787</span><br><span class="line">    dhcp4: true                         </span><br></pre></td></tr></table></figure>

<h2 id="修改在相同目录下的-user-data-文件，expire：后改成false。"><a href="#修改在相同目录下的-user-data-文件，expire：后改成false。" class="headerlink" title="修改在相同目录下的 user-data 文件，expire：后改成false。"></a>修改在相同目录下的 <code>user-data</code> 文件，<code>expire：</code>后改成<code>false</code>。</h2><p><img src="https://s2.loli.net/2021/12/06/6Jked1uLC9oYIfN.png" alt="image-20211205144213769.png"></p>
<h2 id="启动树莓派-1"><a href="#启动树莓派-1" class="headerlink" title="启动树莓派"></a>启动树莓派</h2><p>如果是刷完固件后第一次启动，因为第一次需要进行系统配置，所以第一次不会自动连接。第一次上电过两分钟后重新上电稍等片刻就会自动连接wifi了。</p>
<h1 id="连网"><a href="#连网" class="headerlink" title="连网"></a>连网</h1><p>可以参考:</p>
<p><a href="https://blog.csdn.net/zyr920425/article/details/93351457">Ubuntu Server 18.04 连接 WIFI_zyr920425的博客-CSDN博客</a></p>
<p>编辑,注意需要使用<code>Tab</code>键对齐,建议使用能看到对其线的对其工具,比如<code>sublime</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/netplan/xxxxxxx.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file is generated from information provided by the datasource.  Changes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to it will not persist across an instance reboot.  To <span class="built_in">disable</span> cloud-init<span class="string">&#x27;s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> network configuration capabilities, write a file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> network: &#123;config: disabled&#125;</span></span></span><br><span class="line">network:</span><br><span class="line">    version: 2</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: false</span><br><span class="line">            addresses: [192.168.8.110/24]</span><br><span class="line">    wifis:</span><br><span class="line">        wlan0:</span><br><span class="line">            access-points:</span><br><span class="line">                HUAWEI_PTY:</span><br><span class="line">                    password: pty123456787</span><br><span class="line">            dhcp4: true</span><br><span class="line">            optional: true</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>



<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano  /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>参考:<a href="https://blog.csdn.net/lovely_yoshino/article/details/109448556?ops_request_misc=%7B%22request_id%22:%22163867892516780261940219%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163867892516780261940219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-109448556.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu18&spm=1018.2226.3001.4187">树莓派4安装 18.04ubuntu server（2020.11.2）_lovely_yoshino的博客-CSDN博客_树莓派ubuntu18.04</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse</span><br><span class="line"> </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h1><p>网线连接好,通过<code>ip a</code>查看是否配置好,然后在物理机上尝试<code>ping</code>通后连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh.exe ubuntu@192.168.xx.xx</span><br></pre></td></tr></table></figure>

<h1 id="安装gcc与g"><a href="#安装gcc与g" class="headerlink" title="安装gcc与g++"></a>安装gcc与g++</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">(60条消息) 高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lusongno1/article/details/80558684">信赖域狗腿（dogleg）方法_LSEC小陆的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_30463341/article/details/94809554?ops_request_misc=%7B%22request_id%22:%22163611474316780357221244%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163611474316780357221244&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-94809554.pc_search_mgc_flag&utm_term=%E5%88%97%E6%96%87%E4%BC%AF%E6%A0%BC-%E9%A9%AC%E5%A4%B8%E5%B0%94%E7%89%B9%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B&spm=1018.2226.3001.4187">高斯牛顿(Gauss Newton)、列文伯格-马夸尔特(Levenberg-Marquardt)最优化算法与VSLAM_weixin_30463341的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/a6333230/article/details/83304098">LM算法——列文伯格-马夸尔特算法（最速下降法，牛顿法，高斯牛顿法）（完美解释负梯度方向）_三眼二郎-CSDN博客_lm算法</a></p>
<h1 id="从上倒下为梯度下降法的前世今生已经未来的演化："><a href="#从上倒下为梯度下降法的前世今生已经未来的演化：" class="headerlink" title="从上倒下为梯度下降法的前世今生已经未来的演化："></a>从上倒下为梯度下降法的前世今生已经未来的演化：</h1><p><strong>最速下降法（一阶梯度法）</strong><br><strong>牛顿法（二阶梯度法）</strong><br><strong>高斯牛顿法</strong><br><strong>列文伯格法</strong><br><strong>马夸尔特法</strong></p>
<p>梯度下降主要用于slam中的非线性优化,实际上就是对一个最小二乘问题的求解,这也是上述几种方法的用途.</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://img-blog.csdnimg.cn/202010261811320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM4NjYy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="最速下降-一阶梯度法"><a href="#最速下降-一阶梯度法" class="headerlink" title="最速下降(一阶梯度法)"></a>最速下降(一阶梯度法)</h1><p><strong>最速下降法</strong>（一阶梯度法）就是保留泰勒展开的一阶项用来近似非线性函数**F ( x )**，即：<br>$$<br>F(xk​+Δxk​)≈F(xk​)+J(xk​)TΔxk<br>$$</p>
<p>$$<br>Δxk​=−J(xk)<br>$$</p>
<p>**缺点:**由于仅保留一阶的雅可比矩阵,该方法过于贪心，容易走出锯齿线，反而增加迭代次数。</p>
<h1 id="牛顿法和阻尼牛顿法（二阶梯度法）"><a href="#牛顿法和阻尼牛顿法（二阶梯度法）" class="headerlink" title="牛顿法和阻尼牛顿法（二阶梯度法）"></a>牛顿法和阻尼牛顿法（二阶梯度法）</h1><p>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =−J(x<br>k<br>​<br> )<br>$$</p>
<p>**牛顿法的缺点:**海塞矩阵H计算量太大</p>
<p><strong>阻尼牛顿法</strong>(可以看成是牛顿法与最速法的结合)</p>
<p>阻尼牛顿法就是在使用牛顿法获得增量方向后，进一步对最优步长进行搜索：</p>
<h1 id="高斯牛顿法-仅用于最小二乘"><a href="#高斯牛顿法-仅用于最小二乘" class="headerlink" title="高斯牛顿法(仅用于最小二乘)"></a>高斯牛顿法(仅用于最小二乘)</h1><h3 id="原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开"><a href="#原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开" class="headerlink" title="原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)"></a>原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)</h3><p><strong>增量方程:</strong><br>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>算法流程:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.给定初始值X0</span><br><span class="line">2.对于第k次迭代,求出当前雅可比矩阵J与误差f(x)</span><br><span class="line">3.求解增量方程:H*deltaxk=g</span><br><span class="line">4.若的了他xk足够小,则停止,否则,xk+1 = xk + deltaxk</span><br></pre></td></tr></table></figure>

<p><strong>缺点:</strong></p>
<p>由于是通过雅各比矩阵做的JH(海瑟矩阵)的近似,因此会遇见奇异矩阵与病态矩阵,可能出现算法不收敛.</p>
<h1 id="L-M方法，阻尼牛顿法"><a href="#L-M方法，阻尼牛顿法" class="headerlink" title="L-M方法，阻尼牛顿法"></a>L-M方法，阻尼牛顿法</h1><p><strong>列文伯格-马夸尔特方法的思想</strong><br>针对高斯牛顿法的不足，L-M方法做了两点改进：</p>
<ul>
<li><p>在求解增量Δ xk 时，对其设置了信赖区域</p>
</li>
<li><p>在求得增量Δ xk对其近似效果进行了量化，并根据量化结果对信赖区域进行调整，</p>
<p>再从新计算增量Δ x k，直到近似效果量化结果达到阈值。</p>
</li>
</ul>
<p><strong>增量方程</strong><br>$$<br>(H+λD<br>T<br> D)Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>近似程度的量化</strong><br>$$<br>ρ=<br>(f(xk​+Δx k​)−f(x k​ ))/(J(x k​)TΔxk​)​<br>$$</p>
<ul>
<li>当ρ接近1时，近似效果好；</li>
<li>当ρ太小时，实际减小的值远小于近似函数减小的值，近似效果差，需要缩小近似范围μ</li>
<li>当ρ较大时，实际减小的值大于近似函数减小的值，近似效果差，需要增大近似范围μ </li>
</ul>
<p><strong>算法流程:</strong></p>
<p><img src="https://img-blog.csdn.net/20170712180312420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YmFvaHVhX2J1cHQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>修改和校正树莓派时间</title>
    <url>/blog/2021/12/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%A0%A1%E6%AD%A3%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/github_38111866/article/details/76057237">修改和校正树莓派时间_胡嘿嘿-CSDN博客_树莓派修改时间</a></p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改时区</span></span><br><span class="line">sudo dpkg-reconfigure tzdata</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择亚洲时区 Asia</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择上海时间 Shanghai</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否设置成功</span></span><br><span class="line">date</span><br><span class="line"><span class="meta">#</span><span class="bash"> 校正时间</span></span><br><span class="line">sudo ntpd -s -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制设置时间</span></span><br><span class="line">sudo date  --s=&quot;2017-07-25 10:43:00&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>项目模板</title>
    <url>/blog/2021/10/19/%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="天穹飞控项目"><a href="#天穹飞控项目" class="headerlink" title="天穹飞控项目"></a>天穹飞控项目</h3><p>将模块细分非常细致值得嵌入式借鉴</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRC# tree</span><br><span class="line">.</span><br><span class="line">├── CONTROL</span><br><span class="line">│   ├── flightControl.c</span><br><span class="line">│   ├── flightControl.h</span><br><span class="line">│   ├── missionControl.c</span><br><span class="line">│   ├── missionControl.h</span><br><span class="line">│   ├── motor.c</span><br><span class="line">│   ├── motor.h</span><br><span class="line">│   ├── rc.c</span><br><span class="line">│   ├── rc.h</span><br><span class="line">│   ├── safeControl.c</span><br><span class="line">│   ├── safeControl.h</span><br><span class="line">│   ├── userControl.c</span><br><span class="line">│   ├── userControl.h</span><br><span class="line">│   ├── waypointControl.c</span><br><span class="line">│   └── waypointControl.h</span><br><span class="line">├── DRIVER</span><br><span class="line">│   ├── board.c</span><br><span class="line">│   ├── board.h</span><br><span class="line">│   ├── boardConfigBlueSkyV3.h</span><br><span class="line">│   ├── drv_adc.c</span><br><span class="line">│   ├── drv_adc.h</span><br><span class="line">│   ├── drv_can.c</span><br><span class="line">│   ├── drv_can.h</span><br><span class="line">│   ├── drv_flash.c</span><br><span class="line">│   ├── drv_flash.h</span><br><span class="line">│   ├── drv_i2c_soft.c</span><br><span class="line">│   ├── drv_i2c_soft.h</span><br><span class="line">│   ├── drv_ppm.c</span><br><span class="line">│   ├── drv_ppm.h</span><br><span class="line">│   ├── drv_pwm.c</span><br><span class="line">│   ├── drv_pwm.h</span><br><span class="line">│   ├── drv_sbus.c</span><br><span class="line">│   ├── drv_sbus.h</span><br><span class="line">│   ├── drv_spi.c</span><br><span class="line">│   ├── drv_spi.h</span><br><span class="line">│   ├── drv_usart.c</span><br><span class="line">│   ├── drv_usart.h</span><br><span class="line">│   ├── drv_usb.c</span><br><span class="line">│   └── drv_usb.h</span><br><span class="line">├── LOG</span><br><span class="line">│   ├── logger.c</span><br><span class="line">│   ├── logger.h</span><br><span class="line">│   ├── ulog.c</span><br><span class="line">│   ├── ulog.h</span><br><span class="line">│   ├── ulog_data.c</span><br><span class="line">│   └── ulog_data.h</span><br><span class="line">├── MATH</span><br><span class="line">│   ├── LevenbergMarquardt.c</span><br><span class="line">│   ├── LevenbergMarquardt.h</span><br><span class="line">│   ├── declination.c</span><br><span class="line">│   ├── declination.h</span><br><span class="line">│   ├── kalman3.c</span><br><span class="line">│   ├── kalman3.h</span><br><span class="line">│   ├── kalmanVel.c</span><br><span class="line">│   ├── kalmanVel.h</span><br><span class="line">│   ├── lowPassFilter.c</span><br><span class="line">│   ├── lowPassFilter.h</span><br><span class="line">│   ├── mathTool.c</span><br><span class="line">│   ├── mathTool.h</span><br><span class="line">│   ├── matrix3.c</span><br><span class="line">│   ├── matrix3.h</span><br><span class="line">│   ├── matrix6.c</span><br><span class="line">│   ├── matrix6.h</span><br><span class="line">│   ├── pid.c</span><br><span class="line">│   ├── pid.h</span><br><span class="line">│   ├── quaternion.c</span><br><span class="line">│   ├── quaternion.h</span><br><span class="line">│   ├── rotation.c</span><br><span class="line">│   ├── rotation.h</span><br><span class="line">│   ├── vector3.c</span><br><span class="line">│   └── vector3.h</span><br><span class="line">├── MESSAGE</span><br><span class="line">│   ├── bsklink.c</span><br><span class="line">│   ├── bsklink.h</span><br><span class="line">│   ├── bsklinkDecode.c</span><br><span class="line">│   ├── bsklinkDecode.h</span><br><span class="line">│   ├── bsklinkSend.c</span><br><span class="line">│   ├── bsklinkSend.h</span><br><span class="line">│   ├── mavlinkDecode.c</span><br><span class="line">│   ├── mavlinkDecode.h</span><br><span class="line">│   ├── mavlinkNotice.c</span><br><span class="line">│   ├── mavlinkNotice.h</span><br><span class="line">│   ├── mavlinkParam.c</span><br><span class="line">│   ├── mavlinkParam.h</span><br><span class="line">│   ├── mavlinkSend.c</span><br><span class="line">│   ├── mavlinkSend.h</span><br><span class="line">│   ├── message.c</span><br><span class="line">│   └── message.h</span><br><span class="line">├── MODULE</span><br><span class="line">│   ├── 2smpb.c</span><br><span class="line">│   ├── 2smpb.h</span><br><span class="line">│   ├── battery.c</span><br><span class="line">│   ├── battery.h</span><br><span class="line">│   ├── icm20602.c</span><br><span class="line">│   ├── icm20602.h</span><br><span class="line">│   ├── icm20689.c</span><br><span class="line">│   ├── icm20689.h</span><br><span class="line">│   ├── ist8310.c</span><br><span class="line">│   ├── ist8310.h</span><br><span class="line">│   ├── mmc3630.c</span><br><span class="line">│   ├── mmc3630.h</span><br><span class="line">│   ├── module.c</span><br><span class="line">│   ├── module.h</span><br><span class="line">│   ├── mpu6000.c</span><br><span class="line">│   ├── mpu6000.h</span><br><span class="line">│   ├── mpu6500.c</span><br><span class="line">│   ├── mpu6500.h</span><br><span class="line">│   ├── ms5611.c</span><br><span class="line">│   ├── ms5611.h</span><br><span class="line">│   ├── qmc5883.c</span><br><span class="line">│   ├── qmc5883.h</span><br><span class="line">│   ├── rgb.c</span><br><span class="line">│   ├── rgb.h</span><br><span class="line">│   ├── ublox.c</span><br><span class="line">│   └── ublox.h</span><br><span class="line">├── NAVIGATION</span><br><span class="line">│   ├── ahrs.c</span><br><span class="line">│   ├── ahrs.h</span><br><span class="line">│   ├── ahrsAux.c</span><br><span class="line">│   ├── ahrsAux.h</span><br><span class="line">│   ├── navigation.c</span><br><span class="line">│   └── navigation.h</span><br><span class="line">├── SENSOR</span><br><span class="line">│   ├── accelerometer.c</span><br><span class="line">│   ├── accelerometer.h</span><br><span class="line">│   ├── barometer.c</span><br><span class="line">│   ├── barometer.h</span><br><span class="line">│   ├── gps.c</span><br><span class="line">│   ├── gps.h</span><br><span class="line">│   ├── gyroscope.c</span><br><span class="line">│   ├── gyroscope.h</span><br><span class="line">│   ├── magnetometer.c</span><br><span class="line">│   ├── magnetometer.h</span><br><span class="line">│   ├── sensor.c</span><br><span class="line">│   └── sensor.h</span><br><span class="line">├── SYSTEM</span><br><span class="line">│   ├── faultDetect.c</span><br><span class="line">│   ├── faultDetect.h</span><br><span class="line">│   ├── flightStatus.c</span><br><span class="line">│   ├── flightStatus.h</span><br><span class="line">│   ├── parameter.c</span><br><span class="line">│   └── parameter.h</span><br><span class="line">├── TASK</span><br><span class="line">│   ├── TaskConfig.h</span><br><span class="line">│   ├── control_task.c</span><br><span class="line">│   ├── control_task.h</span><br><span class="line">│   ├── log_task.c</span><br><span class="line">│   ├── log_task.h</span><br><span class="line">│   ├── messageQueue.c</span><br><span class="line">│   ├── messageQueue.h</span><br><span class="line">│   ├── message_task.c</span><br><span class="line">│   ├── message_task.h</span><br><span class="line">│   ├── module_task.c</span><br><span class="line">│   ├── module_task.h</span><br><span class="line">│   ├── navigation_task.c</span><br><span class="line">│   ├── navigation_task.h</span><br><span class="line">│   ├── sensor_task.c</span><br><span class="line">│   └── sensor_task.h</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure>

<h3 id="待添加……"><a href="#待添加……" class="headerlink" title="待添加……"></a>待添加……</h3>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo模板</title>
    <url>/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/blog/2021/11/23/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/daocaokafei/article/details/108922604?ops_request_misc=%7B%22request_id%22:%22163767858216780366532578%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767858216780366532578&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108922604.pc_search_mgc_flag&utm_term=%E7%8A%B6%E6%80%81%E6%9C%BA&spm=1018.2226.3001.4187">什么是状态机？用C语言实现进程5状态模型_一口Linux的专栏-CSDN博客</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stateMachine.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  sta_origin=<span class="number">0</span>,</span><br><span class="line">  sta_running,</span><br><span class="line">  sta_owencpu,</span><br><span class="line">  sta_sleep_int,</span><br><span class="line">  sta_sleep_unint</span><br><span class="line">&#125;State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span>  <span class="keyword">char</span> *statename[]=&#123;</span><br><span class="line">	<span class="string">&quot;origin&quot;</span>,</span><br><span class="line">	<span class="string">&quot;running&quot;</span>,</span><br><span class="line">	<span class="string">&quot;owencpu&quot;</span>,</span><br><span class="line">	<span class="string">&quot;sleep_int&quot;</span>,</span><br><span class="line">	<span class="string">&quot;sleep_unint&quot;</span>,	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">  evt_fork=<span class="number">0</span>,</span><br><span class="line">  evt_sched,</span><br><span class="line">  evt_wait,</span><br><span class="line">  evt_wait_unint,</span><br><span class="line">  evt_wake_up,</span><br><span class="line">  evt_wake, </span><br><span class="line">&#125;EventID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span> <span class="params">(*CallBack)</span><span class="params">(<span class="keyword">void</span> *)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  State curState;<span class="comment">//当前状态</span></span><br><span class="line">  EventID eventId;<span class="comment">//事件ID</span></span><br><span class="line">  State nextState;<span class="comment">//下个状态</span></span><br><span class="line">  CallBack action;<span class="comment">//回调函数</span></span><br><span class="line">&#125;StateTransform ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">State globalState = sta_origin;</span><br><span class="line"><span class="keyword">pthread_t</span> pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">action_callback</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StateTransform *statTran = (StateTransform *)arg;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(statename[statTran-&gt;curState] == statename[statTran-&gt;nextState])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid event,state not change\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;call back state from %s --&gt; %s\n&quot;</span>,</span><br><span class="line">			statename[statTran-&gt;curState],</span><br><span class="line">			statename[statTran-&gt;nextState]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*origin*/</span></span><br><span class="line">StateTransform stateTran_0[]=&#123;</span><br><span class="line">	&#123;sta_origin,evt_fork,         sta_running,action_callback&#125;,</span><br><span class="line">	&#123;sta_origin,evt_sched,      sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wait,        sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wait_unint,sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wake_up,   sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wake,        sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*running*/</span></span><br><span class="line">StateTransform stateTran_1[]=&#123;</span><br><span class="line">	&#123;sta_running,evt_fork,         sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_sched,      sta_owencpu,action_callback&#125;,</span><br><span class="line">	&#123;sta_running,evt_wait,        sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wait_unint,sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wake_up,   sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wake,        sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*owencpu*/</span></span><br><span class="line">StateTransform stateTran_2[]=&#123;</span><br><span class="line">	&#123;sta_owencpu,evt_fork,         sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_sched,      sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wait,        sta_sleep_int,action_callback&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wait_unint,sta_sleep_unint,action_callback&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wake_up,   sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wake,        sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*sleep_int*/</span></span><br><span class="line">StateTransform stateTran_3[]=&#123;</span><br><span class="line">	&#123;sta_sleep_int,evt_fork,         sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_sched,      sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wait,        sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wait_unint,sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wake_up,   sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wake,        sta_running,action_callback&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*sleep_unint*/</span></span><br><span class="line">StateTransform stateTran_4[]=&#123;</span><br><span class="line">	&#123;sta_sleep_unint,evt_fork,         sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_sched,      sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wait,        sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wait_unint,sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wake_up,   sta_running,action_callback&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wake,        sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_machine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	globalState = sta_origin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*显示当前状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">show_stat</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cur stat:%s\n&quot;</span>,statename[globalState]);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATETRANS(n)  (stateTran_##n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*change state &amp; call callback()*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_action</span><span class="params">(StateTransform *statTran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == statTran)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;statTran is NULL\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	globalState = statTran-&gt;nextState;</span><br><span class="line">	<span class="keyword">if</span>(statTran-&gt;action != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		statTran-&gt;action((<span class="keyword">void</span>*)statTran);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid event,state not change\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_happen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(globalState)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> sta_origin:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">0</span>)[event]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_running:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">1</span>)[event]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_owencpu:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">2</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_sleep_int:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">3</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_sleep_unint:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">4</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;state is invalid\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init_machine();</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;pid, <span class="literal">NULL</span>,show_stat, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_fork);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_sched);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_sched);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_wait);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_wake);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o main stateMachine.c -pthread -g</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_常见电路</title>
    <url>/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="驱动输出电路"><a href="#驱动输出电路" class="headerlink" title="驱动输出电路"></a>驱动输出电路</h1><p><img src="https://i.loli.net/2021/11/08/IcfBqFezTlgAm9b.png" alt="image-20211108152310283.png"></p>
<p>这里需要注意的是,<code>uln2803</code>是一种<code>npn</code>输出,输出低电平,因此在其输出端会有上拉电阻.在<code>uln2803</code>左侧接<code>gnd</code>右侧接<code>24v</code>.</p>
<p>这里的<code>74hct245</code>为<code>三态输出八路收发器</code>作用是增加单片机的驱动能力.</p>
<p>将同样用<code>74hct245</code>此电路改为<code>pnp</code>型输出,需要将<code>uln2803</code>换为<code>tbd62783</code>,需要注意输出端需要接<code>下拉电阻</code>.</p>
<p>**!注意:**由于改驱动芯片<code>uln2803</code>输出最大电流为<code>500ma</code>可能出现烧芯片的情况,可以加一个<code>500ma</code>熔断</p>
<h1 id="放大电路-opa2333"><a href="#放大电路-opa2333" class="headerlink" title="放大电路(opa2333)"></a>放大电路(opa2333)</h1><p><img src="https://i.loli.net/2021/11/08/cdPVFXozHa5hrxR.png" alt="image-20211108185457678.png"></p>
<p>这里通过<code>R64</code>,<code>R65</code>阻值的变化来实现放大,具体详细可参考:<a href="https://blog.csdn.net/cyousui/article/details/82936155">(61条消息) 基本运算放大器原理_小神兵之技术篇-CSDN博客_运算放大器</a></p>
<p>值得注意的是,由于是轨到轨的放大电路,输入<code>24v</code>,最大放大电压同样也可以达到<code>24v</code></p>
<h1 id="模拟量采样电路"><a href="#模拟量采样电路" class="headerlink" title="模拟量采样电路"></a>模拟量采样电路</h1><p><img src="https://i.loli.net/2021/11/08/PRZG7qv6kX3yQA9.png" alt="image-20211108191319100.png"></p>
<p>这里两个二极管用以防过压,电压大于<code>3.3v</code>小于<code>26.7v</code>时直接通过<code>+3.3v</code>,输出,而大于<code>26.7v</code>击穿二极管,直接导地.</p>
<p><img src="https://i.loli.net/2021/11/08/F1qsv4pESJwMUbN.png" alt="image-20211108191642356.png"></p>
<p>模拟量采集,还需要注意一点就是,对于电源要进行滤波处理,使电源信号更干净</p>
<h1 id="普通光耦-TLP290-4-与单向高速光耦-PC4D10"><a href="#普通光耦-TLP290-4-与单向高速光耦-PC4D10" class="headerlink" title="普通光耦(TLP290-4)与单向高速光耦(PC4D10)"></a>普通光耦(TLP290-4)与单向高速光耦(PC4D10)</h1><p><img src="https://i.loli.net/2021/11/08/Z6cxwFV4NLpevJK.png" alt="image-20211108192255515.png"></p>
<p><code>TLP290-4</code>为一种普通光耦,可以实现双向导通,这里原理图<code>左边部分有些出入</code>需要注意一下,输出为<code>npn</code>型输出,注意上拉电阻</p>
<p><img src="https://i.loli.net/2021/11/08/lESfhw24NsPrKpc.png" alt="image-20211108191804168.png"></p>
<p><code>pc4d10</code>为告诉光耦,实现的<code>npn</code>型输出,所以注意需要有上拉电阻.</p>
<h1 id="防反接电路"><a href="#防反接电路" class="headerlink" title="防反接电路"></a>防反接电路</h1><p>参考网址:<a href="https://blog.csdn.net/cgy8919/article/details/90909859?ops_request_misc=%7B%22request_id%22:%22163645288216780264054670%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163645288216780264054670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-90909859.pc_search_mgc_flag&utm_term=%E5%8D%95%E7%89%87%E6%9C%BA%E9%98%B2%E5%8F%8D%E6%8E%A5%E7%94%B5%E8%B7%AF&spm=1018.2226.3001.4187">(62条消息) 直流电源输入防反接保护电路总结_cgy8919的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_稚晖君机械臂</title>
    <url>/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E7%A8%9A%E6%99%96%E5%90%9B%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/peng-zhihui/Dummy-Robot">peng-zhihui/Dummy-Robot: 我的超迷你机械臂机器人项目。 (github.com)</a></p>
<h1 id="电源部分"><a href="#电源部分" class="headerlink" title="电源部分:"></a>电源部分:</h1><p>采用<code>TPS61040DBV</code>芯片实现的<code>5v</code>转<code>9v</code>电路,该芯片支持<code>1.8v</code>到<code>6v</code>输入,高达<code>28v</code>输出,同时还支持<code>400ma</code>的电流输出,具体可参考:</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/tps61040.pdf?ts=1636365714478">TPS6104x Low-Power DC-DC Boost Converter in SOT-23 and WSON Packages datasheet (Rev. J) (ti.com)</a></p>
<p><img src="https://i.loli.net/2021/11/08/S7a8ycYL5rbvmOe.png" alt="image-20211108201917859.png"></p>
<p><code>LP2992</code>线性稳压器,输入<code>2.2v</code>到<code>16v</code>输出<code>1.5v</code>到<code>5v</code>,指定250毫安输出电流</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/lp2992.pdf?ts=1636360611776">LP2992 Micropower 250-mA Low-Noise Ultra-Low-Dropout Regulator in SOT-23 and WSON Packages Designed for Use With Very Low-ESR Output Capacitors datasheet (Rev. J) (ti.com)</a></p>
<p><img src="https://i.loli.net/2021/11/08/Pc1Nxinl3avWTtG.png" alt="image-20211108202522586.png"></p>
<p><code>ME3116</code> 是一款内部集成了 <code>MOSFET</code> 的异步整流降压型 稳压器。它在很宽的输入电压范围内（<code>4.75V-40V</code>）能够提供 高达 <code>1A</code> 的负载能力。</p>
<p><img src="https://i.loli.net/2021/11/08/nWz2I4P8y5dTol3.png" alt="image-20211108203139049.png"></p>
<p><code>ME6206</code>:降压稳压器,高精度输出电压：<code>±2%</code>   输出电压：<code>1.5V~5.0V</code>(步长 <code>0.1V</code>)  最大工作电压：<code>6V</code> 带载能力强：当 <code>Vin=4.3V</code> 且 <code>Vout=3.3V</code> 时 <code>Iout=300mA</code>  极低的输入输出电压差： <code>0.2V</code> at <code>90mA</code> and <code>0.40V</code> at <code>200mA</code></p>
<p><img src="https://i.loli.net/2021/11/08/XljkeHb6N1pcW4y.png" alt="image-20211108204012844.png"></p>
<p>这里使用了<code>ss54</code>实现防反接,<code>sy8303</code>降压型<code>dc-dc</code>芯片</p>
<p><img src="https://i.loli.net/2021/11/11/POs7cb8Yxo3TvEU.png" alt="image-20211111191014461.png"></p>
<h1 id="自动下载电路"><a href="#自动下载电路" class="headerlink" title="自动下载电路"></a>自动下载电路</h1><p>采用<code>cp2101</code>usb转串口芯片,通过三极管,实现串口自动下载</p>
<p><img src="https://i.loli.net/2021/11/11/U3pDMn8Qt1cTLvl.png" alt="image-20211111190423177.png"></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_最小系统设计</title>
    <url>/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/little_ox/article/details/105056030">(60条消息) STM32最小系统设计_little_ox的博客-CSDN博客</a></p>
<h1 id="最小系统"><a href="#最小系统" class="headerlink" title="最小系统"></a>最小系统</h1><p>组成:<strong>主芯片</strong>,<strong>复位电路</strong>,<strong>时钟电路</strong>,<strong>电源电路</strong>,<strong>下载电路</strong></p>
<h2 id="主芯片"><a href="#主芯片" class="headerlink" title="主芯片"></a>主芯片</h2><p>根据自己需要的io数量,功能选择好主芯片</p>
<h2 id="复位电路-时钟电路-下载电路"><a href="#复位电路-时钟电路-下载电路" class="headerlink" title="复位电路,时钟电路,下载电路"></a>复位电路,时钟电路,下载电路</h2><p>由于低电平复位,因此可以通过上拉电阻实现,由于<strong>复位电路</strong>与<strong>时钟电路</strong>一般芯片都会提供参考电路或者查查资料都很容易找到,就不再赘述,<strong>下载电路</strong>的话直接<code>clk</code>,<code>dio</code>给他,通过<code>SWD</code>,或者<code>JTAG</code>下载,这里使用的时<code>SWD</code>下载</p>
<p><img src="https://i.loli.net/2021/11/06/uVUHSfX4Lt2Reiq.png" alt="image-20211106195658724.png"></p>
<p>**!注意:**一般芯片都会有电源滤波,因此在布线的过程中注意将电容尽量放的里芯片近些.</p>
<h2 id="晶振的选择"><a href="#晶振的选择" class="headerlink" title="晶振的选择"></a>晶振的选择</h2><p>有源晶振:自供电,有内部电路,精度会高些,当然价格也贵些</p>
<p>无源晶振:内部不供电,与芯片直接相连,精度差些,在对时钟要求没那么高的情况下一般够用</p>
<h2 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h2><p>比较麻烦的是电源电路,或者降压,或者稳压,根据需要实现.</p>
<p>这里提供一种从24v转3.3v的思路电源思路.这里使用<code>TPS5430</code>芯片实现的一种电源降压的方式,这里<code>D2</code>指的是<code>瞬态抑制</code>起到当电压超过24v(比如打火花)进来时,<code>D2</code>导通,24v直接接地,同事使用了F1保险丝做保护        </p>
<p><img src="https://i.loli.net/2021/11/06/OokdWnJcprP4uZV.png" alt="image-20211106200343212.png"></p>
<p><img src="https://i.loli.net/2021/11/06/SXDMrFs3iagZGBq.png" alt="image-20211106200412912.png"></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>注释软件</title>
    <url>/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/F2wN5Bbqqv_3R1gAlA19Pw">几款注释软件推荐</a></p>
<h1 id="javE"><a href="#javE" class="headerlink" title="javE"></a>javE</h1><p><strong><a href="http://www.jave.de/">http://www.jave.de/</a></strong></p>
<p>里边的字体,图片生成挺有意思,不过需要装java</p>
<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><strong><a href="https://josoansi.de/download.php">https://josoansi.de/download.php</a></strong></p>
<p><img src="https://josoansi.de/images/screenshot128.jpg" alt="Screenshot AACircuit 1.28"></p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><a href="http://www.ascii-art.de/">ascii-art</a></p>
<p>有很多有意思的注释,可知看一下直接复制粘贴,很舒爽</p>
<p><a href="https://www.codeproject.com/Articles/4514/CodePlotter-1-6-Add-and-edit-diagrams-in-your-code">CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject</a></p>
<p>类似于”Visio”的一款工具</p>
<p><img src="https://www.codeproject.com/KB/macros/codeplotter/CodePlotter.jpg" alt="Sample Image - CodePlotter.jpg"></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>概率机器人</title>
    <url>/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://gaoyichao.com/Xiaotu/?book=probabilistic_robotics&title=index">概率机器人</a></p>
<h1 id="5-机器人运动模型"><a href="#5-机器人运动模型" class="headerlink" title="5.机器人运动模型"></a>5.机器人运动模型</h1><h2 id="速度模型-概率运动规划"><a href="#速度模型-概率运动规划" class="headerlink" title="速度模型(概率运动规划)"></a>速度模型(概率运动规划)</h2><h3 id="闭式算法"><a href="#闭式算法" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p>
<h3 id="采样算法"><a href="#采样算法" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p>
<h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><h4 id="精确运动"><a href="#精确运动" class="headerlink" title="精确运动"></a>精确运动</h4><p><img src="https://i.loli.net/2021/10/28/q6Bp1FfriNSYJOm.png" alt="image-20211028195757782.png"></p>
<h4 id="真实运动"><a href="#真实运动" class="headerlink" title="真实运动"></a>真实运动</h4><p>加入扰动,模型表达为</p>
<p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p>
<p>加入噪声,求得概率公式为:</p>
<p><img src="https://i.loli.net/2021/10/28/dSyQKWDwZokC31L.png" alt="image-20211028200012951.png"></p>
<h2 id="里程计模型-估计"><a href="#里程计模型-估计" class="headerlink" title="里程计模型(估计)"></a>里程计模型(估计)</h2><p>模型为:</p>
<p><img src="https://i.loli.net/2021/10/28/SlTo9XeFOgYc5mV.png" alt="image-20211028200122122.png"></p>
<h3 id="闭式算法-1"><a href="#闭式算法-1" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/NIADHiMonhT1Kme.png" alt="image-20211028200230307.png"></p>
<h3 id="采样算法-1"><a href="#采样算法-1" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/c48vqLlKwirNEuF.png" alt="image-20211028200258350.png"></p>
<h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导"></a>数学推导</h3><p>三次转换:</p>
<p><img src="https://i.loli.net/2021/10/28/mpeJFAc3E2dYTUB.png" alt="image-20211028200511164.png"></p>
<p>加入噪声:</p>
<p><img src="https://i.loli.net/2021/10/28/zWb12u97LjVsfEt.png" alt="image-20211028200548403.png"></p>
<p>求出坐标:</p>
<p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p>
<p>求得最终概率:</p>
<p><img src="https://i.loli.net/2021/10/28/JMKtbz5W2ErdQCO.png" alt="image-20211028200832805.png"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_通讯设计</title>
    <url>/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="CAN"><a href="#CAN" class="headerlink" title="CAN:"></a>CAN:</h1><p><img src="https://i.loli.net/2021/11/06/Cs8JxWr3kPG7efT.png" alt="image-20211106130338091-16361750226251.png"></p>
<p><img src="https://i.loli.net/2021/11/06/6BkYVPWyMIU5g1Z.png" alt="image-20211106133256690.png"></p>
<p>两张图用的都是<code>TJA1050</code>,速度<code>1Mbps</code>,不过后期的处理略有些不同,上图can信号分两路输出,而下图,为保护电路,加入了<code>fuse</code>(熔断器),<code>SMAJ30CA</code>(瞬态抑制二极管)</p>
<p><img src="https://i.loli.net/2021/11/06/tcjs9VvHAG8ENQX.png" alt="image-20211106140618661.png"></p>
<p>这张图用的是<code>max3051</code>3.3v供电,高速运行<code>1Mbps</code>,这里使用了<code>ACT45B</code>共模电感起<code>EMI</code>滤波的作用，用于抑制高速信号线产生的电磁波向外辐射发射.</p>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><p><img src="https://i.loli.net/2021/11/06/NuSOBZ4Yldot6wp.png" alt="image-20211106141453916.png"></p>
<p><img src="https://i.loli.net/2021/11/06/T8zrX3fUBA4Slc2.png" alt="image-20211106141550298.png"></p>
<p>由于采用<code>3.3v</code>供电,使用芯片为<code>sp3485</code>,参考图二,<code>5v</code>供电可更换为<code>max485</code>,电路设计上也还是同样,图一,采用<code>熔断器</code>与<code>瞬态一直二极管</code>保护电路</p>
<p><img src="https://i.loli.net/2021/11/06/QHouRcwMjXm7fFh.png" alt="image-20211106142404847"></p>
<p>这张图就是<code>max485</code>实现的<code>RS485</code>电路,同样对于电路保护也采用熔断器与瞬态一直二极管,同时采用电容进行进一步滤波.这里发送接收通过<code>EN</code>控制,三极管做开关功能,<code>EN</code>为0时接收,为1时发送.</p>
<h1 id="232"><a href="#232" class="headerlink" title="232"></a>232</h1><p><img src="https://i.loli.net/2021/11/06/J8CwfLA7H1uErT4.png" alt="image-20211106143625304"></p>
<p>数据手册:</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/max3232.pdf?ts=1636166679814">具有 ±15kV ESD 保护功能的 MAX3232 3V 至 5.5V 多通道 RS-232 线路驱动器和接收器 datasheet </a></p>
<p>布板参考:</p>
<p><img src="https://i.loli.net/2021/11/06/wghYLF1WtiadvNS.png" alt="image-20211106143955599.png"></p>
<h1 id="USB转串口"><a href="#USB转串口" class="headerlink" title="USB转串口"></a>USB转串口</h1><p><img src="https://i.loli.net/2021/11/06/oKLkuhrp9EUb43w.png" alt="image-20211106145617779.png"></p>
<p>这张图是type_c转串口的图,图中使用<code>CH340N</code>实现板子最小化,非常<strong>nice</strong></p>
<p>下面是他的开源链接:<a href="https://oshwhub.com/vcijj/TYPE-C-usbzhuai-chuan-kou">TYPE C usb转串口 - 立创EDA开源硬件平台 (oshwhub.com)</a></p>
<p>当然为了保护电路,我们也可以在上边加上<code>熔断</code>与<code>瞬时抑制二极管</code></p>
<h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p><strong>参考渡鸦卡发版设计</strong></p>
<p><img src="https://i.loli.net/2021/11/06/u3pGfIP86yELD4F.png" alt="image-20211106150109596.png"></p>
<p><strong>大佬的串口转以太网设计:</strong></p>
<p><a href="https://oshwhub.com/jixin/CH9121-4c2c4f99e2494eee8421dd23768820a1">串口转以太网模块-CH9121 - 立创EDA开源硬件平台 (oshwhub.com)</a></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>编程规范</title>
    <url>/blog/2021/10/19/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><h4 id="1-原则"><a href="#1-原则" class="headerlink" title="1. 原则"></a>1. 原则</h4><ol>
<li>简洁明了，提高代码可读性，读的是代码而不是注释，注释永远都是辅助的。</li>
<li>零告警，严谨的语法才能保障代码表达和编译器理解的是一至的。</li>
</ol>
<h4 id="2-排版"><a href="#2-排版" class="headerlink" title="2. 排版"></a>2. 排版</h4><ol>
<li>程序块之间、变量声明之间，用空行分隔</li>
<li>突出语法关键字</li>
<li>一行不要太长，换行增加可读性</li>
<li>Tab键排版</li>
</ol>
<h4 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h4><ol>
<li><p>注释的目的是阐明意图目的，而不是翻译某行代码的动作</p>
</li>
<li><p>注释的原则是尽量代码自注释，代码越清晰，可读性越高</p>
</li>
<li><p>统一格式 **/* 注释内容 */**， *号与注释内容之间有一个空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*************************************************</span><br><span class="line">Copyright 	 //版权</span><br><span class="line">File name:	 // 文件名</span><br><span class="line">Author： 	//作者</span><br><span class="line">Version: 	 //版本号</span><br><span class="line">Description: // 用于详细说明此程序文件完成的主要功能，与其他模块</span><br><span class="line">			// 或函数的接口，输出值、取值范围、含义及参数间的控</span><br><span class="line">			// 制、顺序、独立或依赖等关系</span><br><span class="line">Others: 	// 其它内容的说明</span><br><span class="line">Log: 		// 修改日志，包括修改内容，日期，修改人等</span><br><span class="line">*************************************************/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*@ Description: 函数描述，描述本函数的基本功能</span><br><span class="line">* @param 1 – 参数 1.</span><br><span class="line">* @param 2 – 参数 2</span><br><span class="line">* @return – 返回值</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-定义"><a href="#4-定义" class="headerlink" title="4. 定义"></a>4. 定义</h4><ol>
<li><p>命名风格</p>
<ol>
<li>模块名+文件名+功能描述，之间采用短下划线分隔</li>
<li>功能描述部分，采用驼峰风格</li>
</ol>
<p>例如，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SAFE_LASER_setLaserShield</span><span class="params">(<span class="keyword">uint8_t</span> _EN)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>宏定义</p>
<ol>
<li>define 必须大写</li>
<li>typedef 可以小写</li>
</ol>
<p>例如，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASK_R200RXID1 		0x198 	<span class="comment">/* HEX格式 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> StackSize_t；   		<span class="comment">/* 仅用于堆栈 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型定义</p>
<p>使用linux自带类型定义规则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint8_t  	unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int8_t   	char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint16_t 	unsigned short</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int16_t  	short</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint32_t 	unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int32_t  	int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint64_t 	unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int64_t  	long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL  		0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h4><ol>
<li>变量通用规则<ol>
<li>采用驼峰风格,首字母大写</li>
<li>在函数开始是全部定义，不允许在函数中间定义</li>
<li>变量命名必须可以表示其含义</li>
<li>必须初始化</li>
</ol>
</li>
<li>局部变量<ol>
<li>本地局部变量必须用static关键字修饰</li>
</ol>
</li>
<li>全局变量<ol>
<li>全局变量必须以g开头</li>
</ol>
</li>
<li>函数变量<ol>
<li>变量必须以_开头</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static uint8_t SafeLaserSet = 0;</span><br><span class="line">uint8_t gSafeLaserSet = 0;</span><br><span class="line">static uint8_t _SafeLaserSet = 0;</span><br></pre></td></tr></table></figure>

<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h4><ol>
<li>函数名必须能够自注释，必要是需要增加注释写明意图</li>
<li>内部函数必须使用static定义，命名可以不加模块名</li>
<li>外部函数<ol>
<li>必须在头文件中声明，</li>
<li>命名时必须带模块名，</li>
<li>必须给出带注释，并写明函数意图，参数说明，返回值</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static uint_t SAFE_LASER_setLaseShield(uint8_t _EN);</span><br><span class="line">void SAFE_LASER_setLaseShield(uint8_t _EN);</span><br></pre></td></tr></table></figure>

<h4 id="7-文件"><a href="#7-文件" class="headerlink" title="7. 文件"></a>7. 文件</h4><ol>
<li><p>头文件</p>
<ol>
<li><p>命名规则模块名+功能，小写，例如os_task.h</p>
</li>
<li><p>格式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OS_TASK_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __OS_TASK_H__</span></span><br><span class="line"></span><br><span class="line">....<span class="comment">/* 开放的宏定义 */</span></span><br><span class="line">....<span class="comment">/* 开放的全局变量声明 */</span></span><br><span class="line">....<span class="comment">/* 开放的函数声明 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>源文件</p>
<ol>
<li><p>命名规则模块名+功能，小写，例如os_task.c</p>
</li>
<li><p>格式如下，举例只为说明源文件中，各元素的顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;- <span class="number">1</span> - 引用头文件 -&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;os_task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">2</span> - 定义本文件用到的宏 -&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASK_SWITCH_INTERVAL 10 	<span class="comment">/* 单位ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> StackSize_t ； 	 	<span class="comment">/* 仅用于堆栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">3</span> - 本地变量 -&gt;</span><br><span class="line"><span class="keyword">static</span> StackSize_t *TopStack = <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">4</span> - 开放的全局变量 -&gt;</span><br><span class="line"><span class="keyword">uint32_t</span> gOsTaskEventBitMap = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">5</span> - 本地函数，仅在本文件使用 -&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TASK_TaskSwitch</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">6</span> - 开放的函数 -&gt;</span><br><span class="line"><span class="keyword">void</span> OS_TASK_TaskDelay(<span class="keyword">uint16_t</span> _ms)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">return</span>；   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="8-约定俗成简写"><a href="#8-约定俗成简写" class="headerlink" title="8.约定俗成简写"></a>8.约定俗成简写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addition           	add           		加</span><br><span class="line">subtraction 		sub              	减</span><br><span class="line">multiplication 		mul           		乘法</span><br><span class="line">division          	div             	除法</span><br><span class="line">answer            	ans           		响应、回答</span><br><span class="line">array               arr             	数组、集合</span><br><span class="line">average          	avg            		平均</span><br><span class="line">buffer              buf或buff   			缓冲区</span><br><span class="line">capture           	cap或capt  			捕获</span><br><span class="line">check              	chk            		检查</span><br><span class="line">count              	cnt            		计数器</span><br><span class="line">column            	col            		列</span><br><span class="line">control            	ctrl            	控制</span><br><span class="line">decode           	dec           		解码、译码</span><br><span class="line">define             	def           		定义</span><br><span class="line">delete             	del           		删除</span><br><span class="line">destination     	dst或dest 			目的</span><br><span class="line">display           	disp          		显示</span><br><span class="line">encode          	enc            		编码</span><br><span class="line">environment  		env           		环境</span><br><span class="line">error              	err             	错误</span><br><span class="line">float               flt              	浮动、浮点</span><br><span class="line">frequency      		freq           		频率</span><br><span class="line">header          	hdr            		开始、开头</span><br><span class="line">index             	idx            		索引、指示、</span><br><span class="line">image            	img           		影像、镜像</span><br><span class="line">increment      		inc            		增加、增量</span><br><span class="line">initalize         	init            	初始化</span><br><span class="line">iteration        	itr             	循环、迭代</span><br><span class="line">length           	len            		长度</span><br><span class="line">memory        		mem          		内存</span><br><span class="line">middle           	mid           		中值</span><br><span class="line">make             	mk            		制造、形成</span><br><span class="line">message       		msg          		消息</span><br><span class="line">number         		num         	 	数量、编号</span><br><span class="line">operand        		opnd        		操作数</span><br><span class="line">optimization  		opt           		最优</span><br><span class="line">operator       		optr          		操作</span><br><span class="line">packet          	pkt            		消息包</span><br><span class="line">positon         	pos           		位置</span><br><span class="line">previous       		pre或prev  			以前的</span><br><span class="line">pointer         	ptr             	指针</span><br><span class="line">record          	rcd             	记录</span><br><span class="line">receive         	recv           		收到、接收</span><br><span class="line">result           	res             	结果</span><br><span class="line">return          	ret              	返回</span><br><span class="line">source         		src              	源头</span><br><span class="line">stack           	stk              	栈</span><br><span class="line">string          	str               	字符串</span><br><span class="line">table           	tab              	表</span><br><span class="line">temporary   		tmp或temp  			临时</span><br><span class="line">total            	tot               	全部的</span><br><span class="line">time stamp  		ts                	时间戳</span><br><span class="line">value           	val              	值</span><br></pre></td></tr></table></figure>

<p>有互斥意义的变量或者动作相反的函数应该是用互斥词组命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add/remove  	begin/end 		create/destroy 		insert/delete </span><br><span class="line">first/last 		get/release 	increment/decrement put/get 		add/delete</span><br><span class="line">lock/unlock 	open/close 		min/max 			old/new </span><br><span class="line">start/stop 		next/previous 	source/target 		show/hide </span><br><span class="line">send/receive 	source/destination 					copy/paste 		up/down</span><br></pre></td></tr></table></figure>

<h4 id="9-模块"><a href="#9-模块" class="headerlink" title="9. 模块"></a>9. 模块</h4><ol>
<li><p>模块必须具有封装性，且对外提供尽量少的必要接口，接口必须提供详细的注释描述</p>
</li>
<li><p>模块的组织形式可以是文件夹形式，也可以是文件形式</p>
</li>
<li><p>文件都以小写命名</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">    ├── src <span class="comment">/* 应用层代码 */</span></span><br><span class="line">    │   ├── main.c <span class="comment">/* 应用入口 */</span></span><br><span class="line">    │   ├── test.c</span><br><span class="line">    │   ├── test1.c  </span><br><span class="line">    ├── include <span class="comment">/* 设备驱动代码 */</span></span><br><span class="line">    │   ├── test.h</span><br><span class="line">    │   ├── test1.h </span><br><span class="line">    ├── debug <span class="comment">/* 芯片厂家提供的库代码 */</span></span><br><span class="line">    │   ├── MakeFile</span><br><span class="line">    │   ├── CMake</span><br><span class="line">    │   └── main</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux程序开机启动与后台启动</title>
    <url>/blog/2021/12/27/%E8%87%AA%E5%90%AF%E5%8A%A8_%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_36328643/article/details/89359724?ops_request_misc=%7B%22request_id%22:%22164058731416780265430164%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164058731416780265430164&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-89359724.pc_search_insert_es_download&utm_term=ubuntu18%E8%87%AA%E5%90%AF%E5%8A%A8&spm=1018.2226.3001.4187">(91条消息) Ubuntu18.04 开机自启动脚本_cxh的博客-CSDN博客_ubuntu18.04开机自启动脚本</a> </p>
<p> <a href="https://blog.csdn.net/qq_42353939/article/details/89242941?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.nonecase">(91条消息) linux如何后台运行服务_六指黑侠i的博客-CSDN博客_linux 后台运行</a> </p>
<h1 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rc-local.service生成</span></span><br><span class="line">sudo nano /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionPathExists=/etc/rc.local  #脚本文件位置</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start  #配置的脚本文件rc.local为start</span><br><span class="line">TimeoutSec=0    </span><br><span class="line">StandardOutput=tty  #标准输出</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99  #优先级，当有多个开机启动文件时可以设置不同的值</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成rc.local</span></span><br><span class="line">sudo nano /etc/rc.local</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh -e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># rc.local</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Make sure that the script will <span class="string">&quot;exit 0&quot;</span> on success or any other</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> value on error.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># In order to enable or disable this script just change the execution</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># By default this script does nothing.</span></span></span><br><span class="line">echo &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.log</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给rc.local加上权限，启用服务，启动服务并检查状态</span></span><br><span class="line">sudo chmod +x /etc/rc.local</span><br><span class="line">sudo systemctl enable rc-local</span><br><span class="line">sudo systemctl start rc-local.service</span><br><span class="line">sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure>

<h1 id="不挂断后台启动"><a href="#不挂断后台启动" class="headerlink" title="不挂断后台启动"></a>不挂断后台启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>

<h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></span><br><span class="line">jobs -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死进程</span></span><br><span class="line">sudo kill 7889</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符标签操作</title>
    <url>/blog/2022/01/03/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A0%87%E7%AD%BE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_38721302/article/details/82699934?ops_request_misc=%7B%22request_id%22:%22164121291816780261944453%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164121291816780261944453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-82699934.pc_search_insert_es_download&utm_term=c%E8%AF%AD%E8%A8%80%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">(94条消息) 嵌入式学习之C语言运算符标签操作_foolish的博客-CSDN博客</a> </p>
<h1 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=xxx； [<span class="number">0x12</span>] <span class="comment">//有一个int类型的指针，它的指针变量存储的地址为0x12。</span></span><br><span class="line">p=p+<span class="number">1</span>；<span class="comment">//指针加法,指向[0x13]</span></span><br></pre></td></tr></table></figure>

<h1 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符[]"></a>下标运算符[]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(p+n)=p[n]; <span class="comment">//n为下标,相当于,数组下标</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>常用好用的论文网站</title>
    <url>/blog/2022/01/15/%E8%AE%BA%E6%96%87%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://scholar.google.com/scholar?hl=zh-CN&as_sdt=0,5&q=Pure+pursuit+optimization+algorithm&oq=">Google 学术搜索</a> </p>
<p> <a href="https://sci-hub.mksa.top/">Sci-Hub (mksa.top)</a> </p>
<p> <a href="https://site.sciping.com/">科塔学术导航 - 最专业、准确、及时和全面的科研与学术资源导航平台 (sciping.com)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这里的几个网站中科塔网很全面,可以配合sci_hub使用,极易食用.</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像源</title>
    <url>/blog/2021/12/12/%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>华为镜像源: <a href="https://mirrors.huaweicloud.com/home">https://mirrors.huaweicloud.com/home</a></p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
