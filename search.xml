<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++时间操作</title>
    <url>/blog/2022/05/05/C++11%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u012010054/article/details/81259135?ops_request_misc=%7B%22request_id%22:%22165173467916781683972413%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165173467916781683972413&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81259135.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=clock_gettime&spm=1018.2226.3001.4187">(131条消息) clock_gettime 函数笔记_神秘的羔羊的博客-CSDN博客_clock_gettime</a></p>
<h1 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime"></a>clock_gettime</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clk_id,struct timespec *tp)</span></span>;</span><br><span class="line"><span class="comment">//clk_id : 检索和设置的clk_id指定的时钟时间。</span></span><br><span class="line"><span class="comment">//CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户改成其他,则对应的时间相应改变。</span></span><br><span class="line"><span class="comment">//CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响。</span></span><br><span class="line"><span class="comment">//CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间。</span></span><br><span class="line"><span class="comment">//CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec; <span class="comment">/* 秒*/</span></span><br><span class="line">    <span class="keyword">long</span> tv_nsec; <span class="comment">/* 纳秒*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">time1</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">time2</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">float</span> temp;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;time1);      </span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;time2);   </span><br><span class="line">    temp = (time2.tv_nsec - time1.tv_nsec) / <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %f ms\n&quot;</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++智能指针</title>
    <url>/blog/2022/05/05/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://wentian.blog.csdn.net/article/details/109566645?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&utm_relevant_index=2"> C++自学24:唯一智能指针</a></p>
<p><a href="https://blog.csdn.net/qfturauyls/article/details/106772813?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3">尽量使用std::make_unique和std::make_shared而不直接使用new（总结)</a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; a = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">666</span>); <span class="comment">// 智能指针具有唯一性</span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; b = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="comment">// create std::initializer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// create std::vector using std::initializer_list ctor</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>

<h1 id="make-queue"><a href="#make-queue" class="headerlink" title="make_queue"></a>make_queue</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// following constructor is no longer needed since C++20</span></span><br><span class="line">    <span class="built_in">Vec3</span>(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>) <span class="keyword">noexcept</span> : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Vec3&amp; v) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;&#123; x=&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;, z=&quot;</span> &lt;&lt; v.z &lt;&lt; <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Use the default constructor.</span></span><br><span class="line">    std::unique_ptr&lt;Vec3&gt; v1 = std::make_unique&lt;Vec3&gt;();</span><br><span class="line">    <span class="comment">// Use the constructor that matches these arguments</span></span><br><span class="line">    std::unique_ptr&lt;Vec3&gt; v2 = std::make_unique&lt;Vec3&gt;(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Create a unique_ptr to an array of 5 elements</span></span><br><span class="line">    std::unique_ptr&lt;Vec3[]&gt; v3 = std::make_unique&lt;Vec3[]&gt;(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;make_unique&lt;Vec3&gt;():      &quot;</span> &lt;&lt; *v1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;make_unique&lt;Vec3&gt;(0,1,2): &quot;</span> &lt;&lt; *v2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;make_unique&lt;Vec3[]&gt;(5):   &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">setw</span>(i ? <span class="number">30</span> : <span class="number">0</span>) &lt;&lt; v3[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++查看内存使用</title>
    <url>/blog/2022/05/09/C++%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/zjl_1026_2001/article/details/2294072?ops_request_misc=%7B%22request_id%22:%22165208801016781667894376%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165208801016781667894376&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-2294072-null-null.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=/proc/self/statm&spm=1018.2226.3001.4187">(131条消息) PROC系列之—/proc/pid/statm_沙漠里的海豚的博客-CSDN博客_proc statm</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat  /proc/self/statm</span><br><span class="line">654 57 44 0 0 334 0</span><br></pre></td></tr></table></figure>

<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU 以及CPU0。。。的每行的每个参数意思（以第一行为例）为：</span><br><span class="line">参数 解释 /proc/ /status</span><br><span class="line">Size (pages) 任务虚拟地址空间的大小 VmSize/4</span><br><span class="line">Resident(pages) 应用程序正在使用的物理内存的大小 VmRSS/4</span><br><span class="line">Shared(pages) 共享页数 0</span><br><span class="line">Trs(pages) 程序所拥有的可执行虚拟内存的大小 VmExe/4</span><br><span class="line">Lrs(pages) 被映像到任务的虚拟内存空间的库的大小 VmLib/4</span><br><span class="line">Drs(pages) 程序数据段和用户态的栈的大小 （VmData+ VmStk ）4</span><br><span class="line">dt(pages) 0 </span><br></pre></td></tr></table></figure>

<h1 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_mem_usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/statm&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>   str[<span class="number">300</span>];</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="built_in">fread</span>(str, <span class="number">1</span>, <span class="number">200</span>, f);</span><br><span class="line">    str[n]   = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MEM: %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">fclose</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>DWA</title>
    <url>/blog/2022/03/08/DWA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/gophae/article/details/105299926?ops_request_misc=%7B%22request_id%22:%22164691297316780271566311%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164691297316780271566311&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105299926.article_score_rank&utm_term=dwa&spm=1018.2226.3001.4187">(114条消息) DWA动态窗口法的原理及应用_gophae的博客-CSDN博客_动态窗口法</a> </p>
<p> <a href="https://www.bilibili.com/video/BV19b4y1d7Hz?p=4">ROS 2D导航原理系列教程合集（WHEELTEC）_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/ShisatoYano/dynamic_window_approach">ShisatoYano/dynamic_window_approach (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/qq_43711697/article/details/106880637?ops_request_misc=%7B%22request_id%22:%22164698653816780265453796%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164698653816780265453796&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106880637.article_score_rank&utm_term=dwa%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(114条消息) SLAM学习：DWA算法原理和Python编程实现_YuriFan的博客-CSDN博客_dwa算法实现</a> </p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://s2.loli.net/2022/03/11/YCO1pAGnsjdcoEy.png" alt="20200621101602368.png"></p>
<h1 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 1:1000 % 迭代1000次</span><br><span class="line">	dwa_control();</span><br><span class="line">	motion();</span><br><span class="line">	if 接近目标点:</span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line">dwa_control():</span><br><span class="line">	calc_dynamic_window(); -&gt; calc_final_input();</span><br><span class="line"></span><br><span class="line">calc_final_input():</span><br><span class="line">	calc_trajectory()-&gt;to_goal_cost-&gt;speed_cost-&gt;obst_cost-&gt;u_traj(v,w)</span><br></pre></td></tr></table></figure>

<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a><a href="https://github.com/ShisatoYano/dynamic_window_approach">参考代码</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化状态信息</span></span><br><span class="line"><span class="function">DynamicWindow <span class="title">calc_dynamic_window</span><span class="params">(State *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DynamicWindow dw = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from robot specification</span></span><br><span class="line">    <span class="keyword">float</span> vs[<span class="number">4</span>] = &#123;MIN_SPD_MS, MAX_SPD_MS, -MAX_YAWRATE_RS, MAX_YAWRATE_RS&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from motion model</span></span><br><span class="line">    <span class="keyword">float</span> vd[<span class="number">4</span>] = &#123;st-&gt;v_ms - MAX_ACCEL_MS2 * DT_S,</span><br><span class="line">                   st-&gt;v_ms + MAX_ACCEL_MS2 * DT_S,</span><br><span class="line">                   st-&gt;omega_rads - MAX_DYAWRATE_RS2 * DT_S,</span><br><span class="line">                   st-&gt;omega_rads + MAX_DYAWRATE_RS2 * DT_S&#125;;</span><br><span class="line"></span><br><span class="line">    dw.min_v = max(vs[<span class="number">0</span>], vd[<span class="number">0</span>]);</span><br><span class="line">    dw.max_v = min(vs[<span class="number">1</span>], vd[<span class="number">1</span>]);</span><br><span class="line">    dw.min_yr = max(vs[<span class="number">2</span>], vd[<span class="number">2</span>]);</span><br><span class="line">    dw.max_yr = min(vs[<span class="number">3</span>], vs[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一系列轨迹</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">float</span> v = dw-&gt;min_v; v &lt; dw-&gt;max_v; v+=V_RESO) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">float</span> y = dw-&gt;min_yr; y &lt; dw-&gt;max_yr; y+=YAWRATE_RESO) &#123;</span><br><span class="line">        traj = calc_trajectory(&amp;st_init, v, y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate cost</span></span><br><span class="line">        to_goal_cost = GOAL_COST_GAIN * calc_to_goal_cost(&amp;traj, goal);</span><br><span class="line">        speed_cost = SPD_COST_GAIN * (MAX_SPD_MS - traj.back().v_ms);</span><br><span class="line">        obst_cost = OBST_COST_GAIN*calc_obstacle_cost(&amp;traj, obst, obst_num);</span><br><span class="line">        final_cost = to_goal_cost + speed_cost + obst_cost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search minimum trajectory</span></span><br><span class="line">        <span class="keyword">if</span> (min_cost &gt;= final_cost)</span><br><span class="line">        &#123;</span><br><span class="line">            min_cost = final_cost;</span><br><span class="line">            min_u.v_ms = v;</span><br><span class="line">            min_u.omega_rads = y;</span><br><span class="line">            best_traj = traj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后输出</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_plan</category>
      </categories>
      <tags>
        <tag>path_plan</tag>
      </tags>
  </entry>
  <entry>
    <title>c++风格</title>
    <url>/blog/2022/05/03/C++%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南 - 内容目录 — Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 文件:</span><br><span class="line">a_b_c.cc</span><br><span class="line">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span><br><span class="line"></span><br><span class="line">#ifndef FOO_BAR_BAZ_H_</span><br><span class="line">#define FOO_BAR_BAZ_H_</span><br><span class="line">...</span><br><span class="line">#endif // FOO_BAR_BAZ_H_</span><br><span class="line">// 类型:</span><br><span class="line">struct Abc&#123;&#125;;</span><br><span class="line">class Abc&#123;&#125;;</span><br><span class="line">enum Abc&#123;&#125;;</span><br><span class="line">namespace abc&#123;&#125;</span><br><span class="line">// 变量:</span><br><span class="line">string table_name;  // 好 - 用下划线.</span><br><span class="line"></span><br><span class="line">// 类数据成员</span><br><span class="line">class TableInfo &#123;</span><br><span class="line">  ...</span><br><span class="line"> private:</span><br><span class="line">  string table_name_;  // 好 - 后加下划线.</span><br><span class="line">  string tablename_;   // 好.</span><br><span class="line">  static Pool&lt;TableInfo&gt;* pool_;  // 好.</span><br><span class="line">  static Pool&lt;TableInfo&gt;* m_pool;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 结构体变量</span><br><span class="line">struct UrlTableProperties &#123;</span><br><span class="line">  string name;</span><br><span class="line">  int num_entries;</span><br><span class="line">  static Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 常量命名,声明为 constexpr 或 const 的变量</span><br><span class="line">const int kDaysInAWeek = 7;</span><br><span class="line">constexpr int kDaysWeek = 7;</span><br><span class="line"></span><br><span class="line">// 枚举</span><br><span class="line">ENUM_NAME</span><br><span class="line"></span><br><span class="line">// 宏命名</span><br><span class="line">#define ROUND(x) ...</span><br><span class="line">#define PI_ROUNDED 3.0</span><br></pre></td></tr></table></figure>



<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.cc文件主要用于linux</span><br><span class="line">.hpp <span class="keyword">template</span></span><br></pre></td></tr></table></figure>

<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只有当函数只有 10 行甚至更少时才将其定义为内联函数.(小且频繁)</span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  一般用于func内,不做全局static</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static class Create();</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">create</span><span class="params">()</span></span>; <span class="comment">// 主要用于创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo/public/fooserver.h&quot;</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/commandlineflags.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo/public/bar.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure>

<h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">尽量多的使用<span class="keyword">const</span>与<span class="keyword">constexpr</span>保证安全需要</span><br></pre></td></tr></table></figure>

<h2 id="声明初始化"><a href="#声明初始化" class="headerlink" title="声明初始化"></a>声明初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用RAII,尽量使用POD</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">A a = <span class="built_in">A</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  	<span class="built_in">A</span>()&#123;</span><br><span class="line">       	b = <span class="keyword">new</span> <span class="built_in">B</span>(); </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B* b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">my_useful_class.cc</span><br></pre></td></tr></table></figure>

<h1 id="注释-Doxygen"><a href="#注释-Doxygen" class="headerlink" title="注释(Doxygen)"></a>注释(Doxygen)</h1><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> rate = <span class="number">0.49</span>;</span><br><span class="line"><span class="comment">// lamber</span></span><br><span class="line"><span class="keyword">auto</span> r2 = [=](<span class="keyword">double</span> monty, <span class="keyword">int</span> year)-&gt;<span class="keyword">double</span>&#123;<span class="keyword">return</span> monty*rate*year; &#125;;</span><br></pre></td></tr></table></figure>



<h2 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h2><h2 id="explicit-显示表达-尽量多使用"><a href="#explicit-显示表达-尽量多使用" class="headerlink" title="explicit(显示表达)(尽量多使用)"></a>explicit(显示表达)(尽量多使用)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般用于只一个量,且容易出现隐式转换的时候</span><br></pre></td></tr></table></figure>

<h2 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h2 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构体一般只有成员变量</span><br></pre></td></tr></table></figure>

<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseInterface</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="keyword">public</span>: <span class="function">BaseInterface</span></span><br><span class="line"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(A); <span class="comment">// 不建议</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(a); <span class="comment">// 建议</span></span><br></pre></td></tr></table></figure>

<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f = <span class="number">0.22</span>);</span><br></pre></td></tr></table></figure>

<h2 id="初始化-0-nullptr-NULL"><a href="#初始化-0-nullptr-NULL" class="headerlink" title="初始化(0,nullptr,NULL)"></a>初始化(0,nullptr,NULL)</h2><h2 id="i-与-i"><a href="#i-与-i" class="headerlink" title="i++与++i"></a>i++与++i</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(intertor i = s.<span class="built_in">begin</span>();++i;s.<span class="built_in">end</span>()) <span class="comment">// 避免重复</span></span><br></pre></td></tr></table></figure>

<h2 id="struct初始化"><a href="#struct初始化" class="headerlink" title="struct初始化"></a>struct初始化</h2><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> =</span> &#123;<span class="number">0</span>,<span class="number">1.2</span>,<span class="string">&quot;hello&quot;</span>&#125;; <span class="comment">// POD</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra与Astar</title>
    <url>/blog/2022/03/08/Dijkstra_Astar/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<p> <a href="https://github.com/Superone77/AGV_dijkstra">基于dijkstra算法，实现路径规划 </a> </p>
<p> <a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?from=search&seid=18009837363580622939&spm_id_from=333.337.0.0">机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/sky068/AStarSearch/tree/master/Astar">AStarSearch</a> </p>
<h1 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h1><p><img src="https://s2.loli.net/2022/03/08/1SKOmE9rfQBdeU3.png" alt="1646742549_1_.png"></p>
<h1 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h1><p><img src="https://s2.loli.net/2022/03/08/ao59Z7ADG4E1wYz.png" alt="1646743310_1_.png"></p>
<h1 id="使用优先级队列实现"><a href="#使用优先级队列实现" class="headerlink" title="使用优先级队列实现"></a>使用优先级队列实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型:fill (ForwardIterator first, ForwardIterator last, const T&amp; val);</span></span><br><span class="line"><span class="built_in">fill</span>(dist, dist + nV + <span class="number">1</span>, INF);</span><br><span class="line"><span class="comment">// 原型:priority_queue&lt;Type, Container, Functional&gt;</span></span><br><span class="line"><span class="comment">// P表示最短距离与定点编号,greater:升序队列,less:降序队列</span></span><br><span class="line">priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 将起点加入优先队列</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	P p = q.<span class="built_in">top</span>();   <span class="comment">//从尚未使用的顶点中找到一个距离最小的顶点,由于是升序队列,所以取出的是最小的</span></span><br><span class="line">	q.<span class="built_in">pop</span>(); <span class="comment">// 将顶点从优先队列中删除</span></span><br><span class="line">	<span class="keyword">int</span> v = p.second; <span class="comment">// 取出顶点编号</span></span><br><span class="line">	<span class="keyword">if</span> (dist[v] &lt; p.first) <span class="comment">// 如果该顶点的距离已经被更新,则跳过</span></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span> (v == end) <span class="comment">// 如果该顶点是终点,则跳出循环</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++)&#123; <span class="comment">// 遍历该顶点的所有邻接点</span></span><br><span class="line">		Edge &amp;e = G[v][i]; <span class="comment">// 取出与该顶点相连的边</span></span><br><span class="line">		<span class="keyword">int</span> dis = dist[v] + e.cost; <span class="comment">// 更新该顶点的距离</span></span><br><span class="line">		<span class="keyword">if</span> (dist[e.to] &gt; dis)&#123;   <span class="comment">// 如果新距离比原来的距离小,则更新</span></span><br><span class="line">			dist[e.to] = dist[v] + e.cost;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">P</span>(dist[e.to], e.to));</span><br><span class="line">			G4[v].<span class="built_in">push_back</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dist[e.to] == dis)&#123;</span><br><span class="line">			G4[v].<span class="built_in">push_back</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Astar算法"><a href="#Astar算法" class="headerlink" title="Astar算法"></a>Astar算法</h1><p><img src="https://s2.loli.net/2022/03/10/FWxtfuIJkzcUpZN.png" alt="1646894719_1_.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">APoint* <span class="title">CAstar::findWay</span><span class="params">(APoint *beginPoint, APoint *endPoint,vector&lt; vector&lt;APoint*&gt; &gt;&amp; allPoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传递地图</span></span><br><span class="line">    _allPoints = allPoints;</span><br><span class="line">    </span><br><span class="line">    _endPoint = endPoint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_endPoint-&gt;type == AType::ATYPE_BARRIER)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;终点是障碍&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*_endPoint == *beginPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;起始点相同&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _openList.<span class="built_in">push_back</span>(beginPoint);</span><br><span class="line">    beginPoint-&gt;type = AType::ATYPE_OPENED;</span><br><span class="line">    <span class="comment">// F = G + H</span></span><br><span class="line">    beginPoint-&gt;f = <span class="built_in">getF</span>(beginPoint);</span><br><span class="line">    <span class="comment">//---------</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取最小值的节点</span></span><br><span class="line">        _curPoint = _openList[<span class="number">0</span>];</span><br><span class="line">        _openList.<span class="built_in">erase</span>(_openList.<span class="built_in">begin</span>());</span><br><span class="line">        _curPoint-&gt;type = AType::ATYPE_CLOSED;</span><br><span class="line">        _closeList.<span class="built_in">push_back</span>(_curPoint);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*_curPoint == *_endPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;have find way&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> _curPoint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取相邻的节点</span></span><br><span class="line">        vector&lt;APoint*&gt; neVec = <span class="built_in">getNeighboringPoint</span>(_curPoint);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;neVec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmpoint = neVec[i];</span><br><span class="line">            <span class="keyword">if</span> (tmpoint-&gt;type == AType::ATYPE_CLOSED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否在开放列表里</span></span><br><span class="line">            <span class="keyword">if</span> (tmpoint-&gt;type != AType::ATYPE_OPENED)</span><br><span class="line">            &#123;</span><br><span class="line">                tmpoint-&gt;parent = _curPoint;</span><br><span class="line">                tmpoint-&gt;g = _curPoint-&gt;g + <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//计算H值</span></span><br><span class="line">                tmpoint-&gt;h = <span class="built_in">getH</span>(tmpoint);</span><br><span class="line">                <span class="comment">//添加到开放列表里</span></span><br><span class="line">                _openList.<span class="built_in">push_back</span>(tmpoint);</span><br><span class="line">                tmpoint-&gt;type = AType::ATYPE_OPENED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//已经在开放列表里</span></span><br><span class="line">                <span class="keyword">if</span> (tmpoint-&gt;h &lt; _curPoint-&gt;h)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmpoint-&gt;parent = _curPoint;</span><br><span class="line">                    tmpoint-&gt;g = _curPoint-&gt;g + <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序 F值最小的排在前面</span></span><br><span class="line">        <span class="built_in">sort</span>(_openList.<span class="built_in">begin</span>(), _openList.<span class="built_in">end</span>(), mySort);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (_openList.<span class="built_in">size</span>()&gt;<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---can not find way---&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_plan</category>
      </categories>
      <tags>
        <tag>path_plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Hu不变矩</title>
    <url>/blog/2022/05/03/Hu%E4%B8%8D%E5%8F%98%E7%9F%A9/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_26898461/article/details/47123405?ops_request_misc=&request_id=&biz_id=102&utm_term=Hu%E4%B8%8D%E5%8F%98%E7%9F%A9&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-47123405.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(130条消息) Hu不变矩原理及opencv实现_beihangzxm123的博客-CSDN博客_hu不变矩</a></p>
<p><a href="https://blog.csdn.net/purgle/article/details/50976268?ops_request_misc=%7B%22request_id%22:%22165154407916782388032079%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165154407916782388032079&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-50976268.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=hu%E4%B8%8D%E5%8F%98%E7%9F%A9%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8&spm=1018.2226.3001.4187">(130条消息) 图像的局部特征研究–Hu不变矩_purgle的博客-CSDN博客_hu不变矩</a></p>
<p><a href="https://github.com/egdw/HU">egdw/HU: Hu矩阵 C++实现 (github.com)</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> M[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Mat&gt; <span class="title">cutImage</span><span class="params">(Mat image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Mat&gt; roi;</span><br><span class="line">	<span class="keyword">int</span> rwidth = image.cols/<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> rheight = image.rows/<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>;y &lt; image.rows<span class="number">-10</span>;y +=rheight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt;  image.cols<span class="number">-10</span>;x += rwidth)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">Rect <span class="title">rect</span><span class="params">(x, y, rwidth, rheight)</span></span>;</span><br><span class="line">			rect &amp;= Rect(<span class="number">0</span>, <span class="number">0</span>, image.cols, image.rows);;</span><br><span class="line">			roi.push_back(image(rect));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> roi;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcHu</span><span class="params">(Mat image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bmpWidth = image.cols;</span><br><span class="line">	<span class="keyword">int</span> bmpHeight = image.rows;</span><br><span class="line">	<span class="keyword">int</span> bmpStep = image.step; </span><br><span class="line">	<span class="keyword">int</span> bmpChannels = image.channels();</span><br><span class="line">	uchar* pBmpBuf = image.data;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">double</span> m00=<span class="number">0</span>,m11=<span class="number">0</span>,m20=<span class="number">0</span>,m02=<span class="number">0</span>,m30=<span class="number">0</span>,m03=<span class="number">0</span>,m12=<span class="number">0</span>,m21=<span class="number">0</span>;  <span class="comment">//中心矩 </span></span><br><span class="line">	<span class="keyword">double</span> x0=<span class="number">0</span>,y0=<span class="number">0</span>;                                    <span class="comment">//计算中心距时所使用的临时变量（x-x&#x27;） </span></span><br><span class="line">	<span class="keyword">double</span> u20=<span class="number">0</span>,u02=<span class="number">0</span>,u11=<span class="number">0</span>,u30=<span class="number">0</span>,u03=<span class="number">0</span>,u12=<span class="number">0</span>,u21=<span class="number">0</span>;        <span class="comment">//规范化后的中心矩</span></span><br><span class="line">	<span class="keyword">double</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,t3=<span class="number">0</span>,t4=<span class="number">0</span>,t5=<span class="number">0</span>;<span class="comment">//临时变量</span></span><br><span class="line">	<span class="keyword">int</span> Center_x=<span class="number">0</span>,Center_y=<span class="number">0</span>;<span class="comment">//重心 </span></span><br><span class="line">	<span class="keyword">int</span> i,j;            <span class="comment">//循环变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//  获得图像的区域重心(普通矩)</span></span><br><span class="line">	<span class="keyword">double</span> s10=<span class="number">0</span>,s01=<span class="number">0</span>,s00=<span class="number">0</span>;  <span class="comment">//0阶矩和1阶矩  </span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bmpHeight;j++)<span class="comment">//y</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bmpWidth;i++)<span class="comment">//x</span></span><br><span class="line">		&#123;</span><br><span class="line">			s10+=i*pBmpBuf[j*bmpStep+i];</span><br><span class="line">			s01+=j*pBmpBuf[j*bmpStep+i];</span><br><span class="line">			s00+=pBmpBuf[j*bmpStep+i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Center_x=(<span class="keyword">int</span>)(s10/s00+<span class="number">0.5</span>);</span><br><span class="line">	Center_y=(<span class="keyword">int</span>)(s01/s00+<span class="number">0.5</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//  计算二阶、三阶矩(中心矩)</span></span><br><span class="line">	m00=s00; </span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bmpHeight;j++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bmpWidth;i++)<span class="comment">//x </span></span><br><span class="line">		&#123; </span><br><span class="line">			x0=(i-Center_x); </span><br><span class="line">			y0=(j-Center_y); </span><br><span class="line">			m11+=x0*y0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">			m20+=x0*x0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">			m02+=y0*y0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">			m03+=y0*y0*y0*pBmpBuf[j*bmpStep+i];</span><br><span class="line">			m30+=x0*x0*x0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">			m12+=x0*y0*y0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">			m21+=x0*x0*y0*pBmpBuf[j*bmpStep+i]; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//  计算规范化后的中心矩: mij/pow(m00,((i+j+2)/2)</span></span><br><span class="line">	u20=m20/<span class="built_in">pow</span>(m00,<span class="number">2</span>); </span><br><span class="line">	u02=m02/<span class="built_in">pow</span>(m00,<span class="number">2</span>); </span><br><span class="line">	u11=m11/<span class="built_in">pow</span>(m00,<span class="number">2</span>);</span><br><span class="line">	u30=m30/<span class="built_in">pow</span>(m00,<span class="number">2.5</span>); </span><br><span class="line">	u03=m03/<span class="built_in">pow</span>(m00,<span class="number">2.5</span>);</span><br><span class="line">	u12=m12/<span class="built_in">pow</span>(m00,<span class="number">2.5</span>); </span><br><span class="line">	u21=m21/<span class="built_in">pow</span>(m00,<span class="number">2.5</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//  计算中间变量</span></span><br><span class="line">	t1=(u20-u02); </span><br><span class="line">	t2=(u30<span class="number">-3</span>*u12); </span><br><span class="line">	t3=(<span class="number">3</span>*u21-u03); </span><br><span class="line">	t4=(u30+u12);</span><br><span class="line">	t5=(u21+u03);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//  计算不变矩 </span></span><br><span class="line">	M[<span class="number">0</span>]=u20+u02; </span><br><span class="line">	M[<span class="number">1</span>]=t1*t1+<span class="number">4</span>*u11*u11; </span><br><span class="line">	M[<span class="number">2</span>]=t2*t2+t3*t3; </span><br><span class="line">	M[<span class="number">3</span>]=t4*t4+t5*t5;</span><br><span class="line">	M[<span class="number">4</span>]=t2*t4*(t4*t4<span class="number">-3</span>*t5*t5)+t3*t5*(<span class="number">3</span>*t4*t4-t5*t5); </span><br><span class="line">	M[<span class="number">5</span>]=t1*(t4*t4-t5*t5)+<span class="number">4</span>*u11*t4*t5;</span><br><span class="line">	M[<span class="number">6</span>]=t3*t4*(t4*t4<span class="number">-3</span>*t5*t5)-t2*t5*(<span class="number">3</span>*t4*t4-t5*t5);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareHu</span><span class="params">(<span class="keyword">double</span> mo[<span class="number">9</span>][<span class="number">7</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>, min = <span class="number">100</span>, max = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += mo[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span>(mo[i][<span class="number">0</span>]&gt;max)</span><br><span class="line">			max = mo[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span>(mo[i][<span class="number">0</span>]&lt;min)</span><br><span class="line">			min = mo[i][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	sum /= <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum - min &gt; max - sum) max = min;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">		<span class="keyword">if</span> (mo[i][<span class="number">0</span>]==max)&#123; no = i;<span class="keyword">break</span>;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout&lt;&lt;max&lt;&lt;endl&lt;&lt;no&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawCross</span><span class="params">(<span class="keyword">int</span> n, Mat image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> centerx = <span class="number">0</span>, centery = <span class="number">0</span>, widstep = <span class="number">0</span>, heistep = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	widstep = image.cols/<span class="number">6</span>;</span><br><span class="line">	heistep = image.rows/<span class="number">6</span>;</span><br><span class="line">	</span><br><span class="line">	centerx = n%<span class="number">3</span> * widstep * <span class="number">2</span> + widstep;</span><br><span class="line">	centery = n/<span class="number">3</span> * heistep * <span class="number">2</span> + heistep;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Scalar <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">	line(image, Point(centerx<span class="number">-20</span>, centery), Point(centerx+<span class="number">20</span>, centery), color, <span class="number">2</span>);</span><br><span class="line">	line(image, Point(centerx, centery<span class="number">-10</span>), Point(centerx, centery+<span class="number">10</span>), color, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	Mat src, binary;</span><br><span class="line">	<span class="built_in">vector</span> &lt;Mat&gt; srcRoi;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">double</span> moment[<span class="number">9</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (--count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> imageName[<span class="number">10</span>];</span><br><span class="line">		sprintf_s(imageName, <span class="string">&quot;%d.jpg&quot;</span>, count);</span><br><span class="line">		src = imread(imageName, <span class="number">1</span>);</span><br><span class="line">		Canny(src, binary, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">		srcRoi = cutImage(binary);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			calcHu(srcRoi[i]);</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">7</span>;j++)</span><br><span class="line">				moment[i][j] = M[j];	</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">int</span> no = compareHu(moment);</span><br><span class="line">		drawCross(no, src);</span><br><span class="line">		imshow(imageName, src);</span><br><span class="line">		waitKey(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS时间戳函数和输出显示</title>
    <url>/blog/2022/03/07/ROS%E6%97%B6%E9%97%B4%E6%88%B3%E5%87%BD%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://blog.csdn.net/Kevin_Xie86/article/details/112765340?ops_request_misc=%7B%22request_id%22:%22164662467216780357265424%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164662467216780357265424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-112765340.pc_search_insert_es_download&utm_term=ros%E6%97%B6%E9%97%B4%E6%88%B3%E6%89%93%E5%8D%B0&spm=1018.2226.3001.4187">(112条消息) ROS时间戳函数和输出显示_Kevin_Xie86的博客-CSDN博客_ros 时间戳</a> </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> t = msg-&gt;header.stamp.toSec()<span class="comment">//把时间戳转化成浮点型格式</span></span><br><span class="line">pringf(<span class="string">&quot;time:%f\n&quot;</span>,t);<span class="comment">//输出显示</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>OccupyGridMap</title>
    <url>/blog/2022/05/03/OccupyGridMap/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://gaoyichao.com/Xiaotu/?book=probabilistic_robotics&title=pr_chapter9">无处不在的小土-pr_chapter9 (gaoyichao.com)</a></p>
<p><a href="https://github.com/markcsie/OccupancyGridMapping">markcsie/OccupancyGridMapping (github.com)</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GridMapping *laserGridMapping = <span class="keyword">new</span> GridMapping();</span><br><span class="line">updateGridMap(pose,scan);</span><br><span class="line">	- gridToXY();</span><br><span class="line">	- inverseSensorModel();</span><br><span class="line">showGridMap();</span><br><span class="line">saveGridMap();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>RRT</title>
    <url>/blog/2022/03/16/RRT/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://space.bilibili.com/193098059">IR艾若机器人的个人空间_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/qq_29648015/article/details/105406878?ops_request_misc=%7B%22request_id%22:%22164740720916780357232327%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164740720916780357232327&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105406878.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=rrt%E7%AE%97%E6%B3%95matlab%E4%BB%A3%E7%A0%81&spm=1018.2226.3001.4187">(115条消息) 快速随机搜索树（RRT）的MATLAB代码实现_露摇芝麻粒的博客-CSDN博客_快速搜索随机树</a> </p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p><img src="https://s2.loli.net/2022/03/16/1txrWDcUu6JLnBI.png" alt="1647390917_1_.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 初始化起点,终点坐标</span><br><span class="line">1 采样点,采样点与步长连线</span><br><span class="line">2 根据一定步长判断是否中间有障碍物,若没有生成新节点</span><br><span class="line">3 一直循环,直到新节点跟终点距离在一定范围内,我们判断为找到终点</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>有一个小技巧,可以在获得随机点ian加入以终点为随机点的可能性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">planning</span>(<span class="params">self, animation=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    rrt path planning</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    animation: flag for animation on or off</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    self.node_list = [self.start]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.max_iter):</span><br><span class="line">        <span class="comment"># 生成随机节点</span></span><br><span class="line">        rnd_node = self.get_random_node()</span><br><span class="line">        <span class="comment"># 获得最近节点id</span></span><br><span class="line">        nearest_ind = self.get_nearest_node_index(self.node_list, rnd_node)</span><br><span class="line">        <span class="comment"># 加入最近节点列表</span></span><br><span class="line">        nearest_node = self.node_list[nearest_ind]</span><br><span class="line">        <span class="comment"># 根据最近节点计算新节点</span></span><br><span class="line">        new_node = self.steer(nearest_node, rnd_node, self.expand_dis)</span><br><span class="line">        <span class="comment"># 判断新节点是否在障碍物内,如果不是则加入新节点列表</span></span><br><span class="line">        <span class="keyword">if</span> self.check_if_outside_play_area(new_node, self.play_area) <span class="keyword">and</span> \</span><br><span class="line">            self.check_collision(new_node, self.obstacle_list):</span><br><span class="line">            self.node_list.append(new_node)</span><br><span class="line">        <span class="comment"># 绘制动画</span></span><br><span class="line">        <span class="keyword">if</span> animation <span class="keyword">and</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            self.draw_graph(rnd_node)</span><br><span class="line">        <span class="comment"># 计算与终点距离,如果不在障碍物内,则路径规划完成</span></span><br><span class="line">        <span class="keyword">if</span> self.calc_dist_to_goal(self.node_list[-<span class="number">1</span>].x,</span><br><span class="line">                                    self.node_list[-<span class="number">1</span>].y) &lt;= self.expand_dis:</span><br><span class="line">            final_node = self.steer(self.node_list[-<span class="number">1</span>], self.end,</span><br><span class="line">                                    self.expand_dis)</span><br><span class="line">            <span class="keyword">if</span> self.check_collision(final_node, self.obstacle_list):</span><br><span class="line">                <span class="keyword">return</span> self.generate_final_course(<span class="built_in">len</span>(self.node_list) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> animation <span class="keyword">and</span> i % <span class="number">5</span>:</span><br><span class="line">            self.draw_graph(rnd_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># cannot find path</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">ImpRgb=imread(<span class="string">&#x27;newmap.png&#x27;</span>);</span><br><span class="line">Imp=rgb2gray(ImpRgb);</span><br><span class="line">imshow(Imp)</span><br><span class="line">xL=<span class="built_in">size</span>(Imp,<span class="number">1</span>);<span class="comment">%地图x轴长度</span></span><br><span class="line">yL=<span class="built_in">size</span>(Imp,<span class="number">2</span>);<span class="comment">%地图y轴长度</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x_I, y_I, <span class="string">&#x27;ro&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">5</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(x_G, y_G, <span class="string">&#x27;go&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">5</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="comment">% 绘制起点和目标点</span></span><br><span class="line">count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:<span class="number">3000</span></span><br><span class="line">    p_rand=[];</span><br><span class="line">    <span class="comment">%Step 1: 在地图中随机采样一个点x_rand</span></span><br><span class="line">    <span class="comment">% 这里有个技巧,可以在这里加一个几率直接连接到终点</span></span><br><span class="line">    <span class="comment">%提示：用（p_rand(1),p_rand(2)）表示环境中采样点的坐标</span></span><br><span class="line">    p_rand(<span class="number">1</span>)=<span class="built_in">ceil</span>(<span class="built_in">rand</span>()*xL); <span class="comment">% rand()生成的是0~1均匀分布的随机数，乘以800再向上取整，数便为[1,800]间的整数</span></span><br><span class="line">    p_rand(<span class="number">2</span>)=<span class="built_in">ceil</span>(<span class="built_in">rand</span>()*yL);</span><br><span class="line">    </span><br><span class="line">    p_near=[];</span><br><span class="line">    <span class="comment">%Step 2: 遍历树，从树中找到最近邻近点x_near </span></span><br><span class="line">    <span class="comment">%提示：x_near已经在树T里</span></span><br><span class="line">    min_distance = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:count</span><br><span class="line">        distance = <span class="built_in">sqrt</span>( ( T.v(<span class="built_in">i</span>).x - p_rand(<span class="number">1</span>) )^<span class="number">2</span> + ( T.v(<span class="built_in">i</span>).y - p_rand(<span class="number">2</span>) )^<span class="number">2</span> );</span><br><span class="line">        <span class="keyword">if</span> distance &lt; min_distance</span><br><span class="line">            min_distance = distance;</span><br><span class="line">            <span class="comment">% 通过index确定树中使用分支</span></span><br><span class="line">            index = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    p_near(<span class="number">1</span>) = T.v(index).x;</span><br><span class="line">    p_near(<span class="number">2</span>) = T.v(index).y;</span><br><span class="line">    </span><br><span class="line">    p_new=[];</span><br><span class="line">    <span class="comment">%Step 3: 扩展得到x_new节点</span></span><br><span class="line">    <span class="comment">%提示：注意使用扩展步长Delta</span></span><br><span class="line">    p_new(<span class="number">1</span>) = p_near(<span class="number">1</span>) + <span class="built_in">round</span>( ( p_rand(<span class="number">1</span>)-p_near(<span class="number">1</span>) ) * Delta/min_distance );</span><br><span class="line">    p_new(<span class="number">2</span>) = p_near(<span class="number">2</span>) + <span class="built_in">round</span>( ( p_rand(<span class="number">2</span>)-p_near(<span class="number">2</span>) ) * Delta/min_distance );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%检查节点是否是collision-free</span></span><br><span class="line">    <span class="keyword">if</span> ~collisionChecking(p_near,p_new,Imp) </span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    count=count+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%Step 4: 将x_new插入树T </span></span><br><span class="line">    <span class="comment">%提示：新节点x_new的父节点是x_near</span></span><br><span class="line">    T.v(count).x = p_new(<span class="number">1</span>);         </span><br><span class="line">    T.v(count).y = p_new(<span class="number">2</span>); </span><br><span class="line">    T.v(count).xPrev = p_near(<span class="number">1</span>);    </span><br><span class="line">    T.v(count).yPrev = p_near(<span class="number">2</span>);</span><br><span class="line">    T.v(count).dist = min_distance;          </span><br><span class="line">    </span><br><span class="line">    <span class="comment">%Step 5:检查是否到达目标点附近 </span></span><br><span class="line">    <span class="comment">%提示：注意使用目标点阈值Thr，若当前节点和终点的欧式距离小于Thr，则跳出当前for循环</span></span><br><span class="line">    new_distance = <span class="built_in">sqrt</span>( ( p_new(<span class="number">1</span>) - x_G )^<span class="number">2</span> + ( p_new(<span class="number">2</span>) - y_G )^<span class="number">2</span> );</span><br><span class="line">    <span class="keyword">if</span> new_distance &lt;= Thr</span><br><span class="line">        <span class="built_in">plot</span>(p_new(<span class="number">1</span>), p_new(<span class="number">2</span>), <span class="string">&#x27;bo&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">2</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;b&#x27;</span>); <span class="comment">% 绘制x_new</span></span><br><span class="line">        line( [p_new(<span class="number">1</span>) p_near(<span class="number">1</span>)], [p_new(<span class="number">2</span>) p_near(<span class="number">2</span>)], <span class="string">&#x27;Marker&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;-&#x27;</span>); <span class="comment">%连接x_near和x_new</span></span><br><span class="line">        line( [x_G p_new(<span class="number">1</span>)], [y_G p_new(<span class="number">2</span>)], <span class="string">&#x27;Marker&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;-&#x27;</span>); <span class="comment">%连接x_Target和x_new</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%Step 6:将x_near和x_new之间的路径画出来</span></span><br><span class="line">    <span class="comment">%提示 1：使用plot绘制，因为要多次在同一张图上绘制线段，所以每次使用plot后需要接上hold on命令</span></span><br><span class="line">    <span class="comment">%提示 2：在判断终点条件弹出for循环前，记得把x_near和x_new之间的路径画出来</span></span><br><span class="line">    <span class="built_in">plot</span>(p_new(<span class="number">1</span>), p_new(<span class="number">2</span>), <span class="string">&#x27;bo&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">2</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;b&#x27;</span>); <span class="comment">% 绘制x_new</span></span><br><span class="line">    line( [p_new(<span class="number">1</span>) p_near(<span class="number">1</span>)], [p_new(<span class="number">2</span>) p_near(<span class="number">2</span>)], <span class="string">&#x27;Marker&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;-&#x27;</span>); <span class="comment">%连接x_near和x_new</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">   </span><br><span class="line">    pause(<span class="number">0.1</span>); <span class="comment">%暂停0.1s，使得RRT扩展过程容易观察</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="RRT"><a href="#RRT" class="headerlink" title="RRT*"></a>RRT*</h1><h2 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h2><p> <a href="https://blog.csdn.net/yuxuan20062007/article/details/88843690?ops_request_misc=%7B%22request_id%22:%22164740853916781683991506%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164740853916781683991506&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88843690.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=rrt*%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(115条消息) 【规划】RRT*算法图解_笑扬轩逸的博客-CSDN博客_rrt算法</a> </p>
<p> <a href="https://blog.csdn.net/weixin_43795921/article/details/88557317">(115条消息) 运动规划RRT<em>算法图解_何伯特的博客-CSDN博客_rrt</em>算法</a> </p>
<p> <a href="https://blog.csdn.net/weixin_46723764/article/details/115513924?ops_request_misc=%7B%22request_id%22:%22164740853916781683955662%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164740853916781683955662&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-115513924.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=rrt*%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(115条消息) 基于matlab的RRT&amp;RRT<em>算法实现以及可视化_肉bot的博客-CSDN博客_rrt</em>算法</a> </p>
<h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><p>两个改进:</p>
<ul>
<li>当前节点重新选择父节点</li>
<li>范围内的节点重新连接</li>
<li>渐进最优</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/16/UwWxEh14opSbCRZ.png" alt="RRTstar1.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在RRT算法基础上加入了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.check_collision(new_node, self.obstacle_list):</span><br><span class="line">    <span class="comment"># 找出最近的节点</span></span><br><span class="line">    near_inds = self.find_near_nodes(new_node)</span><br><span class="line">    <span class="comment"># 重新选择父节点</span></span><br><span class="line">    node_with_updated_parent = self.choose_parent(</span><br><span class="line">    	new_node, near_inds)</span><br><span class="line">    <span class="keyword">if</span> node_with_updated_parent:</span><br><span class="line">        <span class="comment"># 范围内的点进行重新连接</span></span><br><span class="line">        self.rewire(node_with_updated_parent, near_inds)</span><br><span class="line">        self.node_list.append(node_with_updated_parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	self.node_list.append(new_node)</span><br></pre></td></tr></table></figure>

<h1 id="Inform-RRT"><a href="#Inform-RRT" class="headerlink" title="Inform RRT*"></a>Inform RRT*</h1><p>目的是为了加快渐进最优速度,采用在椭圆中采样的方式,代码中实际上就是将smaple转换为informed_sample</p>
<p><img src="https://s2.loli.net/2022/03/19/HpJDULt9MrQ2Rng.png" alt="1647679338_1_.png"></p>
<p>算法主要体现在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入Cbest Cmin xCenter C(旋转矩阵)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">informed_sample</span>(<span class="params">self, cMax, cMin, xCenter, C</span>):</span></span><br><span class="line">    <span class="keyword">if</span> cMax &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">        <span class="comment"># 椭圆长短边</span></span><br><span class="line">        r = [cMax / <span class="number">2.0</span>,</span><br><span class="line">        math.sqrt(cMax ** <span class="number">2</span> - cMin ** <span class="number">2</span>) / <span class="number">2.0</span>,</span><br><span class="line">        math.sqrt(cMax ** <span class="number">2</span> - cMin ** <span class="number">2</span>) / <span class="number">2.0</span>]</span><br><span class="line">        <span class="comment"># 构建对焦矩阵</span></span><br><span class="line">        L = np.diag(r)</span><br><span class="line">        <span class="comment"># 圆形采样</span></span><br><span class="line">        xBall = self.sample_unit_ball()</span><br><span class="line">        <span class="comment"># 构建椭圆采样,并平移旋转矩阵</span></span><br><span class="line">        rnd = np.dot(np.dot(C, L), xBall) + xCenter</span><br><span class="line">        rnd = [rnd[(<span class="number">0</span>, <span class="number">0</span>)], rnd[(<span class="number">1</span>, <span class="number">0</span>)]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	rnd = self.sample_free_space()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rnd</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_plan</category>
      </categories>
      <tags>
        <tag>path_plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebooks</title>
    <url>/blog/2021/11/03/Jupyter/</url>
    <content><![CDATA[<h1 id="安装Jupyter"><a href="#安装Jupyter" class="headerlink" title="安装Jupyter"></a>安装Jupyter</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install jupyter # 或 pip install jupyter</span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu下使用jupyter"><a href="#Ubuntu下使用jupyter" class="headerlink" title="Ubuntu下使用jupyter"></a>Ubuntu下使用jupyter</h1><p><a href="https://blog.csdn.net/qq_31347869/article/details/88049014?ops_request_misc=%7B%22request_id%22:%22163767267616780264096453%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767267616780264096453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88049014.pc_search_mgc_flag&utm_term=ubuntu%E4%BD%BF%E7%94%A8jupyter&spm=1018.2226.3001.4187">Ubuntu 下 Jupyter 的使用_yaoyz105-CSDN博客</a></p>
<h1 id="Vscode使用jupyter"><a href="#Vscode使用jupyter" class="headerlink" title="Vscode使用jupyter"></a>Vscode使用jupyter</h1><p><a href="https://blog.csdn.net/mogoweb/article/details/103248829?ops_request_misc=%7B%22request_id%22:%22163767211116780269884950%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767211116780269884950&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-103248829.pc_search_mgc_flag&utm_term=vscode+jupyter&spm=1018.2226.3001.4187">在VS Code中编写Jupyter Notebook_云水木石-CSDN博客</a></p>
<h1 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h1><p><a href="https://blog.csdn.net/qq_33619378/article/details/83037106?ops_request_misc=%7B%22request_id%22:%22163678378316780265426611%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163678378316780265426611&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83037106.pc_search_mgc_flag&utm_term=jupyter&spm=1018.2226.3001.4187">Jupyter Notebooks的安装和使用介绍_LarsCheng’s Blog-CSDN博客</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>罗技遥控</title>
    <url>/blog/2021/11/03/Logitechcontrol/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_44793491/article/details/120494536?ops_request_misc=%7B%22request_id%22:%22163868705416780265496202%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163868705416780265496202&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-120494536.pc_search_mgc_flag&utm_term=%E7%BD%97%E6%8A%80f710%E6%89%8B%E6%9F%84+ubuntu%E9%A9%B1%E5%8A%A8&spm=1018.2226.3001.4187">罗技F310与F710游戏手柄驱动（附C++源码）_冬瓜-CSDN博客</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Logitech_controller.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define ----------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Logitech_DRIVER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Logitech_DRIVER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ---------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_A     0x001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_B     0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_X     0x201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_Y     0x301</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LB    0x401</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RB    0x501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_BACK  0x601</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_START 0x701</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_HOME  0x801</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LT 0x202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RT 0x502</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_X 0x602</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_Y 0x702</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LEFTSTICK_X 0x002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_LEFTSTICK_Y 0x102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RIGHTSTICK_X 0x302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RIGHTSTICK_Y 0x402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_PRESS 0x001    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_RELEASE 0x0    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_LOW_VALUE 0xffff8001 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSKEY_CROSS_HIGH_VALUE 0x7fff   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logitech</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *dev;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Logitech(<span class="keyword">char</span>* device);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Keystate_map;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen_input</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_key_state</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//Logitech_DRIVER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Logitech_controller.c </span><br><span class="line">#include &quot;Logitech_controller.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Logitech::Logitech(char* device)</span><br><span class="line">&#123;</span><br><span class="line">    dev = device;</span><br><span class="line">    memset(buf, 0, sizeof buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Logitech::init()</span><br><span class="line">&#123;</span><br><span class="line">    fd = open(dev, O_RDONLY);</span><br><span class="line">    if (fd == -1) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Cannot open %s: %s.\n&quot;, dev, strerror(errno));</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    /*Key Status*/</span><br><span class="line"></span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_A] =0;</span><br><span class="line">    Keystate_map[JSKEY_B] =0;</span><br><span class="line">    Keystate_map[JSKEY_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_Y] =0;</span><br><span class="line"></span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_LB] =0;</span><br><span class="line">    Keystate_map[JSKEY_RB] =0;</span><br><span class="line">   </span><br><span class="line">    /* 0 is released */</span><br><span class="line">    /* 1 is press    */</span><br><span class="line">    Keystate_map[JSKEY_BACK] =0;</span><br><span class="line">    Keystate_map[JSKEY_START] =0;</span><br><span class="line">    Keystate_map[JSKEY_HOME] =0;</span><br><span class="line">    </span><br><span class="line">    /*  0 is released */</span><br><span class="line">    /* -1 is the left or up button is pressed */</span><br><span class="line">    /*  1 is the right or down button is pressed*/</span><br><span class="line">    Keystate_map[JSKEY_CROSS_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_CROSS_Y] =0;</span><br><span class="line"></span><br><span class="line">    /* the result is the value of the key(0~99)*/</span><br><span class="line">    Keystate_map[JSKEY_LT] =0;</span><br><span class="line">    Keystate_map[JSKEY_RT] =0;</span><br><span class="line"></span><br><span class="line">    /* the result is the value of the key(-100~100)*/</span><br><span class="line">    Keystate_map[JSKEY_LEFTSTICK_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_LEFTSTICK_Y] =0;</span><br><span class="line">    Keystate_map[JSKEY_RIGHTSTICK_X] =0;</span><br><span class="line">    Keystate_map[JSKEY_RIGHTSTICK_Y] =0;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logitech::listen_input()</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        memset(buf, 0, sizeof buf);</span><br><span class="line">        n = read(fd, &amp;buf, sizeof buf);</span><br><span class="line">        n = n / sizeof(int);</span><br><span class="line">        if (n == (ssize_t)-1) &#123;</span><br><span class="line">            if (errno == EINTR)</span><br><span class="line">                continue;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unsigned short btn = buf[1] &gt;&gt; 16;</span><br><span class="line">        short val = (short)(buf[1] &amp; 0xffff);</span><br><span class="line"></span><br><span class="line">         /*Test for button ID*/</span><br><span class="line">         //cout&lt;&lt;&quot;0x&quot;&lt;&lt;hex&lt;&lt;btn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if (btn == JSKEY_LT || btn == JSKEY_RT)</span><br><span class="line">        &#123;</span><br><span class="line">            unsigned short prs_val = val + 32768;</span><br><span class="line">            val = (unsigned short) (((long)prs_val)*100/65536);</span><br><span class="line">            Keystate_map[btn]= val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (btn == JSKEY_LEFTSTICK_X || btn == JSKEY_LEFTSTICK_Y ||</span><br><span class="line">                 btn == JSKEY_RIGHTSTICK_X || btn == JSKEY_RIGHTSTICK_Y)</span><br><span class="line">        &#123;</span><br><span class="line">            /* y-axis reverse */</span><br><span class="line">            if(btn==JSKEY_LEFTSTICK_Y||btn == JSKEY_RIGHTSTICK_Y)</span><br><span class="line">            &#123;val=(-1)*val;&#125;</span><br><span class="line">            val = val*100/32767;</span><br><span class="line">            Keystate_map[btn]= val;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            switch (val)</span><br><span class="line">            &#123;</span><br><span class="line">            case JSKEY_PRESS:</span><br><span class="line">                Keystate_map[btn]=1;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_RELEASE:</span><br><span class="line">                Keystate_map[btn]=0;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_CROSS_LOW_VALUE:</span><br><span class="line">                Keystate_map[btn]=-1;</span><br><span class="line">                break;</span><br><span class="line">            case JSKEY_CROSS_HIGH_VALUE:</span><br><span class="line">                Keystate_map[btn]=1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            /* y-axis reverse */</span><br><span class="line">            if(btn==JSKEY_CROSS_Y)</span><br><span class="line">            &#123;Keystate_map[btn]=(-1)*Keystate_map[btn];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_key_state();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logitech::print_key_state()</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_A = &quot;&lt;&lt;Keystate_map[JSKEY_A]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_B = &quot;&lt;&lt;Keystate_map[JSKEY_B]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_X = &quot;&lt;&lt;Keystate_map[JSKEY_X]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_Y = &quot;&lt;&lt;Keystate_map[JSKEY_Y]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LB = &quot;&lt;&lt;Keystate_map[JSKEY_LB]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RB = &quot;&lt;&lt;Keystate_map[JSKEY_RB]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_BACK = &quot;&lt;&lt;Keystate_map[JSKEY_BACK]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_START = &quot;&lt;&lt;Keystate_map[JSKEY_START]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_HOME = &quot;&lt;&lt;Keystate_map[JSKEY_HOME]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LT = &quot;&lt;&lt;Keystate_map[JSKEY_LT]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RT = &quot;&lt;&lt;Keystate_map[JSKEY_RT]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_CROSS_X = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_X]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_CROSS_Y = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_Y]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_LEFTSTICK_X  = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_X] &lt;&lt;&quot;     JSKEY_LEFTSTICK_Y   = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_Y]&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;&quot;JSKEY_RIGHTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_X]&lt;&lt;&quot;     JSKEY_RIGHTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_Y]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.cpp</span><br><span class="line">#include &quot;Logitech_controller.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char path[] = &quot;/dev/input/js0&quot;;</span><br><span class="line">    Logitech gamepad(path);</span><br><span class="line"></span><br><span class="line">    gamepad.init();</span><br><span class="line">    gamepad.listen_input();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>!注意:由于不同遥控对于io定义不同,所以需要改动一下**<code>Logitech_controller.h</code><strong>中的</strong><code>#define</code>**</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP服务</title>
    <url>/blog/2021/11/23/FTP/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ncut_wxj/article/details/106198896?ops_request_misc=%7B%22request_id%22:%22163767320116780264025266%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767320116780264025266&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-106198896.pc_search_mgc_flag&utm_term=ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85ftp&spm=1018.2226.3001.4187">在虚拟机的Ubuntu上部署FTP服务器_ncut_wxj的博客-CSDN博客</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example config file /etc/vsftpd.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># The default compiled in settings are fairly paranoid. This sample file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> loosens things up a bit, to make the ftp daemon more usable.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please see vsftpd.conf.5 <span class="keyword">for</span> all compiled <span class="keyword">in</span> defaults.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># READ THIS: This example file is NOT an exhaustive list of vsftpd options.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Please <span class="built_in">read</span> the vsftpd.conf.5 manual page to get a full idea of vsftpd<span class="string">&#x27;s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> capabilities.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Run standalone?  vsftpd can run either from an inetd or as a standalone</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> daemon started from an initscript.</span></span></span><br><span class="line">listen=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This directive enables listening on IPv6 sockets. By default, listening</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sockets. If you want that (perhaps because you want to listen on specific</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> addresses) then you must run two copies of vsftpd with two configuration</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> files.</span></span></span><br><span class="line">listen_ipv6=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Allow anonymous FTP? (Disabled by default).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">这个是设置是否允许匿名登录ftp服务器，不允许。</span></span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to allow local users to log in.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">是否允许本机用户登录</span></span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to enable any form of FTP write command.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">允许上传文件到ftp服务器</span></span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Default umask for local users is 077. You may wish to change this to 022,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> if your users expect that (022 is used by most other ftpd&#x27;</span>s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">local_umask=022</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Uncomment this to allow the anonymous FTP user to upload files. This only</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> has an effect <span class="keyword">if</span> the above global write <span class="built_in">enable</span> is activated. Also, you will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> obviously need to create a directory writable by the FTP user.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Uncomment this if you want the anonymous FTP user to be able to create</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> new directories.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Activate directory messages - messages given to remote users when they</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go into a certain directory.</span></span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If enabled, vsftpd will display directory listings with the time</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span>  your  <span class="built_in">local</span>  time  zone.  The default is to display GMT. The</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">times</span> returned by the MDTM FTP <span class="built_in">command</span> are also affected by this</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> option.</span></span><br><span class="line">use_localtime=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Activate logging of uploads/downloads.</span></span></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Make sure PORT transfer connections originate from port 20 (ftp-data).</span></span></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If you want, you can arrange for uploaded anonymous files to be owned by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a different user. Note! Using <span class="string">&quot;root&quot;</span> <span class="keyword">for</span> uploaded files is not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> recommended!</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown_username=whoever</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may override where the log file goes if you like. The default is shown</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> below.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">xferlog_file=/var/<span class="built_in">log</span>/vsftpd.log</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># If you want, you can have your log file in standard ftpd xferlog format.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that the default <span class="built_in">log</span> file location is /var/<span class="built_in">log</span>/xferlog <span class="keyword">in</span> this <span class="keyword">case</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">xferlog_std_format=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may change the default value for timing out an idle session.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">idle_session_timeout=600</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may change the default value for timing out a data connection.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">data_connection_timeout=120</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># It is recommended that you define on your system a unique user which the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ftp server can use as a totally isolated and unprivileged user.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">nopriv_user=ftpsecure</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Enable this and the server will recognise asynchronous ABOR requests. Not</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> recommended <span class="keyword">for</span> security (the code is non-trivial). Not enabling it,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> however, may confuse older FTP clients.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">async_abor_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># By default the server will pretend to allow ASCII mode but in fact ignore</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the request. Turn on the below options to have the server actually <span class="keyword">do</span> ASCII</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mangling on files when <span class="keyword">in</span> ASCII mode.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Beware that on some FTP servers, ASCII support allows a denial of service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> attack (DoS) via the <span class="built_in">command</span> <span class="string">&quot;SIZE /big/file&quot;</span> <span class="keyword">in</span> ASCII mode. vsftpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> predicted this attack and has always been safe, reporting the size of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> raw file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ASCII mangling is a horrible feature of the protocol.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ascii_upload_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ascii_download_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may fully customise the login banner string:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ftpd_banner=Welcome to blah FTP service.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may specify a file of disallowed anonymous e-mail addresses. Apparently</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useful <span class="keyword">for</span> combatting certain DoS attacks.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deny_email_enable=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (default follows)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">banned_email_file=/etc/vsftpd.banned_emails</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may restrict local users to their home directories.  See the FAQ for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the possible risks <span class="keyword">in</span> this before using chroot_local_user or</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chroot_list_enable below.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chroot_local_user=YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># You may specify an explicit list of local users to chroot() to their home</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directory. If chroot_local_user is YES, <span class="keyword">then</span> this list becomes a list of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> users to NOT chroot().</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (Warning! chroot<span class="string">&#x27;ing can be very dangerous. If using chroot, make sure that</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> the user does not have write access to the top level directory within the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> chroot)</span></span></span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> (default follows) 允许chroot_list文件中配置的用户登录此ftp服务器。</span></span></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> default to avoid remote users being able to cause excessive I/O on large</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">ls_recurse_enable=YES</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Customization</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Some of vsftpd&#x27;</span>s settings don<span class="string">&#x27;t fit the filesystem layout by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> default.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This option should be the name of a directory which is empty.  Also, the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> directory should not be writable by the ftp user. This directory is used</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> as a secure chroot() jail at times vsftpd does not require filesystem</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> access.</span></span></span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This string is the name of the PAM service vsftpd will use.</span></span></span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># This option specifies the location of the RSA certificate to use for SSL</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> encrypted connections.</span></span></span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">ssl_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># Uncomment this to indicate that vsftpd use a utf8 filesystem.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">utf8_filesystem=YES</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">配置ftp服务器的上传下载文件所在的目录。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">这个地址中的 “/home/python” 是这个Ubuntu系统的用户主目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">它的用户名叫 “python”，文件夹 “ftpfile” 是后来创建的</span></span></span><br><span class="line">local_root=/home/python/ftpfile</span><br></pre></td></tr></table></figure>

<h1 id="给ftp服务器配置使用用户等信息"><a href="#给ftp服务器配置使用用户等信息" class="headerlink" title="给ftp服务器配置使用用户等信息"></a>给ftp服务器配置使用用户等信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">ftp_user</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="文件夹内输入"><a href="#文件夹内输入" class="headerlink" title="文件夹内输入"></a>文件夹内输入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp:/192.168.xx.xx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RTOS多任务访问同一个UART的操作方法</title>
    <url>/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q">RTOS多任务访问同一个UART的操作方法</a></p>
<p>在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。</p>
<p>处理“混乱”局面的方法比较多，下面基于<strong>FreeRTOS</strong>，以UART为例讲讲常见的<em><strong>互斥</strong></em>、<em><strong>队列</strong></em>这两种方法。</p>
<h3 id="互斥访问方法"><a href="#互斥访问方法" class="headerlink" title="互斥访问方法"></a><strong>互斥访问方法</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建互斥量资源</span></span><br><span class="line">SemaphoreHandle_t xSemaphore = <span class="literal">NULL</span>;</span><br><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//占用资源</span></span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xSemaphore, <span class="number">10</span> ) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//使用资源(发送数据)</span></span><br><span class="line">      USART_SendNByte();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      xSemaphoreGive(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>信号量与互斥量区别</strong>：</p>
<p><strong>信号量</strong>：多个任务同步使用某个资源；</p>
<p>一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作；</p>
<p><strong>互斥量</strong>：多任务互斥使用某个资源；</p>
<p>一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源；</p>
<h3 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a><strong>队列操作方法</strong></h3><p>队列操作方法就是FIFO，先入先出的原理。比如：<strong>任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t xQueue;</span><br><span class="line">xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);</span><br><span class="line"></span><br><span class="line">xTaskCreate(UART_Send_Task, <span class="string">&quot;UART_Send&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, TASK_PRIORITY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskA_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskB_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_Send_Task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//循环读取队列BUF</span></span><br><span class="line">    <span class="keyword">if</span>(xQueueReceive(xQueue, &amp;Buf, <span class="number">10</span>) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      USART_SendNByte(&amp;Buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton</title>
    <url>/blog/2022/05/05/Singleton_C++/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/pezy/DesignPatterns/blob/master/Singleton/main.cpp">DesignPatterns (github.com)</a> </p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>主要用于全局变量(单例模式)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> President &amp;<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> President instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">President</span>(<span class="keyword">const</span> President &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  President &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> President &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I am the president of the United States of America.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">President</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> President &amp;president1 = President::<span class="built_in">GetInstance</span>();</span><br><span class="line">  <span class="keyword">const</span> President &amp;president2 = President::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">  president1.<span class="built_in">Speak</span>();</span><br><span class="line">  president2.<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(&amp;president1 == &amp;president2); <span class="comment">// same address, point to same object.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>VoxelGrid_filter</title>
    <url>/blog/2022/04/27/VoxelGrid_filter/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_44494725/article/details/103156435?ops_request_misc=%7B%22request_id%22:%22165106602716781483792182%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165106602716781483792182&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-1-103156435.nonecase&utm_term=%E4%BD%93%E7%B4%A0%E6%BB%A4%E6%B3%A2+c++&spm=1018.2226.3001.4450">(129条消息) 体素栅格对点云下采样（从基础写起）——源码解析C++_weixin_44494725的博客-CSDN博客_体素栅格</a></p>
<p><a href="https://github.com/nestormh/voxel_odometry">nestormh/voxel_odometry: Voxel grid and particle filter based approach for estimating odometry. </a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>所谓<strong>下采样</strong>是对点云的一种滤波，目的是减少点云数目,并尽可能保持点云原有形状，从而减少计算量。<br>所谓<strong>体素栅格</strong>是将点云空间划分为一个个极小的格子，格子里包含几个点。<br>对体素栅格里面的点取平均或者加权平均，得到一个点，代替原来的几个点。<br>显然，栅格选的越大，滤波后点云点数越少，速度快，但是会对原来的点云过度模糊;<br>栅格选的越小，作用反之。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">samplePCByQuantization</span><span class="params">(Mat pc, <span class="keyword">float</span> xrange[<span class="number">2</span>], <span class="keyword">float</span> yrange[<span class="number">2</span>], <span class="keyword">float</span> zrange[<span class="number">2</span>], <span class="keyword">float</span> sampleStep, <span class="keyword">int</span> weightByCenter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt; std::vector&lt;<span class="keyword">int</span>&gt; &gt; map;</span><br><span class="line"><span class="comment">//map.size()为体素栅格个数</span></span><br><span class="line"><span class="comment">//map[i].size()为当前体素栅格包含的点数，里面存的是pc的点索引</span></span><br><span class="line">  <span class="keyword">int</span> numSamplesDim = (<span class="keyword">int</span>)(<span class="number">1.0</span>/sampleStep);</span><br><span class="line"><span class="comment">//numSamplesDim：采样个数。sampleStep：相对采样长度</span></span><br><span class="line"><span class="comment">//sampleStep×D=实际采样距离</span></span><br><span class="line"><span class="comment">//同时，D/实际采样距离=采样个数=numSamplesDim</span></span><br><span class="line">  <span class="keyword">float</span> xr = xrange[<span class="number">1</span>] - xrange[<span class="number">0</span>];<span class="comment">//包围盒子的边长</span></span><br><span class="line">  <span class="keyword">float</span> yr = yrange[<span class="number">1</span>] - yrange[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">float</span> zr = zrange[<span class="number">1</span>] - zrange[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numPoints = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  map.<span class="built_in">resize</span>((numSamplesDim+<span class="number">1</span>)*(numSamplesDim+<span class="number">1</span>)*(numSamplesDim+<span class="number">1</span>));</span><br><span class="line"><span class="comment">//此处resize的是map的size，表示体素栅格的个数</span></span><br><span class="line"><span class="comment">//map.size():体素栅格的个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OpenMP might seem like a good idea, but it didn&#x27;t speed this up for me</span></span><br><span class="line">  <span class="comment">//#pragma omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pc.rows; i++)<span class="comment">//遍历pc中每一个点i</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>* point = pc.ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line"><span class="comment">//定义指针* point指向pc的第i个元素（六维）</span></span><br><span class="line">    <span class="comment">// quantize a point</span></span><br><span class="line"><span class="comment">//  xr/numSamplesDim=xr×sampleStep=实际采样距离</span></span><br><span class="line"><span class="comment">//(point[0]-xrange[0])/实际采样距离：代表当前坐标point[0]在第(int) 几个采样距离处</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> xCell =(<span class="keyword">int</span>) ((<span class="keyword">float</span>)numSamplesDim*(point[<span class="number">0</span>]-xrange[<span class="number">0</span>])/xr);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> yCell =(<span class="keyword">int</span>) ((<span class="keyword">float</span>)numSamplesDim*(point[<span class="number">1</span>]-yrange[<span class="number">0</span>])/yr);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> zCell =(<span class="keyword">int</span>) ((<span class="keyword">float</span>)numSamplesDim*(point[<span class="number">2</span>]-zrange[<span class="number">0</span>])/zr);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = xCell*numSamplesDim*numSamplesDim+yCell*numSamplesDim+zCell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*#pragma omp critical</span></span><br><span class="line"><span class="comment">        &#123;*/</span></span><br><span class="line">    map[index].<span class="built_in">push_back</span>(i);<span class="comment">//把具有相同xCell、yCell、zCell的点i存到同一个索引index下面</span></span><br><span class="line"><span class="comment">//此时，map就是一个个体素栅格，里面包含了若干个点</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    numPoints += (map[i].<span class="built_in">size</span>()&gt;<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//把map[i]中所有的点数目统计起来，就是pc的总点数</span></span><br><span class="line">  Mat pcSampled = <span class="built_in">Mat</span>(numPoints, pc.cols, CV_32F);<span class="comment">//cols代表x,y,z,nx,ny,nz六列</span></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.<span class="built_in">size</span>(); i++)<span class="comment">//对每一个体素栅格</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> px=<span class="number">0</span>, py=<span class="number">0</span>, pz=<span class="number">0</span>;<span class="comment">//下采样后的坐标</span></span><br><span class="line">    <span class="keyword">double</span> nx=<span class="number">0</span>, ny=<span class="number">0</span>, nz=<span class="number">0</span>;<span class="comment">//下采样后的法线</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; curCell = map[i];<span class="comment">//curCell：向量包含当前体素栅格的所有点</span></span><br><span class="line"><span class="comment">//map[i]里存的是PC中点的索引（int）</span></span><br><span class="line">    <span class="keyword">int</span> cn = (<span class="keyword">int</span>)curCell.<span class="built_in">size</span>();<span class="comment">//cn:每个体素栅格包含的点数</span></span><br><span class="line">    <span class="keyword">if</span> (cn&gt;<span class="number">0</span>)<span class="comment">//因为map[i]可能为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (weightByCenter)<span class="comment">//体素栅格求重心</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> xCell, yCell, zCell;<span class="comment">//第几个cell</span></span><br><span class="line">        <span class="keyword">double</span> xc, yc, zc;<span class="comment">//体素栅格的质心坐标</span></span><br><span class="line">        <span class="keyword">double</span> weightSum = <span class="number">0</span> ;</span><br><span class="line">        zCell = i % numSamplesDim;<span class="comment">//这个i是map的index，</span></span><br><span class="line"><span class="comment">//index = xCell*numSamplesDim*numSamplesDim+yCell*numSamplesDim+zCell;</span></span><br><span class="line">        yCell = ((i-zCell)/numSamplesDim) % numSamplesDim;</span><br><span class="line">        xCell = ((i-zCell-yCell*numSamplesDim)/(numSamplesDim*numSamplesDim));<span class="comment">//第几个cell</span></span><br><span class="line"><span class="comment">//0.5 * (double)xr/numSamplesDim：半个格子的长度</span></span><br><span class="line"><span class="comment">//(double)xr/numSamplesDim：一个格子的长度</span></span><br><span class="line"><span class="comment">//xCell* (double)xr/numSamplesDim 前面所有整数个格子的长度</span></span><br><span class="line">        xc = ((<span class="keyword">double</span>)xCell+<span class="number">0.5</span>) * (<span class="keyword">double</span>)xr/numSamplesDim + (<span class="keyword">double</span>)xrange[<span class="number">0</span>];<span class="comment">//xc：体素栅格的重心坐标x</span></span><br><span class="line">        yc = ((<span class="keyword">double</span>)yCell+<span class="number">0.5</span>) * (<span class="keyword">double</span>)yr/numSamplesDim + (<span class="keyword">double</span>)yrange[<span class="number">0</span>];</span><br><span class="line">        zc = ((<span class="keyword">double</span>)zCell+<span class="number">0.5</span>) * (<span class="keyword">double</span>)zr/numSamplesDim + (<span class="keyword">double</span>)zrange[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cn; j++)<span class="comment">//体素栅格中每一点</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> ptInd = curCell[j];<span class="comment">//ptInd是pc中的点的索引</span></span><br><span class="line">          <span class="keyword">float</span>* point = pc.ptr&lt;<span class="keyword">float</span>&gt;(ptInd);</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">double</span> dx = point[<span class="number">0</span>]-xc;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">double</span> dy = point[<span class="number">1</span>]-yc;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">double</span> dz = point[<span class="number">2</span>]-zc;<span class="comment">//计算体素栅格中每一点与质心的距离：d</span></span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(dx*dx+dy*dy+dz*dz);</span><br><span class="line">          <span class="keyword">double</span> w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (d&gt;EPS)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// it is possible to use different weighting schemes.</span></span><br><span class="line">            <span class="comment">// inverse weigthing was just good for me</span></span><br><span class="line">            <span class="comment">// exp( - (distance/h)**2 )</span></span><br><span class="line">            <span class="comment">//const double w = exp(-d*d);</span></span><br><span class="line">            w = <span class="number">1.0</span>/d;<span class="comment">//由d计算权重，inverse weigthing</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//float weights[3]=&#123;1,1,1&#125;;</span></span><br><span class="line">          px += w*(<span class="keyword">double</span>)point[<span class="number">0</span>];</span><br><span class="line">          py += w*(<span class="keyword">double</span>)point[<span class="number">1</span>];</span><br><span class="line">          pz += w*(<span class="keyword">double</span>)point[<span class="number">2</span>];</span><br><span class="line">          nx += w*(<span class="keyword">double</span>)point[<span class="number">3</span>];</span><br><span class="line">          ny += w*(<span class="keyword">double</span>)point[<span class="number">4</span>];</span><br><span class="line">          nz += w*(<span class="keyword">double</span>)point[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">          weightSum+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        px/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">        py/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">        pz/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">        nx/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">        ny/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">        nz/=(<span class="keyword">double</span>)weightSum;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个体素栅格中：px=（x1*1/d1+x2*1/d2+...+xcn1/dcn）/（1/d1+1/d2+...1/dcn）</span></span><br><span class="line"><span class="comment">//py，pz同理</span></span><br><span class="line"><span class="comment">//得到加权质心</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;<span class="comment">//普通求平均的质心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> ptInd = curCell[j];</span><br><span class="line">          <span class="keyword">float</span>* point = pc.ptr&lt;<span class="keyword">float</span>&gt;(ptInd);</span><br><span class="line"></span><br><span class="line">          px += (<span class="keyword">double</span>)point[<span class="number">0</span>];</span><br><span class="line">          py += (<span class="keyword">double</span>)point[<span class="number">1</span>];</span><br><span class="line">          pz += (<span class="keyword">double</span>)point[<span class="number">2</span>];</span><br><span class="line">          nx += (<span class="keyword">double</span>)point[<span class="number">3</span>];</span><br><span class="line">          ny += (<span class="keyword">double</span>)point[<span class="number">4</span>];</span><br><span class="line">          nz += (<span class="keyword">double</span>)point[<span class="number">5</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        px/=(<span class="keyword">double</span>)cn;</span><br><span class="line">        py/=(<span class="keyword">double</span>)cn;</span><br><span class="line">        pz/=(<span class="keyword">double</span>)cn;</span><br><span class="line">        nx/=(<span class="keyword">double</span>)cn;</span><br><span class="line">        ny/=(<span class="keyword">double</span>)cn;</span><br><span class="line">        nz/=(<span class="keyword">double</span>)cn;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//定义指针pcData指向pcSampled的第c个元素</span></span><br><span class="line">      <span class="keyword">float</span> *pcData = pcSampled.ptr&lt;<span class="keyword">float</span>&gt;(c);</span><br><span class="line">      pcData[<span class="number">0</span>]=(<span class="keyword">float</span>)px;</span><br><span class="line">      pcData[<span class="number">1</span>]=(<span class="keyword">float</span>)py;</span><br><span class="line">      pcData[<span class="number">2</span>]=(<span class="keyword">float</span>)pz;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 法向量标准化</span></span><br><span class="line">      <span class="keyword">double</span> norm = <span class="built_in">sqrt</span>(nx*nx+ny*ny+nz*nz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (norm&gt;EPS)</span><br><span class="line">      &#123;</span><br><span class="line">        pcData[<span class="number">3</span>]=(<span class="keyword">float</span>)(nx/norm);</span><br><span class="line">        pcData[<span class="number">4</span>]=(<span class="keyword">float</span>)(ny/norm);</span><br><span class="line">        pcData[<span class="number">5</span>]=(<span class="keyword">float</span>)(nz/norm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//#pragma omp atomic</span></span><br><span class="line">      c++;</span><br><span class="line"></span><br><span class="line">      curCell.<span class="built_in">clear</span>();<span class="comment">//清空当前体素栅格</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">return</span> pcSampled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维体素滤波</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LaserScan <span class="title">Voxelfilter</span><span class="params">(LaserScan scan, <span class="keyword">float</span> Resolution)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> min_x = <span class="number">-10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> min_y = <span class="number">-10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> max_y = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenY = (<span class="keyword">int</span>)(std::<span class="built_in">round</span>((max_y - min_y) / Resolution));</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; rebuf;</span><br><span class="line">    LaserScan result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;point:scan)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = point.<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">int</span> y = point.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 仅采用4m内scan数据</span></span><br><span class="line">        <span class="keyword">float</span> dis = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">        <span class="keyword">if</span>(dis &gt; <span class="number">4.0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> xGrid = (<span class="keyword">int</span>)(std::<span class="built_in">round</span>((point.x - min_x) / Resolution));</span><br><span class="line">        <span class="keyword">int</span> yGrid = (<span class="keyword">int</span>)(std::<span class="built_in">round</span>((point.y - min_y) / Resolution));</span><br><span class="line">        <span class="keyword">int</span> index = yGrid * lenY + xGrid;</span><br><span class="line">        <span class="keyword">if</span>(!rebuf[index])</span><br><span class="line">        &#123;</span><br><span class="line">            rebuf[index] = <span class="number">1</span>;</span><br><span class="line">            result.<span class="built_in">push_back</span>(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>addr2line</title>
    <url>/blog/2022/05/11/addr2line/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_23101811/article/details/122184548">(132条消息) addr2line 输出为?:0可能原因_qq_23101811的博客-CSDN博客</a> </p>
<p> <a href="https://blog.csdn.net/lhf_tiger/article/details/9088609">(132条消息) addr2line命令_残阳的博客-CSDN博客_addr2line命令用法</a> </p>
<p> <a href="https://blog.csdn.net/carefree2005/article/details/120737841?ops_request_misc=%7B%22request_id%22:%22165224592316781683954060%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165224592316781683954060&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-120737841-null-null.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=dmesg&spm=1018.2226.3001.4187">(132条消息) Linux命令之dmesg命令_浪子吴天的博客-CSDN博客_dmesg</a> </p>
<h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译注意使用-g模式编译</span></span><br><span class="line">gcc -o <span class="built_in">test</span> -g test.c</span><br><span class="line"><span class="comment">#清除内核环形缓冲区(ring butter)</span></span><br><span class="line">dmesg -C </span><br><span class="line"><span class="comment">#执行文件</span></span><br><span class="line">./<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 查看所有开机日志信息</span></span><br><span class="line">dmesg</span><br><span class="line">[3540868.730553] traps: <span class="built_in">test</span>[4331] <span class="built_in">trap</span> divide error ip:55d347e5067b sp:7ffdb3499f50 error:0</span><br><span class="line">[3540868.730567]  <span class="keyword">in</span> <span class="built_in">test</span>[55d347e50000+1000]</span><br><span class="line"><span class="comment"># 计算ip</span></span><br><span class="line">ip: 55d347e5067b - 55d347e50000 = 067b</span><br><span class="line"><span class="comment"># addr2line -e test 067b</span></span><br><span class="line">/var/testhelper/programsymbols/tes.c:8</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>amcl原理分析</title>
    <url>/blog/2021/11/25/amcl%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/p942005405/article/details/108569970?ops_request_misc=%7B%22request_id%22:%22163486681116780264091671%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163486681116780264091671&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-108569970.pc_search_ecpm_flag&utm_term=amcl&spm=1018.2226.3001.4187">slam 学习之 AMCL 概念与原理分析_学之知之的博客-CSDN博客_amcl定位原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/126199044">机器人定位技术：AMCL的参数你真的会调了吗？(一） - 知乎 (zhihu.com)</a></p>
<p>改写amcl</p>
<p><a href="https://zhuanlan.zhihu.com/p/28137335">ROS导航包源码学习2 — 定位 - 知乎 (zhihu.com)</a></p>
<h1 id="概念算法"><a href="#概念算法" class="headerlink" title="概念算法"></a>概念算法</h1><ul>
<li>运动模型(里程计模型)</li>
<li>测量模型(波束模型与似然域模型)</li>
<li>采样算法(KLD采样)</li>
<li>蒙特卡洛算法</li>
<li>自适应蒙特卡洛算法</li>
</ul>
<h1 id="运动模型"><a href="#运动模型" class="headerlink" title="运动模型"></a>运动模型</h1><p>关于<code>速度模型</code>与<code>里程计模型</code> ,主要采取<code>采样模型</code></p>
<p><a href="https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/">概率机器人</a></p>
<p>这里主要使用里程计模型</p>
<h1 id="测量模型"><a href="#测量模型" class="headerlink" title="测量模型"></a>测量模型</h1><p><code>波束模型</code>主要调整六个参数:<img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bhit%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bshort%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Brand%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bmax%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> （ <img src="https://www.zhihu.com/equation?tex=P_%7Bhit%7D" alt="[公式]"> 的方差）和λ（动态障碍物的影响力度)</p>
<p><img src="https://pic4.zhimg.com/80/v2-d036db5bb440afe522b644db5bf3324f_720w.jpg" alt="img"></p>
<p>似然域模型主要调整两个参数<img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bhit%7D" alt="[公式]">  <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Brand%7D" alt="[公式]"> 。</p>
<p><img src="https://pic1.zhimg.com/80/v2-107260979458a0bffb5a1ba9e22d2168_720w.jpg" alt="img"></p>
<h1 id="KLD采样"><a href="#KLD采样" class="headerlink" title="KLD采样"></a>KLD采样</h1><p><strong>目的</strong>:<strong>将估计的概率分布转化为真实的概率分布。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190720103418660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUzMDIzOQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h1>]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>amcl简单使用</title>
    <url>/blog/2021/11/25/amcl%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zx3517288/article/details/78454196">AMCL介绍及参数说明_走过_冬天的博客-CSDN博客_amcl参数配置</a></p>
<p><a href="https://blog.csdn.net/qq_34672671/article/details/105729458?ops_request_misc=%7B%22request_id%22:%22163540823116780274178002%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163540823116780274178002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-29-105729458.pc_search_ecpm_flag&utm_term=amcl&spm=1018.2226.3001.4187">深入AMCL(三):AMCL手动初始化后如何自动定位_yuanguobin01的博客-CSDN博客</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>amcl_demo.launch</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- r2000驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find pepperl_fuchs_r2000)/launch/gui_example.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map server --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布map.yaml,其中包含了pgm文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;map_file&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find run)/map/mymap.yaml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(arg map_file)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Localization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find run)/launch/amcl.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 获取odom数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于采用的是里程计模型,注意里程计的位置输出尤为关键 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;node name=&quot;tcp_server&quot; pkg=&quot;tcp_server&quot; type=&quot;tcp_server&quot; /&gt; --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注意坐标转换:map-&gt;odom-&gt;base_link-&gt;laser_link --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果转换多了,会报错,多转换可能会报laserscan超时,少了,rviz会报没有上级坐标系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;map_to_odom_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0  /map /odom 100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_to_laser_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 /base_link /laser_link 100&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find run)/rviz/hector_map.rviz&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>amcl.launch</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_map_topic&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;scan_topic&quot;</span>      <span class="attr">default</span>=<span class="string">&quot;scan&quot;</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_x&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_y&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_a&quot;</span>  <span class="attr">default</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame_id&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;base_frame_id&quot;</span>   <span class="attr">default</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;global_frame_id&quot;</span> <span class="attr">default</span>=<span class="string">&quot;map&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">type</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amcl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_map_topic&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg use_map_topic)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Publish scans from best pose at a max of 10 Hz --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 差分模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_model_type&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;diff&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 速度模型参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha5&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;gui_publish_rate&quot;</span>          <span class="attr">value</span>=<span class="string">&quot;10.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_beams&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;810&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_range&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;-1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;min_particles&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;500&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_particles&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_err&quot;</span>                   <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_z&quot;</span>                     <span class="attr">value</span>=<span class="string">&quot;0.99&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 里程计模型调节超参 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha1&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha2&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha3&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha4&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 一般情况而言,高斯误差会比较大,可以设置大一些 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_hit&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.95&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_short&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max&quot;</span>               <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_rand&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_sigma_hit&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_lambda_short&quot;</span>        <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_model_type&quot;</span>          <span class="attr">value</span>=<span class="string">&quot;likelihood_field&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_likelihood_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_d&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_a&quot;</span>              <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame_id&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg odom_frame_id)&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame_id&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;$(arg base_frame_id)&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;global_frame_id&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;$(arg global_frame_id)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;resample_interval&quot;</span>         <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Increase tolerance because the computer can get quite busy --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;transform_tolerance&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 快慢指针,一般slow会小一些,良好的值可能为0.001,fast可能为0.01 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_slow&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_fast&quot;</span>       <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 初始位姿 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_x&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_x)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_y&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_y)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;initial_pose_a&quot;</span>            <span class="attr">value</span>=<span class="string">&quot;$(arg initial_pose_a)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span>                      <span class="attr">to</span>=<span class="string">&quot;$(arg scan_topic)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中软件安装方法</title>
    <url>/blog/2022/02/10/apt%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> [(105条消息) ubuntu安装和查看已安装软件包_weixin_34293902的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_34293902/article/details/91799108?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=">https://blog.csdn.net/weixin_34293902/article/details/91799108?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=</a>                查看apt安装的软件包   &amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-91799108.pc_search_result_control_group&amp;spm=1018.2226.3001.4187) </p>
<h1 id="apt安装-卸载"><a href="#apt安装-卸载" class="headerlink" title="apt安装/卸载"></a>apt安装/卸载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">普通安装：apt-get install softname1 softname2 …;</span><br><span class="line"></span><br><span class="line">修复安装：apt-get -f install softname1 softname2... ;(-f Atemp to correct broken dependencies)</span><br><span class="line">重新安装：apt-get --reinstall install softname1 softname2...;</span><br><span class="line">移除式卸载：apt-get remove softname1 softname2 …;（移除软件包，当包尾部有+时，意为安装）</span><br><span class="line"></span><br><span class="line">清除式卸载 ：apt-get --purge remove softname1 softname2...;(同时清除配置)</span><br><span class="line">清除式卸载：apt-get purge sofname1 softname2...;(同上，也清除配置文件)</span><br></pre></td></tr></table></figure>

<h1 id="dpkg安装-卸载"><a href="#dpkg安装-卸载" class="headerlink" title="dpkg安装/卸载"></a>dpkg安装/卸载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">普通安装：dpkg -i package_name.deb</span><br><span class="line"></span><br><span class="line">移除式卸载：dpkg -r pkg1 pkg2 ...;</span><br><span class="line">清除式卸载：dpkg -P pkg1 pkg2...;</span><br></pre></td></tr></table></figure>

<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载解压</span></span><br><span class="line">a．解xx.tar.gz：tar zxf xx.tar.gz </span><br><span class="line">b．解xx.tar.Z：tar zxf xx.tar.Z </span><br><span class="line">c．解xx.tgz：tar zxf xx.tgz </span><br><span class="line">d．解xx.bz2：bunzip2 xx.bz2 </span><br><span class="line">e．解xx.tar：tar xf xx.tar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行安装</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache search # ------(package 搜索包)</span><br><span class="line">apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)</span><br><span class="line">apt-get install # ------(package 安装包)</span><br><span class="line">apt-get install # -----(package --reinstall 重新安装包)</span><br><span class="line">apt-get -f install # -----(强制安装, &quot;-f = --fix-missing&quot;当是修复安装吧...)</span><br><span class="line">apt-get remove #-----(package 删除包)</span><br><span class="line">apt-get remove --purge # ------(package 删除包，包括删除配置文件等)</span><br><span class="line">apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)</span><br><span class="line">apt-get update #------更新源</span><br><span class="line">apt-get upgrade #------更新已安装的包</span><br><span class="line">apt-get dist-upgrade # ---------升级系统</span><br><span class="line">apt-get dselect-upgrade #------使用 dselect 升级</span><br><span class="line">apt-cache depends #-------(package 了解使用依赖)</span><br><span class="line">apt-cache rdepends # ------(package 了解某个具体的依赖,当是查看该包被哪些包依赖吧...)</span><br><span class="line">apt-get build-dep # ------(package 安装相关的编译环境)</span><br><span class="line">apt-get source #------(package 下载该包的源代码)</span><br><span class="line">apt-get clean &amp;&amp; apt-get autoclean # --------清理下载文件的存档 &amp;&amp; 只清理过时的包</span><br><span class="line">apt-get check #-------检查是否有损坏的依赖</span><br><span class="line">dpkg -S filename -----查找filename属于哪个软件包</span><br><span class="line">apt-file search filename -----查找filename属于哪个软件包</span><br><span class="line">apt-file list packagename -----列出软件包的内容</span><br><span class="line">apt-file update --更新apt-file的数据库</span><br><span class="line"></span><br><span class="line">dpkg --info &quot;软件包名&quot; --列出软件包解包后的包名称.</span><br><span class="line">dpkg -l --列出当前系统中所有的包.可以和参数less一起使用在分屏查看. (类似于rpm -qa)</span><br><span class="line">dpkg -l |grep -i &quot;软件包名&quot; --查看系统中与&quot;软件包名&quot;相关联的包.</span><br><span class="line">dpkg -s 查询已安装的包的详细信息.</span><br><span class="line">dpkg -L 查询系统中已安装的软件包所安装的位置. (类似于rpm -ql)</span><br><span class="line">dpkg -S 查询系统中某个文件属于哪个软件包. (类似于rpm -qf)</span><br><span class="line">dpkg -I 查询deb包的详细信息,在一个软件包下载到本地之后看看用不用安装(看一下呗).</span><br><span class="line">dpkg -i 手动安装软件包(这个命令并不能解决软件包之前的依赖性问题),如果在安装某一个软件包的时候遇到了软件依赖的问题,可以用apt-get -f install在解决信赖性这个问题.</span><br><span class="line">dpkg -r 卸载软件包.不是完全的卸载,它的配置文件还存在.</span><br><span class="line">dpkg -P 全部卸载(但是还是不能解决软件包的依赖性的问题)</span><br><span class="line">dpkg -reconfigure 重新配置</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>boost_thread</title>
    <url>/blog/2021/11/25/boost_thread/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>了解boost</p>
<p><a href="https://zhuanlan.zhihu.com/p/66486828">C++ Boost库分类总结（个人收藏） - 知乎 (zhihu.com)</a></p>
<p>boost教程</p>
<p><a href="http://zh.highscore.de/cpp/boost/multithreading.html">Highscore - Boost C++ 库 - 多线程</a></p>
<h1 id="boost多线程同步简单使用"><a href="#boost多线程同步简单使用" class="headerlink" title="boost多线程同步简单使用"></a>boost多线程同步简单使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  boost::this_thread::<span class="built_in">sleep</span>(boost::posix_time::<span class="built_in">seconds</span>(seconds)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">boost::mutex mutex; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">1</span>); </span><br><span class="line">    mutex.<span class="built_in">lock</span>(); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">    mutex.<span class="built_in">unlock</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">boost::thread <span class="title">t1</span><span class="params">(thread)</span></span>; </span><br><span class="line">  <span class="function">boost::thread <span class="title">t2</span><span class="params">(thread)</span></span>; </span><br><span class="line">  t1.<span class="built_in">join</span>(); </span><br><span class="line">  t2.<span class="built_in">join</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>adb使用</title>
    <url>/blog/2022/04/28/adb%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_41635750/article/details/108297319?ops_request_misc=%7B%22request_id%22:%22165113153916780357210551%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165113153916780357210551&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-108297319.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=adb%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">(129条消息) 全网最全adb命令_autofelix的博客-CSDN博客</a></p>
<h1 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb connect <span class="string">&quot;<span class="variable">$ip</span>&quot;</span></span><br><span class="line">adb shell</span><br><span class="line">adb push 本机文件 下机文件夹</span><br><span class="line">adb pull 下机文件 本机文件夹</span><br><span class="line">md5sum 文件 (对比文件是否相同)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>cc++中malloc和calloc以及relloc使用</title>
    <url>/blog/2022/02/24/c++%E4%B8%ADmalloc%E5%92%8Ccalloc%E4%BB%A5%E5%8F%8Arelloc%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/weixin_35890173/article/details/117107121?ops_request_misc=%7B%22request_id%22:%22164568581316780255219883%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164568581316780255219883&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-117107121.pc_search_insert_es_download&utm_term=calloc&spm=1018.2226.3001.4187">(110条消息) c语言中calloc是什么意思,C语言中malloc和calloc以及relloc函数的区别_棒棒鸡不棒的博客-CSDN博客</a> </p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p> char <em>p = (char</em>)maolloc(100); </p>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p> calloc申请的动态内存空间是干净的内存，当你输出内存中的数据时它是NULL  ,而malloc()申请的动态内存空间不一定是干净的，当你输出时有可能会打印出一些未知的数据 </p>
<h2 id="relloc"><a href="#relloc" class="headerlink" title="relloc"></a>relloc</h2><p> rellc()函数是用于你的动态内存空间不足以存储你所要储存的信息时，需要再追加一段内存，函数的格式是：(类型说明符*)relloc(p,size);p是你原来申请的动态空间的首地址，是你要申请的动态内存的大小，而不是你要追加的动态内存空间大小，这一点要切记。 </p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中rand使用</title>
    <url>/blog/2022/02/24/c++%E4%B8%ADrand%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/cnmilan/article/details/7103786">(110条消息) rand 函数 与 srand 函数_myKernel-CSDN博客_srand48</a> </p>
<p> <a href="https://blog.csdn.net/dwell548560/article/details/116794540">(110条消息) drand48()函数_dwell548560的博客-CSDN博客_drand48</a></p>
<p> <a href="https://blog.csdn.net/jx232515/article/details/51510336?ops_request_misc=%7B%22request_id%22:%22165214478616780366576292%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165214478616780366576292&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-51510336-null-null.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=srand((unsigned)time(nullptr))&spm=1018.2226.3001.4187">(132条消息) srand((unsigned)time(NULL))详解_清风lsq的博客-CSDN博客_srand(time(null))</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>rand使用范围是( <em><strong>*0~RAND_MAX*</strong></em> ), srand(seed)函数用于给rand()函数设定种子。一般若是设置srand(time(NULL))**,一现在时间为时间种子, 一般目的是由于rand为伪随机,加上以当前时间为种子的话,便于产生真实随机数</p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test_rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">long</span> n;</span><br><span class="line">          <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">                n = <span class="built_in">rand</span>();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;d\n&quot;</span>, n);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="drand48-函数"><a href="#drand48-函数" class="headerlink" title="drand48()函数"></a>drand48()函数</h1><p> <strong>drand48 返回服从均匀分布的·[0.0, 1.0) 之间的 double 型随机数。</strong> </p>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="built_in">drand48</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中sort,stack使用</title>
    <url>/blog/2022/02/24/c++%E4%B8%ADsort,stack%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/qq_41575507/article/details/105936466?ops_request_misc=%7B%22request_id%22:%22164559614416780255251330%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164559614416780255251330&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105936466.pc_search_insert_es_download&utm_term=sort%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(110条消息) C++ sort()排序详解_ACfun-CSDN博客_c++sort排序</a> </p>
<p> [(110条消息) STL源码剖析 <a href="https://blog.csdn.net/langb2014/article/details/48103447">容器]（五）[stl_stack.h]_深藏功与名-CSDN博客</a> </p>
<h1 id="sort使用"><a href="#sort使用" class="headerlink" title="sort使用"></a>sort使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(data a, data b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里使用的是指针</span></span><br><span class="line"><span class="built_in">sort</span>(exm_set,exm_set + size, cmp1);   </span><br></pre></td></tr></table></figure>

<h1 id="stack使用"><a href="#stack使用" class="headerlink" title="stack使用"></a>stack使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;Tnode*&gt; search_path; </span><br><span class="line">Tnode* pSearch = Kd; </span><br><span class="line"><span class="comment">// stack容器 - 先进后出</span></span><br><span class="line"><span class="comment">// 支持在这里进行push(), pop(), top()操作  </span></span><br><span class="line"><span class="comment">// 比如:</span></span><br><span class="line">search_path.<span class="built_in">push</span>(pSearch);  </span><br><span class="line">search_path.<span class="built_in">top</span>()</span><br><span class="line">search_path.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>0ohm电阻作用</title>
    <url>/blog/2021/12/11/0ohm%E7%94%B5%E9%98%BB%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<p>零欧姆电阻的主要作用有如下：</p>
<p>1,在电路中没有任何功能，只是在PCB上为了调试方便或兼容设计等原因。<br>2,可以做跳线用，如果某段线路不用，直接不贴该电阻即可（不影响外观）。<br>3,在匹配电路参数不确定的时候，以0欧姆代替，实际调试的时候，确定参数，再以具体数值的元件代替。<br>4,想测某部分电路的耗电流的时候，可以去掉0ohm电阻，接上电流表，这样方便测耗电流。<br>5,在布线时,如果实在布不过去了,也可以加一个0欧的电阻。<br>6,在高频信号下，充当电感或电容。（与外部电路特性有关）电感用，主要是解决EMC问题。如地与地，电源和IC Pin间。<br>7,单点接地（指保护接地、工作接地、直流接地在设备上相互分开,各自成为独立系统。）<br>8,熔丝作用；<br>9，单点接地，只要是地，最终都要接到一起，然后入大地。如果不接在一起就是”浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上有四种方法解决此问题：1、用磁珠连接；2、用电容连接；3、用电感连接；4、用0欧姆电阻连接。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。电容隔直通交，造成浮地。电感体积大，杂散参数多，不稳定。0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。<br>10，跨接时用于电流回路，当分割电地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。<br>11，配置电路，一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子。空置跳线在高频时相当于天线，用贴片电阻效果好。<br>12，其他用途，布线时跨线；调试/测试用；临时取代其他贴片器件；作为温度补偿器件；更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔）。</p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>boost安装与测试</title>
    <url>/blog/2021/11/25/boost%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zhangxiao93/article/details/51077933?ops_request_misc=%7B%22request_id%22:%22163782562316780255241172%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163782562316780255241172&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51077933.pc_search_mgc_flag&utm_term=ubuntu+boost%E5%BA%93%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Ubuntu下安装boost库_上善若水-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/yhrun/article/details/8099630">在Ubuntu上安装boost库_一点一滴-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_41722524/article/details/114322697?ops_request_misc=%7B%22request_id%22:%22163782562316780255241172%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163782562316780255241172&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-114322697.pc_search_mgc_flag&utm_term=ubuntu+boost%E5%BA%93%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Ubuntu20.04安装boost库_vanyongqi-CSDN博客_ubuntu 安装boost</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libboost-dev</span><br></pre></td></tr></table></figure>

<h2 id="build安装"><a href="#build安装" class="headerlink" title="build安装"></a>build安装</h2><ul>
<li>下载boost库:<a href="https://www.boost.org/">Boost C++ Libraries</a></li>
<li>解压: <code>tar -xzvf boost_1_xx_xx.tar.gz</code></li>
<li>进入解压目录,执行脚本,<code>sudo ./bootstrap.sh</code></li>
<li>安装, <code>sudo ./b2 install</code></li>
<li>测试环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾添加</span></span><br><span class="line">export CPLUS_INCLUDE_PATH=/usr/local/include/boost:$CPLUS_INCLUDE_PATH</span><br><span class="line">export LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano test.cpp</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="number">1</span>;<span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;boost::<span class="built_in">bind</span>(fun,_1,_2)(m,n)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>

<h1 id="cmake使用boost库"><a href="#cmake使用boost库" class="headerlink" title="cmake使用boost库"></a>cmake使用boost库</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">// CMakeLists.txt</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(boost_test)</span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED COMPONENTS system thread)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(boost_test boost_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(boost_test <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boost_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="number">1</span>;<span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;boost::<span class="built_in">bind</span>(fun,_1,_2)(m,n)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++条件运算符(?:)</title>
    <url>/blog/2022/05/03/c++%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zaishuiyifangxym/article/details/101107702?ops_request_misc=%7B%22request_id%22:%22165155021216780357213584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165155021216780357213584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-101107702.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=c++++:&spm=1018.2226.3001.4187">(130条消息) C++ 条件运算符 (?:)_TechArtisan6的博客-CSDN博客_c++条件运算符</a></p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式1 ? 表达式2 ：表达式3</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a &gt; b ? a + b : a - b;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Eigen</title>
    <url>/blog/2022/03/02/Eigen/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_40335930/article/details/93750838?ops_request_misc=%7B%22request_id%22:%22164619871816780274142755%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164619871816780274142755&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-93750838.pc_search_insert_es_download&utm_term=eigen::vector3d%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0&spm=1018.2226.3001.4187">(110条消息) EIGEN:学习笔记_hpu_lx-CSDN博客</a> </p>
<p> <a href="https://blog.csdn.net/hurmean/article/details/70143723">(110条消息) eigen与matlab对应函数列表_Hurmean的博客-CSDN博客</a> </p>
<h1 id="eigen与matlab对应函数列表"><a href="#eigen与matlab对应函数列表" class="headerlink" title="eigen与matlab对应函数列表"></a>eigen与matlab对应函数列表</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple quickref for Eigen. Add anything that&#x27;s missing.</span></span><br><span class="line"><span class="comment">// Main author: Keir Mierle</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; C;   <span class="comment">// Full dynamic. Same as MatrixXd.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></span><br><span class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 float matrix.</span></span><br><span class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 float matrix.</span></span><br><span class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 float matrix.</span></span><br><span class="line">VectorXd v;                           <span class="comment">// Dynamic column vector of doubles</span></span><br><span class="line"><span class="keyword">double</span> s;                            </span><br><span class="line"></span><br><span class="line"><span class="comment">// Basic usage</span></span><br><span class="line"><span class="comment">// Eigen          // Matlab           // comments</span></span><br><span class="line">x.size()          <span class="comment">// length(x)        // vector size</span></span><br><span class="line">C.rows()          <span class="comment">// size(C,1)        // number of rows</span></span><br><span class="line">C.cols()          <span class="comment">// size(C,2)        // number of columns</span></span><br><span class="line">x(i)              <span class="comment">// x(i+1)           // Matlab is 1-based</span></span><br><span class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       //</span></span><br><span class="line"></span><br><span class="line">A.resize(<span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">B.resize(<span class="number">4</span>, <span class="number">9</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">A.resize(<span class="number">3</span>, <span class="number">3</span>);   <span class="comment">// Ok; size didn&#x27;t change.</span></span><br><span class="line">B.resize(<span class="number">3</span>, <span class="number">9</span>);   <span class="comment">// Ok; only dynamic cols changed.</span></span><br><span class="line">                  </span><br><span class="line">A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,     <span class="comment">// Initialize A. The elements can also be</span></span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,     <span class="comment">// matrices, which are stacked along cols</span></span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;     <span class="comment">// and then the rows are stacked.</span></span><br><span class="line">B &lt;&lt; A, A, A;     <span class="comment">// B is three horizontally stacked A&#x27;s.</span></span><br><span class="line">A.fill(<span class="number">10</span>);       <span class="comment">// Fill A with all 10&#x27;s.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen                            // Matlab</span></span><br><span class="line">MatrixXd::Identity(rows,cols)       <span class="comment">// eye(rows,cols)</span></span><br><span class="line">C.setIdentity(rows,cols)            <span class="comment">// C = eye(rows,cols)</span></span><br><span class="line">MatrixXd::Zero(rows,cols)           <span class="comment">// zeros(rows,cols)</span></span><br><span class="line">C.setZero(rows,cols)                <span class="comment">// C = ones(rows,cols)</span></span><br><span class="line">MatrixXd::Ones(rows,cols)           <span class="comment">// ones(rows,cols)</span></span><br><span class="line">C.setOnes(rows,cols)                <span class="comment">// C = ones(rows,cols)</span></span><br><span class="line">MatrixXd::Random(rows,cols)         <span class="comment">// rand(rows,cols)*2-1        // MatrixXd::Random returns uniform random numbers in (-1, 1).</span></span><br><span class="line">C.setRandom(rows,cols)              <span class="comment">// C = rand(rows,cols)*2-1</span></span><br><span class="line">VectorXd::LinSpaced(size,low,high)   <span class="comment">// linspace(low,high,size)&#x27; </span></span><br><span class="line">v.setLinSpaced(size,low,high)        <span class="comment">// v = linspace(low,high,size)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Matrix slicing and blocks. All expressions listed here are read/write.</span></span><br><span class="line"><span class="comment">// Templated size versions are faster. Note that Matlab is 1-based (a size N</span></span><br><span class="line"><span class="comment">// vector is x(1)...x(N)).</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">x.head(n)                          <span class="comment">// x(1:n)</span></span><br><span class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)</span></span><br><span class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.row(i)                           <span class="comment">// P(i+1, :)</span></span><br><span class="line">P.col(j)                           <span class="comment">// P(:, j+1)</span></span><br><span class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(:, i+1:i+rows)</span></span><br><span class="line">P.middleRows(i, rows)              <span class="comment">// P(:, i+1:i+rows)</span></span><br><span class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(:, end-rows+1:end)</span></span><br><span class="line">P.bottomRows(rows)                 <span class="comment">// P(:, end-rows+1:end)</span></span><br><span class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Of particular note is Eigen&#x27;s swap function which is highly optimized.</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, i)</span></span><br><span class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Views, transpose, etc; all read-write except for .adjoint().</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.adjoint()                        <span class="comment">// R&#x27;</span></span><br><span class="line">R.transpose()                      <span class="comment">// R.&#x27; or conj(R&#x27;)</span></span><br><span class="line">R.diagonal()                       <span class="comment">// diag(R)</span></span><br><span class="line">x.asDiagonal()                     <span class="comment">// diag(x)</span></span><br><span class="line">R.transpose().colwise().reverse(); <span class="comment">// rot90(R)</span></span><br><span class="line">R.conjugate()                      <span class="comment">// conj(R)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All the same as Matlab, but matlab doesn&#x27;t have *= style operators.</span></span><br><span class="line"><span class="comment">// Matrix-vector.  Matrix-matrix.   Matrix-scalar.</span></span><br><span class="line">y  = M*x;          R  = P*Q;        R  = P*s;</span><br><span class="line">a  = b*M;          R  = P - Q;      R  = s*P;</span><br><span class="line">a *= M;            R  = P + Q;      R  = P/s;</span><br><span class="line">                   R *= Q;          R  = s*P;</span><br><span class="line">                   R += Q;          R *= s;</span><br><span class="line">                   R -= Q;          R /= s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vectorized operations on each element independently</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">R = P.cwiseProduct(Q);    <span class="comment">// R = P .* Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() * s.<span class="built_in">array</span>();<span class="comment">// R = P .* s</span></span><br><span class="line">R = P.cwiseQuotient(Q);   <span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() / Q.<span class="built_in">array</span>();<span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() + s.<span class="built_in">array</span>();<span class="comment">// R = P + s</span></span><br><span class="line">R = P.<span class="built_in">array</span>() - s.<span class="built_in">array</span>();<span class="comment">// R = P - s</span></span><br><span class="line">R.<span class="built_in">array</span>() += s;           <span class="comment">// R = R + s</span></span><br><span class="line">R.<span class="built_in">array</span>() -= s;           <span class="comment">// R = R - s</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt; Q.<span class="built_in">array</span>();    <span class="comment">// R &lt; Q</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt;= Q.<span class="built_in">array</span>();   <span class="comment">// R &lt;= Q</span></span><br><span class="line">R.cwiseInverse();         <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().inverse();      <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sin</span>()           <span class="comment">// sin(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">cos</span>()           <span class="comment">// cos(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">pow</span>(s)          <span class="comment">// P .^ s</span></span><br><span class="line">R.<span class="built_in">array</span>().square()        <span class="comment">// P .^ 2</span></span><br><span class="line">R.<span class="built_in">array</span>().cube()          <span class="comment">// P .^ 3</span></span><br><span class="line">R.cwiseSqrt()             <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sqrt</span>()          <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">exp</span>()           <span class="comment">// exp(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">log</span>()           <span class="comment">// log(P)</span></span><br><span class="line">R.cwiseMax(P)             <span class="comment">// max(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().max(P.<span class="built_in">array</span>())  <span class="comment">// max(R, P)</span></span><br><span class="line">R.cwiseMin(P)             <span class="comment">// min(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().min(P.<span class="built_in">array</span>())  <span class="comment">// min(R, P)</span></span><br><span class="line">R.cwiseAbs()              <span class="comment">// abs(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">abs</span>()           <span class="comment">// abs(P)</span></span><br><span class="line">R.cwiseAbs2()             <span class="comment">// abs(P.^2)</span></span><br><span class="line">R.<span class="built_in">array</span>().abs2()          <span class="comment">// abs(P.^2)</span></span><br><span class="line">(R.<span class="built_in">array</span>() &lt; s).select(P,Q);  <span class="comment">// (R &lt; s ? P : Q)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reductions.</span></span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">R.minCoeff()              <span class="comment">// min(R(:))</span></span><br><span class="line">R.maxCoeff()              <span class="comment">// max(R(:))</span></span><br><span class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">R.sum()                   <span class="comment">// sum(R(:))</span></span><br><span class="line">R.colwise().sum()         <span class="comment">// sum(R)</span></span><br><span class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R&#x27;)&#x27;</span></span><br><span class="line">R.prod()                  <span class="comment">// prod(R(:))</span></span><br><span class="line">R.colwise().prod()        <span class="comment">// prod(R)</span></span><br><span class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R&#x27;)&#x27;</span></span><br><span class="line">R.trace()                 <span class="comment">// trace(R)</span></span><br><span class="line">R.all()                   <span class="comment">// all(R(:))//检测矩阵中是否全为非零元素</span></span><br><span class="line">R.colwise().all()         <span class="comment">// all(R)</span></span><br><span class="line">R.rowwise().all()         <span class="comment">// all(R, 2)</span></span><br><span class="line">R.any()                   <span class="comment">// any(R(:))//检测矩阵中是否有非零元素，如果有，则返回1，否则，返回0。用法和all一样</span></span><br><span class="line">R.colwise().any()         <span class="comment">// any(R)</span></span><br><span class="line">R.rowwise().any()         <span class="comment">// any(R, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dot products, norms, etc.</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">x.norm()                  <span class="comment">// norm(x).    Note that norm(R) doesn&#x27;t work in Eigen.</span></span><br><span class="line">x.squaredNorm()           <span class="comment">// dot(x, x)   Note the equivalence is not true for complex</span></span><br><span class="line">x.dot(y)                  <span class="comment">// dot(x, y)</span></span><br><span class="line">x.cross(y)                <span class="comment">// cross(x, y) Requires #include &lt;Eigen/Geometry&gt;</span></span><br><span class="line"></span><br><span class="line"> Type conversion</span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">A.cast&lt;<span class="keyword">double</span>&gt;();                  <span class="comment">// double(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">float</span>&gt;();                   <span class="comment">// single(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">int</span>&gt;();                     <span class="comment">// int32(A)</span></span><br><span class="line">A.real();                          <span class="comment">// real(A)</span></span><br><span class="line">A.imag();                          <span class="comment">// imag(A)</span></span><br><span class="line"><span class="comment">// if the original type equals destination type, no work is done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that for most operations Eigen requires all operands to have the same type:</span></span><br><span class="line">MatrixXf F = MatrixXf::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">A += F;                <span class="comment">// illegal in Eigen. In Matlab A = A+F is allowed</span></span><br><span class="line">A += F.cast&lt;<span class="keyword">double</span>&gt;(); <span class="comment">// F converted to double and then added (generally, conversion happens on-the-fly)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen can map existing memory into Eigen matrices.</span></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">Vector3f::Map(<span class="built_in">array</span>).fill(<span class="number">10</span>);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Matrix2i <span class="title">mat2x2</span><span class="params">(data)</span></span>;                    <span class="comment">// copies data into mat2x2</span></span><br><span class="line">Matrix2i::Map(data) = <span class="number">2</span>*mat2x2;           <span class="comment">// overwrite elements of data with 2*mat2x2</span></span><br><span class="line">MatrixXi::Map(data, <span class="number">2</span>, <span class="number">2</span>) += mat2x2;      <span class="comment">// adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solve Ax = b. Result stored in x. Matlab: x = A \ b.</span></span><br><span class="line">x = A.ldlt().solve(b));  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.llt() .solve(b));  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.lu()  .solve(b));  <span class="comment">// Stable and fast. #include &lt;Eigen/LU&gt;</span></span><br><span class="line">x = A.qr()  .solve(b));  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;</span></span><br><span class="line">x = A.svd() .solve(b));  <span class="comment">// Stable, slowest. #include &lt;Eigen/SVD&gt;</span></span><br><span class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()</span></span><br><span class="line"><span class="comment">// .llt()  -&gt; .matrixL()</span></span><br><span class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()</span></span><br><span class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()</span></span><br><span class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigenvalue problems</span></span><br><span class="line"><span class="comment">// Eigen                          // Matlab</span></span><br><span class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eig</span><span class="params">(A)</span></span>;     <span class="comment">// [vec val] = eig(A)</span></span><br><span class="line">eig.eigenvalues();                <span class="comment">// diag(val)</span></span><br><span class="line">eig.eigenvectors();               <span class="comment">// vec</span></span><br><span class="line"><span class="comment">// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>c++那些事</title>
    <url>/blog/2022/05/05/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/Light-City/CPlusPlusThings">Light-City/CPlusPlusThings: C++那些事 (github.com)</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>STL库</title>
    <url>/blog/2021/10/28/STL/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%7B%22request_id%22:%22163533629716780357269545%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163533629716780357269545&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81913729.pc_search_ecpm_flag&utm_term=c+++stl&spm=1018.2226.3001.4187">C++中STL用法超详细总结</a></p>
<p><a href="https://github.com/peitianyu/MyTinySTL.git">MyTinySTL</a></p>
<h2 id="STL中六大组件："><a href="#STL中六大组件：" class="headerlink" title="STL中六大组件："></a>STL中六大组件：</h2><p><strong>容器（Container）</strong>，是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p>
<p><strong>迭代器（Iterator）</strong>，提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；<br><strong>算法（Algorithm）</strong>，是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；<br><strong>仿函数（Functor</strong>）<br><strong>适配器（Adaptor）</strong><br><strong>分配器（allocator</strong>）</p>
<h3 id="2-1-容器"><a href="#2-1-容器" class="headerlink" title="2.1 容器"></a>2.1 容器</h3><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       <strong>Vector</strong>：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>Deque</strong>：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>List</strong>：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       <strong>Set/Multiset</strong>：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       <strong>Map/Multimap</strong>：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>容器类自动申请和释放内存，无需new和delete操作。</p>
<h3 id="2-2-STL迭代器"><a href="#2-2-STL迭代器" class="headerlink" title="2.2 STL迭代器"></a>2.2 STL迭代器</h3><p><strong>Iterator</strong>（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p><strong>迭代器的作用</strong>：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p>
<h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h3><h4 id="STL中算法大致分为四类："><a href="#STL中算法大致分为四类：" class="headerlink" title="STL中算法大致分为四类："></a>STL中算法大致分为四类：</h4><p><strong>非可变序列算法</strong>：指不直接修改其所操作的容器内容的算法。<br><strong>可变序列算法</strong>：指可以修改它们所操作的容器内容的算法。<br><strong>排序算法</strong>：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。<br><strong>数值算法</strong>：对容器内容进行数值计算。<br>以下对所有算法进行细致分类并标明功能：</p>
<h4 id="lt-一-gt-查找算法-13个-：判断容器中是否包含某个值"><a href="#lt-一-gt-查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值"></a>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</h4><p>adjacent_find:   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的                                                 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>count:                利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>count_if:            利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>equal_range:     功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。<br>find:                   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的                               一个InputIterator。<br>find_end:          在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一                            个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代                               替等于操作。<br>find_first_of:     在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使                             用了用户自定义操作符。<br>find_if:               使用输入的函数代替等于操作符执行find。<br>lower_bound:   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函                             数使用自定义比较操作。<br>upper_bound:  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志                               一个大于value的值。重载函数使用自定义比较操作。<br>search:              给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位                                 置，查找失败指向last1。重载版本使用自定义的比较操作。<br>search_n:          在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p>
<h4 id="lt-二-gt-排序和通用算法-14个-：提供元素排序策略"><a href="#lt-二-gt-排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="&lt;二&gt;排序和通用算法(14个)：提供元素排序策略"></a>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</h4><p>inplace_merge:      合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>merge:                    合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>nth_element:          将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重                                    载版本使用自定义的比较操作。<br>partial_sort:            对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>partition:                 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>random_shuffle:    对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>reverse:                  将指定范围内元素重新反序排序。<br>reverse_copy:        与reverse类似，不过将结果写入另一个容器。<br>rotate:                     将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>rotate_copy:           与rotate类似，不过将结果写入另一个容器。<br>sort:                         以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>stable_sort:            与sort类似，不过保留相等元素之间的顺序关系。<br>stable_partition:    与partition类似，不过不保证保留容器中的相对顺序。</p>
<h4 id="lt-三-gt-删除和替换算法-15个"><a href="#lt-三-gt-删除和替换算法-15个" class="headerlink" title="&lt;三&gt;删除和替换算法(15个)"></a>&lt;三&gt;删除和替换算法(15个)</h4><p>copy:                    复制序列<br>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>iter_swap:           交换两个ForwardIterator的值。<br>remove:               删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和                               remove_if函数。<br>remove_copy:     将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>remove_if:           删除指定范围内输入操作结果为true的所有元素。<br>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>replace:               将指定范围内所有等于vold的元素都用vnew代替。<br>replace_copy:     与replace类似，不过将结果写入另一个容器。<br>replace_if:           将指定范围内所有操作结果为true的元素用新值代替。<br>replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>swap:                   交换存储在两个对象中的值。<br>swap_range:       将指定范围内的元素与另一个序列元素值进行交换。<br>unique:                清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>unique_copy:      与unique类似，不过把结果输出到另一个容器。</p>
<h4 id="lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合"><a href="#lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合" class="headerlink" title="&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合"></a>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</h4><p>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p>
<h4 id="lt-五-gt-算术算法-4个"><a href="#lt-五-gt-算术算法-4个" class="headerlink" title="&lt;五&gt;算术算法(4个)"></a>&lt;五&gt;算术算法(4个)</h4><p>accumulate:               iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>partial_sum:               创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>inner_product:           对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p>
<h4 id="lt-六-gt-生成和异变算法-6个"><a href="#lt-六-gt-生成和异变算法-6个" class="headerlink" title="&lt;六&gt;生成和异变算法(6个)"></a>&lt;六&gt;生成和异变算法(6个)</h4><p>fill:                 将输入值赋给标志范围内的所有元素。<br>fill_n:            将输入值赋给first到first+n范围内的所有元素。<br>for_each:      用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>generate:      连续调用输入的函数来填充指定的范围。<br>generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>transform:    将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p>
<h4 id="lt-七-gt-关系算法-8个"><a href="#lt-七-gt-关系算法-8个" class="headerlink" title="&lt;七&gt;关系算法(8个)"></a>&lt;七&gt;关系算法(8个)</h4><p>equal:                                  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>includes:                             判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>max:                                     返回两个元素中较大一个。重载版本使用自定义比较操作。<br>max_element:                      返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>min:                                      返回两个元素中较小一个。重载版本使用自定义比较操作。<br>min_element:                       返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>mismatch:                            并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p>
<h4 id="lt-八-gt-集合算法-4个"><a href="#lt-八-gt-集合算法-4个" class="headerlink" title="&lt;八&gt;集合算法(4个)"></a>&lt;八&gt;集合算法(4个)</h4><p>set_union:                            构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>set_intersection:                 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>set_difference:                    构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用 自定义的比较操作。<br>set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</p>
<h4 id="lt-九-gt-堆算法-4个"><a href="#lt-九-gt-堆算法-4个" class="headerlink" title="&lt;九&gt;堆算法(4个)"></a>&lt;九&gt;堆算法(4个)</h4><p>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>pop_heap:   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>sort_heap:  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p>
<h3 id="2-4-仿函数"><a href="#2-4-仿函数" class="headerlink" title="2.4 仿函数"></a>2.4 仿函数</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><pre><code>    仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。
</code></pre>
<p>　　有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。</p>
<pre><code>   1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。

   2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。
</code></pre>
<h4 id="2-4-2-仿函数-functor-在编程语言中的应用"><a href="#2-4-2-仿函数-functor-在编程语言中的应用" class="headerlink" title="2.4.2 仿函数(functor)在编程语言中的应用"></a>2.4.2 仿函数(functor)在编程语言中的应用</h4><p>1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//int sort_function( const void *a, const void *b);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> list[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line">   <span class="built_in">qsort</span>((<span class="keyword">void</span> *)list, <span class="number">5</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(list[<span class="number">0</span>]), sort_function);<span class="comment">//起始地址，个数，元素大小，回调函数 </span></span><br><span class="line">   <span class="keyword">int</span>  x;</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, list[x]);</span><br><span class="line">			      </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	for_each(ia, ia + <span class="number">5</span>, display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-仿函数在STL中的定义"><a href="#2-4-3-仿函数在STL中的定义" class="headerlink" title="2.4.3 仿函数在STL中的定义"></a>2.4.3 仿函数在STL中的定义</h4><p>要使用STL内建的仿函数，必须包含<functional>头文件。而头文件中包含的仿函数分类包括</p>
<pre><code>1）算术类仿函数
    加：plus&lt;T&gt;
    减：minus&lt;T&gt;
    乘：multiplies&lt;T&gt;
    除：divides&lt;T&gt;
    模取：modulus&lt;T&gt;
    否定：negate&lt;T&gt;
</code></pre>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="comment">//120</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>, multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//15</span></span><br><span class="line">	cout &lt;&lt; multiplies&lt;<span class="keyword">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	modulus&lt;<span class="keyword">int</span>&gt;  modulusObj;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">modulusObj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2）关系运算类仿函数</p>
<pre><code>           等于：equal_to&lt;T&gt;

           不等于：not_equal_to&lt;T&gt;

           大于：greater&lt;T&gt;

           大于等于：greater_equal&lt;T&gt;

           小于：less&lt;T&gt;

           小于等于：less_equal&lt;T&gt;

          从大到小排序：
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">sort</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3）逻辑运算仿函数</p>
<pre><code>             逻辑与：logical_and&lt;T&gt;

             逻辑或：logical_or&lt;T&gt;

             逻辑否：logical_no&lt;T&gt;
</code></pre>
<p>除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结</p>
<h3 id="2-5-容器适配器"><a href="#2-5-容器适配器" class="headerlink" title="2.5 容器适配器"></a>2.5 容器适配器</h3><p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p>
<p>什么是容器适配器<br>   ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例        如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出      了栈的行为）。</p>
<p>容器适配器<br>   要使用适配器，需要加入一下头文件：</p>
<pre><code>#include &lt;stack&gt;        //stack
#include&lt;queue&gt;       //queue、priority_queue
</code></pre>
<p>种类    默认顺序容器    可用顺序容器    说明<br>stack    deque    vector、list、deque<br>queue    deque    list、deque    基础容器必须提供push_front()运算<br>priority_queue    vector    vector、deque    基础容器必须提供随机访问功能<br>定义适配器<br>  1、初始化</p>
<pre><code>    stack&lt;int&gt; stk(dep);
</code></pre>
<p>  2、覆盖默认容器类型</p>
<pre><code>   stack&lt;int,vector&lt;int&gt; &gt; stk;
</code></pre>
<p>使用适配器</p>
<h4 id="2-5-1-stack"><a href="#2-5-1-stack" class="headerlink" title="2.5.1 stack"></a>2.5.1 stack</h4><p>stack<int> s;<br>stack&lt; int, vector<int> &gt; stk;  //覆盖基础容器类型，使用vector实现stk<br>s.empty();  //判断stack是否为空，为空返回true，否则返回false<br>s.size();   //返回stack中元素的个数<br>s.pop();    //删除栈顶元素，但不返回其值<br>s.top();    //返回栈顶元素的值，但不删除此元素<br>s.push(item);   //在栈顶压入新元素item<br>实例：括号匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	stack&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s)  <span class="comment">//C++11新标准，即遍历一次字符串s</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ss.<span class="built_in">push</span>(c);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; ss.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;					</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; <span class="string">&quot;Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;Not Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-queue-amp-priority-queue"><a href="#2-5-2-queue-amp-priority-queue" class="headerlink" title="2.5.2 queue &amp; priority_queue"></a>2.5.2 queue &amp; priority_queue</h4><p>queue<int> q; //priority_queue<int> q;<br>q.empty();  //判断队列是否为空<br>q.size();   //返回队列长度<br>q.push(item);   //对于queue，在队尾压入一个新元素<br>               //对于priority_queue，在基于优先级的适当位置插入新元素</p>
<p>//queue only:<br>q.front();  //返回队首元素的值，但不删除该元素<br>q.back();   //返回队尾元素的值，但不删除该元素</p>
<p>//priority_queue only:<br>q.top();    //返回具有最高优先级的元素值，但不删除该元素</p>
<h2 id="常用容器用法介绍"><a href="#常用容器用法介绍" class="headerlink" title="常用容器用法介绍"></a>常用容器用法介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h5><p>vector():创建一个空vector<br>vector(int nSize):创建一个vector,元素个数为nSize<br>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>vector(const vector&amp;):复制构造函数<br>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p>
<h5 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h5><p>void push_back(const T&amp; x):向量尾部增加一个元素X<br>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>
<h5 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h5><p>iterator erase(iterator it):删除向量中迭代器指向元素<br>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>void pop_back():删除向量中最后一个元素<br>void clear():清空向量中所有元素</p>
<h5 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h5><p>reference at(int pos):返回pos位置元素的引用<br>reference front():返回首元素的引用<br>reference back():返回尾元素的引用<br>iterator begin():返回向量头指针，指向第一个元素<br>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p>
<h5 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h5><p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p>
<h5 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h5><p>int size() const:返回向量中元素的个数<br>int capacity() const:返回当前向量张红所能容纳的最大元素值<br>int max_size() const:返回最大可允许的vector元素数量值</p>
<h5 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h5><p>void swap(vector&amp;):交换两个同类型向量的数据<br>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
<h5 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h5><p>1.push_back 在数组的最后添加一个数据</p>
<p>2.pop_back 去掉数组的最后一个数据</p>
<p>3.at 得到编号位置的数据</p>
<p>4.begin 得到数组头的指针</p>
<p>5.end 得到数组的最后一个单元+1的指针</p>
<p>6．front 得到数组头的引用</p>
<p>7.back 得到数组的最后一个单元的引用</p>
<p>8.max_size 得到vector最大可以是多大</p>
<p>9.capacity 当前vector分配的大小</p>
<p>10.size 当前使用数据的大小</p>
<p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p>
<p>12.reserve 改变当前vecotr所分配空间的大小</p>
<p>13.erase 删除指针指向的数据项</p>
<p>14.clear 清空当前的vector</p>
<p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p>
<p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p>
<p>17.empty 判断vector是否为空</p>
<p>18.swap 与另一个vector交换数据</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>#include &lt; vector&gt;<br>using namespace std;</p>
<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>Vector&lt;类型&gt;标识符<br>Vector&lt;类型&gt;标识符(最大容量)<br>Vector&lt;类型&gt;标识符(最大容量,初始所有值)<br>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值<br>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a>3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//去掉数组最后一个数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)<span class="comment">//size()容器中实际数据个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br><span class="line"></span><br><span class="line">0,1,2,3,4,</span><br></pre></td></tr></table></figure>

<h5 id="clear-清除容器中所有数据"><a href="#clear-清除容器中所有数据" class="headerlink" title="clear()清除容器中所有数据"></a>clear()清除容器中所有数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">clear</span>();<span class="comment">//清除容器中所以数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sort</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从小到大</span></span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从小到大:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从大到小:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从大到小 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从小到大:</span><br><span class="line">0,1,3,</span><br><span class="line"></span><br><span class="line">从大到小:</span><br><span class="line">3,1,0,</span><br></pre></td></tr></table></figure>

<p>1.注意 sort 需要头文件 #include <algorithm></p>
<p>2.如果想 sort 来降序，可重写 sort</p>
<p>bool compare(int a,int b)<br>{<br>    return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序<br>}<br>int a[20]={2,4,1,23,5,76,0,43,24,65},i;<br>for(i=0;i&lt;20;i++)<br>    cout&lt;&lt; a[i]&lt;&lt; endl;<br>sort(a,a+20,compare);</p>
<h5 id="访问（直接数组访问-amp-迭代器访问）"><a href="#访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="访问（直接数组访问&amp;迭代器访问）"></a>访问（直接数组访问&amp;迭代器访问）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序访问</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);   </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;直接利用数组：&quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//方法一 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;利用迭代器：&quot;</span> ;</span><br><span class="line">    <span class="comment">//方法二，使用迭代器将容器中数据输出 </span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.<span class="built_in">begin</span>();it!=obj.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接利用数组：0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">利用迭代器：0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h5 id="二维数组两种定义方法（结果一样）"><a href="#二维数组两种定义方法（结果一样）" class="headerlink" title="二维数组两种定义方法（结果一样）"></a>二维数组两种定义方法（结果一样）</h5><p>方法一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N, vector&lt;<span class="keyword">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">3.2 deque</span><br></pre></td></tr></table></figure>

<p>所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 </p>
<p>Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 </p>
<p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 </p>
<p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>#include<deque>  // 头文件<br>deque<type> deq;  // 声明一个元素类型为type的双端队列que<br>deque<type> deq(size);  // 声明一个类型为type、含有size个默认值初始化元素的的双端队列que<br>deque<type> deq(size, value);  // 声明一个元素类型为type、含有size个value元素的双端队列que<br>deque<type> deq(mydeque);  // deq是mydeque的一个副本<br>deque<type> deq(first, last);  // 使用迭代器first、last范围内的元素初始化deq</p>
<h4 id="deque的常用成员函数"><a href="#deque的常用成员函数" class="headerlink" title="deque的常用成员函数"></a>deque的常用成员函数</h4><p>deque<int> deq;<br>deq[ ]：用来访问双向队列中单个的元素。<br>deq.front()：返回第一个元素的引用。<br>deq.back()：返回最后一个元素的引用。<br>deq.push_front(x)：把元素x插入到双向队列的头部。<br>deq.pop_front()：弹出双向队列的第一个元素。<br>deq.push_back(x)：把元素x插入到双向队列的尾部。<br>deq.pop_back()：弹出双向队列的最后一个元素。</p>
<h4 id="deque的一些特点"><a href="#deque的一些特点" class="headerlink" title="deque的一些特点"></a>deque的一些特点</h4><p>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。<br>可以在内部进行插入和删除操作，但性能不及list。<br>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。<br>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。<br>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。<br>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。<br>deque不支持对容量和内存分配时机的控制。<br>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。<br>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。<br>deque不提供容量操作：capacity()和reverse()，但是vector可以。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;                                  <span class="comment">/*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/</span></span><br><span class="line">	q.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">front</span>());    <span class="comment">/*清除第一个元素后输出第一个(6)*/</span></span><br><span class="line">	q.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">back</span>());     <span class="comment">/*清除最后一个元素后输出最后一个(7)*/</span></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = q.<span class="built_in">begin</span>(); it != q.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="list定义"><a href="#list定义" class="headerlink" title="list定义"></a>list定义</h4><p>List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件</p>
<p>#include <list></p>
<h4 id="list定义和初始化"><a href="#list定义和初始化" class="headerlink" title="list定义和初始化"></a>list定义和初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;int&gt;lst1;          //创建空list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lst2(5);       //创建含有5个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst3(3,2);  //创建含有3个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst4(lst2);    //使用lst2初始化lst4</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst5(lst2.begin(),lst2.end());  //同lst4</span><br></pre></td></tr></table></figure>

<h4 id="list常用操作函数"><a href="#list常用操作函数" class="headerlink" title="list常用操作函数"></a>list常用操作函数</h4><p>Lst1.assign() 给list赋值<br>Lst1.back() 返回最后一个元素<br>Lst1.begin() 返回指向第一个元素的迭代器<br>Lst1.clear() 删除所有元素<br>Lst1.empty() 如果list是空的则返回true<br>Lst1.end() 返回末尾的迭代器<br>Lst1.erase() 删除一个元素<br>Lst1.front() 返回第一个元素<br>Lst1.get_allocator() 返回list的配置器<br>Lst1.insert() 插入一个元素到list中<br>Lst1.max_size() 返回list能容纳的最大元素数量<br>Lst1.merge() 合并两个list<br>Lst1.pop_back() 删除最后一个元素<br>Lst1.pop_front() 删除第一个元素<br>Lst1.push_back() 在list的末尾添加一个元素<br>Lst1.push_front() 在list的头部添加一个元素<br>Lst1.rbegin() 返回指向第一个元素的逆向迭代器<br>Lst1.remove() 从list删除元素<br>Lst1.remove_if() 按指定条件删除元素<br>Lst1.rend() 指向list末尾的逆向迭代器<br>Lst1.resize() 改变list的大小<br>Lst1.reverse() 把list的元素倒转<br>Lst1.size() 返回list中的元素个数<br>Lst1.sort() 给list排序<br>Lst1.splice() 合并两个list<br>Lst1.swap() 交换两个list<br>Lst1.unique() 删除list中相邻重复的元素</p>
<h4 id="List使用实例"><a href="#List使用实例" class="headerlink" title="List使用实例"></a>List使用实例</h4><h5 id="迭代器遍历list"><a href="#迭代器遍历list" class="headerlink" title="迭代器遍历list"></a>迭代器遍历list</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++)</span><br><span class="line">   &#123;</span><br><span class="line">     cout&lt;&lt;*iter;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h5 id="综合实例1"><a href="#综合实例1" class="headerlink" title="综合实例1"></a>综合实例1</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTINT;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTCHAR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//用LISTINT创建一个list对象</span></span><br><span class="line">	LISTINT listOne;</span><br><span class="line">	<span class="comment">//声明i为迭代器</span></span><br><span class="line">	LISTINT::iterator i;</span><br><span class="line"></span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">	listOne.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">	 </span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	listOne.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listOne.begin()--- listOne.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (i = listOne.<span class="built_in">begin</span>(); i != listOne.<span class="built_in">end</span>(); ++i)</span><br><span class="line">		cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	LISTINT::reverse_iterator ir;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listOne.rbegin()---listOne.rend():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (ir = listOne.<span class="built_in">rbegin</span>(); ir != listOne.<span class="built_in">rend</span>(); ir++) &#123;</span><br><span class="line">		cout &lt;&lt; *ir &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">accumulate</span>(listOne.<span class="built_in">begin</span>(), listOne.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sum=&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//用LISTCHAR创建一个list对象</span></span><br><span class="line">	LISTCHAR listTwo;</span><br><span class="line">	<span class="comment">//声明i为迭代器</span></span><br><span class="line">	LISTCHAR::iterator j;</span><br><span class="line">	 </span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	 </span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">	listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listTwo.begin()---listTwo.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = listTwo.<span class="built_in">begin</span>(); j != listTwo.<span class="built_in">end</span>(); ++j)</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	j = <span class="built_in">max_element</span>(listTwo.<span class="built_in">begin</span>(), listTwo.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The maximum element in listTwo is: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<h5 id="综合实例2"><a href="#综合实例2" class="headerlink" title="综合实例2"></a>综合实例2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; INTLIST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前向后显示list队列的全部元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_list</span><span class="params">(INTLIST list, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INTLIST::iterator plist;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The contents of &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (plist = list.<span class="built_in">begin</span>(); plist != list.<span class="built_in">end</span>(); plist++)</span><br><span class="line">		cout &lt;&lt; *plist &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试list容器的功能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//list1对象初始为空 </span></span><br><span class="line">	INTLIST list1;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list2</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list3</span><span class="params">(list2.begin(), --list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//声明一个名为i的双向迭代器 </span></span><br><span class="line">	INTLIST::iterator i;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	list1.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.push_back(7) and list1.push_back(8):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">	list1.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.push_front(6) and list1.push_front(5):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">insert</span>(++list1.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.insert(list1.begin()+1,3,9):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//测试引用类函数 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.front()=&quot;</span> &lt;&lt; list1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.back()=&quot;</span> &lt;&lt; list1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">pop_front</span>();</span><br><span class="line">	list1.<span class="built_in">pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.pop_front() and list1.pop_back():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">erase</span>(++list1.<span class="built_in">begin</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.erase(++list1.begin()):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list2.<span class="built_in">assign</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list2.assign(8,1):&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.max_size(): &quot;</span> &lt;&lt; list1.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.size(): &quot;</span> &lt;&lt; list1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1.empty(): &quot;</span> &lt;&lt; list1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1&gt;list3: &quot;</span> &lt;&lt; (list1 &gt; list3) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;list1&lt;list3: &quot;</span> &lt;&lt; (list1 &lt; list3) &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">sort</span>();</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	list1.<span class="built_in">splice</span>(++list1.<span class="built_in">begin</span>(), list3);</span><br><span class="line">	<span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">	<span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。</p>
<p>C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。</p>
<p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p>
<h4 id="基本操作函数"><a href="#基本操作函数" class="headerlink" title="基本操作函数"></a>基本操作函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin()         返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素</span><br><span class="line"></span><br><span class="line">find()          查找一个元素</span><br><span class="line"></span><br><span class="line">get_allocator() 返回map的配置器</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()          返回map中元素的个数</span><br><span class="line"></span><br><span class="line">swap()           交换两个map</span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头文件</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; ID_Name;</span><br></pre></td></tr></table></figure>

<p>// 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; 2015, &quot;Jim&quot; &#125;,</span><br><span class="line">                &#123; 2016, &quot;Tom&quot; &#125;,</span><br><span class="line">                &#123; 2017, &quot;Bob&quot; &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。</p>
<p>二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt;::iterator it;</span><br><span class="line">map&lt;int,int&gt; mmap;</span><br><span class="line">const map&lt;int,int&gt; const_mmap;</span><br><span class="line"></span><br><span class="line">it = mmap.begin(); //iterator</span><br><span class="line">mmap.cbegin(); //const_iterator</span><br><span class="line"></span><br><span class="line">const_mmap.begin(); //const_iterator</span><br><span class="line">const_mmap.cbegin(); //const_iterator</span><br></pre></td></tr></table></figure>

<p>返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h5 id="用insert插入pair数据"><a href="#用insert插入pair数据" class="headerlink" title="用insert插入pair数据"></a>用insert插入pair数据</h5><p>//数据的插入–第一种：用insert函数插入pair数据  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用insert函数插入value-type数据"><a href="#用insert函数插入value-type数据" class="headerlink" title="用insert函数插入value_type数据"></a>用insert函数插入value_type数据</h5><p>//第二种：用insert函数插入value_type数据，下面举例说明  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用insert函数进行多个插入"><a href="#用insert函数进行多个插入" class="headerlink" title="用insert函数进行多个插入"></a>用insert函数进行多个插入</h5><p>insert共有4个重载函数：</p>
<p>// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败<br>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</p>
<p>//在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排<br>iterator insert (const_iterator position, const value_type&amp; val);</p>
<p>// 插入多个<br>void insert (InputIterator first, InputIterator last);</p>
<p>//c++11开始支持，使用列表插入多个<br>void insert (initializer_list<value_type> il);<br>下面是具体使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入单个值</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">200</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回插入位置以及是否插入成功</span></span><br><span class="line">    std::pair&lt;std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;element &#x27;z&#x27; already existed&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; with a value of &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">300</span>));  <span class="comment">//效率更高</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>, <span class="number">400</span>));  <span class="comment">//效率非最高</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//范围多值插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; anothermap;</span><br><span class="line">    anothermap.<span class="built_in">insert</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 列表形式插入</span></span><br><span class="line">    anothermap.<span class="built_in">insert</span>(&#123; &#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">100</span> &#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">200</span>&#125; &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用数组方式插入数据"><a href="#用数组方式插入数据" class="headerlink" title="用数组方式插入数据"></a>用数组方式插入数据</h5><p>//第三种：用数组方式插入数据，下面举例说明  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[1] = &quot;student_one&quot;;   </span><br><span class="line">    mapStudent[2] = &quot;student_two&quot;;    </span><br><span class="line">    mapStudent[3] = &quot;student_three&quot;;    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br><span class="line"></span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;));</span><br></pre></td></tr></table></figure>

<p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br></pre></td></tr></table></figure>

<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>
<p>下面给出完成代码，演示插入成功与否问题</p>
<p>//验证插入函数的作用效果  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;   </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> 大家可以用如下程序，看下用数组插入在数据覆盖上的效果</p>
<p>//验证数组形式插入数据的效果   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_two&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_three&quot;</span>;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="查找、删除、交换"><a href="#查找、删除、交换" class="headerlink" title="查找、删除、交换"></a>查找、删除、交换</h4><p><strong>查找</strong></p>
<p>// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器<br>// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator<br>iterator find (const key_type&amp; k);<br>const_iterator find (const key_type&amp; k) const;<br> <strong>删除</strong></p>
<p>// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器<br>iterator erase( iterator pos )</p>
<p>// 删除一定范围内的元素，并返回一个指向下一元素的迭代器<br>iterator erase( const_iterator first, const_iterator last );</p>
<p>// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1<br>size_t erase( const key_type&amp; key );</p>
<p>// 清空map，清空后的size为0<br>void clear();<br><strong>交换</strong> </p>
<p>// 就是两个map的内容互换<br>void swap( map&amp; other );</p>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>// 查询map是否为空<br>bool empty();</p>
<p>// 查询map中键值对的数量<br>size_t size();</p>
<p>// 查询map所能包含的最大键值对数量，和系统和应用库有关。<br>// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了<br>size_t max_size();</p>
<p>// 查询关键字为key的元素的个数，在map里结果非0即1<br>size_t count( const Key&amp; key ) const; //</p>
<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p>
<p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。</p>
<h5 id="小于号-lt-重载"><a href="#小于号-lt-重载" class="headerlink" title="小于号 &lt; 重载"></a>小于号 &lt; 重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (tagStudentinfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></span><br><span class="line">	&#123;     <span class="comment">//这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </span></span><br><span class="line">		<span class="keyword">if</span> (niD &lt; _A.niD) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (niD == _A.niD)</span><br><span class="line">			<span class="keyword">return</span> strName.<span class="built_in">compare</span>(_A.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nSize;   <span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="仿函数的应用，这个时候结构体中没有直接的小于号重载"><a href="#仿函数的应用，这个时候结构体中没有直接的小于号重载" class="headerlink" title="仿函数的应用，这个时候结构体中没有直接的小于号重载"></a>仿函数的应用，这个时候结构体中没有直接的小于号重载</h5><p>//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Studentinfo <span class="keyword">const</span> &amp;_A, Studentinfo <span class="keyword">const</span> &amp;_B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD &lt; _B.niD)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD == _B.niD)</span><br><span class="line">			<span class="keyword">return</span> _A.strName.<span class="built_in">compare</span>(_B.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>, sort&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？</p>
<p>   map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。</p>
<p>   unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。</p>
<p>   还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。</p>
<p>   最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。</p>
<p>至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。</p>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>std::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。</p>
<p>set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p>
<p>由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。</p>
<p>　　multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p>
<p>　　set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。</p>
<h4 id="set常用成员函数"><a href="#set常用成员函数" class="headerlink" title="set常用成员函数"></a>set常用成员函数</h4><ol>
<li><p>begin()–返回指向第一个元素的迭代器</p>
</li>
<li><p>clear()–清除所有元素</p>
</li>
<li><p>count()–返回某个值元素的个数</p>
</li>
<li><p>empty()–如果集合为空，返回true</p>
</li>
<li><p>end()–返回指向最后一个元素的迭代器</p>
</li>
<li><p>equal_range()–返回集合中与给定值相等的上下限的两个迭代器</p>
</li>
<li><p>erase()–删除集合中的元素</p>
</li>
<li><p>find()–返回一个指向被查找到元素的迭代器</p>
</li>
<li><p>get_allocator()–返回集合的分配器</p>
</li>
<li><p>insert()–在集合中插入元素</p>
</li>
<li><p>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器</p>
</li>
<li><p>key_comp()–返回一个用于元素间值比较的函数</p>
</li>
<li><p>max_size()–返回集合能容纳的元素的最大限值</p>
</li>
<li><p>rbegin()–返回指向集合中最后一个元素的反向迭代器</p>
</li>
<li><p>rend()–返回指向集合中第一个元素的反向迭代器</p>
</li>
<li><p>size()–集合中元素的数目</p>
</li>
<li><p>swap()–交换两个集合变量</p>
</li>
<li><p>upper_bound()–返回大于某个值元素的迭代器</p>
</li>
<li><p>value_comp()–返回一个用于比较元素间的值的函数</p>
</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p> 以下代码涉及的内容：<br>1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？</p>
<p>2、set容器中，如何让元素类型为自定义类型？</p>
<p>3、set容器的insert函数的返回值为什么类型？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数CompareSet，在test02使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="comment">//bool operator()(int v1, int v2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    return v1 &lt; v2;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person类，用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; person.mName &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数ComparePerson,用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//名字大的在前面，如果名字相同，年龄大的排前面</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.mName == p2.mName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.mName &gt; p2.mName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//set容器默认从小到大排序</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:10 20 30</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* set的insert函数返回值为一个对组(pair)。</span></span><br><span class="line"><span class="comment">       对组的第一个值first为set类型的迭代器：</span></span><br><span class="line"><span class="comment">       1、若插入成功，迭代器指向该元素。</span></span><br><span class="line"><span class="comment">       2、若插入失败，迭代器指向之前已经存在的元素</span></span><br><span class="line"><span class="comment">       对组的第二个值seconde为bool类型：</span></span><br><span class="line"><span class="comment">       1、若插入成功，bool值为true</span></span><br><span class="line"><span class="comment">       2、若插入失败，bool值为false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == ret.second)</span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果想让set容器从大到小排序，需要给set容</span></span><br><span class="line"><span class="comment">       器提供一个仿函数,本例的仿函数为CompareSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, CompareSet&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:30,20,10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* set元素类型为Person，当set元素类型为自定义类型的时候</span></span><br><span class="line"><span class="comment">       必须给set提供一个仿函数，用于比较自定义类型的大小，</span></span><br><span class="line"><span class="comment">       否则无法通过编译 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;Person,ComparePerson&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Marry&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">36</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multiset容器的insert函数返回值为什么？ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印multiset</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* multiset的insert函数返回值为multiset类型的迭代器，</span></span><br><span class="line"><span class="comment">       指向新插入的元素。multiset允许插入相同的值，因此</span></span><br><span class="line"><span class="comment">       插入一定成功，因此不需要返回bool类型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator iter = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><p>C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。</p>
<pre><code>    unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:
</code></pre>
<p> 使用unordered_set需要包含#include<unordered_set>头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。</p>
<p>除此之外unordered_multiset也是一种可选的容器。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>USBCAN/CANalyst-II</title>
    <url>/blog/2021/11/11/USBCAN/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/muyoufansem/article/details/117955581?ops_request_misc=&request_id=&biz_id=102&utm_term=canalyst&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117955581.pc_search_mgc_flag&spm=1018.2226.3001.4187">(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动</a></p>
<p><a href="https://blog.csdn.net/qq_38766896/article/details/109404097?ops_request_misc=%7B%22request_id%22:%22163642380516780264058809%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163642380516780264058809&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109404097.pc_search_mgc_flag&utm_term=canalyst-ii+linux&spm=1018.2226.3001.4187">Ubuntu16.04 （ROS）下通过CAN分析仪（USBCAN/CANalyst-II）调试无人车助力转向电机（1）_秋名山的过客-CSDN博客</a></p>
<p><a href="http://www.gcgd.net/newsinfo_726.html">USBCAN在Linux系统下使用说明 (gcgd.net)</a></p>
<p><a href="https://blog.csdn.net/qq_41545537/article/details/106714246?ops_request_misc=%7B%22request_id%22:%22163607238916780271515211%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163607238916780271515211&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-106714246.pc_search_mgc_flag&utm_term=ubuntucan%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">ubuntu下研华工控机CAN卡驱动的安装与测试_星辰和大海都需要门票的博客-CSDN博客</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>介绍两款使用过的<code>usb</code>转<code>can</code>的使用方法</p>
<p>一款是广成科技的<code>USBCAN-I PRO</code><a href="http://www.gcgd.net/tecrjlist.html">资料下载 (gcgd.net)</a></p>
<p>一款是创芯科技的<code>CANalyst</code><a href="https://www.zhcxgd.com/ZLXZ.html">珠海创芯科技有限公司 - 珠海创芯科技 (zhcxgd.com)</a></p>
<h1 id="软件安装与使用"><a href="#软件安装与使用" class="headerlink" title="软件安装与使用"></a>软件安装与使用</h1><h2 id="USBCAN"><a href="#USBCAN" class="headerlink" title="USBCAN:"></a>USBCAN:</h2><p><a href="http://www.gcgd.net/newsinfo_388.html">沈阳广成科技USBCAN系列产品驱动安装及ECANTools软件使用方法 (gcgd.net)</a></p>
<p><a href="https://pan.baidu.com/s/10R7zou8yxzarjlwlJkeN1A#list/path=%2FGC-USBCAN-----%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%B9%E9%80%89%E6%8B%A9%E9%9C%80%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6">GC-USBCAN—–点击进入文件夹选择需要下载的文件_免费高速下载|百度网盘-分享无限制 (baidu.com)</a></p>
<h2 id="CANalyst"><a href="#CANalyst" class="headerlink" title="CANalyst:"></a>CANalyst:</h2><p><a href="https://blog.csdn.net/muyoufansem/article/details/117955581?ops_request_misc=&request_id=&biz_id=102&utm_term=canalyst&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117955581.pc_search_mgc_flag&spm=1018.2226.3001.4187">(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动</a></p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="建议采用官方例程至少不会出错"><a href="#建议采用官方例程至少不会出错" class="headerlink" title="!建议采用官方例程至少不会出错"></a>!建议采用官方例程至少不会出错</h2><h2 id="这里推荐两个例程可以验证学习"><a href="#这里推荐两个例程可以验证学习" class="headerlink" title="这里推荐两个例程可以验证学习"></a>这里推荐两个例程可以验证学习</h2><p><a href="https://github.com/VincentCheungM/ESR_canalyst_ros">VincentCheungM/ESR_canalyst_ros: A warped ROS driver for CANalyst-II and ESR Radar (github.com)</a></p>
<p><a href="https://github.com/Andy-jg/RaspberryCanalyst-2">Andy-jg/RaspberryCanalyst-2: linux use the canalyst-2 (github.com)</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="!注意"></a>!注意</h1><p>由于can驱动使用时每次都需要<code>sudo</code>,可以加配置,这样就不需要每次都<code>sudo</code>了</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/udev/rules.d/99-myusb.rules</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;,</span><br><span class="line">GROUP=&quot;users&quot;, MODE=&quot;0777&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>carto建图与定位</title>
    <url>/blog/2022/04/18/carto%E5%BB%BA%E5%9B%BE%E4%B8%8E%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_36976685/article/details/103834608?ops_request_misc=%7B%22request_id%22:%22165025689116780271994944%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165025689116780271994944&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-103834608.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=cartographer%E7%BA%AF%E5%AE%9A%E4%BD%8D&spm=1018.2226.3001.4187">(124条消息) Cartographer用于机器人纯定位_梦凝小筑的博客-CSDN博客_cartographer纯定位</a></p>
<p><a href="https://blog.csdn.net/qq_41807801/article/details/112058770?ops_request_misc=%7B%22request_id%22:%22165025403116780269840689%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165025403116780269840689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112058770.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=cartographer%E5%BB%BA%E5%9B%BE&spm=1018.2226.3001.4187">(124条消息) 使用Cartographer2D建图_熊铁树的博客-CSDN博客_cartographer建图流程</a></p>
<p><a href="https://blog.csdn.net/zhao_ke_xue/article/details/87875984?ops_request_misc=&request_id=&biz_id=102&utm_term=cartographer%E5%BB%BA%E5%9B%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-87875984.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(124条消息) 用自己的机器人实现cartographer建图测试与地图保存应该这样做_白茶-清欢的博客-CSDN博客_cartographer建图</a></p>
<p><a href="https://blog.csdn.net/weixin_43259286/article/details/105143605?ops_request_misc=&request_id=&biz_id=102&utm_term=cartographer%E7%BA%AF%E5%AE%9A%E4%BD%8D%E5%AF%BC%E8%88%AAmapserver&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105143605.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(125条消息) 【移动机器人技术】Cartographer使用流程-建图-纯定位-导航_A MAN NAMED MAGIC的博客-CSDN博客_cartographer 定位</a></p>
<p><a href="https://blog.csdn.net/yuexiaduzhui/article/details/108124038">(127条消息) ROS SLAM功能包应用方法–cartographer_鸢雨如歌的博客-CSDN博客_cartographer 导航</a></p>
<p><a href="https://blog.csdn.net/QLeelq/article/details/112237663?ops_request_misc=%7B%22request_id%22:%22165028205416780255271354%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165028205416780255271354&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-112237663.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=cartographer+%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187">(127条消息) cartographer建图参数配置详细说明_非晚非晚的博客-CSDN博客_cartographer参数配置</a></p>
<h1 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h1><p>demo_revo_lds.launch</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动仿真程序 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;include file=&quot;$(find robot_sim_demo)/launch/robot_spawn.launch&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动关键的建图节点，这是我们主要要更改的地方，更改下面的configuration_directory和configuration_basename的路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find carto)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename revo_lds.lua&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 更改horizontal_laser_2d为我们的雷达话题 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;remap from=&quot;scan&quot; to=&quot;scan&quot; /&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 更改odom为里程计话题 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;remap from=&quot;odom&quot; to=&quot;odom&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 一般不更改，有个建图分辨率参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_occupancy_grid_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_occupancy_grid_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-resolution 0.05&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下面这两个一般直接注释掉，我们自己需要再启动就可以了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">args</span>=<span class="string">&quot;-d $(find carto)/rviz/cartographer.rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件 revo_lds.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;map_builder.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;trajectory_builder.lua&quot;</span></span><br><span class="line"></span><br><span class="line">options = &#123;</span><br><span class="line">  map_builder = MAP_BUILDER,</span><br><span class="line">  trajectory_builder = TRAJECTORY_BUILDER,</span><br><span class="line">  map_frame = <span class="string">&quot;map&quot;</span>,</span><br><span class="line">	<span class="comment">-- tracking_frame更改为我们机器人的基坐标tf，一般是base_link，</span></span><br><span class="line">  tracking_frame = <span class="string">&quot;base_link&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 以下四个参数与里程计有关，在下面进行单独说明</span></span><br><span class="line">  odom_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">  published_frame = <span class="string">&quot;base_link&quot;</span>,</span><br><span class="line">  provide_odom_frame = <span class="literal">false</span>,</span><br><span class="line">	use_odometry = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  publish_frame_projected_to_2d = <span class="literal">false</span>,</span><br><span class="line">  use_pose_extrapolator = <span class="literal">true</span>,</span><br><span class="line">  use_nav_sat = <span class="literal">false</span>,</span><br><span class="line">  use_landmarks = <span class="literal">false</span>,</span><br><span class="line">  num_laser_scans = <span class="number">1</span>,</span><br><span class="line">  num_multi_echo_laser_scans = <span class="number">0</span>,</span><br><span class="line">  num_subdivisions_per_laser_scan = <span class="number">1</span>,</span><br><span class="line">  num_point_clouds = <span class="number">0</span>,</span><br><span class="line">  lookup_transform_timeout_sec = <span class="number">0.2</span>,</span><br><span class="line">  submap_publish_period_sec = <span class="number">0.3</span>,</span><br><span class="line">  pose_publish_period_sec = <span class="number">5e-3</span>,</span><br><span class="line">  trajectory_publish_period_sec = <span class="number">30e-3</span>,</span><br><span class="line">  rangefinder_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  odometry_sampling_ratio = <span class="number">0.3</span>,</span><br><span class="line">  fixed_frame_pose_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  imu_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  landmarks_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAP_BUILDER.use_trajectory_builder_2d = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER_2D.submaps.num_range_data = <span class="number">35</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.min_range = <span class="number">0.3</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.max_range = <span class="number">8.</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.missing_data_ray_length = <span class="number">1.</span></span><br><span class="line"><span class="comment">-- 决定是否使用imu数据</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.use_imu_data = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER_2D.use_online_correlative_scan_matching = <span class="literal">true</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.linear_search_window = <span class="number">0.1</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.translation_delta_cost_weight = <span class="number">10.</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.rotation_delta_cost_weight = <span class="number">1e-1</span></span><br><span class="line"></span><br><span class="line">POSE_GRAPH.optimization_problem.huber_scale = <span class="number">1e2</span></span><br><span class="line">POSE_GRAPH.optimize_every_n_nodes = <span class="number">35</span></span><br><span class="line">POSE_GRAPH.constraint_builder.min_score = <span class="number">0.65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure>

<h1 id="纯定位"><a href="#纯定位" class="headerlink" title="纯定位"></a>纯定位</h1><p>demo_backpack_2d_localization.launch</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find robot_sim_demo)/launch/robot_spawn.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            -configuration_directory $(find carto)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">            -configuration_basename backpack_2d_localization.lua</span></span></span><br><span class="line"><span class="string"><span class="tag">            -load_state_filename /root/catkin_ws/src/ROS-Academy-for-Beginners/carto/map/carto_2022_04_18_1.pbstream&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;points2&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/camera/depth/points&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- &lt;node name=&quot;cartographer_occupancy_grid_node&quot; pkg=&quot;cartographer_ros&quot;</span></span><br><span class="line"><span class="comment">        type=&quot;cartographer_occupancy_grid_node&quot; args=&quot;-resolution 0.05</span></span><br><span class="line"><span class="comment">                                                -pure_localization 1&quot; /&gt; --&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map server --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;map_file&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find carto)/map/carto.yaml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(arg map_file)&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find navigation_sim_demo)/launch/include/move_base.launch.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">args</span>=<span class="string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>backpack_2d_localization.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;backpack_2d.lua&quot;</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER.pure_localization_trimmer = &#123;</span><br><span class="line">  max_submaps_to_keep = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">POSE_GRAPH.optimize_every_n_nodes = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure>

<p>backpack_2d.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;map_builder.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;trajectory_builder.lua&quot;</span></span><br><span class="line"></span><br><span class="line">options = &#123;</span><br><span class="line">  map_builder = MAP_BUILDER,</span><br><span class="line">  trajectory_builder = TRAJECTORY_BUILDER,</span><br><span class="line">  map_frame = <span class="string">&quot;map&quot;</span>,</span><br><span class="line">	<span class="comment">-- tracking_frame更改为我们机器人的基坐标tf，一般是base_link，</span></span><br><span class="line">  tracking_frame = <span class="string">&quot;base_footprint&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 以下四个参数与里程计有关，在下面进行单独说明</span></span><br><span class="line">  odom_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">  published_frame = <span class="string">&quot;base_footprint&quot;</span>,</span><br><span class="line">  provide_odom_frame = <span class="literal">false</span>,</span><br><span class="line">	use_odometry = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  publish_frame_projected_to_2d = <span class="literal">false</span>,</span><br><span class="line">  use_pose_extrapolator = <span class="literal">true</span>,</span><br><span class="line">  use_nav_sat = <span class="literal">false</span>,</span><br><span class="line">  use_landmarks = <span class="literal">false</span>,</span><br><span class="line">  num_laser_scans = <span class="number">1</span>,</span><br><span class="line">  num_multi_echo_laser_scans = <span class="number">0</span>,</span><br><span class="line">  num_subdivisions_per_laser_scan = <span class="number">1</span>,</span><br><span class="line">  num_point_clouds = <span class="number">0</span>,</span><br><span class="line">  lookup_transform_timeout_sec = <span class="number">0.2</span>,</span><br><span class="line">  submap_publish_period_sec = <span class="number">0.3</span>,</span><br><span class="line">  pose_publish_period_sec = <span class="number">5e-3</span>,</span><br><span class="line">  trajectory_publish_period_sec = <span class="number">30e-3</span>,</span><br><span class="line">  rangefinder_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  odometry_sampling_ratio = <span class="number">0.3</span>,</span><br><span class="line">  fixed_frame_pose_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  imu_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">  landmarks_sampling_ratio = <span class="number">1.</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAP_BUILDER.use_trajectory_builder_2d = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER_2D.submaps.num_range_data = <span class="number">35</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.min_range = <span class="number">0.3</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.max_range = <span class="number">8.</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.missing_data_ray_length = <span class="number">1.</span></span><br><span class="line"><span class="comment">-- 决定是否使用imu数据</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.use_imu_data = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER_2D.use_online_correlative_scan_matching = <span class="literal">true</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.linear_search_window = <span class="number">0.1</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.translation_delta_cost_weight = <span class="number">10.</span></span><br><span class="line">TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.rotation_delta_cost_weight = <span class="number">1e-1</span></span><br><span class="line"></span><br><span class="line">POSE_GRAPH.optimization_problem.huber_scale = <span class="number">1e2</span></span><br><span class="line">POSE_GRAPH.optimize_every_n_nodes = <span class="number">35</span></span><br><span class="line">POSE_GRAPH.constraint_builder.min_score = <span class="number">0.65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure>

<h1 id="参数意义"><a href="#参数意义" class="headerlink" title="参数意义"></a>参数意义</h1>]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake实现多文件编译</title>
    <url>/blog/2021/12/03/cmake%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h3 id="Cmake文件结构"><a href="#Cmake文件结构" class="headerlink" title="Cmake文件结构"></a>Cmake文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/cmake# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── Queue</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── QUE.cpp</span><br><span class="line">    │       ├── QUE.h</span><br><span class="line">    │       └── main.cpp</span><br><span class="line">    └── canalyst_test</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        ├── lib</span><br><span class="line">        │   └── libcontrolcan.so</span><br><span class="line">        └── src</span><br><span class="line">            ├── Tongyi_Driver.cpp</span><br><span class="line">            ├── Tongyi_Driver.h</span><br><span class="line">            ├── controlcan.cpp</span><br><span class="line">            ├── controlcan.h</span><br><span class="line">            └── main.cpp</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译</span></span><br><span class="line">cd .. &amp;&amp; cd build &amp;&amp; cmake ../src &amp;&amp; make -j </span><br></pre></td></tr></table></figure>

<h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(Cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加下层cmake</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(canalyst_test)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(Queue)</span><br></pre></td></tr></table></figure>

<h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build &amp;&amp; bin/./queue</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cjson精度丢失</title>
    <url>/blog/2021/11/24/cjson%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_33858485/article/details/93953963?ops_request_misc=&request_id=&biz_id=102&utm_term=cjson%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-93953963.pc_search_mgc_flag&spm=1018.2226.3001.4187">(80条消息) cJSON精度丢失问题_weixin_33858485的博客-CSDN博客</a></p>
<p>在<code>cJSON.c</code>中的<code>print_number</code>函数中的<code>sprintf((char*)number_buffer, &quot;%1.17g&quot;, d);</code>更改为</p>
<p><code>sprintf((char*)number_buffer, &quot;%1.4g&quot;, d);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Render the number nicely from the given item into a string. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> cJSON_bool <span class="title">print_number</span><span class="params">(<span class="keyword">const</span> cJSON * <span class="keyword">const</span> item, printbuffer * <span class="keyword">const</span> output_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">double</span> d = item-&gt;valuedouble;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> number_buffer[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* temporary buffer to print the number into */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> decimal_point = get_decimal_point();</span><br><span class="line">    <span class="keyword">double</span> test = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This checks for NaN and Infinity */</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(d) || isinf(d))</span><br><span class="line">    &#123;</span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */</span></span><br><span class="line">        <span class="comment">// 更改这里的1.4,这里指的是保留4位小数</span></span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%1.4g&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check whether the original double can be recovered */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">sscanf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%lg&quot;</span>, &amp;test) != <span class="number">1</span>) || !compare_double((<span class="keyword">double</span>)test, d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* If not, print with 17 decimal places of precision */</span></span><br><span class="line">            <span class="comment">// 更改这里的1.4,这里指的是保留4位小数</span></span><br><span class="line">            length = <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)number_buffer, <span class="string">&quot;%1.4g&quot;</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sprintf failed or buffer overrun occurred */</span></span><br><span class="line">    <span class="keyword">if</span> ((length &lt; <span class="number">0</span>) || (length &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(number_buffer) - <span class="number">1</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve appropriate space in the output */</span></span><br><span class="line">    output_pointer = ensure(output_buffer, (<span class="keyword">size_t</span>)length + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the printed number to the output and replace locale</span></span><br><span class="line"><span class="comment">     * dependent decimal point with &#x27;.&#x27; */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((<span class="keyword">size_t</span>)length); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number_buffer[i] == decimal_point)</span><br><span class="line">        &#123;</span><br><span class="line">            output_pointer[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output_pointer[i] = number_buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    output_pointer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    output_buffer-&gt;offset += (<span class="keyword">size_t</span>)length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cJSON</title>
    <url>/blog/2021/11/10/cJSON/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/Mculover666/article/details/103796256?ops_request_misc=%7B%22request_id%22:%22163610505416780261970843%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163610505416780261970843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-103796256.pc_search_mgc_flag&utm_term=cjson&spm=1018.2226.3001.4187">(65条消息) cJSON使用详细教程 | 一个轻量级C语言JSON解析器_Mculover666的博客（嵌入式_)</a></p>
<p> <a href="https://github.com/DaveGamble/cJSON.git">cJSON-github</a></p>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* cjson_test = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_skill = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个JSON数据对象(链表头结点) */</span></span><br><span class="line">    cjson_test = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条字符串类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddStringToObject(cjson_test, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;mculover666&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条整数类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddNumberToObject(cjson_test, <span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一条浮点类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddNumberToObject(cjson_test, <span class="string">&quot;weight&quot;</span>, <span class="number">55.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个嵌套的JSON数据（添加一个链表节点） */</span></span><br><span class="line">    cjson_address = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddStringToObject(cjson_address, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;China&quot;</span>);</span><br><span class="line">    cJSON_AddNumberToObject(cjson_address, <span class="string">&quot;zip-code&quot;</span>, <span class="number">111111</span>);</span><br><span class="line">    cJSON_AddItemToObject(cjson_test, <span class="string">&quot;address&quot;</span>, cjson_address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个数组类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cjson_skill = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;C&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;Java&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( <span class="string">&quot;Python&quot;</span> ));</span><br><span class="line">    cJSON_AddItemToObject(cjson_test, <span class="string">&quot;skill&quot;</span>, cjson_skill);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */</span></span><br><span class="line">    cJSON_AddFalseToObject(cjson_test, <span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印JSON对象(整条链表)的所有数据 */</span></span><br><span class="line">    str = cJSON_Print(cjson_test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = </span><br><span class="line"><span class="string">&quot;&#123;                              \</span></span><br><span class="line"><span class="string">    \&quot;name\&quot;:\&quot;mculover666\&quot;,   \</span></span><br><span class="line"><span class="string">    \&quot;age\&quot;: 22,                \</span></span><br><span class="line"><span class="string">    \&quot;weight\&quot;: 55.5,           \</span></span><br><span class="line"><span class="string">    \&quot;address\&quot;:                \</span></span><br><span class="line"><span class="string">        &#123;                       \</span></span><br><span class="line"><span class="string">            \&quot;country\&quot;: \&quot;China\&quot;,\</span></span><br><span class="line"><span class="string">            \&quot;zip-code\&quot;: 111111\</span></span><br><span class="line"><span class="string">        &#125;,                      \</span></span><br><span class="line"><span class="string">    \&quot;skill\&quot;: [\&quot;c\&quot;, \&quot;Java\&quot;, \&quot;Python\&quot;],\</span></span><br><span class="line"><span class="string">    \&quot;student\&quot;: false          \</span></span><br><span class="line"><span class="string">&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* cjson_test = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_name = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_age = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_weight = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address_country = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_address_zipcode = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_skill = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON* cjson_student = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>    skill_array_size = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    cJSON* cjson_skill_item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析整段JSO数据 */</span></span><br><span class="line">    cjson_test = cJSON_Parse(message);</span><br><span class="line">    <span class="keyword">if</span>(cjson_test == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse fail.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 依次根据名称提取JSON数据（键值对） */</span></span><br><span class="line">    cjson_name = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    cjson_age = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    cjson_weight = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;weight&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, cjson_name-&gt;valuestring);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age:%d\n&quot;</span>, cjson_age-&gt;valueint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;weight:%.1f\n&quot;</span>, cjson_weight-&gt;valuedouble);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析嵌套json数据 */</span></span><br><span class="line">    cjson_address = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;address&quot;</span>);</span><br><span class="line">    cjson_address_country = cJSON_GetObjectItem(cjson_address, <span class="string">&quot;country&quot;</span>);</span><br><span class="line">    cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, <span class="string">&quot;zip-code&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address-country:%s\naddress-zipcode:%d\n&quot;</span>, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析数组 */</span></span><br><span class="line">    cjson_skill = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;skill&quot;</span>);</span><br><span class="line">    skill_array_size = cJSON_GetArraySize(cjson_skill);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;skill:[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; skill_array_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s,&quot;</span>, cjson_skill_item-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\b]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析布尔型数据 */</span></span><br><span class="line">    cjson_student = cJSON_GetObjectItem(cjson_test, <span class="string">&quot;student&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(cjson_student-&gt;valueint == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student: false\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student:error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关-JSMN-仅解析"><a href="#相关-JSMN-仅解析" class="headerlink" title="相关 - JSMN(仅解析)"></a>相关 - JSMN(仅解析)</h1><p><a href="https://blog.csdn.net/aa1319594154/article/details/118934166?ops_request_misc=%7B%22request_id%22:%22163663425616780271531802%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163663425616780271531802&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118934166.pc_search_mgc_flag&utm_term=jsmn&spm=1018.2226.3001.4187">JSMN介绍和使用_心飞的博客-CSDN博客</a></p>
<p><a href="https://zserge.com/jsmn/">The most simple JSON parser in C for small systems (zserge.com)</a></p>
<p><a href="https://github.com/zserge/jsmn">zserge/jsmn: Jsmn is a world fastest JSON parser/tokenizer. This is the official repo replacing the old one at Bitbucket (github.com)</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp学习</title>
    <url>/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/gyshgx868/cpp-tutorial">C++ 教程 (github.com)</a></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a></p>
<h1 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h1><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>声明指定类型的常量,此类型不会发生变化.</p>
<p>比如常用的字符串<code>const char* str</code>,例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>当然也会有常数,常指针等.只需要记住它修饰的是它后边的那个.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str #值不能改</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *str #值不能改</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> str #修饰的是常数指针,该指针不能修改</span><br></pre></td></tr></table></figure>

<h2 id="static修饰"><a href="#static修饰" class="headerlink" title="static修饰"></a>static修饰</h2><p>静态变量,在程序的生命周期内保持局部变量的存在,用于保存上一次运行数据,比如计数等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>预处理器,例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7070</span></span><br></pre></td></tr></table></figure>

<h2 id="extern储存类"><a href="#extern储存类" class="headerlink" title="extern储存类"></a>extern储存类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// support.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个文件之间传递参数.</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p>寄存器局部变量,用于快速访问.因此也意味着最大尺寸只有寄存器尺寸.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>量在创建线程时创建，并在销毁线程时销毁。可以将 thread_local <code>仅应用于数据声明和定义</code>，thread_local <code>不能用于函数声明或定义</code>。thread_local 说明符可以与 static 或 extern 合并。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first_name[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125; emp;</span><br></pre></td></tr></table></figure>

<h3 id="（-）点运算符"><a href="#（-）点运算符" class="headerlink" title="（.）点运算符"></a>（.）点运算符</h3><p>下面的代码把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcpy(emp.first_name, &quot;zara&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="（-gt-）箭头运算符"><a href="#（-gt-）箭头运算符" class="headerlink" title="（-&gt;）箭头运算符"></a>（-&gt;）箭头运算符</h3><p>如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员，需要编写如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(p_emp-&gt;first_name, <span class="string">&quot;zara&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符 ? :"></a>条件运算符 ? :</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y &lt; <span class="number">10</span>)&#123; </span><br><span class="line">   var = <span class="number">30</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   var = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可写为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var = (y &lt; <span class="number">10</span>) ? <span class="number">30</span> : <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span> (data type)</span><br></pre></td></tr></table></figure>

<h2 id="指针运算符（-amp-和-）"><a href="#指针运算符（-amp-和-）" class="headerlink" title="指针运算符（&amp; 和 *）"></a>指针运算符（&amp; 和 *）</h2><h3 id="取地址运算符-amp-间接寻址运算符"><a href="#取地址运算符-amp-间接寻址运算符" class="headerlink" title="取地址运算符 &amp; 间接寻址运算符 *"></a>取地址运算符 &amp; 间接寻址运算符 *</h3><p>顾名思义,挺形象的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var;</span><br><span class="line">   <span class="keyword">int</span>  *ptr;</span><br><span class="line">   <span class="keyword">int</span>  val;</span><br><span class="line">   var = <span class="number">3000</span>;</span><br><span class="line">   <span class="comment">// 获取 var 的地址</span></span><br><span class="line">   ptr = &amp;var;</span><br><span class="line">   <span class="comment">// 获取 ptr 的值</span></span><br><span class="line">   val = *ptr;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of var :&quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of ptr :&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of val :&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传参三种方式"><a href="#传参三种方式" class="headerlink" title="传参三种方式"></a>传参三种方式</h2><h3 id="传值、传址、传引用"><a href="#传值、传址、传引用" class="headerlink" title="传值、传址、传引用"></a><strong>传值、传址、传引用</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a*a</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">man</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function">    a</span>=a*a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function">    *a</span>=*a * *a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">uint8_t</span>* *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    *buffer = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>,number=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fun1</span>(a)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">man</span>(b);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cubeByReference</span>(&amp;number);</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是<code>this</code>指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>

<h2 id="数学运算-include-lt-cmath"><a href="#数学运算-include-lt-cmath" class="headerlink" title="数学运算 #include &lt;cmath"></a>数学运算 #include &lt;cmath</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 数字定义</span></span><br><span class="line">   <span class="keyword">short</span>  s = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span>    i = <span class="number">-1000</span>;</span><br><span class="line">   <span class="keyword">long</span>   l = <span class="number">100000</span>;</span><br><span class="line">   <span class="keyword">float</span>  f = <span class="number">230.47</span>;</span><br><span class="line">   <span class="keyword">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 数学运算</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sin(d) :&quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;floor(d) :&quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过time实现的伪随机数"><a href="#通过time实现的伪随机数" class="headerlink" title="通过time实现的伪随机数"></a>通过time实现的伪随机数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="keyword">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setw-函数"><a href="#setw-函数" class="headerlink" title="setw() 函数"></a>setw() 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::setw;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>( <span class="number">7</span> )&lt;&lt; j &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class="line"># 结果</span><br><span class="line">Element        Value</span><br><span class="line">      <span class="number">0</span>          <span class="number">100</span></span><br><span class="line">      <span class="number">1</span>          <span class="number">101</span></span><br><span class="line">      <span class="number">2</span>          <span class="number">102</span></span><br><span class="line">      <span class="number">3</span>          <span class="number">103</span></span><br><span class="line">      <span class="number">4</span>          <span class="number">104</span></span><br><span class="line">      <span class="number">5</span>          <span class="number">105</span></span><br><span class="line">      <span class="number">6</span>          <span class="number">106</span></span><br><span class="line">      <span class="number">7</span>          <span class="number">107</span></span><br><span class="line">      <span class="number">8</span>          <span class="number">108</span></span><br><span class="line">      <span class="number">9</span>          <span class="number">109</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串操作-include-lt-string"><a href="#字符串操作-include-lt-string" class="headerlink" title="字符串操作 #include &lt;string"></a>字符串操作 #include &lt;string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, s2); <span class="comment">// s2复制到s1</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2); <span class="comment">// s2拼接到s1后边,类似于:string str = str1 + str2;</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);     <span class="comment">// 字符串长度</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2); <span class="comment">// 比较两字符串,相同回0,s1&lt;s2返回小于0,反之,大于0</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch); <span class="comment">// 返回字符ch第一次在s1中出现得位置指针</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2); <span class="comment">// 返回字符串s2在s1中出现的位姿指针</span></span><br><span class="line"><span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">	str3 = str1;</span><br><span class="line"><span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   	str3 = str1 + str2;</span><br><span class="line"><span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   	len = str3.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h2 id="时间-include-lt-ctime"><a href="#时间-include-lt-ctime" class="headerlink" title="时间 #include &lt;ctime"></a>时间 #include &lt;ctime</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *time)</span></span>; 						<span class="comment">// 返回当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 				<span class="comment">// 返回 day month year hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 		<span class="comment">// 返回tm时间结构体</span></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">clock</span><span class="params">(<span class="keyword">void</span>)</span></span>;                			<span class="comment">// 该函数返回程序执行起,处理器时钟所使用的时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">asctime</span> <span class="params">( <span class="keyword">const</span> struct tm * time )</span></span>;		<span class="comment">// 返回 day month date hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; 			<span class="comment">// 用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *time)</span></span>;					<span class="comment">// 该函数返回日历时间</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span> <span class="params">( <span class="keyword">time_t</span> time2, <span class="keyword">time_t</span> time1 )</span></span>; <span class="comment">// 该函数返回 time1 和 time2 之间相差的秒数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">()</span></span>;								<span class="comment">// 该函数可用于格式化日期和时间为指定的格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="keyword">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cin、cout、cerr-和-clog-标准输入输出"><a href="#cin、cout、cerr-和-clog-标准输入输出" class="headerlink" title="cin、cout、cerr 和 clog 标准输入输出"></a><strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 标准输入输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin :一个istream对象,用来从标准输入读取数据。</span><br><span class="line">cout:一个ostream对象，经过缓冲区而直接输出.</span><br><span class="line">cerr:一个ostream对象,写到cerr数据是不缓冲</span><br><span class="line">clog:一个ostream对象,被缓冲的</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="comment">// 使用 Books Book;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 books Book;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;books;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取别名 pin32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> pint32;</span><br><span class="line">pint32 x, y, z;</span><br></pre></td></tr></table></figure>

<p>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line"><span class="comment">// 取地址</span></span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line"><span class="comment">// 访问成员</span></span><br><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="c-对象"><a href="#c-对象" class="headerlink" title="c++对象"></a>c++对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 访问修饰符</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 类成员函数 </span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   				<span class="comment">// 构造函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="keyword">const</span> Line &amp;obj); 	<span class="comment">//拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  				<span class="comment">// 析构函数声明</span></span><br><span class="line"> 	</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个<code>空间代价换时间的节省</code>。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神:</p>
<ul>
<li>1.在内联函数内不允许使用循环语句和开关语句；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.类结构中所在的类说明内部定义的函数是内联函数。</li>
</ul>
<p>结论: 一个较为合理的经验准则是, <strong>不要内联超过 10 行的函数</strong>. <strong>谨慎对待析构函数</strong>, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (20,10): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (0,200): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (100,1010): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p>
<p><strong>this</strong> 指针的类型可理解为 <strong>Box*</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 实际上就是指针引用结构体成员</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>类内重调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">         box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">         <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">算术运算符</th>
<th align="center">+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关系运算符</td>
<td align="center">==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center">||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td align="center">单目运算符</td>
<td align="center">+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td align="center">自增自减运算符</td>
<td align="center">++(自增)，–(自减)</td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center">| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td align="center">赋值运算符</td>
<td align="center">=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td align="center">空间申请与释放</td>
<td align="center">new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td align="center">其他运算符</td>
<td align="center"><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td>
</tr>
</tbody></table>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 纯虚数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>头文件:<strong>iostream</strong> 和 <strong>fstream</strong></p>
<h3 id="读写文件模板"><a href="#读写文件模板" class="headerlink" title="读写文件模板"></a>读写文件模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h3 id="变量动态内存"><a href="#变量动态内存" class="headerlink" title="变量动态内存"></a>变量动态内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="数组动态内存"><a href="#数组动态内存" class="headerlink" title="数组动态内存"></a>数组动态内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pvalue[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] pvalue; </span><br></pre></td></tr></table></figure>

<h3 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> [] myBoxArray; <span class="comment">// Delete array</span></span><br></pre></td></tr></table></figure>

<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">   pvalue  = new double;   // 为变量请求内存</span><br><span class="line"> </span><br><span class="line">   *pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">   cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   delete pvalue;         // 释放内存</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br><span class="line">name::<span class="built_in">func</span>();  <span class="comment">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>

<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">//全特化，由于是全特化，参数都指定了，参数列表故为空。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">int</span> ,<span class="keyword">char</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i,<span class="keyword">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="comment">//由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">char</span>,T2&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">char</span> i,T2 j):<span class="built_in">a</span>(j),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;个数偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; <span class="comment">//这是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1*,T2*&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1* i,T2* j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;指针偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1* a;</span><br><span class="line">    T2* b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;<span class="comment">//同理这也是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1 <span class="keyword">const</span>,T2 <span class="keyword">const</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;const偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">0.1</span>,<span class="number">0.2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; <span class="title">t3</span><span class="params">(<span class="string">&#x27;A&#x27;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>*,<span class="keyword">int</span>*&gt; <span class="title">t4</span><span class="params">(&amp;a,&amp;a)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">int</span>&gt; <span class="title">t5</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)</span></span><br></pre></td></tr></table></figure>

<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 将x转换为字符串</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line">## 将x,y连接</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT( x, y )  x ## y</span></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br></pre></td></tr></table></figure>

<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl; <span class="comment">//当前行号</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl; <span class="comment">//当前文件名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl; <span class="comment">//当前年月日</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl; <span class="comment">//当前时分秒</span></span><br></pre></td></tr></table></figure>

<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalHandler</span><span class="params">( <span class="keyword">int</span> signum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序 </span></span><br><span class="line">   <span class="built_in">exit</span>(signum);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line">    <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">if</span>( i == <span class="number">3</span> )&#123;</span><br><span class="line">          <span class="comment">// 信号抬起</span></span><br><span class="line">          <span class="built_in">raise</span>( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_create</span> (thread, attr, start_routine, arg) </span><br><span class="line"><span class="comment">// 参数:线程指针,线程属性,线程函数,函数参数</span></span><br><span class="line"><span class="comment">// 线程显性退出</span></span><br><span class="line"><span class="built_in">pthread_exit</span> (<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<h3 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  thread_id;</span><br><span class="line">   <span class="keyword">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">td</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line">rc = <span class="built_in">pthread_create</span>(threadid, <span class="literal">NULL</span>,PrintHello, (<span class="keyword">void</span> *)&amp;td[i]);</span><br></pre></td></tr></table></figure>

<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span> (threadid, status) </span><br><span class="line"><span class="built_in">pthread_detach</span> (threadid) </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">    </span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="keyword">void</span> *status;</span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">   <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="keyword">void</span> *)i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线程</span></span><br><span class="line">   <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = <span class="built_in">pthread_join</span>(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector与iterator"><a href="#vector与iterator" class="headerlink" title="vector与iterator"></a>vector与iterator</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>/dev/null使用</title>
    <url>/blog/2022/05/03/dev_null%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_44388689/article/details/120705959?ops_request_misc=&request_id=&biz_id=102&utm_term=/dev/null&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120705959.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(130条消息) 关于/dev/null及用途（Linux黑洞）_RayPick的博客-CSDN博客_dev/null</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>用来当作垃圾站,不用的东西扔进去,可以用来清理文件内容.</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> std:: <span class="function">ofstream <span class="title">dummy_ostream</span><span class="params">(<span class="string">&quot;/dev/null&quot;</span>,std::iso::out)</span></span>;</span><br><span class="line">std::ofstream&amp; Logger::<span class="keyword">operator</span>[](<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">	<span class="keyword">return</span> (m_logs.<span class="built_in">find</span>(name) == m_logs.<span class="built_in">end</span>()) ? dummy_ostream : m_logs[names];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>evo使用</title>
    <url>/blog/2022/04/26/evo/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/hanmoge/article/details/113593380?ops_request_misc=%7B%22request_id%22:%22165094059516782425130568%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165094059516782425130568&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-113593380.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=gazebo%E8%8E%B7%E5%BE%97%E7%9C%9F%E5%AE%9E%E4%BD%8D%E5%A7%BF&spm=1018.2226.3001.4187">(128条消息) 如何获得gazebo仿真中的机器人位姿真值_寒墨阁的博客-CSDN博客_gazebo获取机器人位置</a></p>
<p><a href="https://blog.csdn.net/u011341856/article/details/104594392/?ops_request_misc=&request_id=&biz_id=102&utm_term=evo_traj%E8%BD%89%E6%8F%9B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-104594392.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(128条消息) evo安装、evo使用方法详细介绍使用教程</a></p>
<p><a href="https://blog.csdn.net/xiaojinger_123/article/details/120141017?ops_request_misc=&request_id=&biz_id=102&utm_term=evo_traj%E8%BD%89%E6%8F%9B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-120141017.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(128条消息) evo评测VINS-MONO—代码修改、数据格式转换、数据测试_可即的博客-CSDN博客_vins测试</a></p>
<p><a href="https://blog.csdn.net/qq_43265072/article/details/104715515?ops_request_misc=%7B%22request_id%22:%22165089732116780357243284%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165089732116780357243284&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-104715515.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=evo_traj+tum&spm=1018.2226.3001.4187">(128条消息) evo测评TUM数据集_dididada~的博客-CSDN博客_evo tum</a></p>
<h1 id="gazebo获得真实位姿"><a href="#gazebo获得真实位姿" class="headerlink" title="gazebo获得真实位姿"></a>gazebo获得真实位姿</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在gazebo仿真模型文件中添加： --&gt;</span><br><span class="line">&lt;gazebo&gt;</span><br><span class="line">  &lt;plugin name=&quot;p3d_base_controller&quot; filename=&quot;libgazebo_ros_p3d.so&quot;&gt;</span><br><span class="line">    &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">    &lt;updateRate&gt;50.0&lt;/updateRate&gt;</span><br><span class="line">    &lt;bodyName&gt;base_footprint&lt;/bodyName&gt;</span><br><span class="line">    &lt;topicName&gt;base_pose_ground_truth&lt;/topicName&gt;</span><br><span class="line">    &lt;gaussianNoise&gt;0.0&lt;/gaussianNoise&gt;</span><br><span class="line">    &lt;frameName&gt;map&lt;/frameName&gt;</span><br><span class="line">    &lt;xyzOffsets&gt;0 0 0&lt;/xyzOffsets&gt;</span><br><span class="line">    &lt;rpyOffsets&gt;0 0 0&lt;/rpyOffsets&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure>

<h1 id="ros生成tum文件"><a href="#ros生成tum文件" class="headerlink" title="ros生成tum文件"></a>ros生成tum文件</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/PoseWithCovarianceStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;nav_msgs/Odometry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvoCreatTum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EvoCreatTum</span>();</span><br><span class="line">    ~<span class="built_in">EvoCreatTum</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> nav_msgs::Odometry::ConstPtr&amp; msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ros::NodeHandle nh_;</span><br><span class="line">    ros::Subscriber sub_;</span><br><span class="line">    std::string odom_topic_;</span><br><span class="line">    nav_msgs::Odometry pose_;</span><br><span class="line">    std::string outFilename_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EvoCreatTum::<span class="built_in">EvoCreatTum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ros::Time::<span class="built_in">init</span>();</span><br><span class="line">    nh_.param&lt;std::string&gt;(<span class="string">&quot;/odom_topic&quot;</span>, odom_topic_, <span class="string">&quot;/odom&quot;</span>);</span><br><span class="line">    nh_.param&lt;std::string&gt;(<span class="string">&quot;outFilename&quot;</span>, outFilename_, <span class="string">&quot;/root/catkin_ws/devel/lib/evo_creat_tum/outpose.txt&quot;</span>);</span><br><span class="line">    sub_ = nh_.<span class="built_in">subscribe</span>(odom_topic_, <span class="number">1</span>, &amp;EvoCreatTum::poseCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EvoCreatTum::~<span class="built_in">EvoCreatTum</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EvoCreatTum::poseCallback</span><span class="params">(<span class="keyword">const</span> nav_msgs::Odometry::ConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::Time currTime = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">double</span> t_s = currTime.<span class="built_in">toSec</span>();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; &quot;t_s: &quot; &lt;&lt; t_s &lt;&lt; std::endl;</span></span><br><span class="line">    pose_ = *msg;</span><br><span class="line">    <span class="keyword">double</span> tx = pose_.pose.pose.position.x;</span><br><span class="line">    <span class="keyword">double</span> ty = pose_.pose.pose.position.y;</span><br><span class="line">    <span class="keyword">double</span> tz = pose_.pose.pose.position.z;</span><br><span class="line">    <span class="keyword">double</span> qx = pose_.pose.pose.orientation.x;</span><br><span class="line">    <span class="keyword">double</span> qy = pose_.pose.pose.orientation.y;</span><br><span class="line">    <span class="keyword">double</span> qz = pose_.pose.pose.orientation.z;</span><br><span class="line">    <span class="keyword">double</span> qw = pose_.pose.pose.orientation.w;</span><br><span class="line">    std::fstream outTumpose;</span><br><span class="line">    <span class="comment">// 打开并向后添加</span></span><br><span class="line">    outTumpose.<span class="built_in">open</span>(outFilename_, std::ios::out | std::ios::app);</span><br><span class="line">    outTumpose &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; t_s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; tx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ty &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tz &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; qx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; qy &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; qz &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; qw &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;evo_creat_tum_node&quot;</span>); <span class="comment">// 节点的名字</span></span><br><span class="line">    EvoCreatTum evo_creat_tum;</span><br><span class="line">    ros::<span class="built_in">spin</span>(); <span class="comment">// 程序执行到此处时开始进行等待，每次订阅的消息到来都会执行一次ScanCallback()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- creat_tum --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;/odom_topic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/odom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;outFilename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/root/catkin_ws/devel/lib/evo_creat_tum/outpose.txt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;evo_creat_tum&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;evo_creat_tum&quot;</span> <span class="attr">type</span>=<span class="string">&quot;evo_creat_tum&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="evo使用"><a href="#evo使用" class="headerlink" title="evo使用"></a>evo使用</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配准前</span></span><br><span class="line">evo_traj tum CameraTrajectory.txt groundtruth.txt -p</span><br><span class="line"><span class="comment"># 配准后</span></span><br><span class="line">evo_traj tum CameraTrajectory.txt --ref=groundtruth.txt -p -a</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">evo_ape tum groundtruth.txt CameraTrajectory.txt -r full -va -p --save_results results/ORB.zip</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>easy_logger</title>
    <url>/blog/2021/11/26/easy_log/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/armink/EasyLogger">一款超轻量级(ROM&lt;1.6K, RAM&lt;0.3k)、高性能的 C/C++ 日志库 </a></p>
<h1 id="移植到linux"><a href="#移植到linux" class="headerlink" title="移植到linux"></a>移植到linux</h1><p><a href="https://github.com/peitianyu/easy_log">peitianyu/easy_log (github.com)</a></p>
<p>注意修改log文件保存路径,在<code>easy_log/include/elog_file_cfg.h</code>中</p>
<p>一款更加轻量化的log工具,可以自行更改函数,实现功能</p>
<p><a href="https://github.com/peitianyu/light_log/blob/main/README.md"> peitianyu/light_log (github.com)</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake配置模板</title>
    <url>/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="Cmake教程"><a href="#Cmake教程" class="headerlink" title="Cmake教程"></a>Cmake教程</h3><h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://www.hahack.com/codes/cmake/">CMake 入门实战 | HaHack</a></p>
<h3 id="Cmake文件结构"><a href="#Cmake文件结构" class="headerlink" title="Cmake文件结构"></a>Cmake文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/cmake# tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── include</span><br><span class="line">│   └── func.h</span><br><span class="line">└── src</span><br><span class="line">    ├── func.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── shell.sh</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译</span></span><br><span class="line">cd .. &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(canalyst)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake的c++设置</span></span><br><span class="line"><span class="comment"># 告知當前使用的是交叉編譯方式，必須配置</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="string">&quot;gcc&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"><span class="comment"># 执行路径设置</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH ../bin)</span><br><span class="line"><span class="comment"># 设置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -Wall -pthread -std=c++11 -fPIC &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.h文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.cpp文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src  SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib)</span><br><span class="line"><span class="keyword">set</span>(LIB_LIST</span><br><span class="line">    libcontrolcan.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="comment"># message(&quot;src :$&#123;SRC_LIST&#125; &quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC_LIST&#125;</span> )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;LIB_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在src文件夹下运行shell.sh</span></span><br><span class="line">./shell</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言的三种传参方式</title>
    <url>/blog/2021/12/15/c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">man</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=a*a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a * *a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">uint8_t</span>* *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    *buffer = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>,number=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fun1(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    man(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    cubeByReference(&amp;number);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *buf;</span><br><span class="line">    fun2(&amp;buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 10; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, buf[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序注意点</title>
    <url>/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A">https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A</a></p>
<h3 id="意想不到的八进制"><a href="#意想不到的八进制" class="headerlink" title="意想不到的八进制"></a>意想不到的八进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b为八进制</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">34</span>, b=<span class="number">034</span>; </span><br></pre></td></tr></table></figure>

<h3 id="指针加减运算"><a href="#指针加减运算" class="headerlink" title="指针加减运算"></a>指针加减运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="number">0x00001000</span>;  </span><br><span class="line">a=a+<span class="number">1</span>;  </span><br><span class="line">p=p+<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 这里的p是指针,</span></span><br><span class="line"><span class="comment">// p+1实际上是按照公式p+1*sizeof(int)来计算的。</span></span><br></pre></td></tr></table></figure>

<p>比如RAM初始化零操作,如下,只有4字节空间被初始化为零</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *pRAMaddr;         <span class="comment">//定义地址指针变量  </span></span><br><span class="line"><span class="comment">// pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节</span></span><br><span class="line"><span class="keyword">for</span>(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=<span class="number">4</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">     *pRAMaddr=<span class="number">0x00000000</span>;   <span class="comment">//指定RAM地址清零  </span></span><br><span class="line">    <span class="comment">// 这里清除了四个字节</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="关键字sizeof"><a href="#关键字sizeof" class="headerlink" title="关键字sizeof"></a>关键字sizeof</h3><p><strong>sizeof</strong>是一个关键字,需要注意的是,<strong>使用sizeof获取数组长度时，不要对指针应用sizeof操作符</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearRAM</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);i++) <span class="comment">//这里用法错误，array实际上是指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">array</span>[i]=<span class="number">0x00</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> Fle[<span class="number">20</span>];  </span><br><span class="line">      </span><br><span class="line">    ClearRAM(Fle);          <span class="comment">//只能清除数组Fle中的前四个元素  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="结构体填充"><a href="#结构体填充" class="headerlink" title="结构体填充"></a>结构体填充</h3><p>结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体：</p>
<p>第一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">short</span> s；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">&#125;str_test1; </span><br></pre></td></tr></table></figure>

<p>第二个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">    <span class="keyword">short</span> s；      </span><br><span class="line">&#125;str_test2;</span><br></pre></td></tr></table></figure>

<p>这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？</p>
<p>其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下<strong>第一个结构体变量占用8个字节</strong>，<strong>第二个结构体占用12个字节</strong>，差别很大。第一个结构体变量在内存中的存储格式如图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1~4字节  cc填充SSSS</span><br><span class="line">5~8字节  XXXXXXXX</span><br></pre></td></tr></table></figure>

<p>第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1~4字节   cc填充</span><br><span class="line">5~8字节   XXXXXXXX</span><br><span class="line">9~12字节  ssss填充</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>g2o</title>
    <url>/blog/2022/03/02/g2o/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/gaoxiang12/slambook2/tree/master/ch6">slambook2/ch6 at master · gaoxiang12/slambook2 (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx/article/details/121266020?spm=1001.2014.3001.5501">(111条消息) 从零开始搭二维激光SLAM — 基于g2o的后端优化的代码实现</a> </p>
<p> <a href="https://blog.csdn.net/electech6/article/details/88018481">(111条消息) 从零开始一起学习SLAM | 掌握g2o顶点编程套路_计算机视觉life-CSDN博客</a> </p>
<p> <a href="https://github.com/Forrest-Z/Slam-Project-Of-MyOwn/blob/master/test/slam_simulation_with_g2o/slamSimulationTest.cpp">Slam-Project-Of-MyOwn/slamSimulationTest.cpp at master</a> </p>
<p> <a href="https://blog.csdn.net/Yong_Qi2015/article/details/105259976?ops_request_misc=%7B%22request_id%22:%22164620942316780264055749%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164620942316780264055749&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105259976.pc_search_insert_es_download&utm_term=g2o&spm=1018.2226.3001.4187">(111条消息) SLAM从0到1之图优化g2o：从看懂代码到动手编写（长文）_3D视觉工坊-CSDN博客</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在图优化里,g2o使用非常普遍,需要注意一下关于( vertex)与(edge)概念与选择.实现步骤如下:</p>
<ul>
<li> <em>创建一个线性求解器LinearSolver</em> </li>
<li> <em>创建BlockSolver。并用上面定义的线性求解器初始化</em> </li>
<li> <em>创建总求解器solver</em> </li>
<li> <em>稀疏优化器（SparseOptimizer）</em> </li>
<li> <em>定义图的顶点和边。并添加到SparseOptimizer中</em> </li>
<li> <em>设置优化参数，开始执行优化</em> </li>
</ul>
<h1 id="高翔博士"><a href="#高翔博士" class="headerlink" title="高翔博士"></a>高翔博士</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/g2o_core_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点，模板参数：优化变量维度和数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    _estimate += Eigen::Vector3d(update);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">CurveFittingEdge</span><span class="params">(<span class="keyword">double</span> x)</span> : <span class="title">BaseUnaryEdge</span><span class="params">()</span>, _<span class="title">x</span><span class="params">(x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;estimate();</span><br><span class="line">    _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - <span class="built_in">std</span>::<span class="built_in">exp</span>(abc(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + abc(<span class="number">1</span>, <span class="number">0</span>) * _x + abc(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算雅可比矩阵</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;estimate();</span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">exp</span>(abc[<span class="number">0</span>] * _x * _x + abc[<span class="number">1</span>] * _x + abc[<span class="number">2</span>]);</span><br><span class="line">    _jacobianOplusXi[<span class="number">0</span>] = -_x * _x * y;</span><br><span class="line">    _jacobianOplusXi[<span class="number">1</span>] = -_x * y;</span><br><span class="line">    _jacobianOplusXi[<span class="number">2</span>] = -y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">double</span> _x;  <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">  <span class="keyword">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;        <span class="comment">// 估计参数值</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">100</span>;                                 <span class="comment">// 数据点</span></span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;                        <span class="comment">// 噪声Sigma值</span></span><br><span class="line">  <span class="keyword">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">  cv::RNG rng;                                 <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">    x_data.push_back(x);</span><br><span class="line">    y_data.push_back(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">  <span class="comment">// 第1步：创建一个线性求解器LinearSolver</span></span><br><span class="line">  <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;  <span class="comment">// 每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">  <span class="comment">// 第2步：创建BlockSolver。并用上面定义的线性求解器初始化</span></span><br><span class="line">  <span class="keyword">typedef</span> g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType; <span class="comment">// 线性求解器类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 梯度下降方法，可以从GN, LM, DogLeg 中选</span></span><br><span class="line">  <span class="comment">// 第3步：创建总求解器solver。并从GN, LM, DogLeg 中选一个，再用上述块求解器BlockSolver初始化</span></span><br><span class="line">  <span class="keyword">auto</span> solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmGaussNewton(</span><br><span class="line">    g2o::make_unique&lt;BlockSolverType&gt;(g2o::make_unique&lt;LinearSolverType&gt;()));</span><br><span class="line">  <span class="comment">// 第4步：创建终极大boss 稀疏优化器（SparseOptimizer）</span></span><br><span class="line">  g2o::SparseOptimizer optimizer;     <span class="comment">// 图模型</span></span><br><span class="line">  optimizer.setAlgorithm(solver);   <span class="comment">// 设置求解器</span></span><br><span class="line">  optimizer.setVerbose(<span class="literal">true</span>);       <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第5步：定义图的顶点和边。并添加到SparseOptimizer中</span></span><br><span class="line">  <span class="comment">// 往图中增加顶点</span></span><br><span class="line">  CurveFittingVertex *v = <span class="keyword">new</span> CurveFittingVertex();</span><br><span class="line">  v-&gt;setEstimate(Eigen::Vector3d(ae, be, ce));</span><br><span class="line">  v-&gt;setId(<span class="number">0</span>);</span><br><span class="line">  optimizer.addVertex(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往图中增加边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    CurveFittingEdge *edge = <span class="keyword">new</span> CurveFittingEdge(x_data[i]);</span><br><span class="line">    edge-&gt;setId(i);</span><br><span class="line">    edge-&gt;setVertex(<span class="number">0</span>, v);                <span class="comment">// 设置连接的顶点</span></span><br><span class="line">    edge-&gt;setMeasurement(y_data[i]);      <span class="comment">// 观测数值</span></span><br><span class="line">    edge-&gt;setInformation(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::Identity() * <span class="number">1</span> / (w_sigma * w_sigma)); <span class="comment">// 信息矩阵：协方差矩阵之逆</span></span><br><span class="line">    optimizer.addEdge(edge);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行优化</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;start optimization&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">  <span class="comment">// 第6步：设置优化参数，开始执行优化</span></span><br><span class="line">  optimizer.initializeOptimization();</span><br><span class="line">  optimizer.optimize(<span class="number">10</span>);</span><br><span class="line">  chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">  chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.count() &lt;&lt; <span class="string">&quot; seconds. &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出优化值</span></span><br><span class="line">  Eigen::Vector3d abc_estimate = v-&gt;estimate();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;estimated model: &quot;</span> &lt;&lt; abc_estimate.transpose() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="李想大佬"><a href="#李想大佬" class="headerlink" title="李想大佬"></a>李想大佬</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加Vertex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G2oSolver::AddNode</span><span class="params">(karto::Vertex&lt;karto::LocalizedRangeScan&gt; *pVertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  karto::Pose2 odom = pVertex-&gt;GetObject()-&gt;GetCorrectedPose();</span><br><span class="line">  g2o::VertexSE2 *poseVertex = <span class="keyword">new</span> g2o::VertexSE2;</span><br><span class="line">  poseVertex-&gt;setEstimate(g2o::SE2(odom.GetX(), odom.GetY(), odom.GetHeading()));</span><br><span class="line">  poseVertex-&gt;setId(pVertex-&gt;GetObject()-&gt;GetUniqueId());</span><br><span class="line">  mOptimizer.addVertex(poseVertex);</span><br><span class="line">  ROS_DEBUG(<span class="string">&quot;[g2o] Adding node %d.&quot;</span>, pVertex-&gt;GetObject()-&gt;GetUniqueId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加edge</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G2oSolver::AddConstraint</span><span class="params">(karto::Edge&lt;karto::LocalizedRangeScan&gt; *pEdge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Create a new edge</span></span><br><span class="line">  g2o::EdgeSE2 *odometry = <span class="keyword">new</span> g2o::EdgeSE2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set source and target</span></span><br><span class="line">  <span class="keyword">int</span> sourceID = pEdge-&gt;GetSource()-&gt;GetObject()-&gt;GetUniqueId();</span><br><span class="line">  <span class="keyword">int</span> targetID = pEdge-&gt;GetTarget()-&gt;GetObject()-&gt;GetUniqueId();</span><br><span class="line">  odometry-&gt;vertices()[<span class="number">0</span>] = mOptimizer.vertex(sourceID);</span><br><span class="line">  odometry-&gt;vertices()[<span class="number">1</span>] = mOptimizer.vertex(targetID);</span><br><span class="line">  <span class="keyword">if</span> (odometry-&gt;vertices()[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">&quot;[g2o] Source vertex with id %d does not exist!&quot;</span>, sourceID);</span><br><span class="line">    <span class="keyword">delete</span> odometry;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (odometry-&gt;vertices()[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">&quot;[g2o] Target vertex with id %d does not exist!&quot;</span>, targetID);</span><br><span class="line">    <span class="keyword">delete</span> odometry;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the measurement (odometry distance between vertices)</span></span><br><span class="line">  karto::LinkInfo *pLinkInfo = (karto::LinkInfo *)(pEdge-&gt;GetLabel());</span><br><span class="line">  karto::Pose2 diff = pLinkInfo-&gt;GetPoseDifference();</span><br><span class="line">  <span class="function">g2o::SE2 <span class="title">measurement</span><span class="params">(diff.GetX(), diff.GetY(), diff.GetHeading())</span></span>;</span><br><span class="line">  odometry-&gt;setMeasurement(measurement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the covariance of the measurement</span></span><br><span class="line">  karto::Matrix3 precisionMatrix = pLinkInfo-&gt;GetCovariance().Inverse();</span><br><span class="line">  Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; info;</span><br><span class="line">  info(<span class="number">0</span>, <span class="number">0</span>) = precisionMatrix(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  info(<span class="number">0</span>, <span class="number">1</span>) = info(<span class="number">1</span>, <span class="number">0</span>) = precisionMatrix(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  info(<span class="number">0</span>, <span class="number">2</span>) = info(<span class="number">2</span>, <span class="number">0</span>) = precisionMatrix(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">  info(<span class="number">1</span>, <span class="number">1</span>) = precisionMatrix(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  info(<span class="number">1</span>, <span class="number">2</span>) = info(<span class="number">2</span>, <span class="number">1</span>) = precisionMatrix(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  info(<span class="number">2</span>, <span class="number">2</span>) = precisionMatrix(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  odometry-&gt;setInformation(info);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the constraint to the optimizer</span></span><br><span class="line">  ROS_DEBUG(<span class="string">&quot;[g2o] Adding Edge from node %d to node %d.&quot;</span>, sourceID, targetID);</span><br><span class="line">  mOptimizer.addEdge(odometry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="道峰大佬-直接将V计算给edge"><a href="#道峰大佬-直接将V计算给edge" class="headerlink" title="道峰大佬 - 直接将V计算给edge"></a>道峰大佬 - 直接将V计算给edge</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">slam::optimizer::GraphOptimize optimizer;</span><br><span class="line">optimizer.createOptimizer();</span><br><span class="line">optimizer.setMaxIeration(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加顶点,加边</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">robotPoseCurr</span><span class="params">( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span> keyFrameCount = <span class="number">0</span>;</span><br><span class="line">optimizer.addVertex( robotPoseCurr, keyFrameCount ); <span class="comment">// add a vertex</span></span><br><span class="line"></span><br><span class="line">Eigen::Matrix3d information = Eigen::Matrix3d::Identity(); <span class="comment">//information matrix</span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T1 = slam.v2t( robotPosePrev );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T2 = slam.v2t( robotPoseCurr );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T = T1.inverse() * T2;</span><br><span class="line">Eigen::Vector3f V = slam.t2v( T );</span><br><span class="line">optimizer.addEdge( V, keyFrameCount - <span class="number">1</span>, keyFrameCount, information ); <span class="comment">// add a edge</span></span><br><span class="line"></span><br><span class="line">Eigen::Matrix3d information = <span class="number">1</span> * Eigen::Matrix3d::Identity(); <span class="comment">//information matrix</span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T1 = slam.v2t( robotPoseCurr );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T2 = slam.v2t( keyPoses[loopId] );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T = T1.inverse() * T2;</span><br><span class="line">Eigen::Vector3f V = slam.t2v( T );</span><br><span class="line">optimizer.addEdge( V, keyFrameCount, loopId, information ); <span class="comment">// add a loop constraint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">optimizer.execuateGraphOptimization(); <span class="comment">// execuate the graph optimization</span></span><br><span class="line">optimizer.getOptimizedResults(); <span class="comment">// get the optimized results</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Vector3f&gt; estimatedPoses = optimizer.getEstimatedPoses();</span><br></pre></td></tr></table></figure>

<h1 id="设置一元边-使用现成的edge"><a href="#设置一元边-使用现成的edge" class="headerlink" title="设置一元边 - 使用现成的edge"></a>设置一元边 - 使用现成的edge</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往图中增加边    </span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    CurveFittingEdge* edge = <span class="keyword">new</span> CurveFittingEdge( x_data[i] );</span><br><span class="line">    edge-&gt;setId(i);</span><br><span class="line">    edge-&gt;setVertex( <span class="number">0</span>, v );                   					</span><br><span class="line">    optimizer.addEdge( edge );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设置二元边-前后两个位姿"><a href="#设置二元边-前后两个位姿" class="headerlink" title="设置二元边( 前后两个位姿 )"></a>设置二元边( 前后两个位姿 )</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> Point2f p:points_2d )&#123;</span><br><span class="line">    g2o::EdgeProjectXYZ2UV* edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">    edge-&gt;setId ( index );  <span class="comment">// 边的b编号    </span></span><br><span class="line">    edge-&gt;setVertex ( <span class="number">1</span>, pose );</span><br><span class="line">    edge-&gt;setMeasurement ( Eigen::Vector2d ( p.x, p.y ) );  <span class="comment">// 设置观测的特征点图像坐标    </span></span><br><span class="line">    edge-&gt;setInformation( Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt;::Identity()*<span class="number">1</span>/(w_sigma*w_sigma) ); <span class="comment">// 信息矩阵：协方差矩阵之逆</span></span><br><span class="line">    optimizer.addEdge ( edge );</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>follow大佬</title>
    <url>/blog/2022/02/28/follow%E5%A4%A7%E4%BD%AC/</url>
    <content><![CDATA[<h1 id="slam方向"><a href="#slam方向" class="headerlink" title="slam方向"></a>slam方向</h1><p> <a href="https://charon-cheung.github.io/categories/">categories | 沉默杀手 (charon-cheung.github.io)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx?spm=1011.2124.3001.5113">(110条消息) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主</a> </p>
<p> <a href="https://blog.csdn.net/zhao_ke_xue?type=blog">(110条消息) 「小白学移动机器人」一个专注分享移动机器人相关知识的公众号！_白茶-清欢_CSDN博客-从零搭建ROS机器人平台,slam相关,ros领域博主</a> </p>
<p> <a href="https://github.com/Forrest-Z">Forrest-Z (zhouzuhong) (github.com)</a> </p>
<p> <a href="https://github.com/softdream">softdream (道锋) (github.com)</a> </p>
<p> <a href="https://heyijia.blog.csdn.net/?type=blog">(116条消息) 白巧克力亦唯心的博客_CSDN博客-算法推导系列</a> </p>
<h1 id="规划-控制"><a href="#规划-控制" class="headerlink" title="规划-控制"></a>规划-控制</h1><p> <a href="https://space.bilibili.com/287989852/video?tid=0&page=2&keyword=&order=pubdate">忠厚老实的老王的个人空间_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://space.bilibili.com/193098059">IR艾若机器人的个人空间_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://space.bilibili.com/477041559">小黎的Ally的个人空间_哔哩哔哩_bilibili</a> </p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>f1c100s_buildroot</title>
    <url>/blog/2022/02/17/f1c100s_buildroot/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://github.com/aodzip/buildroot-tiny200">aodzip/buildroot-tiny200: Buildroot Package for F1C100s/200s (github.com)</a> </p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装库文件"><a href="#安装库文件" class="headerlink" title="安装库文件"></a>安装库文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install wget unzip build-essential git bc swig libncurses-dev libpython3-dev libssl-dev</span><br><span class="line">sudo apt install python3-distutils</span><br></pre></td></tr></table></figure>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/aodzip/buildroot-tiny200</span><br></pre></td></tr></table></figure>

<h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd buildroot-tiny200</span><br><span class="line">make widora_mangopi_r3_defconfig</span><br></pre></td></tr></table></figure>

<h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/blog/2021/10/19/git/</url>
    <content><![CDATA[<h3 id="推送新创建git"><a href="#推送新创建git" class="headerlink" title="推送新创建git"></a>推送新创建git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入本地文件夹</span></span><br><span class="line">cd tool</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line">echo &quot;# tool&quot; &gt;&gt; README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化git</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add -A 上传全部</span></span><br><span class="line">git add README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释</span></span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加分支</span></span><br><span class="line">git branch -M main</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加默认远程库</span></span><br><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="推送已存在的库"><a href="#推送已存在的库" class="headerlink" title="推送已存在的库"></a>推送已存在的库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="git删除远程库文件"><a href="#git删除远程库文件" class="headerlink" title="git删除远程库文件"></a>git删除远程库文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --help # 帮助命令</span><br><span class="line">git pull origin master # 将远程仓库里面的项目拉下来</span><br><span class="line">dir # 查看有哪些文件夹</span><br><span class="line">git rm -r --cached yun_app # 删除yun_app文件夹</span><br><span class="line">git commit -m ‘删除了yun_app’ # 提交,添加操作说明</span><br><span class="line">git push -u origin master # 将本次更改更新到github项目上去</span><br></pre></td></tr></table></figure>

<h3 id="git删除远程分支"><a href="#git删除远程分支" class="headerlink" title="git删除远程分支"></a>git删除远程分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速创建分支并切换分支 (dev 分支)</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支 ： 如分支名为dev</span></span><br><span class="line">git branch -d dev 会在删除前检查merge状态（其与上游分支或者与head）。</span><br><span class="line">git branch -D dev 它会直接删除,不检查</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git push origin --delete dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理本地不存在的远程分支，如别人删除了dev,但是你本地查看还有，就可以执行该条命令</span></span><br><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>

<h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 查看分支：git branch</span><br><span class="line"></span><br><span class="line">* 创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-clone文件代理"><a href="#git-clone文件代理" class="headerlink" title="git clone文件代理"></a>git clone文件代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git clone https://ghproxy.com/https://github.com/stilleshan/ServerStatus</span><br><span class="line"></span><br><span class="line">wget &amp; curl</span><br><span class="line">wget https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">wget https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br><span class="line">curl -O https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">curl -O https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>fstream</title>
    <url>/blog/2022/04/26/fstream/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_42333471/article/details/88093789?ops_request_misc=%7B%22request_id%22:%22165093885916782425191425%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165093885916782425191425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88093789.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=+std::ios::out+%7C+std::ios::app&spm=1018.2226.3001.4187">(128条消息) C++ 深究fstream打开方式ios::app,ios::ate,ios::in,ios::out_悟名堂的博客-CSDN博客_fstream ios::app</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><h2 id="默认-覆盖原文件"><a href="#默认-覆盖原文件" class="headerlink" title="默认(覆盖原文件)"></a>默认(覆盖原文件)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第一次打开文件</span></span><br><span class="line">	ofstream outfile;</span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">&quot;D:\\afile.dat&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter your name:&quot;</span>;</span><br><span class="line">	cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line">	outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二次打开文件</span></span><br><span class="line">	ofstream outfile2;</span><br><span class="line">	outfile2.<span class="built_in">open</span>(<span class="string">&quot;D:\\afile.dat&quot;</span>);<span class="comment">//**待修改语句**</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter your age:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; data;</span><br><span class="line">	outfile2 &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	outfile2.<span class="built_in">close</span>();<span class="comment">//第二次关闭文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用iso-app-在文末尾添加"><a href="#使用iso-app-在文末尾添加" class="headerlink" title="使用iso::app(在文末尾添加)"></a>使用iso::app(在文末尾添加)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outfile2.open(&quot;D:\\afile.dat&quot;, ios::app);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>gtest安装与使用</title>
    <url>/blog/2022/04/15/gtest%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/joelcat/article/details/90766192?ops_request_misc=%7B%22request_id%22:%22165087082116780357286038%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165087082116780357286038&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-90766192.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=gtest+cmake&spm=1018.2226.3001.4187">(128条消息) cmake + googletest 之一 入门_Joel的小喵咪的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_39036287/article/details/106772896?ops_request_misc=%7B%22request_id%22:%22165087349316782246480465%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165087349316782246480465&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-106772896.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=gtest+%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">(128条消息) GTest的安装与使用_蕾蕾的好包包的博客-CSDN博客_gtest安装</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://ghproxy.com/https://github.com/google/googletest.git</span><br><span class="line"><span class="built_in">cd</span> googletest &amp;&amp; mkdir build</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake ..</span><br><span class="line">sudo make -j4 </span><br><span class="line"><span class="built_in">cd</span> lib &amp;&amp; </span><br><span class="line">sudo cp *.a /usr/lib</span><br></pre></td></tr></table></figure>

<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── src</span><br><span class="line">│   └── myproject</span><br><span class="line">│       └── myclass.hpp</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── test_my_class.cpp</span><br></pre></td></tr></table></figure>

<h2 id="文件-从上到下"><a href="#文件-从上到下" class="headerlink" title="文件(从上到下)"></a>文件(从上到下)</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启测试</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MY_PROJECT_SRC</span><br><span class="line">        src/myproject/myclass.hpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject</span><br><span class="line">        <span class="variable">$&#123;MY_PROJECT_SRC&#125;</span></span><br><span class="line">        main.cpp )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加测试目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myclass.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">my_class</span>(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="comment"># 查找 GTest 库</span></span><br><span class="line"><span class="keyword">find_package</span>(GTest REQUIRED)</span><br><span class="line"><span class="comment"># GTest 的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;GTEST_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(test_my_class test_my_class.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接测试库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( test_my_class</span><br><span class="line">        <span class="variable">$&#123;GTEST_BOTH_LIBRARIES&#125;</span></span><br><span class="line">        pthread )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到测试</span></span><br><span class="line">gtest_discover_tests(test_my_class)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_my_class.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;myproject/myclass.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_my_class, get_age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">my_class <span class="title">myClass</span><span class="params">(<span class="string">&quot;Joel&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(myClass.<span class="built_in">get_age</span>() == <span class="number">16</span>) &lt;&lt; <span class="string">&quot;age is not 16&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_my_class, get_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">my_class <span class="title">myClass</span><span class="params">(<span class="string">&quot;Joel&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(myClass.<span class="built_in">get_name</span>(), <span class="string">&quot;Joel&quot;</span>) &lt;&lt; <span class="string">&quot;name is not Joel&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="具体工具类"><a href="#具体工具类" class="headerlink" title="具体工具类"></a>具体工具类</h1><h2 id="布尔值检查"><a href="#布尔值检查" class="headerlink" title="布尔值检查"></a>布尔值检查</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_TRUE(<em>condition</em>);</td>
<td>EXPECT_TRUE(<em>condition</em>);</td>
<td><em>condition</em> is true</td>
</tr>
<tr>
<td>ASSERT_FALSE(<em>condition</em>);</td>
<td>EXPECT_FALSE(<em>condition</em>);</td>
<td><em>condition</em> is false</td>
</tr>
</tbody></table>
<h2 id="数值型数据检查"><a href="#数值型数据检查" class="headerlink" title="数值型数据检查"></a>数值型数据检查</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_EQ(<em>expected</em>, <em>actual</em>);</td>
<td>EXPECT_EQ(<em>expected</em>, <em>actual</em>);</td>
<td><em>expected</em> == <em>actual</em></td>
</tr>
<tr>
<td>ASSERT_NE(<em>val1</em>, <em>val2</em>);</td>
<td>EXPECT_NE(<em>val1</em>, <em>val2</em>);</td>
<td><em>val1</em> != <em>val2</em></td>
</tr>
<tr>
<td>ASSERT_LT(<em>val1</em>, <em>val2</em>);</td>
<td>EXPECT_LT(<em>val1</em>, <em>val2</em>);</td>
<td><em>val1</em> &lt; <em>val2</em></td>
</tr>
<tr>
<td>ASSERT_LE(<em>val1</em>, <em>val2</em>);</td>
<td>EXPECT_LE(<em>val1</em>, <em>val2</em>);</td>
<td><em>val1</em> &lt;= <em>val2</em></td>
</tr>
<tr>
<td>ASSERT_GT(<em>val1</em>, <em>val2</em>);</td>
<td>EXPECT_GT(<em>val1</em>, <em>val2</em>);</td>
<td><em>val1</em> &gt; <em>val2</em></td>
</tr>
<tr>
<td>ASSERT_GE(<em>val1</em>, <em>val2</em>);</td>
<td>EXPECT_GE(<em>val1</em>, <em>val2</em>);</td>
<td><em>val1</em> &gt;= <em>val2</em></td>
</tr>
</tbody></table>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_STREQ(<em>expected_str</em>, <em>actual_str</em>);</td>
<td>EXPECT_STREQ(<em>expected_str</em>, <em>actual_str</em>);</td>
<td>两个C字符串有相同的内容</td>
</tr>
<tr>
<td>ASSERT_STRNE(<em>str1</em>, <em>str2</em>);</td>
<td>EXPECT_STRNE(<em>str1</em>, <em>str2</em>);</td>
<td>两个C字符串有不同的内容</td>
</tr>
<tr>
<td>ASSERT_STRCASEEQ(<em>expected_str</em>, <em>actual_str</em>);</td>
<td>EXPECT_STRCASEEQ(<em>expected_str</em>, <em>actual_str</em>);</td>
<td>两个C字符串有相同的内容，忽略大小写</td>
</tr>
<tr>
<td>ASSERT_STRCASENE(<em>str1</em>, <em>str2</em>);</td>
<td>EXPECT_STRCASENE(<em>str1</em>, <em>str2</em>);</td>
<td>两个C字符串有不同的内容，忽略大小写</td>
</tr>
</tbody></table>
<h2 id="异常检查"><a href="#异常检查" class="headerlink" title="异常检查"></a>异常检查</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_THROW(<em>statement</em>, <em>exception_type</em>);</td>
<td>EXPECT_THROW(<em>statement</em>, <em>exception_type</em>);</td>
<td><em>statement</em> throws an exception of the given type</td>
</tr>
<tr>
<td>ASSERT_ANY_THROW(<em>statement</em>);</td>
<td>EXPECT_ANY_THROW(<em>statement</em>);</td>
<td><em>statement</em> throws an exception of any type</td>
</tr>
<tr>
<td>ASSERT_NO_THROW(<em>statement</em>);</td>
<td>EXPECT_NO_THROW(<em>statement</em>);</td>
<td><em>statement</em> doesn’t throw any exception</td>
</tr>
</tbody></table>
<h2 id="浮点型检查"><a href="#浮点型检查" class="headerlink" title="浮点型检查"></a>浮点型检查</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_FLOAT_EQ(<em>expected, actual</em>);</td>
<td>EXPECT_FLOAT_EQ(<em>expected, actual</em>);</td>
<td>the two float values are almost equal</td>
</tr>
<tr>
<td>ASSERT_DOUBLE_EQ(<em>expected, actual</em>);</td>
<td>EXPECT_DOUBLE_EQ(<em>expected, actual</em>);</td>
<td>the two double values are almost equal</td>
</tr>
</tbody></table>
<h2 id="邻近值比较"><a href="#邻近值比较" class="headerlink" title="邻近值比较"></a>邻近值比较</h2><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_NEAR(<em>val1, val2, abs_error</em>);</td>
<td>EXPECT_NEAR*(val1, val2, abs_error*);</td>
<td>the difference between <em>val1</em> and <em>val2</em> doesn’t exceed the given absolute error</td>
</tr>
</tbody></table>
<h2 id="事件机制-全局-gt-TestSuite-gt-TestCase"><a href="#事件机制-全局-gt-TestSuite-gt-TestCase" class="headerlink" title="事件机制(全局-&gt;TestSuite-&gt;TestCase)"></a>事件机制(全局-&gt;TestSuite-&gt;TestCase)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;</span><br><span class="line">        age=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*********** &quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot; **********&quot;</span>&lt;&lt;endl;;</span><br><span class="line">        &#125;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooEnvironment</span> :</span> <span class="keyword">public</span> testing::Environment&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment SetUP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment TearDown&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> Student *s;</span><br><span class="line"><span class="comment">//在第一个test之前，最后一个test之后调用SetUpTestCase()和TearDownTestCase()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMap</span>:</span><span class="keyword">public</span> testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpTestCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;SetUpTestCase()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    s=<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TearDownTestCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TearDownTestCase()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;SetUp() is running&quot;</span>&lt;&lt;endl;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TearDown()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">TEST_F</span>(TestMap, Test1)</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// you can refer to s here</span></span><br><span class="line">    s-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testing::<span class="built_in">AddGlobalTestEnvironment</span>(<span class="keyword">new</span> FooEnvironment);</span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>hector源码理解</title>
    <url>/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>大佬的分析,包含代码注释解析与源码重写,论文翻译</p>
<p><a href="https://blog.csdn.net/qq_36355662/article/details/90349302">Hector_slam源码框架分析_翎风的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/cyberniklee/p/8484104.html">Hector SLAM解读（1）原文翻译 - cyberniklee - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/scomup/p/7075296.html">HectorSLAM论文解析・代码重写（2） - scomup - 博客园 (cnblogs.com)</a></p>
<p><a href="https://github.com/zhangwenxiao/HectorSlamWithoutROS">zhangwenxiao/HectorSlamWithoutROS: 脱离ROS的hector slam算法 (github.com)</a></p>
<h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>该开源系统的主要代码在hector_mapping文件夹中，文件夹里有src文件夹和include文件夹，包含了算法所有的核心代码。<br>通过对源码的梳理，整理出了如下流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190520100840536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU1NjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>大佬的图非常清晰的可以看到,整个代码分为<code>地图匹配</code>与<code>地图更新</code></p>
<h1 id="地图匹配"><a href="#地图匹配" class="headerlink" title="地图匹配"></a>地图匹配</h1><p>主要采用<strong>非线性优化</strong>—-<strong>高斯牛顿法</strong>,实际上就是通过激光数据与现有地图的差距(双线性插补),通过最小二乘法,计算概率,从而更新位移增量,计算出机器人最可能存在位置</p>
<h2 id="双线性插值计算栅格概率"><a href="#双线性插值计算栅格概率" class="headerlink" title="双线性插值计算栅格概率"></a>双线性插值计算栅格概率</h2><p><a href="https://zhuanlan.zhihu.com/p/110754637">一篇文章为你讲透双线性插值 - 知乎 (zhihu.com)</a></p>
<p>通过双线性插补得到一个位置,然后通过最小二乘法,更新位移增量</p>
<h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1b441177kr?from=search&seid=5703864891923353812&spm_id_from=333.337.0.0">【泡泡机器人公开课】第三十课：非线性优化与g2o-高翔_哔哩哔哩_bilibili</a></p>
<h1 id="地图更新"><a href="#地图更新" class="headerlink" title="地图更新"></a>地图更新</h1><p>用bresenham<code>划线</code>算法计算激光途经栅格</p>
<p><a href="https://blog.csdn.net/yzh1994414/article/details/82860187">(60条消息) Bresenham 算法原理_yzh1994414的博客-CSDN博客_bresenham</a></p>
<p><a href="https://blog.csdn.net/datase/article/details/83620338">画线算法-Bresenham算法_天才樱木-CSDN博客_bresenham画线算法</a></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><p>（1）不需要使用里程计，可以用于地面不平坦区域及空中飞行器。<br>（2）使用多分辨率地图能避免局部最小值。</p>
<h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h4><p>（1）要求雷达更新频率较高，测量噪声小；或者机器人运动速度低。<br>（2）无法利用精确的里程计信息。</p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>g2o与ceres-solver安装</title>
    <url>/blog/2022/04/19/g2o%E4%B8%8Eceres-solver%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/zzcjake/article/details/113817651">(127条消息) ubuntu18.04安装g2o_弓满路长的博客-CSDN博客_ubuntu18.04安装g2o</a></p>
<h1 id="g2o安装"><a href="#g2o安装" class="headerlink" title="g2o安装"></a>g2o安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install libeigen3-dev libsuitesparse-dev qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5</span><br><span class="line"><span class="comment"># 下载g2o</span></span><br><span class="line">git <span class="built_in">clone</span> https://ghproxy.com/https://github.com/RainerKuemmerle/g2o.git</span><br><span class="line"><span class="built_in">cd</span> g2o &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="ceres-solver安装"><a href="#ceres-solver安装" class="headerlink" title="ceres-solver安装"></a>ceres-solver安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line">deb https://cz.archive.ubuntu.com/ubuntu trusty main universe</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br><span class="line"><span class="comment"># 获取ceres-solver</span></span><br><span class="line">git <span class="built_in">clone</span> https://ceres-solver.googlesource.com/ceres-solver</span><br><span class="line"><span class="built_in">cd</span> ceres-solver &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo安装</title>
    <url>/blog/2021/12/17/hexo%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.no_search_link&spm=1001.2101.3001.4242.1">(91条消息) hexo史上最全搭建教程_Fangzh的技术博客-CSDN博客_hexo</a> </p>
<p> <a href="https://blog.csdn.net/guzhao593/article/details/81712016?ops_request_misc=%7B%22request_id%22:%22164057576416780357213843%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164057576416780357213843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81712016.pc_search_insert_es_download&utm_term=%E5%8D%87%E7%BA%A7node%E7%89%88%E6%9C%AC&spm=1018.2226.3001.4187">(91条消息) node版本如何升级_赵天铭的博客-CSDN博客_升级node版本</a> </p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装git</span></span><br><span class="line">sudo apt-get install git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装nodejs</span></span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h1 id="nodejs问题"><a href="#nodejs问题" class="headerlink" title="nodejs问题"></a>nodejs问题</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g n</span><br><span class="line">npm i -g n --force</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级版本号</span></span><br><span class="line">n 版本号 如 n 10.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级最新</span></span><br><span class="line">n latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级最近稳定</span></span><br><span class="line">n stable</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hex解析</title>
    <url>/blog/2022/01/03/hex%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/a1037488611/article/details/43340055?ops_request_misc=%7B%22request_id%22:%22164121480016780269824327%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164121480016780269824327&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-43340055.nonecase&utm_term=hex%E8%A7%A3%E6%9E%90&spm=1018.2226.3001.4450">(94条消息) HEX文件格式解析_a1037488611的专栏-CSDN博客_hex文件格式解析</a> </p>
<h1 id="格式如下"><a href="#格式如下" class="headerlink" title="格式如下"></a>格式如下</h1><p><img src="https://s2.loli.net/2022/01/03/UjoEasnlNmLwYtZ.png" alt="1641215282358.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">：(冒号)每个Intel HEX 记录 都由冒 号开头 ；</span><br><span class="line">LL 是 数 据 长 度域, 它 代表 记录当 中 数 据字 节 (dd) 的 数量 ；</span><br><span class="line">aaaa 是地址域, 它代表 记录当 中 数据的起始地址；</span><br><span class="line">TT是代表HEX 记录类 型的域 , 它 可能是以下 数 据 当 中的一 个：</span><br><span class="line">    00 – 数 据 记录（Data Record）</span><br><span class="line">    01 – 文件结 束 记录（End of FileRecord）</span><br><span class="line">    02 – 扩展段地址 记录（ExtendedSegment Address Record）</span><br><span class="line">	03 – 开始段地址 记录（Start Segment Address Record）</span><br><span class="line">    04 – 扩展 线 性地址 记录（Extended Linear Address Record）</span><br><span class="line">	05 – 开始线性地址 记录（Extended Segment Address Record）</span><br><span class="line">dd 是数 据域 , 它 代表一 个 字 节 的 数 据. 一 个记录 可以有 许 多 数 据字 节 . 记录当 中 数 据字 节 的 数 量必 须 和数 据 长 度域(ll) 中指定的 数字相符.</span><br><span class="line">cc 是校验 和域 , 它 表示 这个记录 的校 验 和. 校 验 和的 计 算是通 过将记录当 中所有十六 进 制 编码数 字 对 的 值相加, 以256 为 模 进 行以下 补 足.</span><br><span class="line"></span><br><span class="line">表示为：“：[1字节长度][2字节地址][1字节记录类型][n字节段][1字节校验和] ”</span><br></pre></td></tr></table></figure>

<h1 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10 2462 00 464C5549442050524F46494C4500464C33</span><br><span class="line">：[10个数据长度][字节地址为:0x2462][记录类型为:00 数据记录][n字节段数据][crc校验:0x33]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>hector基础使用</title>
    <url>/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_41459903/article/details/102795148">思岚A1激光雷达hector_mapping建图与定位_欧俊岑的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_44785456/article/details/116789296?ops_request_misc=%7B%22request_id%22:%22163453792216780255277807%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163453792216780255277807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116789296.pc_search_ecpm_flag&utm_term=r2000+hector&spm=1018.2226.3001.4187">tx2+r2000激光雷达 hector建图_大家安静啊的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_36170626/article/details/98316545?ops_request_misc=%7B%22request_id%22:%22163454144916780262550313%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163454144916780262550313&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-98316545.pc_search_ecpm_flag&utm_term=hector_slam%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187">hectorslam之EAI雷达(ydlidar_x2l)配置过程_sunshine-CSDN博客</a></p>
<p><a href="https://github.com/NickL77/RPLidar_Hector_SLAM">NickL77/RPLidar_Hector_SLAM: Hector SLAM without odometry data on ROS with the RPLidar A1 (github.com)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hector是纯粹基于laserscan数据的算法,只需要提供scan数据即可,这里使用r2000做实验.因此第一步应该发布scan数据.</p>
<h1 id="Scan激光数据发布"><a href="#Scan激光数据发布" class="headerlink" title="Scan激光数据发布"></a>Scan激光数据发布</h1><p>r2000提供了ros发布的驱动文件,因此只需要修改些配置即可.</p>
<p>驱动网址:</p>
<p><a href="https://github.com/dillenberger/pepperl_fuchs">dillenberger/pepperl_fuchs: Pepperl+Fuchs R2000 Driver (github.com)</a></p>
<p>修改一下配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pepperl_fuchs_r2000&quot;</span> <span class="attr">type</span>=<span class="string">&quot;r2000_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;r2000_driver_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scanner_ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.1.19&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;frame_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;laser_link&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_frequency&quot;</span> <span class="attr">value</span>=<span class="string">&quot;35&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;samples_per_scan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;remap from=&quot;/r2000_driver_node/scan&quot; to=&quot;scan&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;node pkg=&quot;dummy_slam_broadcaster&quot; type=&quot;dummy_slam_broadcaster_node&quot; name=&quot;dummy_slam_broadcaster&quot;/&gt;</span></span><br><span class="line"><span class="comment">  &lt;node name=&quot;rvizLocal&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; respawn=&quot;false&quot; output=&quot;screen&quot; args=&quot;-d $(find pepperl_fuchs_r2000)/rviz/test.rviz&quot; required=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanner_ip       r2000的配置激光ip地址</span><br><span class="line">frame_id         发布出去的框架id(用于tf转换)</span><br><span class="line">scan_frequency   扫描频率</span><br><span class="line">samples_per_scan 每圈的扫描数</span><br><span class="line"># 值得注意的是这里r2000发不出去的scan节点为/r2000_driver_node/scan</span><br><span class="line"># 可以通过remap重定义为/scan</span><br><span class="line">最后通过rviz显示</span><br></pre></td></tr></table></figure>

<p>ros执行命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br></pre></td></tr></table></figure>

<h1 id="使用hector-mapping建图并定位"><a href="#使用hector-mapping建图并定位" class="headerlink" title="使用hector_mapping建图并定位"></a>使用hector_mapping建图并定位</h1><p>这里可以直接在系统中安装hector,并新建<code>hector_mapping.launch</code>文件,指令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-hector-slam</span><br><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_create_pkg run_launch # 因为内部都是launch文件并不需要依赖包</span><br><span class="line">cd run_launch &amp;&amp; sudo mkdir launch &amp;&amp; cd launch</span><br><span class="line">sudo nano hector_mapping.launch</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Frame names --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定map-&gt; odom转换是否应该由系统发布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_odom_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坐标系id,hector会将map与车体做tf连接到一块,而车体与激光之间的连接需要我们自己做 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;map&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于没有使用里程计,改为base_link即可 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Tf use --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_scan_transformation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_pose_start_estimate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map size / start point --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_resolution&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 地图尺寸需要注意一下,如果地图太小,可能导致激光范围过大,超出地图,这样匹配坐标会很挫 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;512&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_min_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;-1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_multi_res_levels&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_pub_period&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_min_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 激光扫描距离要适中,如果太小也会出现建图建的很挫的现象 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_timing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定scanmatcher到map的转换是否发布到TF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_scanmatch_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布的坐标名 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map update parameters --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_free&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_occupied&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.7&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_distance_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_angle_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.06&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Advertising config --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;advertise_map_service&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描订阅器的队列大小 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_subscriber_queue_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里更改一下scan_topic 如果我们做了重定向,需要改为/scan--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_topic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/r2000_driver_node/scan&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- !注意:这一步需要将车体坐标系与激光坐标系进行tf转换连接起来 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_to_laser_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0.105 0 0 0 /base_link /laser_link 100&quot;</span>/&gt;</span>_</span><br><span class="line">	<span class="comment">&lt;!-- 这里使用的是hector自带的rviz配置,我们也可以在他的基础上增减功能,另存到我们自己的文件src/run_launch/rviz/map/hector_map.rviz --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行步骤:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发布scan数据</span></span><br><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动hector_mapping</span></span><br><span class="line">roslaunch run_launch hector_mapping.launch</span><br></pre></td></tr></table></figure>

<h1 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h1><p><img src="https://img-blog.csdnimg.cn/20210514140914724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210514140924770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.订阅/scan不要出错</p>
<p>2.tf转换尤为需要注意,map-&gt;base_link-&gt;laser_link</p>
<p>3.激光距离与地图大小需要注意一下,这里设不好容易崩</p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>hugo配置</title>
    <url>/blog/2021/10/19/hugo/</url>
    <content><![CDATA[<h3 id="git安装与配置"><a href="#git安装与配置" class="headerlink" title="git安装与配置"></a>git安装与配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install git </span><br><span class="line"><span class="meta">#</span><span class="bash">git配置</span></span><br><span class="line">git config --global user.name &quot;zoey&quot;</span><br><span class="line">git config --global user.email &quot;zoey686@163.com&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看设置用户名与密码</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="hugo安装"><a href="#hugo安装" class="headerlink" title="hugo安装"></a>hugo安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo apt install hugo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动安装</span></span><br><span class="line">wget https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.deb</span><br><span class="line">sudo dpkg -i hugo_0.54.0_Linux-64bit.deb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">hugo --help</span><br><span class="line">hugo version</span><br></pre></td></tr></table></figure>

<h4 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h4><p>新建git文件夹用以git模板等，并在文件夹下新建myblog，用来存放博客页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建git文件夹并git初始化</span></span><br><span class="line">mkdir gitFile  </span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建myblog文件夹用来存放博客页面</span></span><br><span class="line">hugo new site myblog</span><br></pre></td></tr></table></figure>

<p>myblog下面就会有以下几个文件夹自动生成</p>
<table>
<thead>
<tr>
<th align="center">文件夹名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">archetypes</td>
<td align="center">文章开头形式</td>
</tr>
<tr>
<td align="center">content</td>
<td align="center">内容</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">自定义模板</td>
</tr>
<tr>
<td align="center">layouts</td>
<td align="center">网页模板文件</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">存储图片一些其他的资源</td>
</tr>
<tr>
<td align="center">themes</td>
<td align="center">主题</td>
</tr>
<tr>
<td align="center">config.toml</td>
<td align="center">配置文件</td>
</tr>
</tbody></table>
<h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>在（<a href="https://themes.gohugo.io/%EF%BC%89%E4%B8%AD%E6%8C%91%E9%80%89%E4%B8%BB%E9%A2%98,%E8%BF%99%E9%87%8C%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFdiary%E4%B8%BB%E9%A2%98%EF%BC%88[Diary">https://themes.gohugo.io/）中挑选主题,这里选择的是diary主题（[Diary</a> | Hugo Themes (gohugo.io)](<a href="https://themes.gohugo.io/themes/hugo-theme-diary/)%EF%BC%89">https://themes.gohugo.io/themes/hugo-theme-diary/)）</a></p>
<p>例子：（<a href="https://sunua.gitee.io/simonblog/">浅蓝色 (gitee.io)</a>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载diary主题到themes文件夹下并重命名为diary</span></span><br><span class="line">git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置config.toml文件</span></span><br><span class="line">nano config.toml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baseURL = &quot;https://peitianyu.github.io/pty_blog.github.io&quot;</span><br><span class="line">DefaultContentLanguage = &quot;zh&quot; # Theme&#x27;s display language, supports: en, fr, zh, zh-hant</span><br><span class="line">languageCode = &quot;zh-hant&quot;</span><br><span class="line">title = &quot;武装带你&quot;</span><br><span class="line">copyright = &quot;This is a customized copyright.&quot;</span><br><span class="line">theme = &quot;diary&quot;</span><br><span class="line"></span><br><span class="line">[markup]</span><br><span class="line">  [markup.highlight]</span><br><span class="line">    codeFences = true</span><br><span class="line">    guessSyntax = false</span><br><span class="line">    hl_Lines = &quot;&quot;</span><br><span class="line">    lineNoStart = 1</span><br><span class="line">    lineNos = false</span><br><span class="line">    lineNumbersInTable = true</span><br><span class="line">    noClasses = true</span><br><span class="line">    style = &quot;perldoc&quot;</span><br><span class="line">    tabWidth = 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enableOpenGraph = true</span><br><span class="line">enableTwitterCards = true</span><br><span class="line">title = &quot;My Blog&quot; </span><br><span class="line">description = &quot;My HomePage Description&quot;  </span><br><span class="line"></span><br><span class="line">[taxonomies]</span><br><span class="line">   ros = &quot;Ros&quot;</span><br><span class="line">   blog = &quot;Blog&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/blog&quot;</span><br><span class="line">name = &quot;Blog&quot;</span><br><span class="line">weight = 1</span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/ros&quot;</span><br><span class="line">name = &quot;Ros&quot;</span><br><span class="line">weight = 2</span><br></pre></td></tr></table></figure>

<h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><p>默认主目录文章在content/post下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建文章</span><br><span class="line">hugo new post/my_first_blog.md</span><br><span class="line">#创建文章在需要目录(Archive)下</span><br><span class="line">hugo new posts/my_first_blog.md</span><br><span class="line">cd content/post</span><br><span class="line">nano my_first_blog.md</span><br><span class="line"># 注意将draft参数改为false，否则跳过草稿文件，无法预览</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;my_first_blog&quot;</span><br><span class="line">date: 2021-10-12T10:49:31+08:00</span><br><span class="line">draft : false</span><br><span class="line">---</span><br><span class="line">文本内容</span><br></pre></td></tr></table></figure>

<p>本地调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hugo server --theme=blackburn --buildDrafts</span><br></pre></td></tr></table></figure>

<p>其中 –theme 选项可以指定主题，–buildDrafts 包括标记为草稿<br>然后在浏览器里打开： <a href="http://localhost:1313/">http://localhost:1313</a> 即可访问到你的博客</p>
<h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>如果你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：<code>pty_blog.github.io</code> （<strong>pty_blog替换为你的github用户名的小写</strong>）</p>
<p>进入仓库，点击<strong>Settings</strong>进入，找到<strong>GitHub Pages</strong>并点击<strong>Check it out here!<strong>，配置</strong>Source</strong>并<strong>save</strong>，会发现绿色框中显现 <code>Your site is published at https://peitianyu.github.io/pty_blog.github.io/</code></p>
<p>此处<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E4%B9%9F%E6%98%AFconfig.toml%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E8%AE%BE%E7%BD%AEhugo%E7%99%BB%E9%99%86%E7%BD%91%E5%9D%80">https://peitianyu.github.io/pty_blog.github.io/就是我们的网址，也是config.toml文件中设置的网址，设置hugo登陆网址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里的 –baseUrl 一定是https://（Hugo中文文档里为http://），不然你部署后的博客会没有样式！</p>
<p>可看到根目录下多出 /public文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。然后继续在你的站点根目录执行git 命令，添加远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd public</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:peitianyu/pty_blog.github.io.git</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>然后浏览器里访问：<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9A%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82">https://peitianyu.github.io/pty_blog.github.io/即可看到刚刚搭建的博客。</a></p>
<p>发布博客并更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建博客markdown文件，并编辑博客内容(文件名为 **.md )</span><br><span class="line">hugo new post/newBlog.md</span><br><span class="line"># 生成静态页面</span><br><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br><span class="line"># 发布</span><br><span class="line">cd public</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;new blog added&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>io扩展</title>
    <url>/blog/2021/11/11/io%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u012388993/article/details/106386381?ops_request_misc=%7B%22request_id%22:%22163650486016780366540586%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=163650486016780366540586&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-19-106386381.pc_v2_rank_blog_default&utm_term=%E6%89%A9%E5%B1%95io&spm=1018.2226.3001.4450">IO口不够了？基于I2C的 IO扩展芯片驱动和开发_arenascat的博客-CSDN博客_io扩展芯片</a></p>
<p><a href="https://blog.csdn.net/zhengqijun_/article/details/53011409?ops_request_misc=%7B%22request_id%22:%22163650477816780265471235%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163650477816780265471235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-53011409.pc_search_mgc_flag&utm_term=%E6%89%A9%E5%B1%95io&spm=1018.2226.3001.4187">单片机扩展IO口_我的博客-CSDN博客</a></p>
<h1 id="74HC164-三八译码器-矩阵键盘"><a href="#74HC164-三八译码器-矩阵键盘" class="headerlink" title="74HC164(三八译码器),矩阵键盘"></a>74HC164(三八译码器),矩阵键盘</h1><p>这种方式可以实现简单的io扩展,但不可以保持,也就是说,治理只是三位二进制转为八个数,虽然也可以通过加快频率的方式实现.仅用于对时序要求不高的电路,比如led流水灯,而尤其是通讯不太适用的.</p>
<h1 id="采用可编程I-O接口扩展芯片"><a href="#采用可编程I-O接口扩展芯片" class="headerlink" title="采用可编程I/O接口扩展芯片"></a>采用可编程I/O接口扩展芯片</h1><p>这种方式可以实现io扩展,不过需要一定的编程经验.</p>
<p>采用芯片有 <code>8255a</code> 与 <code>MCP23016</code></p>
<p><a href="https://so.szlcsc.com/global.html?k=i/o%E6%89%A9%E5%B1%95%E8%8A%AF%E7%89%87&hot-key=MB85RC16PNF-G-JNERE1">i/o扩展芯片_i/o扩展芯片采购信息-立创电子元器件商城 (szlcsc.com)</a></p>
<h1 id="采用A-D获取按键的位置"><a href="#采用A-D获取按键的位置" class="headerlink" title="采用A/D获取按键的位置"></a>采用A/D获取按键的位置</h1><p>通过不同电压对应不通按键,挺不错的思路</p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>icp</title>
    <url>/blog/2022/04/23/icp/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/A_L_A_N/article/details/81329728?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">(128条消息) 迭代最近点 ICP 详细推导（C++实现）_Alan Lan的博客-CSDN博客_迭代最近点算法</a></p>
<p><a href="https://blog.csdn.net/kksc1099054857/article/details/80280964?ops_request_misc=%7B%22request_id%22:%22165072453016782094836291%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165072453016782094836291&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80280964.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=icp%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(128条消息) ICP算法的原理与实现_酷小川的博客-CSDN博客_icp算法</a></p>
<p><a href="https://blog.csdn.net/jinxianlovelss/article/details/107418509">(128条消息) 基于kdtree与svd的迭代最近点ICP算法的matlab实现_头顶日渐发凉的博客-CSDN博客</a></p>
<p><a href="https://github.com/zjudmd1015/icp">zjudmd1015/icp (github.com)</a></p>
<p><a href="https://github.com/ClayFlannigan/icp">ClayFlannigan/icp: iterative closest point (github.com)</a></p>
<p><a href="https://github.com/Gregjksmith/Iterative-Closest-Point">Gregjksmith/Iterative-Closest-Point</a></p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求质心,求t</span><br><span class="line">去中心化</span><br><span class="line">计算SVD,求R</span><br><span class="line">迭代</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigen&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Eigen::Vector3f&gt;&amp; p1, <span class="keyword">const</span> std::vector&lt;Eigen::Vector3f&gt;&amp; p2,</span></span></span><br><span class="line"><span class="params"><span class="function">         Eigen::Matrix3f&amp; R_12, Eigen::Vector3f&amp; t_12)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(p1.<span class="built_in">size</span>() == p2.<span class="built_in">size</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// center of mass</span></span><br><span class="line">    <span class="keyword">size_t</span> N = p1.<span class="built_in">size</span>();</span><br><span class="line">    Eigen::Vector3f p1_center, p2_center;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        p1_center += p1.<span class="built_in">at</span>(i);</span><br><span class="line">        p2_center += p2.<span class="built_in">at</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    p1_center /= N;</span><br><span class="line">    p2_center /= N;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// remove the center</span></span><br><span class="line">    <span class="function">std::vector&lt;Eigen::Vector3f&gt; <span class="title">q1</span><span class="params">(N)</span>, <span class="title">q2</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        q1[i] = p1.<span class="built_in">at</span>(i) - p1_center;</span><br><span class="line">        q2[i] = p2.<span class="built_in">at</span>(i) - p2_center;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// compute q2*q1^T</span></span><br><span class="line">    Eigen::Matrix3f H = Eigen::Matrix3f::<span class="built_in">Zero</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        H += q2.<span class="built_in">at</span>(i) * q1.<span class="built_in">at</span>(i).<span class="built_in">transpose</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// SVD on H</span></span><br><span class="line">    <span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3f&gt; <span class="title">svd</span><span class="params">(H, Eigen::ComputeFullU | Eigen::ComputeFullV)</span></span>;</span><br><span class="line">    Eigen::Matrix3f U = svd.<span class="built_in">matrixU</span>();</span><br><span class="line">    Eigen::Matrix3f V = svd.<span class="built_in">matrixV</span>();</span><br><span class="line"> </span><br><span class="line">    R_12 = V * U.<span class="built_in">transpose</span>();</span><br><span class="line">    t_12 = p1_center - R_12 * p2_center;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::AngleAxisf <span class="title">angle_axis</span><span class="params">(M_PI / <span class="number">3</span>, Eigen::Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    Eigen::Matrix3f R_12_ = angle_axis.<span class="built_in">matrix</span>();</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">t_12_</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;except R_12:\n&quot;</span> &lt;&lt; R_12_ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;except t_12:\n&quot;</span> &lt;&lt; t_12_.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;Eigen::Vector3f&gt; p1, p2;</span><br><span class="line">    Eigen::Vector3f point;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;/tmp/bunny.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(fin, line)) &#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        ss &gt;&gt; point.<span class="built_in">x</span>();</span><br><span class="line">        ss &gt;&gt; point.<span class="built_in">y</span>();</span><br><span class="line">        ss &gt;&gt; point.<span class="built_in">z</span>();</span><br><span class="line">        p2.<span class="built_in">push_back</span>(point);</span><br><span class="line">        p1.<span class="built_in">push_back</span>(R_12_ * point + t_12_);</span><br><span class="line">    &#125;</span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    Eigen::Matrix3f R_12;</span><br><span class="line">    Eigen::Vector3f t_12;</span><br><span class="line">    <span class="built_in">ICP</span>(p1, p2, R_12, t_12);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result R_12:\n&quot;</span> &lt;&lt; R_12_ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result t_12:\n&quot;</span> &lt;&lt; t_12.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>k60_can_bootloader</title>
    <url>/blog/2021/12/10/k60_can_bootloader/</url>
    <content><![CDATA[<h3 id="参考demo"><a href="#参考demo" class="headerlink" title="参考demo:"></a>参考demo:</h3><p><a href="https://github.com/peitianyu/k60_bootloader">peitianyu/k60_bootloader (github.com)</a></p>
<h3 id="main-c文件配置"><a href="#main-c文件配置" class="headerlink" title="main.c文件配置"></a>main.c文件配置</h3><h4 id="进入mian-c文件加入头文件并引用bootloader-entry-函数"><a href="#进入mian-c文件加入头文件并引用bootloader-entry-函数" class="headerlink" title="进入mian.c文件加入头文件并引用bootloader_entry()函数"></a>进入mian.c文件加入头文件并引用bootloader_entry()函数</h4><p><img src="https://s2.loli.net/2021/12/10/ywEp53mGsnHMbYc.png" alt="1.PNG"></p>
<h4 id="使用ID-0x10发送06-00-00-00-00-00-00-00，表示已经进入app"><a href="#使用ID-0x10发送06-00-00-00-00-00-00-00，表示已经进入app" class="headerlink" title="使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app"></a>使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app</h4><p><img src="https://s2.loli.net/2021/12/10/SvE7taw8y9ozPbh.png" alt="2.png"></p>
<h4 id="判断bootflag是否制一，若是，进入boot模式"><a href="#判断bootflag是否制一，若是，进入boot模式" class="headerlink" title="判断bootflag是否制一，若是，进入boot模式"></a>判断bootflag是否制一，若是，进入boot模式</h4><p><img src="https://s2.loli.net/2021/12/10/7pd6cl9bwtKPzFT.png" alt="3.png"></p>
<h3 id="canbus-c文件配置"><a href="#canbus-c文件配置" class="headerlink" title="canbus.c文件配置"></a>canbus.c文件配置</h3><h4 id="在canbus-c文件中引用头文件，并判断是否0x25发来数据，若有且data-data-0-1-则bootflag-1"><a href="#在canbus-c文件中引用头文件，并判断是否0x25发来数据，若有且data-data-0-1-则bootflag-1" class="headerlink" title="在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1"></a>在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1</h4><p><img src="https://s2.loli.net/2021/12/10/1nd3eMiXpUtBlAr.png" alt="4.png"></p>
<h3 id="keil配置"><a href="#keil配置" class="headerlink" title="keil配置"></a>keil配置</h3><h4 id="将hex烧录地址改为从0x6000开始"><a href="#将hex烧录地址改为从0x6000开始" class="headerlink" title="将hex烧录地址改为从0x6000开始"></a>将hex烧录地址改为从0x6000开始</h4><p><img src="https://s2.loli.net/2021/12/10/UhGvZDBPQqSeM9Y.png" alt="5.png"></p>
<h3 id="树莓派使用"><a href="#树莓派使用" class="headerlink" title="树莓派使用"></a>树莓派使用</h3><h4 id="bootloader-can0-xx-hex"><a href="#bootloader-can0-xx-hex" class="headerlink" title="./bootloader can0 xx.hex"></a>./bootloader can0 xx.hex</h4><p><img src="https://s2.loli.net/2021/12/10/wkOHJ3reb8AXVyT.png" alt="7.PNG"></p>
<h3 id="挂载win10"><a href="#挂载win10" class="headerlink" title="挂载win10"></a>挂载win10</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.2.101/2021.04/CH-K-Lib/Project/1/bootloader/MDK/mk60d10/flash /k60 -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>jetson_nano 踩坑</title>
    <url>/blog/2021/10/19/jetson_nano/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/166464566">玩转智能硬件之Jetson Nano(一)安装篇 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/Ay_yzx/article/details/113779544">Jetson Nano-配置环境_Ay_yzx的博客-CSDN博客</a></p>
<h4 id="预先下载"><a href="#预先下载" class="headerlink" title="预先下载:"></a>预先下载:</h4><p><code>balenaEtcher</code></p>
<p><a href="https://www.balena.io/etcher/">balenaEtcher - Flash OS images to SD cards &amp; USB drives</a></p>
<p><code>系统下载</code></p>
<p>官方默认系统:</p>
<p><a href="https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw">https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw</a></p>
<p>Ubuntu18.04:</p>
<p><a href="https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig">https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig</a> 密码 : tun3</p>
<p><code>sd卡格式化工具</code></p>
<p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">SD Memory Card Formatter for Windows Download | SD Association (sdcard.org)</a></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.格式化sd卡</span><br><span class="line">2.使用balenaEtcher烧录下载好的系统</span><br><span class="line">3.插上卡后做初始化设置</span><br></pre></td></tr></table></figure>

<h3 id="jetson三种供电方式"><a href="#jetson三种供电方式" class="headerlink" title="jetson三种供电方式:"></a>jetson三种供电方式:</h3><h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/weixin_44350337/article/details/111674531?ops_request_misc=%7B%22request_id%22:%22163456105816780262525022%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163456105816780262525022&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111674531.pc_search_ecpm_flag&utm_term=jetson+%E4%BE%9B%E7%94%B5&spm=1018.2226.3001.4187">Jetson nano 的三种供电方式_Dunkle.T的博客-CSDN博客_jetson nano供电</a></p>
<h4 id="分别为"><a href="#分别为" class="headerlink" title="分别为:"></a>分别为:</h4><ul>
<li>USB供电(默认5v2a 仅低功率),使用时拔去条线帽</li>
<li>使用 DC 供电(默认5v 4A),使用时插上跳线帽</li>
<li>使用引脚供电(5v3a 无所谓跳线帽)</li>
</ul>
<h4 id="查看cuda配置"><a href="#查看cuda配置" class="headerlink" title="查看cuda配置"></a>查看cuda配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install jetson-stats</span><br><span class="line">sudo jtop</span><br></pre></td></tr></table></figure>

<h3 id="关于ros安装"><a href="#关于ros安装" class="headerlink" title="关于ros安装"></a>关于ros安装</h3><h4 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://peitianyu.github.io/pty_blog.github.io/ros/ros%E5%AE%89%E8%A3%85/">ROS_安装 (peitianyu.github.io)</a></p>
<h4 id="其他部分按ros安装教程来即可"><a href="#其他部分按ros安装教程来即可" class="headerlink" title="其他部分按ros安装教程来即可"></a>其他部分按ros安装教程来即可</h4><p>比较实用的方案是先按照我的步骤安装ros,之后再通过<code>fishros一行代码</code>解决rosdep问题</p>
<h3 id="远程连接nano"><a href="#远程连接nano" class="headerlink" title="远程连接nano"></a>远程连接nano</h3><p><code>ssh.exe usrname@192.168.xxx.xxx</code></p>
<h3 id="jetson-nano初始化配置"><a href="#jetson-nano初始化配置" class="headerlink" title="jetson nano初始化配置"></a>jetson nano初始化配置</h3><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><code>静态ip设置</code>:<a href="https://www.cnblogs.com/blueyunchao0618/p/11394640.html">Ubuntu 18.04配置静态IP地址)</a></p>
<h4 id="root免密登录"><a href="#root免密登录" class="headerlink" title="root免密登录"></a>root免密登录</h4><p><code>参考网址</code>:<a href="https://blog.csdn.net/qq_44673299/article/details/108658078?ops_request_misc=%7B%22request_id%22:%22163463123116780271513740%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163463123116780271513740&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-108658078.pc_search_ecpm_flag&utm_term=Ubuntu18+root%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95&spm=1018.2226.3001.4187">ubuntu设置root免密登陆</a></p>
<h3 id="vscode连接jetson-nano"><a href="#vscode连接jetson-nano" class="headerlink" title="vscode连接jetson nano"></a>vscode连接jetson nano</h3><h4 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/sqlquan/article/details/111918019?ops_request_misc=%7B%22request_id%22:%22163463106616780264095126%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163463106616780264095126&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111918019.pc_search_ecpm_flag&utm_term=vscode+ssh&spm=1018.2226.3001.4187">vscode设置ssh进行远程编辑_Quan的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>jps</title>
    <url>/blog/2022/03/18/jps/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_45929038/article/details/123133488?ops_request_misc=%7B%22request_id%22:%22164776742216780265425970%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164776742216780265425970&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-123133488.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=jps%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(116条消息) JPS算法_Jason.Li_0012的博客-CSDN博客_jps 算法</a> </p>
<p> <a href="https://www.bilibili.com/video/BV1Et4y167Ak?p=7">运动规划_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/YYRise/jps">YYRise/jps: python实现跳点寻路算法（JPS：Jump Point Search） (github.com)</a> </p>
<p> <a href="https://zhuanlan.zhihu.com/p/290924212">最快速的寻路算法 Jump Point Search - 知乎 (zhihu.com)</a> </p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p><img src="https://s2.loli.net/2022/03/20/k6nXTPCDLwoVuYc.jpg" alt="v2-b2096f0c3630d59238a4d51300c2b8aa_720w.jpg"></p>
<p>与A*算法流程完全一样,只是对于邻接节点的定义不同, <em>A</em>∗算法的邻居节点为几何意义上的邻居，而Jps算法的邻居节点为跳跃所得的邻居。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始</span><br><span class="line">	将起点放入open list中</span><br><span class="line">	while true</span><br><span class="line">		if open list 为空</span><br><span class="line">			搜索失败,结束</span><br><span class="line">		取open list中最小节点</span><br><span class="line">		if 节点为终点</span><br><span class="line">			找到路径,结束</span><br><span class="line">		拓展该节点子节点</span><br><span class="line">		将节点放入closed list中</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<h1 id="修剪邻居节点与跳转规则"><a href="#修剪邻居节点与跳转规则" class="headerlink" title="修剪邻居节点与跳转规则"></a>修剪邻居节点与跳转规则</h1><p><img src="https://s2.loli.net/2022/03/21/zGTZnNfD8s4yQqa.png" alt="1647822945_1_.png"></p>
<h1 id="jps代码"><a href="#jps代码" class="headerlink" title="jps代码"></a>jps代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找路径的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">self, s_pos, e_pos</span>):</span></span><br><span class="line">    self.s_pos, self.e_pos = s_pos, e_pos</span><br><span class="line">    <span class="comment"># 构建开始节点</span></span><br><span class="line">    p = Node(<span class="literal">None</span>, self.s_pos, <span class="number">0</span>, <span class="built_in">abs</span>(self.s_pos[<span class="number">0</span>]-self.e_pos[<span class="number">0</span>]) + <span class="built_in">abs</span>(self.s_pos[<span class="number">1</span>]-self.e_pos[<span class="number">1</span>]))</span><br><span class="line">    self.<span class="built_in">open</span>.append(p)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 扩展F值最小的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果开放列表为空，则不存在路径，返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.<span class="built_in">open</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;not find&quot;</span></span><br><span class="line">        <span class="comment"># 获取F值最小的节点</span></span><br><span class="line">        idx, p = self.get_min_f_node()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find path with extend_round(%d, %d), open_list = %s&quot;</span> % (p.pos[<span class="number">0</span>], p.pos[<span class="number">1</span>], [[n.pos[<span class="number">0</span>], n.pos[<span class="number">1</span>]] <span class="keyword">for</span> n <span class="keyword">in</span> self.<span class="built_in">open</span>]))</span><br><span class="line">        <span class="comment"># 找到路径，生成路径，返回</span></span><br><span class="line">        <span class="keyword">if</span> self.is_target(p):</span><br><span class="line">            self.make_path(p)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 扩展该节点的子节点</span></span><br><span class="line">        self.extend_round(p)</span><br><span class="line">        <span class="comment"># 把此节点压入关闭列表，并从开放列表里删除</span></span><br><span class="line">        self.close.append(p)</span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">open</span>[idx]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩展该节点的子节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extend_round</span>(<span class="params">self, c</span>):</span></span><br><span class="line">    <span class="comment"># 修剪邻近节点</span></span><br><span class="line">    nbs = self.prune_neighbours(c)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;************[%d, %d] --- %s, parent = [%d, %d]&quot;</span> % (c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>], nbs, c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nbs:</span><br><span class="line">        jp = self.jump_node(n,[c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]])<span class="comment"># 跳跃节点</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;expandSuccessors:parent = %s, nb = %s, jp = %s&quot;</span> % ([c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]], n, jp)</span><br><span class="line">        <span class="keyword">if</span> jp:</span><br><span class="line">            <span class="keyword">if</span> self.node_in_close(jp):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            g = self.get_g(jp, c.pos)</span><br><span class="line">            h = self.get_h(jp, self.e_pos)</span><br><span class="line">            node = Node(c, jp, c.g + g, h)</span><br><span class="line">            i = self.node_in_open(node)</span><br><span class="line">            <span class="keyword">if</span> i != -<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 新节点在开放列表</span></span><br><span class="line">                <span class="keyword">if</span> self.<span class="built_in">open</span>[i].g &gt; node.g:</span><br><span class="line">                    <span class="comment"># 现在的路径到比以前到这个节点的路径更好~</span></span><br><span class="line">                    <span class="comment"># 则使用现在的路径</span></span><br><span class="line">                    self.<span class="built_in">open</span>[i].parent = c</span><br><span class="line">                    self.<span class="built_in">open</span>[i].g = node.g</span><br><span class="line">                    self.<span class="built_in">open</span>[i].f = node.g + self.<span class="built_in">open</span>[i].h</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.<span class="built_in">open</span>.append(node)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修剪邻居节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prune_neighbours</span>(<span class="params">self, c</span>):</span></span><br><span class="line">        nbs = []</span><br><span class="line">         <span class="comment"># 不是起始点</span></span><br><span class="line">        <span class="keyword">if</span> c.parent:</span><br><span class="line">            <span class="comment"># 进入的方向</span></span><br><span class="line">            <span class="built_in">dir</span> = c.get_direction()</span><br><span class="line">            <span class="keyword">if</span> self.is_pass(c.pos[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]):</span><br><span class="line">                nbs.append([c.pos[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;dir = &quot;</span>, <span class="built_in">dir</span></span><br><span class="line">             <span class="comment"># 对角线行走; eg:右下(1, 1)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">dir</span>[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">dir</span>[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 下（0， 1）</span></span><br><span class="line">                <span class="keyword">if</span> self.is_pass(c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]):</span><br><span class="line">                    nbs.append([c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line">                 <span class="comment"># 右（1， 0）</span></span><br><span class="line">                <span class="keyword">if</span> self.is_pass(c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]):</span><br><span class="line">                    nbs.append([c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]])</span><br><span class="line">                 <span class="comment"># 左不能走且下可走</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>] - <span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]) <span class="keyword">and</span> </span><br><span class="line">                	self.is_pass(c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]):</span><br><span class="line">                    <span class="comment"># 左下（-1， 1）</span></span><br><span class="line">                    nbs.append([c.pos[<span class="number">0</span>] - <span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line">                 <span class="comment"># 上不能走且右可走</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]-<span class="built_in">dir</span>[<span class="number">1</span>]) <span class="keyword">and</span> </span><br><span class="line">                	self.is_pass(c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]):</span><br><span class="line">                    <span class="comment"># 右上（1， -1）</span></span><br><span class="line">                    nbs.append([c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]-<span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 直行</span></span><br><span class="line">                <span class="comment"># 垂直走</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">dir</span>[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                     <span class="comment"># 右不能走</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>]+<span class="number">1</span>, c.pos[<span class="number">1</span>]):</span><br><span class="line">                        <span class="comment"># 右下</span></span><br><span class="line">                        nbs.append([c.pos[<span class="number">0</span>]+<span class="number">1</span>, c.pos[<span class="number">1</span>]+<span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line">                     <span class="comment"># 左不能走</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>]-<span class="number">1</span>, c.pos[<span class="number">1</span>]):</span><br><span class="line">                        <span class="comment"># 左下</span></span><br><span class="line">                        nbs.append([c.pos[<span class="number">0</span>]-<span class="number">1</span>, c.pos[<span class="number">1</span>]+<span class="built_in">dir</span>[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 水平走，向右走为例                     </span></span><br><span class="line">                     <span class="comment"># 下不能走</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">                         <span class="comment"># 右下</span></span><br><span class="line">                         nbs.append([c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]+<span class="number">1</span>])</span><br><span class="line">                     <span class="comment"># 上不能走</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.is_pass(c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]-<span class="number">1</span>):</span><br><span class="line">                         <span class="comment"># 右上</span></span><br><span class="line">                         nbs.append([c.pos[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], c.pos[<span class="number">1</span>]-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> g_dir:</span><br><span class="line">                <span class="keyword">if</span> self.is_pass(c.pos[<span class="number">0</span>] + d[<span class="number">0</span>], c.pos[<span class="number">1</span>] + d[<span class="number">1</span>]):</span><br><span class="line">                    nbs.append([c.pos[<span class="number">0</span>] + d[<span class="number">0</span>], c.pos[<span class="number">1</span>] + d[<span class="number">1</span>]])</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;prune_neighbours c= %s, nbs = %s&quot;</span> % ([c.pos[<span class="number">0</span>], c.pos[<span class="number">1</span>]], nbs)</span><br><span class="line">        <span class="keyword">return</span> nbs</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ↑ ↓ ← → ↖ ↙ ↗ ↘</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump_node</span>(<span class="params">self, now, pre</span>):</span></span><br><span class="line">        <span class="built_in">dir</span> = [a != b <span class="keyword">and</span> (a - b)/<span class="built_in">abs</span>(a-b) <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(now, pre)]</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;now = %s, pre = %s, dir = %s&quot;</span> %(now, pre, <span class="built_in">dir</span>)        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> now == self.e_pos:</span><br><span class="line">            <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">dir</span>[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">dir</span>[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 左下能走且左不能走，或右上能走且上不能走</span></span><br><span class="line">            <span class="keyword">if</span> (self.is_pass(now[<span class="number">0</span>] - <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]) <span class="keyword">and</span> <span class="keyword">not</span> </span><br><span class="line">                self.is_pass(now[<span class="number">0</span>]-<span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>])) <span class="keyword">or</span> (self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>],</span><br><span class="line">                now[<span class="number">1</span>] - <span class="built_in">dir</span>[<span class="number">1</span>]) <span class="keyword">and</span> <span class="keyword">not</span> self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]-<span class="built_in">dir</span>[<span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">return</span> now</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 水平方向</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">dir</span>[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 右下能走且下不能走， 或右上能走且上不能走</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                * 1 0       0 0 0</span></span><br><span class="line"><span class="string">                0 → 0       0 0 0</span></span><br><span class="line"><span class="string">                * 1 0       0 0 0</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;水平方向:&#x27;</span>, self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>] + <span class="number">1</span>), </span><br><span class="line">                	self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]+<span class="number">1</span>), self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>] 					 - <span class="number">1</span>), self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">and</span> <span class="keyword">not</span> </span><br><span class="line">                    self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]+<span class="number">1</span>)) <span class="keyword">or</span> (self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], </span><br><span class="line">                    now[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">and</span> <span class="keyword">not</span> self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>]-<span class="number">1</span>)):</span><br><span class="line">                    <span class="keyword">return</span> now</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 垂直方向</span></span><br><span class="line">                <span class="comment"># 右下能走且右不能走，或坐下能走且左不能走</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                0 0 0</span></span><br><span class="line"><span class="string">                1 ↓ 1</span></span><br><span class="line"><span class="string">                0 0 0            </span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;垂直方向:&#x27;</span>, self.is_pass(now[<span class="number">0</span>] + <span class="number">1</span>, now[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]), </span><br><span class="line">                	self.is_pass(now[<span class="number">0</span>] + <span class="number">1</span>, now[<span class="number">1</span>]), self.is_pass(now[<span class="number">0</span>]-<span class="number">1</span> , now[<span class="number">1</span>] + </span><br><span class="line">                    <span class="built_in">dir</span>[<span class="number">1</span>]), self.is_pass(now[<span class="number">0</span>] - <span class="number">1</span>, now[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> (self.is_pass(now[<span class="number">0</span>] + <span class="number">1</span>, now[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]) <span class="keyword">and</span> <span class="keyword">not</span> </span><br><span class="line">                    self.is_pass(now[<span class="number">0</span>]+<span class="number">1</span>, now[<span class="number">1</span>])) <span class="keyword">or</span> (self.is_pass(now[<span class="number">0</span>] - <span class="number">1</span>, now[<span class="number">1</span>] +</span><br><span class="line">                    <span class="built_in">dir</span>[<span class="number">1</span>]) <span class="keyword">and</span> <span class="keyword">not</span> self.is_pass(now[<span class="number">0</span>]-<span class="number">1</span>, now[<span class="number">1</span>])):</span><br><span class="line">                    <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">dir</span>[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">dir</span>[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            t1 = self.jump_node([now[<span class="number">0</span>]+<span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>]], now)</span><br><span class="line">            t2 = self.jump_node([now[<span class="number">0</span>], now[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]], now)</span><br><span class="line">            <span class="keyword">if</span> t1 <span class="keyword">or</span> t2:</span><br><span class="line">                <span class="keyword">return</span> now</span><br><span class="line">        <span class="keyword">if</span> self.is_pass(now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>]) <span class="keyword">or</span> self.is_pass(now[<span class="number">0</span>], now[<span class="number">1</span>] +</span><br><span class="line">            <span class="built_in">dir</span>[<span class="number">1</span>]):</span><br><span class="line">            t = self.jump_node([now[<span class="number">0</span>] + <span class="built_in">dir</span>[<span class="number">0</span>], now[<span class="number">1</span>] + <span class="built_in">dir</span>[<span class="number">1</span>]], now)</span><br><span class="line">            <span class="keyword">if</span> t:</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_plan</category>
      </categories>
      <tags>
        <tag>path_plan</tag>
      </tags>
  </entry>
  <entry>
    <title>kf</title>
    <url>/blog/2022/02/28/kf/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://space.bilibili.com/287989852/video?tid=0&page=2&keyword=&order=pubdate">忠厚老实的老王的个人空间_哔哩哔哩_bilibili</a> </p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----卡尔曼滤波算法----</span><br><span class="line">预测步</span><br><span class="line"> - 状态方程</span><br><span class="line"> X(K)minus=F*X(K-1)plus</span><br><span class="line"> - 先验估计</span><br><span class="line"> P(K)minus=F*P(K-1)plus*F&#x27;+Q</span><br><span class="line">更新步</span><br><span class="line"> - 卡尔曼增益:若R足够大,则更偏向于观测值,若R趋近于0,则更相信预测值</span><br><span class="line"> K=P(K)minus*H&#x27;*inv(H*P(K)minus*H&#x27;+R)</span><br><span class="line"> - 更新状态量</span><br><span class="line"> X(K)plus=X(K)minus+K*(y(k)-H*X(K)minus)</span><br><span class="line"> - 更新后验概率</span><br><span class="line"> P(K)plus=(I-K*H)*(K)minus</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc ;close ;clear all;</span><br><span class="line"><span class="comment">%%%%贝叶斯滤波与卡尔曼滤波第八讲matlab代码%%%%%%</span></span><br><span class="line"><span class="comment">%%%%kalman filter</span></span><br><span class="line"><span class="comment">%X(K)=F*X(K-1)+Q</span></span><br><span class="line"><span class="comment">%Y(K)=H*X(K)+R</span></span><br><span class="line"><span class="comment">%%%第一个问题，生成一段随机信号，并滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%生成一段时间t,每隔0.01s采样一次</span></span><br><span class="line">t=<span class="number">0.1</span>:<span class="number">0.01</span>:<span class="number">1</span>;</span><br><span class="line">L=<span class="built_in">length</span>(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">%生成真实信号x，以及观测y</span></span><br><span class="line"><span class="comment">%首先初始化</span></span><br><span class="line">x=<span class="built_in">zeros</span>(<span class="number">1</span>,L);</span><br><span class="line">y=x;</span><br><span class="line">y2=x;</span><br><span class="line"><span class="comment">%生成信号，设x=t^2</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:L</span><br><span class="line">      x(<span class="built_in">i</span>)=t(<span class="built_in">i</span>)^<span class="number">2</span>;</span><br><span class="line">      y(<span class="built_in">i</span>)=x(<span class="built_in">i</span>)+normrnd(<span class="number">0</span>,<span class="number">0.1</span>); <span class="comment">%正态分布随机数，参数为期望和标准差</span></span><br><span class="line">      y2(<span class="built_in">i</span>)=x(<span class="built_in">i</span>)+normrnd(<span class="number">0</span>,<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%信号生成完毕%%%%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%滤波算法%%%%%%</span></span><br><span class="line"><span class="comment">%%%预测方程观测方程怎么写%%%</span></span><br><span class="line"><span class="comment">%观测方程好写Y(K)=X(K)+R R~N(0,1)</span></span><br><span class="line"><span class="comment">%预测方程不好写%%%%，在这里，可以猜一猜是线性增长，但是大多数问题，信号是杂乱无章的，怎么办</span></span><br><span class="line"><span class="comment">%模型一，最粗糙的建模</span></span><br><span class="line"><span class="comment">%X(K)=X(K-1)+Q</span></span><br><span class="line"><span class="comment">%Y(K)=X(K)+R</span></span><br><span class="line"><span class="comment">%猜Q~N(0,1);</span></span><br><span class="line"></span><br><span class="line">F1=<span class="number">1</span>;</span><br><span class="line">H1=<span class="number">1</span>;</span><br><span class="line">Q1=<span class="number">1</span>;</span><br><span class="line">R1=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%初始化x(k)+</span></span><br><span class="line">Xplus1=<span class="built_in">zeros</span>(<span class="number">1</span>,L);<span class="comment">%plus + 的英语 minus -的英语</span></span><br><span class="line"><span class="comment">%我们会经常用到Xplus,Xminus,Pplus,Pminus</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%设置一个初值，假设Xplus1(1)~N(0.01,0.01^2)</span></span><br><span class="line">Xplus1(<span class="number">1</span>)=<span class="number">0.01</span>;</span><br><span class="line">Pplus1=<span class="number">0.01</span>^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%卡尔曼滤波算法</span></span><br><span class="line"><span class="comment">% 预测步</span></span><br><span class="line"><span class="comment">%X(K)minus=F*X(K-1)plus</span></span><br><span class="line"><span class="comment">%P(K)minus=F*P(K-1)plus*F&#x27;+Q(先验概率)</span></span><br><span class="line"><span class="comment">% 更新步</span></span><br><span class="line"><span class="comment">%K=P(K)minus*H&#x27;*inv(H*P(K)minus*H&#x27;+R)</span></span><br><span class="line"><span class="comment">% 若R足够大,则更偏向于观测值,若R趋近于0,则更相信预测值</span></span><br><span class="line"><span class="comment">%X(K)plus=X(K)minus+K*(y(k)-H*X(K)minus)</span></span><br><span class="line"><span class="comment">% 更新后验概率</span></span><br><span class="line"><span class="comment">%P(K)plus=(I-K*H)*P(K)minus</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:L</span><br><span class="line">      <span class="comment">%%%%预测步%%%%%%</span></span><br><span class="line">      Xminus1=F1*Xplus1(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">      Pminus1=F1*Pplus1*F1&#x27;+Q1;</span><br><span class="line">      <span class="comment">%%%%%更新步%%%%%</span></span><br><span class="line">      K1=(Pminus1*H1&#x27;)*inv(H1*Pminus1*H1&#x27;+R1);</span><br><span class="line">      Xplus1(<span class="built_in">i</span>)=Xminus1+K1*(y(<span class="built_in">i</span>)-H1*Xminus1);</span><br><span class="line">      Pplus1=(<span class="number">1</span>-K1*H1)*Pminus1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%模型2</span></span><br><span class="line"><span class="comment">%X(K)=X(K-1)+X&#x27;(K-1)*dt+X&#x27;&#x27;(K-1)*dt^2*(1/2!)+Q2</span></span><br><span class="line"><span class="comment">%Y(K)=X(K)+R R~N(0,1)</span></span><br><span class="line"><span class="comment">%此时状态变量X=[X(K) X&#x27;(K) X&#x27;&#x27;(K) ]T(列向量）</span></span><br><span class="line"><span class="comment">%Y(K)=H*X+R H=[1 0 0](行向量）</span></span><br><span class="line"><span class="comment">%预测方程</span></span><br><span class="line"><span class="comment">%X(K)=X(K-1)+X&#x27;(K-1)*dt+X&#x27;&#x27;(K-1)*dt^2*(1/2!)+Q2</span></span><br><span class="line"><span class="comment">%X&#x27;(K)=0*X(K-1)+X&#x27;(K-1)+X&#x27;&#x27;(K-1)*dt+Q3</span></span><br><span class="line"><span class="comment">%X&#x27;&#x27;(K)=0*X(K-1)+0*X&#x27;(K-1)+X&#x27;&#x27;(K-1)+Q4   %%多项式信号多求几阶导数，总会比较平缓，而</span></span><br><span class="line"><span class="comment">%X&#x27;&#x27;(K)=X&#x27;&#x27;(K-1)+Q3正是描述平缓的随机过程，这种建模相对精细一些，适用范围也较广</span></span><br><span class="line"><span class="comment">%F=1 dt 0.5*dt^2</span></span><br><span class="line"><span class="comment">%  0 1 dt</span></span><br><span class="line"><span class="comment">%  0 0 1</span></span><br><span class="line"><span class="comment">%H=[1 0 0]</span></span><br><span class="line"><span class="comment">%Q= Q2 0 0</span></span><br><span class="line"><span class="comment">%   0 Q3 0</span></span><br><span class="line"><span class="comment">%   0 0  Q4 协方差矩阵</span></span><br><span class="line"></span><br><span class="line">dt=t(<span class="number">2</span>)-t(<span class="number">1</span>);</span><br><span class="line">F2=[<span class="number">1</span>,dt,<span class="number">0.5</span>*dt^<span class="number">2</span>;<span class="number">0</span>,<span class="number">1</span>,dt;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>];<span class="comment">%%%此处要注意矩阵是否病态，若dt特别小，易导致矩阵病态或精度丢失</span></span><br><span class="line">H2=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">Q2=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.0001</span>];</span><br><span class="line">R2=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%设置初值%%%%</span></span><br><span class="line">Xplus2=<span class="built_in">zeros</span>(<span class="number">3</span>,L);</span><br><span class="line">Xplus2(<span class="number">1</span>,<span class="number">1</span>)=<span class="number">0.1</span>^<span class="number">2</span>;</span><br><span class="line">Xplus2(<span class="number">2</span>,<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">Xplus2(<span class="number">3</span>,<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">Pplus2=[<span class="number">0.01</span>, <span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.0001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:L</span><br><span class="line">      <span class="comment">%%%预测步%%%</span></span><br><span class="line">      Xminus2=F2*Xplus2(:,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">      Pminus2=F2*Pplus2*F2&#x27;+Q2;</span><br><span class="line">      <span class="comment">%%%更新步%%%%</span></span><br><span class="line">      K2=(Pminus2*H2&#x27;)*inv(H2*Pminus2*H2&#x27;+R2);</span><br><span class="line">      Xplus2(:,<span class="built_in">i</span>)=Xminus2+K2*(y(<span class="built_in">i</span>)-H2*Xminus2);</span><br><span class="line">      Pplus2=(<span class="built_in">eye</span>(<span class="number">3</span>)-K2*H2)*Pminus2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%可以进行在线滤波，实时滤波%%%%</span></span><br><span class="line"><span class="comment">%问题2，两个传感器，进行滤波</span></span><br><span class="line"><span class="comment">% Y1(K)=X(K)+R</span></span><br><span class="line"><span class="comment">% Y2(K)=X(K)+R</span></span><br><span class="line"><span class="comment">%H=[1 1]T (列向量) X=X(K)</span></span><br><span class="line"><span class="comment">%H=1 0 0 X=X(K) X&#x27;(K) X&#x27;&#x27;(K)</span></span><br><span class="line"><span class="comment">% 1 0 0</span></span><br><span class="line">F3=[<span class="number">1</span>,dt,<span class="number">0.5</span>*dt^<span class="number">2</span>;<span class="number">0</span>,<span class="number">1</span>,dt;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>];<span class="comment">%%%此处要注意矩阵是否病态，若dt特别小，易导致矩阵病态或精度丢失</span></span><br><span class="line">H3=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">Q3=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.0001</span>];</span><br><span class="line">R3=[<span class="number">3</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">3</span>];<span class="comment">%%%%%一定要注意是协方差矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%设置初值%%%%</span></span><br><span class="line">Xplus3=<span class="built_in">zeros</span>(<span class="number">3</span>,L);</span><br><span class="line">Xplus3(<span class="number">1</span>,<span class="number">1</span>)=<span class="number">0.1</span>^<span class="number">2</span>;</span><br><span class="line">Xplus3(<span class="number">2</span>,<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">Xplus3(<span class="number">3</span>,<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">Pplus3=[<span class="number">0.01</span>, <span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.0001</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:L</span><br><span class="line">      <span class="comment">%%%预测步%%%</span></span><br><span class="line">      Xminus3=F3*Xplus3(:,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">      Pminus3=F3*Pplus3*F3&#x27;+Q3;</span><br><span class="line">      <span class="comment">%%%更新步%%%%</span></span><br><span class="line">      K3=(Pminus3*H3&#x27;)*inv(H3*Pminus3*H3&#x27;+R3);</span><br><span class="line">      Y=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">      Y(<span class="number">1</span>,<span class="number">1</span>)= y(<span class="built_in">i</span>);</span><br><span class="line">      Y(<span class="number">2</span>,<span class="number">1</span>)=y2(<span class="built_in">i</span>);</span><br><span class="line">      Xplus3(:,<span class="built_in">i</span>)=Xminus3+K3*(Y-H3*Xminus3);</span><br><span class="line">      Pplus3=(<span class="built_in">eye</span>(<span class="number">3</span>)-K3*H3)*Pminus3;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(t,x,<span class="string">&#x27;r&#x27;</span>,t,y,<span class="string">&#x27;g&#x27;</span>,t,Xplus1(<span class="number">1</span>,:),<span class="string">&#x27;b&#x27;</span>,t,Xplus2(<span class="number">1</span>,:),<span class="string">&#x27;k&#x27;</span>,t,Xplus3(<span class="number">1</span>,:),<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>); </span><br></pre></td></tr></table></figure>

<h1 id="拓展卡尔曼滤波"><a href="#拓展卡尔曼滤波" class="headerlink" title="拓展卡尔曼滤波"></a>拓展卡尔曼滤波</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%EKF代码</span></span><br><span class="line"><span class="comment">%x(k)=sin(3*x(k-1))</span></span><br><span class="line"><span class="comment">%y(k)=x(k)^2</span></span><br><span class="line"><span class="comment">%注意似然概率是多峰分布,具有强烈非线性,当y=4时,不知道x=2还是-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%生成真是信号与观测</span></span><br><span class="line">t=<span class="number">0.01</span>:<span class="number">0.01</span>:<span class="number">1</span>;</span><br><span class="line">n=<span class="built_in">length</span>(t);</span><br><span class="line">x=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">y=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">x(<span class="number">1</span>)=<span class="number">0.1</span>^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n</span><br><span class="line">    x(<span class="built_in">i</span>)=<span class="built_in">sin</span>(<span class="number">3</span>*x(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">    y(<span class="built_in">i</span>)=x(<span class="built_in">i</span>)^<span class="number">2</span>+normrnd(<span class="number">0</span>,<span class="number">0.7</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%EKF</span></span><br><span class="line">Xplus=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">Pplus=<span class="number">0.1</span>;</span><br><span class="line">Xplus(<span class="number">1</span>)=<span class="number">0.1</span>;</span><br><span class="line">Q=<span class="number">0.1</span>;</span><br><span class="line">R=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n</span><br><span class="line">    <span class="comment">% 对x(k)微分,并赋值给A,代替f的线性化</span></span><br><span class="line">    A=<span class="number">3</span>*<span class="built_in">cos</span>(<span class="number">3</span>*Xplus(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">    Xminus=<span class="built_in">sin</span>(<span class="number">3</span>*Xplus(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">    Pminus=A*Pplus*A&#x27;+Q;</span><br><span class="line">    <span class="comment">%更新步</span></span><br><span class="line">    <span class="comment">% 用y(k)微分,复制给C,代替h的线性化</span></span><br><span class="line">    C=<span class="number">2</span>*Xminus;</span><br><span class="line">    K=Pminus*C*inv(C*Pminus*C&#x27;+R);</span><br><span class="line">    Xplus(<span class="built_in">i</span>)=Xminus+K*(y(<span class="built_in">i</span>)-Xminus^<span class="number">2</span>);</span><br><span class="line">    Pplus=(<span class="built_in">eye</span>(<span class="number">1</span>)-K*C)*Pminus;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 注意,实际上拓展卡尔曼滤波器,就是把x(k)微分,代替f的线性化,把y(k)微分,代替h的线性化</span></span><br><span class="line"><span class="built_in">plot</span>(t,x,<span class="string">&#x27;r&#x27;</span>,t,y,<span class="string">&#x27;b&#x27;</span>,t,Xplus,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>kd树</title>
    <url>/blog/2022/02/24/kd%E6%A0%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://www.bilibili.com/video/BV1d5411w7f5/?spm_id_from=333.788.recommend_more_video.0">学生视频-KD树_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://blog.csdn.net/silangquan/article/details/41483689?ops_request_misc=%7B%22request_id%22:%22164559383916780269851564%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164559383916780269851564&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-41483689.nonecase&utm_term=kdtree&spm=1018.2226.3001.4450">(110条消息) 详解KDTree_爱冒险的技术宅-CSDN博客_kdtree</a> </p>
<p> <a href="https://blog.csdn.net/shuiyixin/article/details/88988069?ops_request_misc=&request_id=&biz_id=102&utm_term=kdtree&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-2-88988069.nonecase&spm=1018.2226.3001.4450">(110条消息) 【PCL模块解析 05 之KDTree】01 KDTree原理及代码解析_水亦心的博客-CSDN博客</a> </p>
<p> <a href="https://www.cnblogs.com/earendil/p/8135074.html">KD树 - Earendil - 博客园 (cnblogs.com)</a> </p>
<p>amcl内部也存在kdtree,可以i拿来看看</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>分为生成kdtree与搜索树两部分</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>    </span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">0</span>;    </span><br><span class="line">&#125;;       </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span>&#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">dom_elt</span>;</span>    </span><br><span class="line">    <span class="keyword">int</span> split;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span> * <span class="title">left</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span> * <span class="title">right</span>;</span>    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<h2 id="生成kdtree"><a href="#生成kdtree" class="headerlink" title="生成kdtree"></a>生成kdtree</h2><ul>
<li><strong>多所有数据的各个维度做方差</strong></li>
<li><strong>选择方差大的方向进行,排序选择中位数作为分割点,并保存分割维度</strong></li>
<li><strong>然后在该维度判断大小,小的放在左侧,大的放在右侧</strong></li>
<li><strong>保存左右节点</strong></li>
<li><strong>然后递归</strong></li>
</ul>
<h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><ul>
<li><strong>如果Kd是空的，则设dist为无穷大返回</strong>   </li>
<li><strong>判断分割维度,判断进入左树还是右树,递归,最终找到最接近的叶子节点</strong></li>
<li><strong>判断目标点与叶子节点距离是否大于目标点到超平面距离,若不大于,则叶子节点为最终最接近点,否则回溯上一父节点</strong></li>
<li><strong>比较父节点空间另一叶子节点,若距离最短,则为最近点</strong></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="comment">/*function of this program: build a 2d tree using the input training data  </span></span><br><span class="line"><span class="comment"> the input is exm_set which contains a list of tuples (x,y)  </span></span><br><span class="line"><span class="comment"> the output is a 2d tree pointer*/</span>    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">0</span>;    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">dom_elt</span>;</span>    </span><br><span class="line">    <span class="keyword">int</span> split;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span> * <span class="title">left</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span> * <span class="title">right</span>;</span>    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(data a, data b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(data a, data b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(data a, data b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x &amp;&amp; a.y == b.y)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 调用ChooseSplit函数选择分割维度和分割点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChooseSplit</span><span class="params">(data exm_set[], <span class="keyword">int</span> size, <span class="keyword">int</span> &amp;split, data &amp;SplitChoice)</span></span>&#123;    </span><br><span class="line">    <span class="comment">/*compute the variance on every dimension. Set split as the dismension that have the biggest variance. </span></span><br><span class="line"><span class="comment">    Then choose the instance which is the median on this split dimension.*/</span>    </span><br><span class="line">    <span class="comment">// 计算每个维度的方差。将split设置为方差最大的维度。然后选择实例，它是这个分割维度上的中值。</span></span><br><span class="line">    <span class="comment">/*compute variance on the x,y dimension. DX=EX^2-(EX)^2*/</span>  </span><br><span class="line">    <span class="comment">// 数据方差大表明沿该坐标轴方向上的数据分散得比较开，在这个方向上进行数据分割有较好的分辨率；  </span></span><br><span class="line">    <span class="keyword">double</span> tmp1,tmp2;    </span><br><span class="line">    tmp1 = tmp2 = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)    </span><br><span class="line">    &#123;    </span><br><span class="line">        tmp1 += <span class="number">1.0</span> / (<span class="keyword">double</span>)size * exm_set[i].x * exm_set[i].x;    </span><br><span class="line">        tmp2 += <span class="number">1.0</span> / (<span class="keyword">double</span>)size * exm_set[i].x;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">double</span> v1 = tmp1 - tmp2 * tmp2;  <span class="comment">//compute variance on the x dimension    </span></span><br><span class="line">        </span><br><span class="line">    tmp1 = tmp2 = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)    </span><br><span class="line">    &#123;    </span><br><span class="line">        tmp1 += <span class="number">1.0</span> / (<span class="keyword">double</span>)size * exm_set[i].y * exm_set[i].y;    </span><br><span class="line">        tmp2 += <span class="number">1.0</span> / (<span class="keyword">double</span>)size * exm_set[i].y;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">double</span> v2 = tmp1 - tmp2 * tmp2;  <span class="comment">//compute variance on the y dimension    </span></span><br><span class="line">        </span><br><span class="line">    split = v1 &gt; v2 ? <span class="number">0</span>:<span class="number">1</span>; <span class="comment">//set the split dimension    </span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (split == <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">// sort排序规则：按照x坐标排序</span></span><br><span class="line">        <span class="built_in">sort</span>(exm_set,exm_set + size, cmp1);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;    </span><br><span class="line">        <span class="built_in">sort</span>(exm_set,exm_set + size, cmp2);    </span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//set the split point value </span></span><br><span class="line">    <span class="comment">// 设置分割点值,取中值  </span></span><br><span class="line">    SplitChoice.x = exm_set[size / <span class="number">2</span>].x;    </span><br><span class="line">    SplitChoice.y = exm_set[size / <span class="number">2</span>].y;    </span><br><span class="line">        </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function">Tnode* <span class="title">build_kdtree</span><span class="params">(data exm_set[], <span class="keyword">int</span> size, Tnode* T)</span></span>&#123;    </span><br><span class="line">    <span class="comment">// call function ChooseSplit to choose the split dimension and split point    </span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 若为0则按x维切割，否则按y维切割 </span></span><br><span class="line">        <span class="keyword">int</span> split; </span><br><span class="line">        <span class="comment">// 选择实例  </span></span><br><span class="line">        data dom_elt;    </span><br><span class="line">        <span class="comment">// 调用ChooseSplit函数选择分割维度和分割点</span></span><br><span class="line">        <span class="built_in">ChooseSplit</span>(exm_set, size, split, dom_elt); </span><br><span class="line">        data exm_set_right [<span class="number">100</span>];    </span><br><span class="line">        data exm_set_left [<span class="number">100</span>];    </span><br><span class="line">        <span class="keyword">int</span> sizeleft ,sizeright;    </span><br><span class="line">        sizeleft = sizeright = <span class="number">0</span>;    </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (split == <span class="number">0</span>)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="comment">// 判断是否等于分割点，若小于于则放入左子树，若大于则放入右子树,否则不做处理</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">equal</span>(exm_set[i],dom_elt) &amp;&amp; exm_set[i].x &lt;= dom_elt.x)    </span><br><span class="line">                &#123;    </span><br><span class="line">                    exm_set_left[sizeleft].x = exm_set[i].x;    </span><br><span class="line">                    exm_set_left[sizeleft].y = exm_set[i].y;    </span><br><span class="line">                    sizeleft++;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">equal</span>(exm_set[i],dom_elt) &amp;&amp; exm_set[i].x &gt; dom_elt.x)    </span><br><span class="line">                &#123;    </span><br><span class="line">                    exm_set_right[sizeright].x = exm_set[i].x;    </span><br><span class="line">                    exm_set_right[sizeright].y = exm_set[i].y;    </span><br><span class="line">                    sizeright++;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)    </span><br><span class="line">            &#123;    </span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">equal</span>(exm_set[i],dom_elt) &amp;&amp; exm_set[i].y &lt;= dom_elt.y)    </span><br><span class="line">                &#123;    </span><br><span class="line">                    exm_set_left[sizeleft].x = exm_set[i].x;    </span><br><span class="line">                    exm_set_left[sizeleft].y = exm_set[i].y;    </span><br><span class="line">                    sizeleft++;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">equal</span>(exm_set[i],dom_elt) &amp;&amp; exm_set[i].y &gt; dom_elt.y)    </span><br><span class="line">                &#123;    </span><br><span class="line">                    exm_set_right[sizeright].x = exm_set[i].x;    </span><br><span class="line">                    exm_set_right[sizeright].y = exm_set[i].y;    </span><br><span class="line">                    sizeright++;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        T = <span class="keyword">new</span> Tnode;    </span><br><span class="line">        T-&gt;dom_elt.x = dom_elt.x;    </span><br><span class="line">        T-&gt;dom_elt.y = dom_elt.y;    </span><br><span class="line">        T-&gt;split = split;    </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        T-&gt;left = <span class="built_in">build_kdtree</span>(exm_set_left, sizeleft, T-&gt;left);    </span><br><span class="line">        T-&gt;right = <span class="built_in">build_kdtree</span>(exm_set_right, sizeright, T-&gt;right);    </span><br><span class="line">        <span class="keyword">return</span> T;       </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 计算欧式距离   </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(data a, data b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">double</span> tmp = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(tmp);    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 寻找最近点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchNearest</span><span class="params">(Tnode * Kd, data target, data &amp;nearestpoint, <span class="keyword">double</span> &amp; distance)</span></span>&#123;    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//1. 如果Kd是空的，则设dist为无穷大返回    </span></span><br><span class="line">    <span class="comment">//2. 向下搜索直到叶子结点    </span></span><br><span class="line">        </span><br><span class="line">    stack&lt;Tnode*&gt; search_path;    </span><br><span class="line">    Tnode* pSearch = Kd;    </span><br><span class="line">    data nearest;    </span><br><span class="line">    <span class="keyword">double</span> dist;    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pSearch != <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//pSearch加入到search_path中; </span></span><br><span class="line">        <span class="comment">// stack容器 - 先进后出</span></span><br><span class="line">        <span class="comment">// 一开始放入根结点, 然后根据条件放入左右子树 </span></span><br><span class="line">        <span class="comment">// 支持在这里进行push(), pop(), top()操作  </span></span><br><span class="line">        search_path.<span class="built_in">push</span>(pSearch);    </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (pSearch-&gt;split == <span class="number">0</span>)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(target.x &lt;= pSearch-&gt;dom_elt.x) <span class="comment">/* 如果小于就进入左子树 */</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                pSearch = pSearch-&gt;left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                pSearch = pSearch-&gt;right;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="keyword">if</span>(target.y &lt;= pSearch-&gt;dom_elt.y) <span class="comment">/* 如果小于就进入左子树 */</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                pSearch = pSearch-&gt;left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                pSearch = pSearch-&gt;right;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//取出search_path最后一个赋给nearest    </span></span><br><span class="line">    nearest.x = search_path.<span class="built_in">top</span>()-&gt;dom_elt.x;    </span><br><span class="line">    nearest.y = search_path.<span class="built_in">top</span>()-&gt;dom_elt.y; </span><br><span class="line">    <span class="comment">// printf(&quot;x=%f, y=%f\n&quot;, nearest.x, nearest.y);</span></span><br><span class="line">    <span class="comment">// 弹出pSearch的top   </span></span><br><span class="line">    search_path.<span class="built_in">pop</span>();    </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    dist = <span class="built_in">Distance</span>(nearest, target);    <span class="comment">// 计算找到的叶节点与目标点的欧式距离</span></span><br><span class="line">    <span class="comment">//3. 回溯搜索路径    </span></span><br><span class="line">        </span><br><span class="line">    Tnode* pBack;    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(search_path.<span class="built_in">size</span>() != <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//取出search_path最后一个结点赋给pBack    </span></span><br><span class="line">        <span class="comment">// 回溯到上一层节点</span></span><br><span class="line">        pBack = search_path.<span class="built_in">top</span>();    </span><br><span class="line">        search_path.<span class="built_in">pop</span>();    </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(pBack-&gt;left == <span class="literal">NULL</span> &amp;&amp; pBack-&gt;right == <span class="literal">NULL</span>) <span class="comment">/* 如果pBack为叶子结点 */</span>    </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="comment">// 如果pBack为叶子结点，则计算pBack与目标点的欧式距离，并与nearestpoint比较，如果更小，则更新nearestpoint</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">Distance</span>(nearest, target) &gt; <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target) )    </span><br><span class="line">            &#123;    </span><br><span class="line">                nearest = pBack-&gt;dom_elt;    </span><br><span class="line">                dist = <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target);    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">else</span>           </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">// 定义s为分割线</span></span><br><span class="line">            <span class="keyword">int</span> s = pBack-&gt;split;</span><br><span class="line">            <span class="comment">// 为0时，分割线为x轴</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>)    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">fabs</span>(pBack-&gt;dom_elt.x - target.x) &lt; dist) <span class="comment">/* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */</span>    </span><br><span class="line">                &#123;    </span><br><span class="line">                    <span class="keyword">if</span>( <span class="built_in">Distance</span>(nearest, target) &gt; <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target) )    </span><br><span class="line">                    &#123;    </span><br><span class="line">                        nearest = pBack-&gt;dom_elt;    </span><br><span class="line">                        dist = <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target);    </span><br><span class="line">                    &#125;    </span><br><span class="line">                    <span class="keyword">if</span>(target.x &lt;= pBack-&gt;dom_elt.x) <span class="comment">/* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */</span>    </span><br><span class="line">                        pSearch = pBack-&gt;right;    </span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        pSearch = pBack-&gt;left; <span class="comment">/* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */</span>    </span><br><span class="line">                    <span class="keyword">if</span>(pSearch != <span class="literal">NULL</span>)    </span><br><span class="line">                        <span class="comment">//pSearch加入到search_path中    </span></span><br><span class="line">                        search_path.<span class="built_in">push</span>(pSearch);    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="comment">//  如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交</span></span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">fabs</span>(pBack-&gt;dom_elt.y - target.y) &lt; dist) <span class="comment">/* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */</span>    </span><br><span class="line">                &#123;    </span><br><span class="line">                    <span class="comment">// 若找到的最近点与目标点距离大于上层父节点,则将父节点变为最近节点</span></span><br><span class="line">                    <span class="keyword">if</span>( <span class="built_in">Distance</span>(nearest, target) &gt; <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target) )    </span><br><span class="line">                    &#123;    </span><br><span class="line">                        nearest = pBack-&gt;dom_elt;    </span><br><span class="line">                        dist = <span class="built_in">Distance</span>(pBack-&gt;dom_elt, target);    </span><br><span class="line">                    &#125;    </span><br><span class="line">                    <span class="keyword">if</span>(target.y &lt;= pBack-&gt;dom_elt.y) <span class="comment">/* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */</span>    </span><br><span class="line">                        pSearch = pBack-&gt;right;    </span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        pSearch = pBack-&gt;left; <span class="comment">/* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */</span>    </span><br><span class="line">                    <span class="keyword">if</span>(pSearch != <span class="literal">NULL</span>)    </span><br><span class="line">                       <span class="comment">// pSearch加入到search_path中    </span></span><br><span class="line">                        search_path.<span class="built_in">push</span>(pSearch);    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">                </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;       </span><br><span class="line">    nearestpoint.x = nearest.x;    </span><br><span class="line">    nearestpoint.y = nearest.y;    </span><br><span class="line">    distance = dist;    </span><br><span class="line">        </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">// x,y</span></span><br><span class="line">    data exm_set[<span class="number">100</span>]; <span class="comment">//assume the max training set size is 100    </span></span><br><span class="line">    <span class="keyword">double</span> x,y;    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input the training data in the form x y. One instance per line. Enter -1 -1 to stop.&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;x&gt;&gt;y)&#123;    </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span>&#123;    </span><br><span class="line">            exm_set[id].x = x;    </span><br><span class="line">            exm_set[id].y = y;    </span><br><span class="line">            id++;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span> * <span class="title">root</span> =</span> <span class="literal">NULL</span>;    </span><br><span class="line">    root = <span class="built_in">build_kdtree</span>(exm_set, id, root);    </span><br><span class="line">        </span><br><span class="line">    data nearestpoint;    </span><br><span class="line">    <span class="keyword">double</span> distance;    </span><br><span class="line">    data target;    </span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Enter search point&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;target.x&gt;&gt;target.y)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">searchNearest</span>(root, target, nearestpoint, distance);    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The nearest distance is &quot;</span>&lt;&lt;distance&lt;&lt;<span class="string">&quot;,and the nearest point is &quot;</span>&lt;&lt;nearestpoint.x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;nearestpoint.y&lt;&lt;endl;    </span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Enter search point&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/blog/2022/05/05/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_57023347/article/details/120999277?ops_request_misc=&request_id=&biz_id=102&utm_term=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fc++&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120999277.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(131条消息) C++11——lambda表达式_两片空白的博客-CSDN博客_lambda表达式c++11</a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//最简单的lambda表达式</span></span><br><span class="line">	[]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//捕捉当前作用域的变量，没有参数，编译器推导返回值类型。</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	[=]&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//使用和仿函数差不多</span></span><br><span class="line">	<span class="keyword">auto</span> fun1 = [&amp;](<span class="keyword">int</span> c)&#123;b = a + c; &#125;;</span><br><span class="line">	<span class="built_in">fun1</span>(<span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> fun2 = [&amp;](<span class="keyword">int</span> c)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a + c; &#125;;</span><br><span class="line">	<span class="built_in">fun2</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">fun2</span>(<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//传值捕捉</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> add0 = [x, y]()<span class="keyword">mutable</span>-&gt;<span class="keyword">int</span>&#123; x *= <span class="number">2</span>;<span class="comment">//捕捉传递传值具有常性</span></span><br><span class="line">									<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">add0</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> add1 = [&amp;x, y]()-&gt;<span class="keyword">int</span>&#123; x *= <span class="number">2</span>;<span class="comment">//捕捉传递引用不具有常性</span></span><br><span class="line">							<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">add1</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> add2 = [](<span class="keyword">int</span> s, <span class="keyword">int</span> m)-&gt;<span class="keyword">int</span>&#123; s *= <span class="number">2</span>;<span class="comment">//参数不具有常性</span></span><br><span class="line">								<span class="keyword">return</span> s + m; &#125;;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//最简单的lambda表达式</span></span><br><span class="line">	[]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//捕捉当前作用域的变量，没有参数，编译器推导返回值类型。</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//auto fun1 = [x, y]()-&gt;int&#123;return x + y; &#125;;//编译错误，要和捕捉参数名相同</span></span><br><span class="line">	<span class="comment">//传值传递是捕捉变量的拷贝，实际外面的a，b没有交换</span></span><br><span class="line">	<span class="keyword">auto</span> swap1 = [a, b]()<span class="keyword">mutable</span>&#123;<span class="keyword">int</span> z = a; a = b; b = z; &#125;;</span><br><span class="line">	<span class="built_in">swap1</span>();<span class="comment">//注意还需要调用</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//传引用才能真正修改</span></span><br><span class="line">	<span class="keyword">auto</span> swap2 = [&amp;a, &amp;b]&#123;<span class="keyword">int</span> z = a; a = b; b = z; &#125;;</span><br><span class="line">	<span class="built_in">swap2</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*PF)();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> f1 = []&#123;cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">	<span class="keyword">auto</span> f2 = []&#123;cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">	<span class="comment">// 此处先不解释原因，等lambda表达式底层实现原理看完后，大家就清楚了</span></span><br><span class="line">	<span class="comment">//f1 = f2; // 编译失败---&gt;提示找不到operator=()</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 允许使用一个lambda表达式拷贝构造一个新的副本</span></span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">f3</span><span class="params">(f2)</span></span>;</span><br><span class="line">	<span class="built_in">f3</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 可以将lambda表达式赋值给相同类型的函数指针</span></span><br><span class="line">	PF = f2;</span><br><span class="line">	<span class="built_in">PF</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>linux报错</title>
    <url>/blog/2022/01/15/linux%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/JIEJINQUANIL/article/details/106414938">(99条消息) 编译警告：warning: Clock skew detected. Your build may be incomplete._竭尽全力的专栏-CSDN博客</a> </p>
<h1 id="warning-Clock-skew-detected"><a href="#warning-Clock-skew-detected" class="headerlink" title="warning: Clock skew detected"></a>warning: Clock skew detected</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f | xargs -n 5 touch</span><br></pre></td></tr></table></figure>

<h1 id="apt-upgdate-失败"><a href="#apt-upgdate-失败" class="headerlink" title="apt upgdate 失败"></a>apt upgdate 失败</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/lock-frontend</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br></pre></td></tr></table></figure>

<h1 id="cannot-create-temp-file-for-here-document-No-space-left-on-device的问题解决"><a href="#cannot-create-temp-file-for-here-document-No-space-left-on-device的问题解决" class="headerlink" title="cannot create temp file for here-document: No space left on device的问题解决"></a>cannot create temp file for here-document: No space left on device的问题解决</h1><p>参考网址</p>
<p> <a href="https://www.cnblogs.com/EasonJim/p/6833354.html">Linux出现cannot create temp file for here-document: No space left on device的问题解决 - EasonJim - 博客园 (cnblogs.com)</a> </p>
<p>问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash: cannot create temp file for here-document: No space left on devic</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看/var/<span class="built_in">log</span>路径下文件的大小</span></span><br><span class="line">du -h –max-depth=1 /var/log/* </span><br><span class="line"><span class="meta">#</span><span class="bash">  查看哪个目录最大，一步一步的查找大文件</span></span><br><span class="line">du -sh /*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找最大的文件，参考：http://www.cnblogs.com/kerrycode/p/4391859.html</span></span><br><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux解压</title>
    <url>/blog/2021/11/11/linux%E8%A7%A3%E5%8E%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/scanf_linux/article/details/90382491?ops_request_misc=%7B%22request_id%22:%22163644518016780271536349%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163644518016780271536349&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90382491.pc_search_mgc_flag&utm_term=linux%E8%A7%A3%E5%8E%8Btar.gz&spm=1018.2226.3001.4187">Linux解压.tgz，.tar.gz文件（tar详细参数使用介绍）_echo-CSDN博客_linux解压.tar.gz文件</a></p>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar </span><br><span class="line">tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line">tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span><br><span class="line">tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]</span><br><span class="line">tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载 rar for linux</span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载 zip for linux</span><br></pre></td></tr></table></figure>

<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">tar -xZvf file.tar.Z   //解压tar.Z</span><br><span class="line">tar -Jxvf file.tar.xz</span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line">unzip file.zip //解压zip</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*.tar 用 tar -xvf 解压</span><br><span class="line">*.gz 用 gzip -d或者gunzip 解压</span><br><span class="line">*.tar.gz和*.tgz 用 tar -xzf 解压</span><br><span class="line">*.bz2 用 bzip2 -d或者用bunzip2 解压</span><br><span class="line">*.tar.bz2用tar -xjf 解压</span><br><span class="line">*.Z 用 uncompress 解压</span><br><span class="line">*.tar.Z 用tar -xZf 解压</span><br><span class="line">*.rar 用 unrar e解压</span><br><span class="line">*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_gpio</title>
    <url>/blog/2021/11/23/linux_gpio/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/lell3538/article/details/51277870?ops_request_misc=%7B%22request_id%22:%22163767480816780261986595%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767480816780261986595&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51277870.pc_search_mgc_flag&utm_term=linux%E6%93%8D%E4%BD%9Cgpio&spm=1018.2226.3001.4187">Linux操作GPIO（文件IO方式）_Leon-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/u010299133/article/details/82286700?ops_request_misc=%7B%22request_id%22:%22163767480816780261986595%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767480816780261986595&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82286700.pc_search_mgc_flag&utm_term=linux%E6%93%8D%E4%BD%9Cgpio&spm=1018.2226.3001.4187">在Linux 中的应用层操作gpio的方法_仗劍走天涯-CSDN博客</a></p>
<h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><p><code>控制GPIO</code>的目录位于<code>/sys/class/gpio</code></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 导出</span><br><span class="line">/sys/class/gpio# echo 44 &gt; export</span><br><span class="line">2. 设置方向</span><br><span class="line">/sys/class/gpio/gpio44# echo out &gt; direction</span><br><span class="line">3. 查看方向</span><br><span class="line">/sys/class/gpio/gpio44# cat direction</span><br><span class="line">4. 设置输出</span><br><span class="line">/sys/class/gpio/gpio44# echo 1 &gt; value</span><br><span class="line">5. 查看输出值</span><br><span class="line">/sys/class/gpio/gpio44# cat value</span><br><span class="line">6. 取消导出</span><br><span class="line">/sys/class/gpio# echo 44 &gt; unexport</span><br></pre></td></tr></table></figure>

<p> 以<strong>echo</strong>的形式调用<strong>system</strong>函数进行操作，这种形式编程比较简单，结构比较清晰，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gpio64_low</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 64 &gt; /sys/class/gpio/export&quot;</span>);  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo out &gt; /sys/class/gpio/gpio64/direction&quot;</span>);  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 0 &gt; /sys/class/gpio/gpio64/value&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> 通过<strong>文件</strong>的形式来调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>   <span class="comment">//define O_WRONLY and O_RDONLY</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGpio</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp =<span class="built_in">fopen</span>(<span class="string">&quot;/sys/class/gpio/export&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;export open filed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;   <span class="comment">//create gpio file</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGpioDirection</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> *direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(path,<span class="string">&quot;/sys/class/gpio/gpio%d/direction&quot;</span>,n);</span><br><span class="line">    FILE * fp =<span class="built_in">fopen</span>(path,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;direction open filed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,direction);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;   <span class="comment">//set gpio &quot;in&quot; or &quot;out&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGpioValue</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> value_str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="built_in"><span class="keyword">sizeof</span></span>(path), <span class="string">&quot;/sys/class/gpio/gpio%d/value&quot;</span>, n);</span><br><span class="line">    fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open gpio value for reading!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd, value_str, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to read value!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">atoi</span>(value_str));</span><br><span class="line">&#125;   <span class="comment">//get gpio(n)&#x27;s value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGpioValue</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> value_str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="built_in"><span class="keyword">sizeof</span></span>(path), <span class="string">&quot;/sys/class/gpio/gpio%d/value&quot;</span>, n);</span><br><span class="line">    fd = <span class="built_in">open</span>(path, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open gpio value for writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">        <span class="built_in">strcpy</span>(value_str,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strcpy</span>(value_str,<span class="string">&quot;0&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, value_str, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to write value!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;   <span class="comment">//set gpio(n)&#x27;s value</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initGpio</span>(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">setGpioDirection</span>(<span class="number">18</span>,(<span class="keyword">char</span>*)<span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setGpioValue</span>(<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getGpioValue</span>(<span class="number">18</span>));<span class="comment">//每隔1s输出一次gpio18的值</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">setGpioValue</span>(<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getGpioValue</span>(<span class="number">18</span>));<span class="comment">//每隔1s输出一次gpio18的值</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线性二次型调节器(lqr)</title>
    <url>/blog/2022/03/18/lqr/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/heyijia0327/article/details/39270597?ops_request_misc=%7B%22request_id%22:%22164769962516781685361485%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164769962516781685361485&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-39270597.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=lqr%E6%8E%A7%E5%88%B6&spm=1018.2226.3001.4187">(116条消息) LQR 的直观推导及简单应用_白巧克力亦唯心的博客-CSDN博客_lqr算法</a> </p>
<p> <a href="https://www.bilibili.com/video/BV1GN411X74z?spm_id_from=333.999.0.0">路径规划与轨迹跟踪系列算法学习_第12讲_线性二次型调节器(LQR)法_哔哩哔哩_bilibili</a> </p>
<p><a href="https://github.com/AtsushiSakai/PythonRobotics">https://github.com/AtsushiSakai/PythonRobotics</a></p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ul>
<li><p>对于一个线性系统可以用<strong>x_dot = Ax +Bu</strong>表示,参考全反馈控制模型,我们需要设计一个状态反馈控制器,表示为</p>
<p><strong>u = -Kx</strong>,使得闭环系统满足我们的期望性能.因此可以可得到状态方程为<strong>x_dot = (A-BK)x=Acx</strong></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/PEghOQITaF98z4j.png" alt="1647741354_1_.png"></p>
<ul>
<li>通过设计一款能量函数,如下,希望最优的控制轨迹应该使得该能量函数最小</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/Q1CsRYG3anZAfWE.png" alt="20140914171220986.png"></p>
<p>​      </p>
<ul>
<li>由于<strong>u = -Kx</strong>,我们可以得到,</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/gFoi2VmudcBKUrI.png" alt="20140914171601165.png"></p>
<ul>
<li>为便于求解K,引入常矩阵P,最终化简可以得到</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/ZbtuTqlKEkrGamj.png" alt="1647742289_1_.png"></p>
<ul>
<li>lqr求解流程<ul>
<li> 选择参数矩阵Q,R </li>
<li> 求解Riccati 方程得到矩阵P </li>
<li> 计算 : K = R*-1* B<em>T</em> P</li>
</ul>
</li>
</ul>
<h1 id="lqr结构图"><a href="#lqr结构图" class="headerlink" title="lqr结构图"></a>lqr结构图</h1><p><img src="https://s2.loli.net/2022/03/20/e7YvrR2CKl5gPOD.png" alt="1647749530_1_.png"></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p> 倒立摆的状态变量为<strong>x=[p,p_dot,the,the_dot]T</strong>,其中p(t)是小车位置，θ是倒立摆的角度,这里直接调用matlab中lqr</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span>];</span><br><span class="line">B = [<span class="number">0</span>;<span class="number">0.1</span>;<span class="number">0</span>;<span class="number">-0.1</span>];</span><br><span class="line">C = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>];   <span class="comment">%观测角度</span></span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">10</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line">    ];</span><br><span class="line">R = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">%由上面这个系统，可以计算出K</span></span><br><span class="line">K = lqr(A,B,Q,R);</span><br><span class="line">Ac = A - B*K;</span><br><span class="line"><span class="comment">%对系统进行模拟</span></span><br><span class="line">x0 = [<span class="number">0.1</span>;<span class="number">0</span>;<span class="number">0.1</span>;<span class="number">0</span>]; <span class="comment">%初始状态</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">0.05</span>:<span class="number">20</span>;</span><br><span class="line">u = <span class="built_in">zeros</span>(<span class="built_in">size</span>(t));</span><br><span class="line">[y,x]=lsim(Ac,B,C,D,u,t,x0); </span><br><span class="line"><span class="built_in">plot</span>(t,y);</span><br></pre></td></tr></table></figure>

<h1 id="python实现dlqr"><a href="#python实现dlqr" class="headerlink" title="python实现dlqr"></a>python实现dlqr</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_DARE</span>(<span class="params">A, B, Q, R</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    solve a discrete time_Algebraic Riccati equation (DARE)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    X = Q</span><br><span class="line">    maxiter = <span class="number">150</span></span><br><span class="line">    eps = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxiter):</span><br><span class="line">        Xn = A.T @ X @ A - A.T @ X @ B @ \</span><br><span class="line">            la.inv(R + B.T @ X @ B) @ B.T @ X @ A + Q</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(Xn - X)).<span class="built_in">max</span>() &lt; eps:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        X = Xn</span><br><span class="line">    <span class="keyword">return</span> Xn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dlqr</span>(<span class="params">A, B, Q, R</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Solve the discrete time lqr controller.</span></span><br><span class="line"><span class="string">    x[k+1] = A x[k] + B u[k]</span></span><br><span class="line"><span class="string">    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]</span></span><br><span class="line"><span class="string">    # ref Bertsekas, p.151</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first, try to solve the ricatti equation</span></span><br><span class="line">    X = solve_DARE(A, B, Q, R)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute the LQR gain</span></span><br><span class="line">    K = la.inv(B.T @ X @ B + R) @ (B.T @ X @ A)</span><br><span class="line"></span><br><span class="line">    eigVals, eigVecs = la.eig(A - B @ K)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K, X, eigVals</span><br></pre></td></tr></table></figure>

<p>注意这里的A,B使用的是frenet坐标系</p>
<p>主要是[e,e_dot,the_e,the_e_dot]</p>
<h1 id="关于加入纵向控制lqr算法"><a href="#关于加入纵向控制lqr算法" class="headerlink" title="关于加入纵向控制lqr算法"></a>关于加入纵向控制lqr算法</h1><p>注意: x = [e, dot_e, th_e, dot_th_e, delta_v],当然相关的A,B,Q,R同样修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lqr_speed_steering_control</span>(<span class="params">state, cx, cy, cyaw, ck, pe, pth_e, sp, Q, R</span>):</span></span><br><span class="line">    ind, e = calc_nearest_index(state, cx, cy, cyaw)</span><br><span class="line"></span><br><span class="line">    tv = sp[ind]</span><br><span class="line"></span><br><span class="line">    k = ck[ind]</span><br><span class="line">    v = state.v</span><br><span class="line">    th_e = pi_2_pi(state.yaw - cyaw[ind])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A = [1.0, dt, 0.0, 0.0, 0.0</span></span><br><span class="line">    <span class="comment">#      0.0, 0.0, v, 0.0, 0.0]</span></span><br><span class="line">    <span class="comment">#      0.0, 0.0, 1.0, dt, 0.0]</span></span><br><span class="line">    <span class="comment">#      0.0, 0.0, 0.0, 0.0, 0.0]</span></span><br><span class="line">    <span class="comment">#      0.0, 0.0, 0.0, 0.0, 1.0]</span></span><br><span class="line">    A = np.zeros((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    A[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">    A[<span class="number">0</span>, <span class="number">1</span>] = dt</span><br><span class="line">    A[<span class="number">1</span>, <span class="number">2</span>] = v</span><br><span class="line">    A[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">1.0</span></span><br><span class="line">    A[<span class="number">2</span>, <span class="number">3</span>] = dt</span><br><span class="line">    A[<span class="number">4</span>, <span class="number">4</span>] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># B = [0.0, 0.0</span></span><br><span class="line">    <span class="comment">#     0.0, 0.0</span></span><br><span class="line">    <span class="comment">#     0.0, 0.0</span></span><br><span class="line">    <span class="comment">#     v/L, 0.0</span></span><br><span class="line">    <span class="comment">#     0.0, dt]</span></span><br><span class="line">    B = np.zeros((<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">    B[<span class="number">3</span>, <span class="number">0</span>] = v / L</span><br><span class="line">    B[<span class="number">4</span>, <span class="number">1</span>] = dt</span><br><span class="line"></span><br><span class="line">    K, _, _ = dlqr(A, B, Q, R)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># state vector</span></span><br><span class="line">    <span class="comment"># x = [e, dot_e, th_e, dot_th_e, delta_v]</span></span><br><span class="line">    <span class="comment"># e: lateral distance to the path</span></span><br><span class="line">    <span class="comment"># dot_e: derivative of e</span></span><br><span class="line">    <span class="comment"># th_e: angle difference to the path</span></span><br><span class="line">    <span class="comment"># dot_th_e: derivative of th_e</span></span><br><span class="line">    <span class="comment"># delta_v: difference between current speed and target speed</span></span><br><span class="line">    x = np.zeros((<span class="number">5</span>, <span class="number">1</span>))</span><br><span class="line">    x[<span class="number">0</span>, <span class="number">0</span>] = e</span><br><span class="line">    x[<span class="number">1</span>, <span class="number">0</span>] = (e - pe) / dt</span><br><span class="line">    x[<span class="number">2</span>, <span class="number">0</span>] = th_e</span><br><span class="line">    x[<span class="number">3</span>, <span class="number">0</span>] = (th_e - pth_e) / dt</span><br><span class="line">    x[<span class="number">4</span>, <span class="number">0</span>] = v - tv</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input vector</span></span><br><span class="line">    <span class="comment"># u = [delta, accel]</span></span><br><span class="line">    <span class="comment"># delta: steering angle</span></span><br><span class="line">    <span class="comment"># accel: acceleration</span></span><br><span class="line">    ustar = -K @ x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calc steering input</span></span><br><span class="line">    ff = math.atan2(L * k, <span class="number">1</span>)  <span class="comment"># feedforward steering angle</span></span><br><span class="line">    fb = pi_2_pi(ustar[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># feedback steering angle</span></span><br><span class="line">    delta = ff + fb</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calc accel input</span></span><br><span class="line">    accel = ustar[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delta, ind, e, th_e, accel</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_tracking</category>
      </categories>
      <tags>
        <tag>path_tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>make配置模板</title>
    <url>/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="make文件目录"><a href="#make文件目录" class="headerlink" title="make文件目录"></a>make文件目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/make# tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── conf.sh</span><br><span class="line">├── main.cpp</span><br><span class="line">└── shell.sh</span><br></pre></td></tr></table></figure>

<p>这里使用了shell脚本来实现对于make的编译，由于使用的是<code>wsl</code>在windows下操作导致编码格式含有<code>\r\n</code>，以此有两个shell脚本。</p>
<h3 id="conf-sh"><a href="#conf-sh" class="headerlink" title="conf.sh"></a>conf.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现对于make的编译与运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [[ $1 == clean ]]; then</span><br><span class="line">        make clean</span><br><span class="line">elif [[ $1 == all ]]; then</span><br><span class="line">        make clean &amp;&amp; make -j8 &amp;&amp; ./main</span><br><span class="line">else</span><br><span class="line">        make -j8 &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现将conf.sh的dos编码转化为unix编码，并执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">dos2unix  conf.sh &amp;&amp; ./conf.sh</span><br></pre></td></tr></table></figure>

<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动捕捉符合c/c++编译</span></span><br><span class="line"><span class="comment">#指定编译工具</span></span><br><span class="line">CC = gcc</span><br><span class="line">CPP = g++</span><br><span class="line">LINK = g++</span><br><span class="line"></span><br><span class="line">LIBS = -lsqlite3 -lpthread</span><br><span class="line"><span class="comment">#编译.so 必须添加 -fPIC 和 -shared 选项</span></span><br><span class="line">CCFLAGS = -c -g -fPIC</span><br><span class="line">CPPFLAGS = -c -g -fPIC</span><br><span class="line"></span><br><span class="line"><span class="comment">#期望得到的执行文件或动态库.so</span></span><br><span class="line"><span class="comment">#TARGET=libxx.so</span></span><br><span class="line">TARGET=main</span><br><span class="line"></span><br><span class="line">INCLUDES = -I. <span class="comment">#-I../../</span></span><br><span class="line"></span><br><span class="line">CPPFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.cpp文件</span></span><br><span class="line">CFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.c文件</span></span><br><span class="line"></span><br><span class="line">OBJFILE = $(CFILES:.c=.o) $(CPPFILES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJFILE)</span></span><br><span class="line"><span class="comment"># 编译得到 .so 文件用下面的代码</span></span><br><span class="line"><span class="comment">#   $(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@</span></span><br><span class="line"><span class="comment"># 编译得到可执行文件用下面的代码</span></span><br><span class="line">        <span class="variable">$(LINK)</span> <span class="variable">$^</span> <span class="variable">$(LIBS)</span> -Wall -O2 -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(CCFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">        <span class="variable">$(CPP)</span> -o <span class="variable">$@</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJFILE)</span></span><br></pre></td></tr></table></figure>

<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./shell</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>map_tp_map方法实现的回环检测</title>
    <url>/blog/2022/04/01/map_tp_map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://sci-hub.se/10.1109/ROBIO49542.2019.8961777"> A Triangle Feature Based Map-to-map Matching and Loop Closure for 2D Graph SLAM </a> </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol start="0">
<li><p>建图步:通过csm于pl-icp建图</p>
</li>
<li><p>通过SIFT,SURF,ORB等方式对全局地图与子图选择特征角点</p>
</li>
<li><p>通过L1≥L2≥L3的方式设置三角形(L1=|x1-x2|,L2=|x2-x3|,L3=|x1-x3|) ,分别将全局地图与子图x1,x2,x3分别放入三个数组中备用,记为Tk(3)与Tl(3)</p>
</li>
<li><p>根据以下公式,筛选出合适的对应点,但实际上两个距离只能达到大致相等,因此需要加一个阈值,阈值函数如下,找出全等三角形<br>$$<br>dist^{k}\left ( t_{k}^{i}\left ( 1 \right ),t_{k}^{i}\left ( 2 \right ) \right )\approx dist^{l}\left ( t_{l}^{i}\left ( 1 \right ),t_{l}^{i}\left ( 2 \right ) \right );\</p>
</li>
</ol>
<p>dist^{k}\left ( t_{k}^{i}\left ( 2 \right ),t_{k}^{i}\left ( 3 \right ) \right )\approx dist^{l}\left ( t_{l}^{i}\left ( 2 \right ),t_{l}^{i}\left ( 3 \right ) \right );\</p>
<p>dist^{k}\left ( t_{k}^{i}\left ( 1 \right ),t_{k}^{i}\left ( 3 \right ) \right )\approx dist^{l}\left ( t_{l}^{i}\left ( 1 \right ),t_{l}^{i}\left ( 3 \right ) \right );\</p>
<p>\frac{\left| x1 -x2 \right|}{min\left ( x1,x2 \right )} &lt; 0.03<br>$$<br>4. 根据找出的全等三角形可以得到数组(dX,dY,dTheta),对dTheta在(-pi~pi)上的投票,选出合适的数组(dX,dY,dTheta),通过阈值将不太可能的数组过滤掉<br>5. 通过二部图匹配,km算法最终得到(dX,dY,dTheta),也即得到了初步定位坐标<br>6. 使用icp算法做最后的精细定位</p>
<h1 id="加速算法"><a href="#加速算法" class="headerlink" title="加速算法"></a>加速算法</h1><ul>
<li>在生成三角形时注意可以设置长边阈值,大于最大长边的三角形不生成</li>
<li>在进行第3步的时候可以先进行排序,后进行筛选</li>
<li>在第四步投票时可以通过部分采样的方式,选取一定量样本,加快投票速度</li>
</ul>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>make_pair(),mean(),assign()使用</title>
    <url>/blog/2022/03/07/make_pair(),mean(),assign()%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_41169280/article/details/109861478">(112条消息) make_pair函数_半尺杆头的博客-CSDN博客_make_pair</a> </p>
<p> <a href="https://blog.csdn.net/xlm289348/article/details/8166820?ops_request_misc=%7B%22request_id%22:%22164661925516780255270544%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164661925516780255270544&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-8166820.pc_search_insert_es_download&utm_term=assign&spm=1018.2226.3001.4187">(112条消息) C++STL中vector容器 assign()函数的用法_xlm289348的专栏-CSDN博客_vector的assign函数</a> </p>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="make-pair"><a href="#make-pair" class="headerlink" title="make_pair()"></a>make_pair()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="keyword">int</span>, <span class="keyword">float</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; result &#123;loop_id, yaw_diff_rad&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">float</span>, <span class="keyword">int</span>&gt; sc_dist_result = distanceBetweenScancontexts( curr_desc, context_candidate ); </span><br><span class="line"><span class="keyword">float</span> candidate_dist = sc_dist_result.first;</span><br><span class="line"><span class="keyword">int</span> candidate_align = sc_dist_result.second;</span><br></pre></td></tr></table></figure>

<h2 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mean()求均值</span><br><span class="line">mean（A）</span><br><span class="line">若A为[矩阵](https://so.csdn.net/so/search?q=矩阵&amp;spm=1001.2101.3001.7020)，则输出每一列的均值（一个向量）</span><br><span class="line">若A为列向量，则输出均值（一个数）</span><br><span class="line">若A为行向量，则也是输出均值（一个数），和列向量一样 </span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::MatrixXf <span class="title">invariant_key</span><span class="params">(desc.rows(), <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> row_idx = <span class="number">0</span>; row_idx &lt; desc.rows(); row_idx++ )&#123;</span><br><span class="line">    <span class="comment">// 对一行求均值</span></span><br><span class="line">    Eigen::MatrixXf curr_row = desc.row(row_idx);</span><br><span class="line">    <span class="comment">// mean()求均值</span></span><br><span class="line">    invariant_key(row_idx, <span class="number">0</span>) = curr_row.mean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(const_iterator first,const_iterator last)</span></span>;</span><br><span class="line"><span class="comment">//将区间[first,last)的元素赋值到当前的vector容器中，或者赋n个值为x的元素到vector容器中，这个容器会清除掉vector容器中以前的内容。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2.assign(v1.begin(), v1.end()<span class="number">-6</span>);</span><br><span class="line"><span class="comment">// 将v1从开头到最后第六位赋值给assign</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>map_server</title>
    <url>/blog/2021/11/05/map_server/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/datase/article/details/82495600">(60条消息) map server 功能和作用_天才樱木-CSDN博客_map_server</a></p>
<h1 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun map_server map_saver -f mymap</span><br></pre></td></tr></table></figure>

<p>我们会得到两个文件,<code>mymap.pgm</code>,<code>mymap.yaml</code></p>
<p><code>mymap.pgm</code>为0到1的灰度图</p>
<p><code>mymap.yaml</code>为配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">image: testmap.png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分辨率</span></span><br><span class="line">resolution: 0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始点</span></span><br><span class="line">origin: [0.0, 0.0, 0.0]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 占用阈值</span></span><br><span class="line">occupied_thresh: 0.65</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为自由阈值</span></span><br><span class="line">free_thresh: 0.196</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否应该颠倒白/黑 自由/被占用的语义(阈值的解释不受影响)</span></span><br><span class="line">negate: 0</span><br></pre></td></tr></table></figure>

<h1 id="发布节点"><a href="#发布节点" class="headerlink" title="发布节点"></a>发布节点</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun map_server map_server mymap.yaml</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><strong>map_metadata</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html">nav_msgs/MapMetaData</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这包含了关于占领网格特征的基本信息</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图加载的时间</span></span><br><span class="line">time map_load_time</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的分辨率 [m/cell]</span></span><br><span class="line">float32 resolution</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map width [cells]</span></span><br><span class="line">uint32 width</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map height [cells]</span></span><br><span class="line">uint32 height</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的原点[m, m, rad]。这是地图中单元格(0,0)的真实姿态。</span></span><br><span class="line">geometry_msgs/Pose origin</span><br></pre></td></tr></table></figure>

<p><strong>map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html">nav_msgs/OccupancyGrid</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这代表了一个二维网格地图，其中每个单元格代表占用概率。</span></span><br><span class="line"></span><br><span class="line">Header header </span><br><span class="line"><span class="meta">#</span><span class="bash"> uint32 seq</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> time stamp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> string frame_id</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">地图的元数据</span></span><br><span class="line">MapMetaData info</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射数据，按行主顺序，从(0,0)开始。占用概率在[0,100]范围内。未知是1。</span></span><br><span class="line">int8[] data</span><br></pre></td></tr></table></figure>

<p><strong>static_map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html">nav_msgs/GetMap</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Get the map as a nav_msgs/OccupancyGrid</span></span><br><span class="line">---</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab实现雅可比,海塞矩阵</title>
    <url>/blog/2022/03/01/matlab%E5%AE%9E%E7%8E%B0%E9%9B%85%E5%8F%AF%E6%AF%94,%E6%B5%B7%E5%A1%9E%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_39726697/article/details/115901738?ops_request_misc=%7B%22request_id%22:%22164613329816780271527587%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=164613329816780271527587&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-115901738.nonecase&utm_term=matlab+jacobian()&spm=1018.2226.3001.4450">(110条消息) matlab 构建雅可比矩阵,matlab jacobian函数_weixin_39726697的博客-CSDN博客</a> </p>
<p> <a href="https://blog.csdn.net/weixin_42363600/article/details/115823762?ops_request_misc=%7B%22request_id%22:%22164613336816780274199935%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164613336816780274199935&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-115823762.pc_search_insert_es_download&utm_term=matlab+syms&spm=1018.2226.3001.4187">(110条消息) matlab不能使用syms,matlab syms什么意思_不告诉你不告诉你的博客-CSDN博客</a> </p>
<p> <a href="https://blog.csdn.net/appleyuchi/article/details/95385461?ops_request_misc=&request_id=&biz_id=102&utm_term=matlab%E6%B5%B7%E7%91%9F%E7%9F%A9%E9%98%B5&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-1-95385461.nonecase&spm=1018.2226.3001.4450">(110条消息) matlab计算hessian矩阵_微电子学与固体电子学-CSDN博客_matlab计算海塞矩阵</a> </p>
<p> <a href="https://blog.csdn.net/u014754127/article/details/53486816?ops_request_misc=%7B%22request_id%22:%22164613362016780261992748%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164613362016780261992748&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-53486816.pc_search_insert_es_download&utm_term=matlab+gradient&spm=1018.2226.3001.4187">(110条消息) Matlab中gradient函数的使用方法_Simy Hsu’s Blog-CSDN博客_gradient matlab</a> </p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;close;</span><br><span class="line"><span class="comment">% syms x y z</span></span><br><span class="line"><span class="comment">% jacobian([x*y*z, y^2, x + z], [x, y, z])</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">syms a b c x<span class="comment">% 设变量为a,b,c</span></span><br><span class="line">f = <span class="built_in">exp</span>(a*x^<span class="number">2</span>+b*x+c);</span><br><span class="line">d = jacobian(f,[a,b,c]);<span class="comment">% 进行有雅可比变换</span></span><br><span class="line"><span class="built_in">disp</span>(d)</span><br><span class="line"><span class="comment">% pretty(d)</span></span><br><span class="line"><span class="comment">% hessian矩阵 = 梯度矩阵的雅可比矩阵</span></span><br><span class="line"><span class="comment">% syms x y z;</span></span><br><span class="line"><span class="comment">% f1=(x^2-2*x)*exp(-x^2-y^2-x*y);</span></span><br><span class="line"><span class="comment">% f = x*y + 2*z*x;</span></span><br><span class="line"><span class="comment">% hessian(f,[x,y,z])</span></span><br><span class="line"><span class="comment">% gradient(f1):求f1梯度</span></span><br><span class="line">S=jacobian(gradient(f,[a,b,c]),[a,b,c]);</span><br><span class="line"><span class="built_in">disp</span>(S)</span><br><span class="line"><span class="comment">% pretty(S)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab命令行运行</title>
    <url>/blog/2022/02/28/matlab%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_36317943/article/details/115810835?ops_request_misc=%7B%22request_id%22:%22164604995316780357295449%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164604995316780357295449&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-115810835.pc_search_insert_es_download&utm_term=cmd+matlab&spm=1018.2226.3001.4187">(110条消息) matlab执行cmd命令是什么意思,cmd 命令行方式执行 matlab 脚本_翻译奥莉姐的博客-CSDN博客</a> </p>
<p> <a href="https://zhuanlan.zhihu.com/p/113231869">VScode运行MATLAB（最正确版本） - 知乎 (zhihu.com)</a> </p>
<h1 id="cmd窗口运行"><a href="#cmd窗口运行" class="headerlink" title="cmd窗口运行"></a>cmd窗口运行</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">matlab -nojvm -nodesktop -nodisplay -r test</span><br></pre></td></tr></table></figure>

<h1 id="远程执行-matlab-脚本-关闭终端"><a href="#远程执行-matlab-脚本-关闭终端" class="headerlink" title="远程执行 matlab 脚本(关闭终端)"></a>远程执行 matlab 脚本(关闭终端)</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">matlab -nosplash -nodesktop -r test</span><br></pre></td></tr></table></figure>

<h1 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h1><p><strong>matlab extension pack</strong></p>
<p><strong>code runner</strong></p>
]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab打印函数</title>
    <url>/blog/2022/02/22/matlab%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/rushkid02/article/details/7929189">(109条消息) Matlab之print,fprint,fscanf,disp函数_WITNESS-CSDN博客_matlab print</a> </p>
<h1 id="Matlab之print-fprint-fscanf-disp函数"><a href="#Matlab之print-fprint-fscanf-disp函数" class="headerlink" title="Matlab之print,fprint,fscanf,disp函数"></a>Matlab之print,fprint,fscanf,disp函数</h1><h2 id="print-把函数图形保存下来"><a href="#print-把函数图形保存下来" class="headerlink" title="print - 把函数图形保存下来"></a>print - 把函数图形保存下来</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">minbnd = <span class="number">-4</span>*<span class="built_in">pi</span>;  </span><br><span class="line">maxbnd = <span class="number">4</span>*<span class="built_in">pi</span>;  </span><br><span class="line">t = minbnd:<span class="number">0.1</span>*<span class="built_in">pi</span>:maxbnd;  </span><br><span class="line"><span class="built_in">plot</span>(t, <span class="built_in">sin</span>(t), <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;Linewidth&#x27;</span>, <span class="number">2</span>);  </span><br><span class="line">line([minbnd, maxbnd], [<span class="number">0</span>, <span class="number">0</span>]);    <span class="comment">%绘制x轴  </span></span><br><span class="line">axis([<span class="number">-10</span>, <span class="number">10</span>, <span class="number">-2</span>, <span class="number">2</span>])             <span class="comment">%定义显示的坐标区间:x在(-10,10)之间，y在(-2,2)之间  </span></span><br><span class="line">grid on;  </span><br><span class="line">title(<span class="string">&#x27;sin(x)&#x27;</span>);  </span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);  </span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>);  </span><br><span class="line">print(<span class="string">&#x27;-dpng&#x27;</span>,<span class="string">&#x27;sin.png&#x27;</span>);          <span class="comment">%保存为png图片，在Matlab当前的工作目录下  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-dbmp：保存为bmp格式</span><br><span class="line">-djpeg：保存为jpeg格式</span><br><span class="line">-dpng：保存为png格式</span><br><span class="line">-dpcx：保存为pcx格式</span><br><span class="line">-dpdf：保存为pdf格式</span><br><span class="line">-dtiff：保存为tiff格式</span><br></pre></td></tr></table></figure>

<h2 id="fprintf-按指定格式写入文本文件"><a href="#fprintf-按指定格式写入文本文件" class="headerlink" title="fprintf - 按指定格式写入文本文件"></a>fprintf - 按指定格式写入文本文件</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 输出到屏幕</span></span><br><span class="line">data = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>];  </span><br><span class="line">[row, col] = <span class="built_in">size</span>(data);  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:row  <span class="comment">% for循环</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:col  </span><br><span class="line">    fprintf(<span class="string">&#x27;data(%d, %d) = %d\n&#x27;</span>, <span class="built_in">i</span>, <span class="built_in">j</span>, data(<span class="built_in">i</span>, <span class="built_in">j</span>));   <span class="comment">%直接输出到屏幕；类似于C语言的输出格式  </span></span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%c    单个字符  </span><br><span class="line">%d    有符号十进制数（%i也可以）  </span><br><span class="line">%u    无符号十进制数  </span><br><span class="line">%f    浮点数（%8.4f表示对浮点数取8位宽度，同时4位小数）  </span><br><span class="line">%o    无符号八进制数  </span><br><span class="line">%s    字符串  </span><br><span class="line">%x    小写a-f的十六进制数  </span><br><span class="line">%X    大小a-f的十六进制数</span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 输出到文件</span></span><br><span class="line">data = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>];  </span><br><span class="line">[row, col] = <span class="built_in">size</span>(data);               <span class="comment">%求出矩阵data的行数和列数  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">%加t表示按Windows格式输出换行，即0xOD 0x0A，没有t表示按Linux格式输出换行，即0x0A  </span></span><br><span class="line">fid=fopen(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>);           <span class="comment">%打开文件  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:row  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:col  </span><br><span class="line">    fprintf(fid, <span class="string">&#x27;%d &#x27;</span>, data(<span class="built_in">i</span>, <span class="built_in">j</span>));   <span class="comment">%类似于C语言的输出格式  </span></span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  fprintf(fid, <span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">fprintf(fid, <span class="string">&#x27;This is a string\n&#x27;</span>);  </span><br><span class="line">fprintf(fid, <span class="string">&#x27;%X&#x27;</span>, hex2dec(<span class="string">&#x27;ABCD&#x27;</span>));  </span><br><span class="line">fclose(fid);                           <span class="comment">%最后不要忘记关闭文件！</span></span><br></pre></td></tr></table></figure>

<h2 id="fscanf-文件读取"><a href="#fscanf-文件读取" class="headerlink" title="fscanf - 文件读取"></a>fscanf - 文件读取</h2><p>注意: <strong>fscanf读取数据时会忽略空格，直到回车为止!</strong> </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%加t的理由和上面一样  </span></span><br><span class="line">fid=fopen(<span class="string">&#x27;d:\test.txt&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>);   </span><br><span class="line"><span class="comment">%把数据读到data中。其中data是2*3的矩阵  </span></span><br><span class="line">data=fscanf(fid, <span class="string">&#x27;%d&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>]);   </span><br><span class="line">s=fscanf(fid, <span class="string">&#x27;%s&#x27;</span>);  </span><br><span class="line">d=fscanf(fid, <span class="string">&#x27;%X&#x27;</span>);  </span><br><span class="line"><span class="comment">%关闭文件  </span></span><br><span class="line">fclose(fid);  </span><br><span class="line"><span class="comment">%打印数据 </span></span><br><span class="line"><span class="built_in">disp</span>(data);  </span><br><span class="line"><span class="built_in">disp</span>(s);  </span><br><span class="line"><span class="built_in">disp</span>(d); </span><br></pre></td></tr></table></figure>

<h2 id="disp-输出在Matlab命令窗口"><a href="#disp-输出在Matlab命令窗口" class="headerlink" title="disp -  输出在Matlab命令窗口"></a>disp -  <strong>输出在Matlab命令窗口</strong></h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%单字符串输出：  </span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Hello World!&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">%不同类型数据输出：  </span></span><br><span class="line">num1 = <span class="number">1</span>;  </span><br><span class="line">num2 = <span class="number">2</span>;  </span><br><span class="line"><span class="built_in">disp</span>([ num2str(num1), <span class="string">&#x27; + &#x27;</span>, num2str(num2), <span class="string">&#x27; = &#x27;</span>, num2str(num1+num2)]);  </span><br><span class="line"><span class="comment">% 注意,这里的输出都是转换为string类型在输出的</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab的plot</title>
    <url>/blog/2022/02/22/matlab%E7%9A%84plot/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/T_just_for_tomorrow/article/details/104431429?ops_request_misc=%7B%22request_id%22:%22164550615916780274183421%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164550615916780274183421&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104431429.pc_search_insert_es_download&utm_term=plot&spm=1018.2226.3001.4187">(109条消息) 关于plot函数的一切（史上最全总结）_T_just_for_tomorrow的博客-CSDN博客_plot函数举例</a> </p>
<h1 id="基本输出形式"><a href="#基本输出形式" class="headerlink" title="基本输出形式"></a>基本输出形式</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>（X,Y，LineSpec）<span class="comment">% 这里的X,Y为需要输入参数,LineApec为设置线性，颜色，标记类型</span></span><br></pre></td></tr></table></figure>

<h1 id="具体参数如下图"><a href="#具体参数如下图" class="headerlink" title="具体参数如下图"></a>具体参数如下图</h1><table>
<thead>
<tr>
<th align="left">线性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">实线（默认）</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">虚线</td>
</tr>
<tr>
<td align="left">：</td>
<td align="left">虚线</td>
</tr>
<tr>
<td align="left">-.</td>
<td align="left">点划线</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">图像点的形状</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">o</td>
<td align="left">圈</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">加号</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">星号</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">点</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">十字</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">正方形</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">菱形</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">向上三角形</td>
</tr>
<tr>
<td align="left">v</td>
<td align="left">向下三角形</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">向右三角形</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">左三角形</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">五角星</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">六角形</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">颜色</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">y</td>
<td align="left">黄色</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">品红</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">青色</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">红色</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">绿色</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">蓝色</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">白色</td>
</tr>
<tr>
<td align="left">k</td>
<td align="left">黑色</td>
</tr>
</tbody></table>
<h1 id="绘制多条线"><a href="#绘制多条线" class="headerlink" title="绘制多条线"></a>绘制多条线</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=linespace(<span class="number">-2</span>*<span class="built_in">pi</span>,<span class="number">2</span>*<span class="built_in">pi</span>);   <span class="comment">% linespace（x1.x2,n）是均分计算指令，生成x1到x2之间n个行线型矢量</span></span><br><span class="line">                           <span class="comment">% 默认n是100</span></span><br><span class="line">y1=<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="built_in">cos</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,x,y2)</span><br></pre></td></tr></table></figure>

<h1 id="矩阵做图"><a href="#矩阵做图" class="headerlink" title="矩阵做图"></a>矩阵做图</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y=<span class="built_in">magic</span>(<span class="number">4</span>)   <span class="comment">%magic:生成行列和对角线元素和相等的矩阵，第二章的文章中总结过</span></span><br><span class="line"><span class="built_in">plot</span>(y)</span><br></pre></td></tr></table></figure>

<h1 id="指定线型，颜色和标记"><a href="#指定线型，颜色和标记" class="headerlink" title="指定线型，颜色和标记"></a>指定线型，颜色和标记</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">10</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">sin</span>(x<span class="number">-0.25</span>);</span><br><span class="line">y3 = <span class="built_in">sin</span>(x<span class="number">-0.5</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;g&#x27;</span>,x,y2,<span class="string">&#x27;b--o&#x27;</span>,x,y3,<span class="string">&#x27;c*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="在特定点标记"><a href="#在特定点标记" class="headerlink" title="在特定点标记"></a>在特定点标记</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-o&#x27;</span>,<span class="string">&#x27;MarkerIndices&#x27;</span>,<span class="number">1</span>:<span class="number">5</span>:<span class="built_in">length</span>(y))</span><br></pre></td></tr></table></figure>

<h1 id="显示轴，标题"><a href="#显示轴，标题" class="headerlink" title="显示轴，标题"></a>显示轴，标题</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">140</span>);</span><br><span class="line">y = <span class="built_in">cos</span>(<span class="number">3</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span>,<span class="number">0.7</span>,<span class="number">0.9</span>])</span><br><span class="line"> </span><br><span class="line">title(<span class="string">&#x27;曲线图&#x27;</span>) <span class="comment">%标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>)  <span class="comment">%显示x轴是x</span></span><br><span class="line">ylabel(<span class="string">&#x27;cos(3x)&#x27;</span>)  <span class="comment">%显示y轴</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab中文乱码</title>
    <url>/blog/2022/03/20/matlab%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p>  <a href="https://blog.csdn.net/weixin_45592315/article/details/121953800?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7.pc_relevant_default&utm_relevant_index=8">(116条消息) 解决matlab打开.m文件中文注释乱码问题_童童同学的博客-CSDN博客_.m文件中文乱码</a> </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>查看当前matlab编码格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slCharacterEncoding()</span><br><span class="line">% 乱码一般显示为:ans =</span><br><span class="line">    &#x27;GBK&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开matlab/bin文件夹,将 lcdata_utf8.xml 文件复制并重命名为 lcdata.xml ,若存在该文件,将其改名,保存,文件结构与如下</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/vwmhXk8UoS2AEGb.png" alt="1647767120_1_.png"></p>
<ul>
<li>打开 新复制的lcdata.xml,并删除</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoding</span> <span class="attr">name</span>=<span class="string">”GBK”</span>&gt;</span>  </span><br><span class="line">  &lt; encoding_alias name=”936”&gt;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改并加入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">修改前</span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span> <span class="attr">name</span>=<span class="string">”UTF-8”</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">encoding_alias</span> <span class="attr">name</span>=<span class="string">”utf8”/</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>  </span><br><span class="line">修改后</span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span> <span class="attr">name</span>=<span class="string">”UTF-8”</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">encoding_alias</span> <span class="attr">name</span>=<span class="string">”utf8”/</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">encoding_alias</span> <span class="attr">name</span>=<span class="string">”GBK”/</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>保存并重启matlab</li>
</ul>
]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>melodic+carto</title>
    <url>/blog/2022/04/16/melodic+carto/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/lianxindong/article/details/122395589?ops_request_misc=%7B%22request_id%22:%22165010532816780357289025%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165010532816780357289025&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-122395589.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=melodic%E5%AE%89%E8%A3%85cartographer&spm=1018.2226.3001.4187">(124条消息) （实测成功安装）ubuntu18.04+ros(melodic)安装 cartographer安装_我想lu内只狗的博客-CSDN博客</a> </p>
<h1 id="安装carto"><a href="#安装carto" class="headerlink" title="安装carto"></a>安装carto</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y python-wstool python-rosdep ninja-build stow</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建初始空间</span></span><br><span class="line">mkdir -p cart_ws/src</span><br><span class="line">cd cart_ws</span><br><span class="line">wstool init src  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载包</span></span><br><span class="line">cd src</span><br><span class="line">git clone https://ghproxy.com/https://github.com/cartographer-project/cartographer</span><br><span class="line">git clone https://ghproxy.com/https://github.com/cartographer-project/cartographer_ros</span><br><span class="line">git clone -b 1.14.x https://ghproxy.com/https://github.com/ceres-solver/ceres-solver</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加依赖</span></span><br><span class="line">cd .. &amp;&amp;src/cartographer/scripts/install_abseil.sh</span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update </span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译安装</span></span><br><span class="line">catkin_make_isolated --install --use-ninja</span><br></pre></td></tr></table></figure>

<h1 id="安装ceres-solver"><a href="#安装ceres-solver" class="headerlink" title="安装ceres-solver"></a>安装ceres-solver</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://ceres-solver.googlesource.com/ceres-solver</span><br><span class="line"><span class="built_in">cd</span> ceres-solver</span><br><span class="line">mkdir build&amp;&amp;<span class="built_in">cd</span> build</span><br><span class="line">cmake .. </span><br><span class="line">make -j8&amp;&amp;sudo make install</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><a href="https://google-cartographer-ros.readthedocs.io/en/latest/data.html#d-cartographer-backpack-deutsches-museum">测试包</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=/home/fairy/Downloads/b0-2014-07-11-11-00-49.bag</span><br><span class="line">roslaunch cartographer_ros demo_backpack_3d.launch bag_filename:=/home/fairy/Downloads/b3-2016-03-01-13-39-41.bag </span><br></pre></td></tr></table></figure>

<h1 id="修改-bashrc"><a href="#修改-bashrc" class="headerlink" title="修改~/.bashrc"></a>修改~/.bashrc</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;source ~/cart_ws/devel_isolated/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>moxa配置</title>
    <url>/blog/2022/02/10/moxa%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/menshu1892/article/details/72630830?ops_request_misc=%7B%22request_id%22:%22164428386616780269899340%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164428386616780269899340&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-72630830.pc_search_result_control_group&utm_term=moxa&spm=1018.2226.3001.4187">(105条消息) MOXA串口服务器的配置_MAYBE的博客-CSDN博客_moxa串口服务器</a> </p>
<p> <a href="https://jingyan.baidu.com/article/295430f18d15490c7e0050c6.html">如何设置MOXA的无线AP和Client-百度经验 (baidu.com)</a> </p>
<h1 id="moxa无线ap"><a href="#moxa无线ap" class="headerlink" title="moxa无线ap"></a>moxa无线ap</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新用户有线连接,网址输入 192.168.127.253</span></span><br><span class="line">username:admin</span><br><span class="line">password:moxa</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/10/NPCF2clJebBoRr7.png" alt="1644474829018.png"></p>
<h2 id="修改静态ip"><a href="#修改静态ip" class="headerlink" title="修改静态ip"></a>修改静态ip</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择network setting</span></span><br><span class="line">1\ static</span><br><span class="line">2\ 192.168.xx.xx</span><br><span class="line">3\ 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/10/jzrA5b9vkLxCt7o.png" alt="1644474843435.png"></p>
<h2 id="连接到路由"><a href="#连接到路由" class="headerlink" title="连接到路由"></a>连接到路由</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> WLAN-&gt;Basic WLAN Setup</span></span><br><span class="line">点击site survey查找需要接入ap</span><br><span class="line">submit</span><br><span class="line"><span class="meta">#</span><span class="bash"> WLAN-&gt;WLAN Security Setting</span></span><br><span class="line">passphrase:密码</span><br><span class="line"><span class="meta">#</span><span class="bash"> WLAN-&gt;Advanced WLAN Setting</span></span><br><span class="line">参考图片</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/10/vp4QtkeC3OqjEiT.png" alt="1644475086084.png"></p>
<p><img src="https://s2.loli.net/2022/02/10/zlpNQokyeBbt24r.png" alt="1644475096295.png"></p>
<p><img src="https://s2.loli.net/2022/02/10/qr8eCUHAPXTztnl.png" alt="1644475162592.png"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_shell</title>
    <url>/blog/2021/12/09/linux_shell/</url>
    <content><![CDATA[<h1 id="删除除某文件以外其他文件"><a href="#删除除某文件以外其他文件" class="headerlink" title="删除除某文件以外其他文件"></a>删除除某文件以外其他文件</h1><h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://www.cnblogs.com/blueskycc/p/5139902.html">linux删除指定文件夹中某个文件除外的其他文件 - He元素 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shopt -s extglob</span><br><span class="line">rm -fr !(file1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是多个要排除的，可以这样：</span></span><br><span class="line">rm -rf !(file1|file2)</span><br></pre></td></tr></table></figure>

<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址"></a>参考网址</h2><p><a href="https://www.cnblogs.com/windchen/p/6236299.html">ubuntu 挂载windows共享目录的方法 - Supper阿欣 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fzzfh/p/10330014.html">linux挂载文件报错mount error(13): Permission denied - 风中追风h - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.zhihu.com/question/41745930/answer/510335896">win10 家庭版 cmd运行gpedit.msc找不到文件？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://langbin.blog.csdn.net/article/details/78929045">(2条消息) ubuntu挂载Windows共享文件夹_深藏功与名-CSDN博客_ubuntu挂载windows共享目录</a></p>
<h2 id="pi挂载Ubuntu"><a href="#pi挂载Ubuntu" class="headerlink" title="pi挂载Ubuntu"></a>pi挂载Ubuntu</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount 192.168.2.111:/home/pty/nfs/ /mnt  </span><br></pre></td></tr></table></figure>

<h2 id="pi挂载win"><a href="#pi挂载win" class="headerlink" title="pi挂载win"></a>pi挂载win</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.10.1/d  /mnt -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw,dir_mode=0777,file_mode=0777</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux定时器</title>
    <url>/blog/2021/12/10/linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_34358365/article/details/94217782?ops_request_misc=%7B%22request_id%22:%22163914549216780255279840%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163914549216780255279840&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-94217782.nonecase&utm_term=linux%E5%AE%9A%E6%97%B6%E5%99%A8&spm=1018.2226.3001.4187">LInux下几种定时器的比较和使用_weixin_34358365的博客-CSDN博客</a></p>
<h1 id="1、sleep，usleep和nanosleep"><a href="#1、sleep，usleep和nanosleep" class="headerlink" title="1、sleep，usleep和nanosleep"></a>1、<a href="http://www.jb51.net/LINUXjishu/109403.html">sleep，usleep和nanosleep</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION 1000000L</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">slptm</span>;</span></span><br><span class="line">    <span class="keyword">long</span>   tdif;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tend</span>, <span class="title">tstart</span>;</span> </span><br><span class="line">    slptm.tv_sec = <span class="number">0</span>;</span><br><span class="line">    slptm.tv_nsec = <span class="number">1000</span>;      <span class="comment">//1000 ns = 1 us</span></span><br><span class="line">    <span class="comment">//struct sched_param param;    </span></span><br><span class="line">    <span class="comment">//param.sched_priority = 0;</span></span><br><span class="line">    <span class="comment">//sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);</span></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tstart, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get start time\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosleep(&amp;slptm, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to nanosleep&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tend, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get end time\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tdif = MILLION * (tend.tv_sec - tstart.tv_sec) + (tend.tv_usec - tstart.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nanosleep() time is %ld us\n&quot;</span>, tdif/COUNT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、使用信号量SIGALRM-alarm-只能秒级"><a href="#2、使用信号量SIGALRM-alarm-只能秒级" class="headerlink" title="2、使用信号量SIGALRM + alarm(),只能秒级"></a>2、使用信号量SIGALRM + alarm(),只能秒级</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIGALRM == sig)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;timer\n&quot;</span>);</span><br><span class="line">                alarm(<span class="number">1</span>);       <span class="comment">//重新继续定时1s</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        signal(SIGALRM, timer); <span class="comment">//注册安装信号</span></span><br><span class="line">        alarm(<span class="number">1</span>);       <span class="comment">//触发定时器</span></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、使用RTC-系统硬件提供的RTC，精度可调"><a href="#3、使用RTC-系统硬件提供的RTC，精度可调" class="headerlink" title="3、使用RTC(系统硬件提供的RTC，精度可调)"></a>3、使用RTC(系统硬件提供的RTC，精度可调)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> data = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fd = open (<span class="string">&quot;/dev/rtc&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*Set the freq as 4Hz*/</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(fd, RTC_IRQP_SET, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;ioctl(RTC_IRQP_SET)&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Enable periodic interrupts */</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(fd, RTC_PIE_ON, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;ioctl(RTC_PIE_ON)&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(read(fd, &amp;data, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        close(fd);</span><br><span class="line">                        <span class="built_in">exit</span>(errno);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;timer\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Disable periodic interrupts */</span></span><br><span class="line">        ioctl(fd, RTC_PIE_OFF, <span class="number">0</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、使用select"><a href="#4、使用select" class="headerlink" title="4、使用select()"></a>4、使用select()</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, this is Callback_1: x = %d \n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimer</span><span class="params">(<span class="keyword">int</span> seconds, <span class="keyword">int</span> mseconds,T arg,<span class="keyword">int</span> (*callback)(T))</span> <span class="comment">// Set Timer</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">temp</span>;</span></span><br><span class="line">        temp.tv_sec = seconds;</span><br><span class="line">        temp.tv_usec = mseconds;</span><br><span class="line">        select(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;temp);</span><br><span class="line">        callback(arg);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> last_time;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_diff_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">float</span> time = tv.tv_sec%<span class="number">10</span> + tv.tv_usec / <span class="number">1000000.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; last_time)</span><br><span class="line">                time += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> time_diff = time - last_time;</span><br><span class="line">        last_time = time;</span><br><span class="line">        <span class="keyword">return</span> time_diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> time_diff = get_diff_time();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time_diff = %f \n&quot;</span>, time_diff);</span><br><span class="line">        setTimer(<span class="number">1</span>, <span class="number">0</span>, a, Callback_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mpg处理</title>
    <url>/blog/2021/10/19/mpg%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://blog.csdn.net/qq_44343584/article/details/119992961">(47条消息) ROS开发实践（十三）——ROS中SLAM地图（.pgm格式）编辑软件的安装与使用_Ehang_Maker的博客-CSDN博客</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="http://gimp.baisheng999.com/">Gimp中文网 (baisheng999.com)</a></p>
<h4 id="windows安装流程"><a href="#windows安装流程" class="headerlink" title="windows安装流程:"></a>windows安装流程:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意选择安装路径,其他下一步即可</span><br></pre></td></tr></table></figure>

<h3 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.选择使用笔刷工具</span><br><span class="line">2.设置笔刷大小,硬度为100,力度为100,线型为直线</span><br><span class="line">3.按住Ctrl选择颜色</span><br><span class="line">4.释放后刷刷刷</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>linux报错</title>
    <url>/blog/2022/01/15/linux%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/JIEJINQUANIL/article/details/106414938">(99条消息) 编译警告：warning: Clock skew detected. Your build may be incomplete._竭尽全力的专栏-CSDN博客</a> </p>
<h1 id="warning-Clock-skew-detected"><a href="#warning-Clock-skew-detected" class="headerlink" title="warning: Clock skew detected"></a>warning: Clock skew detected</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f | xargs -n 5 touch</span><br></pre></td></tr></table></figure>

<h1 id="apt-upgdate-失败"><a href="#apt-upgdate-失败" class="headerlink" title="apt upgdate 失败"></a>apt upgdate 失败</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br><span class="line">sudo dpkg --configure -a </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nanoflann</title>
    <url>/blog/2022/05/09/nanoflann/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/u013019296/article/details/109377104">(131条消息) nanoflann库_Being_young的博客-CSDN博客</a> </p>
<p> <a href="https://github.com/jlblancoc/nanoflann">nanoflann: a C++11 header-only library for Nearest Neighbor (NN) search with KD-trees </a> </p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建kd-tree索引</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">my_kd_tree_t</span> = nanoflann::KDTreeSingleIndexAdaptor&lt;</span><br><span class="line">        nanoflann::L2_Simple_Adaptor&lt;<span class="keyword">num_t</span>, PointCloud&lt;<span class="keyword">num_t</span>&gt;&gt;,</span><br><span class="line">        PointCloud&lt;<span class="keyword">num_t</span>&gt;, <span class="number">3</span> <span class="comment">/* dim */</span></span><br><span class="line">        &gt;;</span><br><span class="line"><span class="function"><span class="keyword">my_kd_tree_t</span> <span class="title">index</span><span class="params">(<span class="number">3</span> <span class="comment">/*dim*/</span>, cloud, &#123;<span class="number">10</span> <span class="comment">/* max leaf */</span>&#125;)</span></span>;</span><br><span class="line"><span class="comment">// 2.knn 检索</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span>                   num_results = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">size_t</span>                         ret_index;</span><br><span class="line"><span class="keyword">num_t</span>                          out_dist_sqr;</span><br><span class="line"><span class="function">nanoflann::KNNResultSet&lt;<span class="keyword">num_t</span>&gt; <span class="title">resultSet</span><span class="params">(num_results)</span></span>;</span><br><span class="line">resultSet.<span class="built_in">init</span>(&amp;ret_index, &amp;out_dist_sqr);</span><br><span class="line">index.<span class="built_in">findNeighbors</span>(resultSet, &amp;query_pt[<span class="number">0</span>], nanoflann::<span class="built_in">SearchParams</span>(<span class="number">10</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;knnSearch(nn=&quot;</span> &lt;&lt; num_results &lt;&lt; <span class="string">&quot;): \n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ret_index=&quot;</span> &lt;&lt; ret_index</span><br><span class="line">          &lt;&lt; <span class="string">&quot; out_dist_sqr=&quot;</span> &lt;&lt; out_dist_sqr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>ndt</title>
    <url>/blog/2022/04/29/ndt/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/softdream/ndt-algorithm">softdream/ndt-algorithm (github.com)</a></p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. caculateNDTByFirstScan:主要对前一祯数据做网格化,得到FirstmeanPose,与Pose_Cov</span><br><span class="line">2. estimateTransformationOnce:对当前scan做网格化,然后使用poseCov作为sigma噪声与得到FirstmeanPose做高斯牛顿,然后迭代</span><br><span class="line">3. angleNormalize:角度归一化</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>具体代码参考<a href="https://github.com/softdream/ndt-algorithm">道峰大佬ndt</a></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>nano操作</title>
    <url>/blog/2021/10/19/nano%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><a href="https://blog.csdn.net/weixin_39591031/article/details/114236749?ops_request_misc=%7B%22request_id%22:%22163464180216780269866385%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163464180216780269866385&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-114236749.pc_search_ecpm_flag&utm_term=nano%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">nano使用技巧大全_Xav Pun的博客-CSDN博客_nano使用教程</a></li>
</ul>
<h3 id="便捷快捷键"><a href="#便捷快捷键" class="headerlink" title="便捷快捷键"></a>便捷快捷键</h3><p>注意前缀键<code>Ctrl+b</code>按完后松开，再按下其他键。</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>Alt+x</em></td>
<td align="center">切换帮助栏</td>
</tr>
<tr>
<td align="center"><em>ALT-#</em></td>
<td align="center">显示行号</td>
</tr>
<tr>
<td align="center"><em>CTRL-K</em></td>
<td align="center">剪切到行末</td>
</tr>
<tr>
<td align="center">ALT+6</td>
<td align="center">复制</td>
</tr>
<tr>
<td align="center">SHIFT+方向</td>
<td align="center">选择</td>
</tr>
<tr>
<td align="center">CTRL+u</td>
<td align="center">粘贴</td>
</tr>
<tr>
<td align="center">Alt + u</td>
<td align="center">撤销</td>
</tr>
<tr>
<td align="center">Alt + e</td>
<td align="center">重复</td>
</tr>
<tr>
<td align="center">ALT+&lt;</td>
<td align="center"><em>切换到上一个文件</em></td>
</tr>
<tr>
<td align="center">ALT+&gt; / alt +</td>
<td align="center"><em>切换到下一个文件</em></td>
</tr>
<tr>
<td align="center">CTRL+X</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">CTRL+R CTRL+T</td>
<td align="center">文件浏览器</td>
</tr>
<tr>
<td align="center">CTRL+C</td>
<td align="center">退出文件选择界面</td>
</tr>
<tr>
<td align="center">CTRL+S</td>
<td align="center">保存</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>path_plan</title>
    <url>/blog/2022/03/21/path_plan/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://www.bilibili.com/video/BV1Et4y167Ak/?spm_id_from=333.788.recommend_more_video.2">运动规划_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/teamo1996/Motion-plan">teamo1996/Motion-plan: 深蓝运动规划课程 (github.com)</a> </p>
<p> <a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?from=search&seid=5334828008397768028&spm_id_from=333.337.0.0">机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="基于搜索"><a href="#基于搜索" class="headerlink" title="基于搜索"></a>基于搜索</h2><ul>
<li><p>bfs/dfs</p>
</li>
<li><p>Djikstra</p>
</li>
<li><p>A*</p>
</li>
<li><p>jps</p>
</li>
</ul>
<h2 id="基于采样"><a href="#基于采样" class="headerlink" title="基于采样"></a>基于采样</h2><ul>
<li>dwa</li>
<li>RRT / RRT* / nformed RRT*</li>
</ul>
<h2 id="基于动力学约束"><a href="#基于动力学约束" class="headerlink" title="基于动力学约束"></a>基于动力学约束</h2><ul>
<li>状态栅格搜索算法(State Lattice Search)</li>
<li>OBVP</li>
</ul>
<h2 id="虚拟力场"><a href="#虚拟力场" class="headerlink" title="虚拟力场"></a>虚拟力场</h2><ul>
<li><p>VFF</p>
</li>
<li><p>VFH / VFH+ / VFH*</p>
</li>
</ul>
]]></content>
      <categories>
        <category>path_plan</category>
      </categories>
      <tags>
        <tag>path_plan</tag>
      </tags>
  </entry>
  <entry>
    <title>简单pid控制</title>
    <url>/blog/2021/12/16/pid%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>[P、I、D参数分析及倒立摆心得_一念之间、-CSDN博客_pid 倒立摆](<a href="https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p%E8%A1%A8%E7%A4%BA">https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p表示</a> i表示 d表示&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-8-75249145.pc_search_em_sort&amp;spm=1018.2226.3001.4187)</p>
<p><a href="https://blog.csdn.net/qq_18454025/article/details/103443771?ops_request_misc=%7B%22request_id%22:%22163961834316780274185698%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163961834316780274185698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-3-103443771.pc_search_em_sort&utm_term=pid&spm=1018.2226.3001.4187">PID控制算法的C语言实现_我的博客-CSDN博客_pid算法c程序</a></p>
<h1 id="PID作用"><a href="#PID作用" class="headerlink" title="PID作用"></a>PID作用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P-------作用是提高系统响应速度,过大会出现震荡---------------------------快速性</span><br><span class="line"></span><br><span class="line">I-------作用是消除静差----------------------------------------------准确性</span><br><span class="line"></span><br><span class="line">D-------作用是抑制震荡----------------------------------------------稳定性/预测性</span><br></pre></td></tr></table></figure>

<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pid控制测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P:响应 I:稳差 D:预判</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> kp;</span><br><span class="line">    <span class="keyword">float</span> ki;</span><br><span class="line">    <span class="keyword">float</span> kd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">pos_pid_control</span><span class="params">(<span class="keyword">float</span> target, <span class="keyword">float</span> current, struct PID_CTRL pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> err_last;</span><br><span class="line">    <span class="keyword">float</span> out,err_sum=<span class="number">0</span>,err_d,err;</span><br><span class="line">    err = target - current;</span><br><span class="line">    err_sum += err;</span><br><span class="line">    err_d = err - err_last;</span><br><span class="line">    out = pid.kp * err + pid.ki * err_sum + pid.kd * err_d;</span><br><span class="line">    err_last = err;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gain_pid_control</span><span class="params">(<span class="keyword">float</span> target, <span class="keyword">float</span> current, struct PID_CTRL pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> err_last;</span><br><span class="line">    <span class="keyword">float</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> err = target - current;</span><br><span class="line">    out += pid.kp * (err-err_last) + pid.ki * err;</span><br><span class="line">    err_last = err;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pos_pid_control</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span> <span class="title">pid</span>&#123;</span><span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">    pid.kp = <span class="number">0.5</span>;</span><br><span class="line">    pid.ki = <span class="number">0.2</span>;</span><br><span class="line">    pid.kd = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> target = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> current = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current += <span class="number">0.1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;target: %f, current: %f, out: %f\n&quot;</span>, target, current, <span class="built_in">pos_pid_control</span>(target, current, pid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_gain_pid_control</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PID_CTRL</span> <span class="title">pid</span>&#123;</span><span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">    pid.kp = <span class="number">0.5</span>;</span><br><span class="line">    pid.ki = <span class="number">0.2</span>;</span><br><span class="line">    pid.kd = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> target = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">float</span> current = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current += <span class="number">0.1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;target: %f, current: %f, out: %f\n&quot;</span>, target, current, <span class="built_in">gain_pid_control</span>(target, current, pid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_pos_pid_control</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">test_gain_pid_control</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>pip</title>
    <url>/blog/2021/12/11/pip/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_43146445/article/details/85078685?ops_request_misc=%7B%22request_id%22:%22162487776816780265445855%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162487776816780265445855&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-85078685.pc_search_result_control_group&utm_term=pip%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">(8条消息) pip安装镜像_转载_qq_2711624322-CSDN博客_pip安装镜像</a></p>
<p><a href="https://blog.csdn.net/SimpleLikeMe/article/details/104480017?ops_request_misc=%7B%22request_id%22:%22162761016016780265417243%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162761016016780265417243&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104480017.first_rank_v2_pc_rank_v29&utm_term=pip%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%95%9C%E5%83%8F%E6%BA%90&spm=1018.2226.3001.4187">设pip默认镜像源_SimpleLikeMe的博客-CSDN博客</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">临时使用</span></span><br><span class="line">pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple package</span><br><span class="line"><span class="meta">#</span><span class="bash">配置成固定镜像</span></span><br><span class="line">pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>path_tracking</title>
    <url>/blog/2022/03/17/path_tracking/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/ChenGuiGan/article/details/116459381?ops_request_misc=%7B%22request_id%22:%22164768363916780265425864%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164768363916780265425864&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-116459381.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=%E5%90%8E%E8%BD%AE%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(116条消息) 智能驾驶车辆横向控制算法_肥嘟嘟的左卫门的博客-CSDN博客_汽车横向控制和纵向控制</a> </p>
<p> <a href="https://blog.csdn.net/qq_32618327/article/details/105048427?ops_request_misc=%7B%22request_id%22:%22164768363916780265459403%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164768363916780265459403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105048427.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=%E5%90%8E%E8%BD%AE%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(116条消息) 基于车辆模型的横向控制方法_氢键H-H的博客-CSDN博客_车辆横向控制</a> </p>
<p> <a href="https://zhuanlan.zhihu.com/p/46377932">走进自动驾驶横向控制，你需要这篇超长综述 - 知乎 (zhihu.com)</a> </p>
<p> <a href="https://space.bilibili.com/287989852?from=search&seid=4689260907512510355&spm_id_from=333.337.0.0">忠厚老实的老王的个人空间_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://space.bilibili.com/477041559/channel/seriesdetail?sid=863037">小黎的Ally的个人空间_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?from=search&seid=5334828008397768028&spm_id_from=333.337.0.0">机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili</a> </p>
]]></content>
      <categories>
        <category>path_tracking</category>
      </categories>
      <tags>
        <tag>path_tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread_mutex使用</title>
    <url>/blog/2021/12/17/pthread_mutex%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/networkhunter/article/details/100218945?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-100218945.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">pthread详解_networkhunter的博客-CSDN博客_phread</a></p>
<p><a href="https://blog.csdn.net/z_muyangren/article/details/105398871?ops_request_misc=%7B%22request_id%22:%22163970180516780271917732%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970180516780271917732&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-105398871.pc_search_em_sort&utm_term=pthread_mutex_lock&spm=1018.2226.3001.4187">关于pthread_mutex_lock使用_无专精则不能成，无涉猎则不能通-CSDN博客_pthread_mutex_timedlock</a></p>
<p><a href="https://blog.csdn.net/a6333230/article/details/113654694?ops_request_misc=%7B%22request_id%22:%22163970180516780264024377%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163970180516780264024377&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-113654694.pc_search_em_sort&utm_term=pthread_mutex_lock&spm=1018.2226.3001.4187">linux读写锁 pthread_rwlock/互斥锁pthread_mutex_三眼二郎-CSDN博客_pthread_mutex_t pthread_rwlock_t</a></p>
<h1 id="常用pthread-mutex-lock"><a href="#常用pthread-mutex-lock" class="headerlink" title="常用pthread_mutex_lock"></a>常用pthread_mutex_lock</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="comment">// 初始化互斥量</span></span><br><span class="line"><span class="comment">// 第二个参数为 NULL，互斥锁的属性会设置为默认属性</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mtx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 阻塞调用</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line"><span class="comment">// 非堵塞调用</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">pthread_mutex_trylock</span>(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != err) &#123;</span><br><span class="line">    <span class="keyword">if</span>(EBUSY == err) &#123;</span><br><span class="line">        <span class="comment">//The mutex could not be acquired because it was already locked.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 超时调用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">abs_timeout</span>;</span></span><br><span class="line">abs_timeout.tv_sec = <span class="built_in">time</span>(<span class="literal">NULL</span>) + <span class="number">1</span>;</span><br><span class="line">abs_timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">pthread_mutex_timedlock</span>(&amp;mtx, &amp;abs_timeout);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != err) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ETIMEDOUT == err) &#123;</span><br><span class="line">        <span class="comment">//The mutex could not be locked before the specified timeout expired.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放互斥锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line"><span class="comment">// 销毁线程锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mtx)</span><br></pre></td></tr></table></figure>

<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">/*初始化互斥锁*/</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;<span class="comment">//init cond</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//global</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_a;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_b;<span class="comment">//two thread</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t_a,<span class="literal">NULL</span>,thread2,(<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t_b,<span class="literal">NULL</span>,thread1,(<span class="keyword">void</span>*)<span class="literal">NULL</span>);<span class="comment">//Create thread</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t_a:0x%x, t_b:0x%x:&quot;</span>, t_a, t_b);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t_b,<span class="literal">NULL</span>);<span class="comment">//wait a_b thread end</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *junk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">//互斥锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call thread1 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;cond); <span class="comment">//send sianal to t_b</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread1:******i=%d\n&quot;</span>, i);</span><br><span class="line">        	&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread1: %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1: sleep i=%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1: sleep i=%d******end\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span>*junk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call thread2 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex); <span class="comment">//wait</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2: %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2: sleep i=%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2: sleep i=%d******end\n&quot;</span>, i);		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>pf</title>
    <url>/blog/2022/03/01/pf/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://space.bilibili.com/287989852/video?tid=0&page=2&keyword=&order=pubdate">忠厚老实的老王的个人空间_哔哩哔哩_bilibili</a> </p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pf简单步骤</span><br><span class="line"> - 预测:xk(i)=f(xk-1(i))+vk vk~N(0,Q)</span><br><span class="line"> - 更新:wk(i)=fk(yk-h(xk(i)))*wk-1(i)</span><br><span class="line"> - 归一化:wk(i)=wk(i)/(求和)wk(i)</span><br><span class="line"> - 重采样:具体看下边重采样部分</span><br><span class="line">pf步骤</span><br><span class="line"> - 给初值x0~N(u,sigma^2)</span><br><span class="line"> - 生成x0(i),w0(i)=1/n</span><br><span class="line"> - 预测步,生成x1(i)=f(x0(i))+v,v为~N(0,Q)随机数,共n个</span><br><span class="line"> - 更新步,设观测值y1,生成w1(i)=fR(y-h(x1(i)))*w0(i)</span><br><span class="line"> - 将w1(i)归一化,w1(i)=w1(i)/(求和(w1(i)))</span><br><span class="line"> - 此时得到新的例子x1(i),新的权重w1(i)</span><br><span class="line"> - 再由预测步生成x2(i)=f(x1(i))+v</span><br><span class="line"> - 在由更新步生成w2(i)=fR(y-h(x1(i)))*w1(i),归一化</span><br><span class="line"> - 如此递归</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/01/ozr8eB9E1Sq6xJA.png" alt="pf.png"></p>
<h1 id="具体重采样算法"><a href="#具体重采样算法" class="headerlink" title="具体重采样算法"></a>具体重采样算法</h1><p><img src="https://s2.loli.net/2022/03/01/ERDqpHazQAmuvIf.png" alt="1646098227_1_.png"></p>
<p><img src="https://s2.loli.net/2022/03/01/uplN9aS3nXbQTA2.png" alt="1646098247.png"></p>
<h1 id="求期望与方差"><a href="#求期望与方差" class="headerlink" title="求期望与方差"></a>求期望与方差</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ex = (积分)[(求和)wi*(狄拉克)(x-xi)]dx =(求和)(wi*xi)</span><br><span class="line">Dx = E(x^2)+(Ex)^2 = (求和)(wi*xi^2)+(Ex)^2</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%粒子滤波演示代码</span></span><br><span class="line"><span class="comment">%纸上得来终觉浅，绝知此事要躬行</span></span><br><span class="line"><span class="comment">%演示代码，让机器适应人，代码讲究逻辑性可读性</span></span><br><span class="line"><span class="comment">%工程代码，让人适应机器，强调代码运行速度和性能</span></span><br><span class="line"><span class="comment">%x(i)=sin(x(i-1))+5*x(i-1)/(x(i-1)^2+1)+Q</span></span><br><span class="line"><span class="comment">%y(i)=x(i)^2+R</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%注意，滤波之前一定要写成状态方程观测方程形式</span></span><br><span class="line"><span class="comment">%xk=f(xk-1)</span></span><br><span class="line"><span class="comment">%大多数情况下，是不能直接得到xk与xk-1的关系的</span></span><br><span class="line"><span class="comment">%x=f(t)</span></span><br><span class="line"><span class="comment">%要将x=f(t)转化为xk=F(xk-1),具体可以看第八讲，还有更精细的模型，先看完第八讲，再看《数值分析》</span></span><br><span class="line"><span class="comment">%第九章《常微分方程的数值解法》，第八讲实际上就是欧拉法，你们可以用改进欧拉法，或者龙格库塔法得到更精细的</span></span><br><span class="line"><span class="comment">%xk=F(xk-1)</span></span><br><span class="line"><span class="comment">%生成100个信号</span></span><br><span class="line">t=<span class="number">0.01</span>:<span class="number">0.01</span>:<span class="number">1</span>;</span><br><span class="line">x=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">y=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">%t纯粹用来画图，注意和第八讲的区别，第八讲有dt这里没有，因为我直接给出了xk与xk-1的关系，所以不需要dt</span></span><br><span class="line"><span class="comment">%给初值</span></span><br><span class="line">x(<span class="number">1</span>)=<span class="number">0.1</span>;</span><br><span class="line">y(<span class="number">1</span>)=<span class="number">0.01</span>^<span class="number">2</span>;</span><br><span class="line"><span class="comment">%生成真实数据与观测数据</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="number">100</span></span><br><span class="line">    x(<span class="built_in">i</span>)=<span class="built_in">sin</span>(x(<span class="built_in">i</span><span class="number">-1</span>))+<span class="number">5</span>*x(<span class="built_in">i</span><span class="number">-1</span>)/(x(<span class="built_in">i</span><span class="number">-1</span>)^<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    y(<span class="built_in">i</span>)=x(<span class="built_in">i</span>)^<span class="number">2</span>+normrnd(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%PF start</span></span><br><span class="line"><span class="comment">%设粒子集合</span></span><br><span class="line">n=<span class="number">100</span>;</span><br><span class="line">xold=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">xnew=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">xplus=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">100</span>);<span class="comment">%xplus用于存放滤波值，就是每一次后验概率的期望</span></span><br><span class="line">w=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="comment">%设置x0(i),可以直接在正态分布采样，如果对初值有自信，也可以让所有粒子都相同</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    xold(<span class="built_in">i</span>)=<span class="number">0.1</span>;</span><br><span class="line">    w(<span class="built_in">i</span>)=<span class="number">1</span>/n;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%PF核心代码</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="number">100</span></span><br><span class="line">    <span class="comment">%预测步 由x0推出x1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">        xold(<span class="built_in">j</span>)=<span class="built_in">sin</span>(xold(<span class="built_in">j</span>))+<span class="number">5</span>*xold(<span class="built_in">j</span>)/(xold(<span class="built_in">j</span>)^<span class="number">2</span>+<span class="number">1</span>)+normrnd(<span class="number">0</span>,<span class="number">0.1</span>);<span class="comment">%Q</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%预测步完毕</span></span><br><span class="line">    <span class="comment">%更新步</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="comment">% 因为这里是设置的常数</span></span><br><span class="line">        <span class="comment">%w(j)=w(j)*fR(.....)</span></span><br><span class="line">        <span class="comment">%fR=(2*pi*R)^(-0.5)*exp(-((y(i)-xold(j)^2)^2/(2*R)))</span></span><br><span class="line">        w(<span class="built_in">j</span>)=<span class="built_in">exp</span>(-((y(<span class="built_in">i</span>)-xold(<span class="built_in">j</span>)^<span class="number">2</span>)^<span class="number">2</span>/(<span class="number">2</span>*<span class="number">0.1</span>)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%归一化</span></span><br><span class="line">    w=w/sum(w);</span><br><span class="line">    <span class="comment">%w/sum(w)与k*w/sum(k*w)结果一模一样</span></span><br><span class="line">    <span class="comment">%(2*pi*R)^(-0.5)是常数</span></span><br><span class="line">    <span class="comment">%w(j)，如果每次都重采样，每次w(j)都会被设为1/n，也是常数</span></span><br><span class="line">    <span class="comment">%所以可以将他们去掉</span></span><br><span class="line">    <span class="comment">%重采样</span></span><br><span class="line">    <span class="comment">%N&lt;1/sum(wi^2),若不是每次都重采样，那么代码第54行就要做相应修改，把w(j)加上去</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%生成c,范围为(0~1)</span></span><br><span class="line">    c=<span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">    c(<span class="number">1</span>)=w(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>:n</span><br><span class="line">        c(<span class="built_in">j</span>)=c(<span class="built_in">j</span><span class="number">-1</span>)+w(<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%转盘子，生成随机数，看落在哪个区间</span></span><br><span class="line">    <span class="comment">%首先我们要重采样n个粒子，粒子数要与之前相同</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">        a=unifrnd(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">%均匀分布随机数</span></span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span>:n</span><br><span class="line">            <span class="keyword">if</span> (a&lt;c(k))</span><br><span class="line">                xnew(<span class="built_in">j</span>)=xold(k);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">%%%%一定要break，否则重采样粒子会被最后一个粒子覆盖，具体见新的第十讲</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%重采样完毕</span></span><br><span class="line">    <span class="comment">%把新的粒子赋值给xold，为下一步递推做准备</span></span><br><span class="line">    xold=xnew;</span><br><span class="line">    <span class="comment">%所有粒子权重都设为1/n</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">        w(<span class="built_in">j</span>)=<span class="number">1</span>/n;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%把每一步的后验概率期望赋值给xplus</span></span><br><span class="line">    xplus(<span class="built_in">i</span>)=sum(xnew)/n;    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(t,x,<span class="string">&#x27;r&#x27;</span>,t,xplus,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">%y=x^2+R 似然概率是一个多峰分布，y=4，x=2或-2</span></span><br><span class="line"><span class="comment">%非线性问题一步一个坑，处处是雷</span></span><br><span class="line"><span class="comment">%如果问题本身的性质就是强烈的非线性，比如多峰分布这种，粒子滤波并不能化腐朽为神奇</span></span><br><span class="line"><span class="comment">%尽量不要有多峰分布</span></span><br><span class="line"><span class="comment">%粒子滤波的计算速度是大硬伤</span></span><br><span class="line"><span class="comment">%可以尝试没有重采样的粒子滤波代码会是什么样的，自己尝试写写，自己调调参数 </span></span><br><span class="line"><span class="comment">%主要需要调Q,R,重采样,粒子数目</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>pca降维</title>
    <url>/blog/2022/04/21/pca%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>[PCA算法的原理以及c++实现_chengwei0019的博客-CSDN博客_c++ pca算法](<a href="https://blog.csdn.net/u012700322/article/details/104822390?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pca">https://blog.csdn.net/u012700322/article/details/104822390?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pca</a> c++&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-104822390.142^v9^control,157^v4^control&amp;spm=1018.2226.3001.4187)</p>
<p><a href="https://github.com/ihar/EigenPCA">ihar/EigenPCA: A class for performing principal component analysis using Eigen library (github.com)</a></p>
<p><a href="https://blog.csdn.net/kobeyu652453/article/details/107058229">(PCA降维原理及其代码实现</a></p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCA主成分分析，是模式识别中常见的特征降维的算法，其大体步骤可以分为以下几个部分：</span><br><span class="line">（1）原始特征矩阵归一化处理（假设M和样本，每个样本n个特征，则对M*N的X数据，进行零均值化，即减去这一列的均值）</span><br><span class="line">（2）求取归一化处理后特征矩阵的协方差矩阵</span><br><span class="line">（3）计算协方差矩阵的特征值及其对应的特征向量</span><br><span class="line">（4）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P；</span><br><span class="line">（5）Y=PX即为降维到k维后的数据;</span><br></pre></td></tr></table></figure>

<p>test_data.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 2</span><br><span class="line">2.5 2.4</span><br><span class="line">0.5 0.7</span><br><span class="line">2.2 2.9</span><br><span class="line">1.9 2.2</span><br><span class="line">3.1 3.0</span><br><span class="line">2.3 2.7</span><br><span class="line">2.0 1.6</span><br><span class="line">1.0 1.1</span><br><span class="line">1.5 1.6</span><br><span class="line">1.1 0.9</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">featurenormalize</span><span class="params">(MatrixXd &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算每一维度均值</span></span><br><span class="line">	MatrixXd meanval = X.<span class="built_in">colwise</span>().<span class="built_in">mean</span>();</span><br><span class="line">	RowVectorXd meanvecRow = meanval;</span><br><span class="line">	<span class="comment">//样本均值化为0</span></span><br><span class="line">	X.<span class="built_in">rowwise</span>() -= meanvecRow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeCov</span><span class="params">(MatrixXd &amp;X, MatrixXd &amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算协方差矩阵C = XTX / n-1;</span></span><br><span class="line">	C = X.<span class="built_in">adjoint</span>() * X;</span><br><span class="line">	C = C.<span class="built_in">array</span>() / (X.<span class="built_in">rows</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeEig</span><span class="params">(MatrixXd &amp;C, MatrixXd &amp;vec, MatrixXd &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算特征值和特征向量，使用selfadjont按照对阵矩阵的算法去计算，可以让产生的vec和val按照有序排列</span></span><br><span class="line">	<span class="function">SelfAdjointEigenSolver&lt;MatrixXd&gt; <span class="title">eig</span><span class="params">(C)</span></span>;</span><br><span class="line"> </span><br><span class="line">	vec = eig.<span class="built_in">eigenvectors</span>();</span><br><span class="line">	val = eig.<span class="built_in">eigenvalues</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeDim</span><span class="params">(MatrixXd &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dim;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = val.<span class="built_in">rows</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += <span class="built_in">val</span>(i, <span class="number">0</span>);</span><br><span class="line">		dim = i;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (sum / val.<span class="built_in">sum</span>() &gt;= <span class="number">0.95</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val.<span class="built_in">rows</span>() - dim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;test_data&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//读取数据</span></span><br><span class="line">	<span class="keyword">double</span> a, b; fin &gt;&gt; a; fin &gt;&gt; b;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;pass &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> m = a, n = b;</span><br><span class="line">	<span class="function">MatrixXd <span class="title">X</span><span class="params">(m, n)</span>, <span class="title">C</span><span class="params">(n, n)</span></span>;</span><br><span class="line">	MatrixXd vec, val;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> in[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">			fin &gt;&gt; in[j];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			<span class="built_in">X</span>(i, j - <span class="number">1</span>) = in[j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//pca</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//零均值化</span></span><br><span class="line">	<span class="built_in">featurenormalize</span>(X);</span><br><span class="line">	<span class="comment">//计算协方差</span></span><br><span class="line">	<span class="built_in">computeCov</span>(X, C);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;cov: \n&quot;</span> &lt;&lt; C &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//计算特征值和特征向量</span></span><br><span class="line">	<span class="built_in">computeEig</span>(C, vec, val);</span><br><span class="line">	<span class="comment">//计算损失率，确定降低维数</span></span><br><span class="line">	<span class="keyword">int</span> dim = <span class="built_in">computeDim</span>(val);</span><br><span class="line">	std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; vec &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//计算结果</span></span><br><span class="line">	MatrixXd res = X * vec.<span class="built_in">rightCols</span>(n);</span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;the result is &quot;</span> &lt;&lt; res.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; res.<span class="built_in">cols</span>() &lt;&lt; <span class="string">&quot; after pca algorithm.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	fout &lt;&lt; res;</span><br><span class="line">	fout.<span class="built_in">close</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread简单使用</title>
    <url>/blog/2021/12/17/pthread%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/chenwh_cn/article/details/117225053?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-117225053.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">pthread 线程基本函数_chenwh_cn的博客-CSDN博客_pthread函数</a></p>
<p><a href="https://blog.csdn.net/u013457167/article/details/83691039?ops_request_misc=%7B%22request_id%22:%22163970172716780265411237%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163970172716780265411237&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83691039.pc_search_em_sort&utm_term=pthread&spm=1018.2226.3001.4187">Pthread线程基础学习_我的梦-CSDN博客_pthread教程</a></p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = *((<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int the new thread: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_fun, (<span class="keyword">void</span> *)&amp;test);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ret = <span class="number">5</span>; <span class="comment">// thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr]</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="keyword">void</span>*)&amp;ret);</span><br><span class="line">    <span class="comment">//return (void*)&amp;ret;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待线程结束并回收线程资源，此函数会阻塞，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, *((<span class="keyword">int</span>*)ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread is runing\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>)) <span class="comment">// 立即返回，调用失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;join not working\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after join\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;master is leaving\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thead_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ret = <span class="number">5</span>; <span class="comment">// thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr]</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="keyword">void</span>*)&amp;ret);</span><br><span class="line">    <span class="comment">//return (void*)&amp;ret;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thead_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, *((<span class="keyword">int</span>*)ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread start \n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">        <span class="comment">// 调用pthread_testcancel，让内核去检测是否需要取消当前线程。</span></span><br><span class="line">		<span class="built_in">pthread_testcancel</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> iret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pthread_cancel</span>(tid);<span class="comment">//取消线程</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(tid, &amp;ret);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code %d\n&quot;</span>, (<span class="keyword">int</span>)ret);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>ros2安装</title>
    <url>/blog/2021/12/10/ros2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_44717317/article/details/104547474">Ubuntu18.04 安装ROS Melodic &amp;&amp; Ros2 Dashing踩坑笔记_LukeyAlvin的博客-CSDN博客_ubuntu18安装ros2</a></p>
<p><a href="http://fishros.com/#/fish_home">鱼香ROS (fishros.com)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于ros2很多并不完善,所以采用ros1+ros2的方式实现,这里采用常规+fishros的方式实现安装.最后采用在初始化使用shell脚本选择使用ros版本</p>
<h1 id="Ros1安装"><a href="#Ros1安装" class="headerlink" title="Ros1安装"></a>Ros1安装</h1><p><a href="https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/">ros安装 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<h1 id="Ros2安装"><a href="#Ros2安装" class="headerlink" title="Ros2安装"></a>Ros2安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置UTF-8编码</span></span><br><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新软件源</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-release</span><br><span class="line">curl http://repo.ros2.org/repos.key | sudo apt-key add -</span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过如下命令添加到.bashrc(注意这里如果需要使用两个版本,这一步不需要设置)</span></span><br><span class="line">echo &quot;source /opt/ros/dashing/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> RWM功能</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-dashing-rmw-opensplice-cpp # for OpenSplice</span><br><span class="line">sudo apt install ros-dashing-rmw-connext-cpp # for RTI Connext (requires license agreement)</span><br><span class="line"><span class="meta">#</span><span class="bash"> ros1与ros2通信</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-dashing-ros1-bridge</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装编译工具</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y \</span><br><span class="line">build-essential \</span><br><span class="line">cmake \</span><br><span class="line">git \</span><br><span class="line">python3-colcon-common-extensions \</span><br><span class="line">python3-pip \</span><br><span class="line">python-rosdep \</span><br><span class="line">python3-vcstool \</span><br><span class="line">wget</span><br><span class="line"><span class="meta">#</span><span class="bash"> install some pip packages needed <span class="keyword">for</span> testing</span></span><br><span class="line">sudo -H python3 -m pip install -U \</span><br><span class="line">argcomplete \</span><br><span class="line">flake8 \</span><br><span class="line">flake8-blind-except \</span><br><span class="line">flake8-builtins \</span><br><span class="line">flake8-class-newline \</span><br><span class="line">flake8-comprehensions \</span><br><span class="line">flake8-deprecated \</span><br><span class="line">flake8-docstrings \</span><br><span class="line">flake8-import-order \</span><br><span class="line">flake8-quotes \</span><br><span class="line">pytest-repeat \</span><br><span class="line">pytest-rerunfailures</span><br><span class="line"><span class="meta">#</span><span class="bash"> [Ubuntu 16.04] install extra packages not available or recent enough on Xenial</span></span><br><span class="line">python3 -m pip install -U \</span><br><span class="line">pytest \</span><br><span class="line">pytest-cov \</span><br><span class="line">pytest-runner \</span><br><span class="line">setuptools</span><br><span class="line"><span class="meta">#</span><span class="bash"> install Fast-RTPS dependencies</span></span><br><span class="line">sudo apt install --no-install-recommends -y \</span><br><span class="line">libasio-dev \</span><br><span class="line">libtinyxml2-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">mkdir  ~/ros2_ws</span><br><span class="line">cd /ros2_ws</span><br><span class="line">git clone  https://ghproxy.com/https://github.com/zhangrelay/ros2_tutorials</span><br><span class="line">cd ros2_tutorials</span><br><span class="line">colcon build</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量(也可以将之放入.bashrc中)</span></span><br><span class="line">source /install/setup.sh </span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个终端</span></span><br><span class="line">cd /ros_ws/ros2_tutorials/install</span><br><span class="line">ros2 run demo_nodes_cpp listener</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个终端</span></span><br><span class="line">ros2 run demo_nodes_cpp talker</span><br></pre></td></tr></table></figure>

<h1 id="使用多个ros版本"><a href="#使用多个ros版本" class="headerlink" title="使用多个ros版本"></a>使用多个ros版本</h1><h2 id="保存一个脚本文件-使用前运行"><a href="#保存一个脚本文件-使用前运行" class="headerlink" title="保存一个脚本文件,使用前运行"></a>保存一个脚本文件,使用前运行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span> /opt/ros/melodic/setup.bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span> /opt/ros/dashing/setup.bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ROS 1.0 melodic or ROS 2.0 Dashing</span></span><br><span class="line">echo Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing </span><br><span class="line">read ROS</span><br><span class="line">if (($ROS==1));then</span><br><span class="line">source /opt/ros/melodic/setup.bash</span><br><span class="line">echo &quot;Melodic&quot;</span><br><span class="line">elif (($ROS==2));then</span><br><span class="line">source /opt/ros/dashing/setup.bash</span><br><span class="line">echo &quot;Dashing&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;Non-ROS&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="注意-由于使用不通ros-因此安装时注意将之前保存在-bashrc中的"><a href="#注意-由于使用不通ros-因此安装时注意将之前保存在-bashrc中的" class="headerlink" title="!注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的"></a>!注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的</h2><h2 id="source-opt-ros-melodic-setup-bash"><a href="#source-opt-ros-melodic-setup-bash" class="headerlink" title="# source /opt/ros/melodic/setup.bash"></a><code># source /opt/ros/melodic/setup.bash</code></h2><p><code># source /opt/ros/dashing/setup.bash</code>注释掉</p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>pure_pursuit</title>
    <url>/blog/2022/03/17/pure_pursuit/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://www.bilibili.com/video/BV1Ly4y177dF?spm_id_from=333.999.0.0">路径规划与轨迹跟踪系列算法学习_第10讲_纯跟踪法_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://blog.csdn.net/u013468614/article/details/103502743?ops_request_misc=%7B%22request_id%22:%22164775329916782092941044%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164775329916782092941044&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-103502743.142%5Ev2%5Earticle_score_rank,143%5Ev4%5Econtrol&utm_term=purepursuit&spm=1018.2226.3001.4187">(116条消息) 无人车系统（五）：轨迹跟踪Pure Pursuit方法_windSeS的博客-CSDN博客</a> </p>
<p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程:"></a>算法流程:</h1><p><img src="https://s2.loli.net/2022/03/20/V27CkMqFuAxBe3s.png" alt="1647753144_1_.png"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_target_index</span>(<span class="params">self, state</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To speed up nearest point search, doing it at only first time.</span></span><br><span class="line">    <span class="keyword">if</span> self.old_nearest_point_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># search nearest point index</span></span><br><span class="line">        dx = [state.rear_x - icx <span class="keyword">for</span> icx <span class="keyword">in</span> self.cx]</span><br><span class="line">        dy = [state.rear_y - icy <span class="keyword">for</span> icy <span class="keyword">in</span> self.cy]</span><br><span class="line">        d = np.hypot(dx, dy)</span><br><span class="line">        ind = np.argmin(d)</span><br><span class="line">        self.old_nearest_point_index = ind</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ind = self.old_nearest_point_index</span><br><span class="line">        distance_this_index = state.calc_distance(self.cx[ind],</span><br><span class="line">                                                    self.cy[ind])</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            distance_next_index = state.calc_distance(self.cx[ind + <span class="number">1</span>],</span><br><span class="line">                                                        self.cy[ind + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> distance_this_index &lt; distance_next_index:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ind = ind + <span class="number">1</span> <span class="keyword">if</span> (ind + <span class="number">1</span>) &lt; <span class="built_in">len</span>(self.cx) <span class="keyword">else</span> ind</span><br><span class="line">            distance_this_index = distance_next_index</span><br><span class="line">        self.old_nearest_point_index = ind</span><br><span class="line"></span><br><span class="line">    Lf = k * state.v + Lfc  <span class="comment"># update look ahead distance #更新前瞻距离,与速度有关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># search look ahead target point index # 搜索前瞻目标点索引</span></span><br><span class="line">    <span class="keyword">while</span> Lf &gt; state.calc_distance(self.cx[ind], self.cy[ind]):</span><br><span class="line">        <span class="keyword">if</span> (ind + <span class="number">1</span>) &gt;= <span class="built_in">len</span>(self.cx):</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># not exceed goal</span></span><br><span class="line">        ind += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ind, Lf</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pure_pursuit_steer_control</span>(<span class="params">state, trajectory, pind</span>):</span></span><br><span class="line">    ind, Lf = trajectory.search_target_index(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pind &gt;= ind:</span><br><span class="line">        ind = pind</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ind &lt; <span class="built_in">len</span>(trajectory.cx):</span><br><span class="line">        tx = trajectory.cx[ind]</span><br><span class="line">        ty = trajectory.cy[ind]</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># toward goal</span></span><br><span class="line">        tx = trajectory.cx[-<span class="number">1</span>]</span><br><span class="line">        ty = trajectory.cy[-<span class="number">1</span>]</span><br><span class="line">        ind = <span class="built_in">len</span>(trajectory.cx) - <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw</span><br><span class="line"></span><br><span class="line">    delta = math.atan2(<span class="number">2.0</span> * WB * math.sin(alpha) / Lf, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delta, ind</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_tracking</category>
      </categories>
      <tags>
        <tag>path_tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>ros_cmake配置模板</title>
    <url>/blog/2021/10/19/ros_cmake/</url>
    <content><![CDATA[<h3 id="简易CmakeLists-txt"><a href="#简易CmakeLists-txt" class="headerlink" title="简易CmakeLists.txt"></a>简易CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(hmi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持编译</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  pcl_ros</span><br><span class="line">  perception_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># catkin库</span></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line">  CATKIN_DEPENDS roscpp sensor_msgs pcl_ros</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件库</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"> <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件夹</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node src/hmi_node.cpp src/hmi_core.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖包</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node perception_msgs_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="详细CmakeLists-txt"><a href="#详细CmakeLists-txt" class="headerlink" title="详细CmakeLists.txt"></a>详细CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>()  <span class="comment">#CMake的版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>()         <span class="comment">#项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>()        <span class="comment">#找到编译需要的其他CMake/Catkin  package </span></span><br><span class="line"></span><br><span class="line">catkin_python_setup()   <span class="comment">#catkin新加宏，打开catkin的Python Module的支持</span></span><br><span class="line"></span><br><span class="line">add_message_files()     <span class="comment">#catkin新加宏，添加自定义Message文件 </span></span><br><span class="line"></span><br><span class="line">add_service_files()         <span class="comment">#catkin新加宏，添加自定义Service文件 </span></span><br><span class="line"></span><br><span class="line">add_action_files()          <span class="comment">#catkin新加宏，添加自定义Action文件 </span></span><br><span class="line"></span><br><span class="line">generate_message()      <span class="comment">#catkin新加宏，生成不同语言版本的msg/srv/action接口 </span></span><br><span class="line"></span><br><span class="line">catkin_package()      <span class="comment">#catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>()       <span class="comment">#生成库 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>()      <span class="comment">#生成可执行二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_dependencies</span>()      <span class="comment">#定义目标文件依赖于其他目标文件，确保其他目标已被构建 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>()   <span class="comment">#链接</span></span><br><span class="line"></span><br><span class="line">catkin_add_gtest()      <span class="comment">#catkin新加宏，生成测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>()         <span class="comment">#安装至本机</span></span><br></pre></td></tr></table></figure>

<h3 id="对照实例"><a href="#对照实例" class="headerlink" title="对照实例"></a>对照实例</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)    <span class="comment"># catkin至少需要3.0.2版本以上的Cmake</span></span><br><span class="line"><span class="comment">#通过project()这个函数指定包的名字，在CMake中指定后，你可在其他地方通过使用变量$&#123;PROJECT_NAME&#125;来引用它</span></span><br><span class="line"><span class="keyword">project</span>(ultrasonic_data) </span><br><span class="line"></span><br><span class="line"><span class="comment">## Compile as C++11, supported in ROS Kinetic and newer</span></span><br><span class="line"><span class="comment"># add_compile_options(-std=c++11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package(）  </span></span><br><span class="line"><span class="comment">##find_package(catkin REQUIRED COMPONENTS xyz) 被用于找其他依赖的功能包</span></span><br><span class="line"><span class="comment">##这里指明构建这个package需要依赖的package，我们使用catkin_make的编译方式，至少需要catkin这个包。</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  message_generation</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">  visualization_msgs</span><br><span class="line">  can_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 系统依赖关系是通过CMake的约定找到的</span></span><br><span class="line"><span class="comment"># find_package(Boost REQUIRED COMPONENTS system)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##启动Python模块支持：catkin_python_package()</span></span><br><span class="line"><span class="comment">##如果功能包中提供了一些Python模块.这个宏定义可以确保包中声明的模块和全局脚本被安装</span></span><br><span class="line"><span class="comment">## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html</span></span><br><span class="line"><span class="comment"># catkin_python_setup()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment">## 声明ROS消息、服务和动作 ##</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()</span></span><br><span class="line"><span class="comment">##当我们需要使用.msg.srv.action形式的文件时，我们需要特殊的预处理器把他们转化为系统可以识别特定编程语言（.h.cpp）。</span></span><br><span class="line"><span class="comment">##注意：这些宏必须在catkin_package() 宏前面</span></span><br><span class="line"><span class="comment">##请执行以下步骤：</span></span><br><span class="line"><span class="comment">## * 在package.xml中:</span></span><br><span class="line"><span class="comment">## *1.添加&quot;message_generation&quot;在build_depend标记中</span></span><br><span class="line"><span class="comment">## *2.添加&quot;message_runtime&quot;在exec_depend标记中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## * 在CMakeLists.txt中:</span></span><br><span class="line"><span class="comment">## *1、在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;message_generation&quot; </span></span><br><span class="line"><span class="comment">## *2、在catkin_package(CATKIN_DEPENDS ...)添加&quot;message_runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##   根据需要取消下面“add_######_files”部分的注释</span></span><br><span class="line"><span class="comment">##   * 取消下面的generate_messages(DEPENDENCIES...注释</span></span><br><span class="line"><span class="comment">##   * add every package  to generate_messages(DEPENDENCIES ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##  在&#x27;msg&#x27; 文件夹生成消息</span></span><br><span class="line"> add_message_files(</span><br><span class="line">   FILES</span><br><span class="line">   Ultrasonic.msg</span><br><span class="line"><span class="comment">#   Message2.msg</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="comment">##在 &#x27;srv&#x27; 文件夹生成服务</span></span><br><span class="line"><span class="comment"># add_service_files(</span></span><br><span class="line"><span class="comment">#   FILES</span></span><br><span class="line"><span class="comment">#   Service1.srv</span></span><br><span class="line"><span class="comment">#   Service2.srv</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 &#x27;action&#x27; 文件夹生成动作</span></span><br><span class="line"><span class="comment"># add_action_files(</span></span><br><span class="line"><span class="comment">#   FILES</span></span><br><span class="line"><span class="comment">#   Action1.action</span></span><br><span class="line"><span class="comment">#   Action2.action</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在此处列出的任何添加的消息和服务生成的依赖项</span></span><br><span class="line"><span class="comment">##调用消息/服务/操作生成：generate_messages()</span></span><br><span class="line"> generate_messages(</span><br><span class="line">   DEPENDENCIES</span><br><span class="line"><span class="comment">#   sensor_msgs</span></span><br><span class="line">     std_msgs</span><br><span class="line"><span class="comment">#   visualization_msgs</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"><span class="comment">##声明ROS动态配置参数 ##</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 声明和生成动态重新配置参数包:遵循以下步骤</span></span><br><span class="line"><span class="comment">## * 在package.xml中:</span></span><br><span class="line"><span class="comment">## *添加&quot;dynamic_reconfigure&quot;在build_depend和exec_depend标记中</span></span><br><span class="line"><span class="comment">## * 在CMakeLists.txt中:</span></span><br><span class="line"><span class="comment">## *在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;dynamic_reconfigure&quot; </span></span><br><span class="line"><span class="comment">## * 取消下面 &quot;generate_dynamic_reconfigure_options&quot; 的注释</span></span><br><span class="line"><span class="comment">## 列出要处理的每个.cfg文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Generate dynamic reconfigure parameters in the &#x27;cfg&#x27; folder</span></span><br><span class="line"><span class="comment"># generate_dynamic_reconfigure_options(</span></span><br><span class="line"><span class="comment">#   cfg/DynReconf1.cfg</span></span><br><span class="line"><span class="comment">#   cfg/DynReconf2.cfg</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###################################</span></span><br><span class="line"><span class="comment">## catkin 特定的配置 ##</span></span><br><span class="line"><span class="comment">###################################</span></span><br><span class="line"><span class="comment">##  catkin_package为包生成cmake配置文件  这是一个catkin提供的cmake宏，当我们要给构建系统指定catkin的特定的信息时就需要了</span></span><br><span class="line"><span class="comment">##  或者反过来利用他产生pkg-config和CMake文件。</span></span><br><span class="line"><span class="comment">##指定包编译信息导出：catkin_package()</span></span><br><span class="line"><span class="comment">## 该函数必须在使用 add_library()或add_executable()声明任何targets之前调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## INCLUDE_DIRS: 如果包包含头文件，请取消对INCLUDE_DIRS的注释</span></span><br><span class="line"><span class="comment">## LIBRARIES: 此项目中创建的依赖项目需要的库LIBRARIES</span></span><br><span class="line"><span class="comment">## CATKIN_DEPENDS: catkin_packages依赖的项目</span></span><br><span class="line"><span class="comment">## DEPENDS:  依赖项目需要的系统依赖项</span></span><br><span class="line">catkin_package(</span><br><span class="line">    INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line"><span class="comment">#  LIBRARIES ultrasonic_data</span></span><br><span class="line">    CATKIN_DEPENDS </span><br><span class="line">    message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment">## Build ##</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## include_directories用来设置头文件的相对路径</span></span><br><span class="line"><span class="comment">##include_directories的参数是通过find_package产生的*_INCLUDE_DIRS变量和其他所有额外的头文件路径</span></span><br><span class="line"><span class="comment">##这里&quot;include&quot;表示你的pacakge里面的include这个路径也包含在里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">##添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()##</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">## add_library()用来指定编译产生的库。默认的catkin编译产生共享库：</span></span><br><span class="line"><span class="comment"># add_library($&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   src/$&#123;PROJECT_NAME&#125;/ultrasonic_data.cpp</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## add_dependencies用于设置依赖</span></span><br><span class="line"><span class="comment">##如果你有一个包编译.msg .srv，并且可执行文件要使用他们，那么你就需要创建一个显式的依赖项，</span></span><br><span class="line"><span class="comment">## 我们定义的语言无关的消息类型，消息类型会在编译过程中产生相应的语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要</span></span><br><span class="line"><span class="comment">## 使用add_dependencies($&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br><span class="line"><span class="comment">## add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## add_executable用于设置需要编译的代码和生成的可执行文件</span></span><br><span class="line"><span class="comment">##第一个参数为期望生成的可执行文件名称；后面的参数为参与编译的源文件（cpp),如果需要多个代码文件，用空格区分开</span></span><br><span class="line"><span class="comment">## 推荐的前缀可以确保跨包的目标名称不会冲突</span></span><br><span class="line"><span class="comment"># add_executable($&#123;PROJECT_NAME&#125;_node src/ultrasonic_data_node.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重命名C++无前缀可执行文件</span></span><br><span class="line"><span class="comment">## 利用set_target_properties()函数将这个target进行重命名，在catkin中target的名字必须是唯一的</span></span><br><span class="line"><span class="comment"># set_target_properties($&#123;PROJECT_NAME&#125;_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加可执行文件的cmake目标依赖项</span></span><br><span class="line"><span class="comment">## same as for the library above与上面的库相同</span></span><br><span class="line"><span class="comment"># add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##target_link_libraries用于设置链接库</span></span><br><span class="line"><span class="comment"># target_link_libraries($&#123;PROJECT_NAME&#125;_node</span></span><br><span class="line"><span class="comment">#   $&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(ultrasonic_activate_node</span><br><span class="line">  src/ultrasonic_activate_node.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(ultrasonic_activate_node <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ultrasonic_activate_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(ultrasonic_node</span><br><span class="line">  src/ultrasonic_node.cpp</span><br><span class="line">  src/ultrasonic_filter.cpp</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(ultrasonic_node <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ultrasonic_node</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment">###安装至本机 ##</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有安装目标都应该使用catkin目标变量</span></span><br><span class="line"><span class="comment"># See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##安装Python可执行脚本</span></span><br><span class="line"><span class="comment"># catkin_install_python(PROGRAMS</span></span><br><span class="line"><span class="comment">#   scripts/my_python_script</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装的可执行文件</span></span><br><span class="line"><span class="comment">## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html</span></span><br><span class="line"><span class="comment"># install(TARGETS $&#123;PROJECT_NAME&#125;_node</span></span><br><span class="line"><span class="comment">#   RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 要安装的库</span></span><br><span class="line"><span class="comment">##编译完成后，目标被放入catkin工作空间下的devel目录。一般希望将目标安装到系统上，以使其他用户使用，</span></span><br><span class="line"><span class="comment">##或者安装到本地目录来测试系统级别的安装。也就是说，如果希望能够对代码进行make install，就需要明确目标结束的位置。</span></span><br><span class="line"><span class="comment">##上述过程可以使用CMake的 install()函数实现。</span></span><br><span class="line"><span class="comment">##该函数的参数有</span></span><br><span class="line"><span class="comment">##TARGETS：要安装的目标</span></span><br><span class="line"><span class="comment">##ARCHIVE DESTINATION：静态库和动态链接库DLL(Windows).lib存根</span></span><br><span class="line"><span class="comment">##LIBRARY DESTINATION：非DLL共享库和模块</span></span><br><span class="line"><span class="comment">##RUNTIME DESTINATION：可执行目标和DLL(Windows)模式共享库</span></span><br><span class="line"><span class="comment">## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html</span></span><br><span class="line"><span class="comment"># install(TARGETS $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   RUNTIME DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装头文件</span></span><br><span class="line"><span class="comment">##头文件必须安装到include目录下，这通常通过安装整个文件夹的文件来完成（可以根据文件名模式进行过滤，并排除SVN子文件夹）</span></span><br><span class="line"><span class="comment">##可以通过以下安装规则实现：</span></span><br><span class="line"><span class="comment"># install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment">#   FILES_MATCHING PATTERN &quot;*.h&quot;</span></span><br><span class="line"><span class="comment">#   PATTERN &quot;.svn&quot; EXCLUDE</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装roslaunch文件或其他源</span></span><br><span class="line"><span class="comment">##其他像launchfiles的资源可以安装到 $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># install(FILES</span></span><br><span class="line"><span class="comment">#   # myfile1</span></span><br><span class="line"><span class="comment">#   # myfile2</span></span><br><span class="line"><span class="comment">#   DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"><span class="comment">## 测试编译：catkin_add_gtest()##</span></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 基于gtest测试目标和链接库</span></span><br><span class="line"><span class="comment"># catkin_add_gtest($&#123;PROJECT_NAME&#125;-test test/test_ultrasonic_data.cpp)</span></span><br><span class="line"><span class="comment"># if(TARGET $&#123;PROJECT_NAME&#125;-test)</span></span><br><span class="line"><span class="comment">#   target_link_libraries($&#123;PROJECT_NAME&#125;-test $&#123;PROJECT_NAME&#125;)</span></span><br><span class="line"><span class="comment"># endif()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加要由python osetests运行的文件夹</span></span><br><span class="line"><span class="comment"># catkin_add_nosetests(test)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具体可参考网址"><a href="#具体可参考网址" class="headerlink" title="具体可参考网址"></a>具体可参考网址</h3><p><a href="https://blog.csdn.net/yangtao420902/article/details/110873333?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-110873333.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS中的CMake List详解_yangtao420902的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/CipherPolzz/article/details/118963390?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-118963390.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS下CmakeLists.txt模板_CipherPolzz的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_43877080/article/details/110953533?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-110953533.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">ROS新建程序包CmakeLists和package详解_JayLee719的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_32761549/article/details/104535989?ops_request_misc=%7B%22request_id%22:%22163430132516780264065592%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163430132516780264065592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-104535989.pc_search_ecpm_flag&utm_term=ros%E7%9A%84CMakeLists%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187">(46条消息) ROS中CMakeLists.txt文件 使用 讲解与总结_月照银海似蛟龙的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros_mobile</title>
    <url>/blog/2022/03/07/ros_mobile/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_51684916/article/details/120729348?ops_request_misc=%7B%22request_id%22:%22164663494616780264050389%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164663494616780264050389&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-1-120729348.nonecase&utm_term=ros_mobile&spm=1018.2226.3001.4450">(112条消息) 一款超好用的ROS APP推荐——ROS-Mobile（亲测好用！！！）_尾巴l的博客-CSDN博客_rosapp</a> </p>
<p> <a href="https://github.com/ROS-Mobile/ROS-Mobile-Android">ROS-Mobile/ROS-Mobile-Android: Visualization and controlling application for Android (github.com)</a> </p>
<h2 id="github上有教程"><a href="#github上有教程" class="headerlink" title="github上有教程"></a>github上有教程</h2><img src="https://github.com/ROS-Mobile/ROS-Mobile-Android/blob/master/images/ShortExample01.jpg?raw=true" alt="ShortExample01.jpg" style="zoom: 33%;" /> 

<p>注意填写master!其他使用都比较简单,随意</p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>param</title>
    <url>/blog/2022/04/26/ros_param/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/sinat_16643223/article/details/112441563?ops_request_misc=%7B%22request_id%22:%22165093661116781435481632%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165093661116781435481632&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-112441563.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=ros+param&spm=1018.2226.3001.4187">(128条消息) ROS-节点参数param_TYINY的博客-CSDN博客_node.param</a></p>
<p><a href="https://blog.csdn.net/qq_39779233/article/details/108411778?ops_request_misc=%7B%22request_id%22:%22165094280716781685346224%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165094280716781685346224&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108411778.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=ros+param&spm=1018.2226.3001.4187">(128条消息) 【ROS学习】ROS param 的使用_wongHome的博客-CSDN博客_ros::param::get</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;ros/ros.h&quot;</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//initial and name node </span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_param&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error command paramter! Please run command eg:\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot;rosrun book_param book_param 1\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot;help information:\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot; 1 ------ set param mode(ros::param::set())\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot; 2 ------ set param mode(ros::NodeHandle::setParam())\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot; 3 ------ get param mode(ros::param::get())\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot; 4 ------ get param mode(ros::NodeHandle::getParam())\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;<span class="string">&quot; 5 ------ get param mode(ros::NodeHandle::param())\n&quot;</span>\ </span><br><span class="line">            &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//create node handle </span></span><br><span class="line">    ros::NodeHandle nh; </span><br><span class="line">    <span class="comment">//param variable </span></span><br><span class="line">    <span class="keyword">int</span> IntParam; </span><br><span class="line">    string StrParam; </span><br><span class="line">    <span class="keyword">bool</span> isIntParam, isStrParam; </span><br><span class="line">    <span class="comment">//mode flag </span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]); </span><br><span class="line">     <span class="comment">// set or get param with different ways </span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(flag) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;set param mode(ros::param::set()):&quot;</span>); </span><br><span class="line">            ros::param::<span class="built_in">set</span>(<span class="string">&quot;IntParam&quot;</span>,<span class="number">1</span>); </span><br><span class="line">            ros::param::<span class="built_in">set</span>(<span class="string">&quot;StrParam&quot;</span>,<span class="string">&quot;stringdemo&quot;</span>); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;set param mode(ros::NodeHandle::setParam()):&quot;</span>); </span><br><span class="line">            nh.<span class="built_in">setParam</span>(<span class="string">&quot;IntParam&quot;</span>,<span class="number">1</span>); </span><br><span class="line">            nh.<span class="built_in">setParam</span>(<span class="string">&quot;StrParam&quot;</span>,<span class="string">&quot;stringdemo&quot;</span>); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;get param mode(ros::param::get()):&quot;</span>); </span><br><span class="line">            isIntParam = ros::param::<span class="built_in">get</span>(<span class="string">&quot;IntParam&quot;</span>,IntParam); </span><br><span class="line">            isStrParam = ros::param::<span class="built_in">get</span>(<span class="string">&quot;StrParam&quot;</span>,StrParam); </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(isIntParam)&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;The IntParam is:%d&quot;</span>,IntParam); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get IntParam fail!&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(isIntParam)&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;The StrParam is:%s&quot;</span>,StrParam.<span class="built_in">c_str</span>()); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get StrParam fail!&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;get param mode(ros::NodeHandle::getParam()):&quot;</span>); </span><br><span class="line">            isIntParam = nh.<span class="built_in">getParam</span>(<span class="string">&quot;IntParam&quot;</span>,IntParam); </span><br><span class="line">            isStrParam = nh.<span class="built_in">getParam</span>(<span class="string">&quot;StrParam&quot;</span>,StrParam); </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(isIntParam)&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;The IntParam is:%d&quot;</span>,IntParam); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get IntParam fail!&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(isIntParam)&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;The StrParam is:%s&quot;</span>,StrParam.<span class="built_in">c_str</span>()); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get StrParam fail!&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;get param mode(ros::NodeHandle::param()):&quot;</span>); </span><br><span class="line">            <span class="comment">//warning: this way will set default value when get no param! </span></span><br><span class="line">            nh.<span class="built_in">param</span>(<span class="string">&quot;IntParam&quot;</span>,IntParam,<span class="number">11</span>); </span><br><span class="line">            <span class="comment">// be careful when use ros::NodeHandle::param get string param! </span></span><br><span class="line">            nh.param&lt;std::string&gt;(<span class="string">&quot;StrParam&quot;</span>,StrParam,<span class="string">&quot;stringdemo_default&quot;</span>); </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;\nThe IntParam is:%d\nThe StrParam is:%s&quot;</span>,IntParam,StrParam.<span class="built_in">c_str</span>()); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;flag value is not in range: [1,5]&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="launch文件配置"><a href="#launch文件配置" class="headerlink" title="launch文件配置"></a>launch文件配置</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--param参数配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--param name=&quot;table_description&quot; command=&quot;$(find xacro)/xacro.py $(find gazebo_worlds)/objects/table.urdf.xacro&quot; /--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--rosparam参数配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rosparam</span>&gt;</span>   </span><br><span class="line">        param3: 3</span><br><span class="line">        param4: 4</span><br><span class="line">        param5: 5</span><br><span class="line">    <span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--以上写法将参数转成YAML文件加载，注意param前面必须为空格，不能用Tab，否则YAML解析错误--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--rosparam file=&quot;$(find robot_sim_demo)/config/xbot-u_control.yaml&quot; command=&quot;load&quot; /--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">name</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">param1:1</span></span><br><span class="line"><span class="string">param2:&quot;str&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros_rosbag</title>
    <url>/blog/2021/11/02/rosbag/</url>
    <content><![CDATA[<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://blog.csdn.net/qiqiqiqi0000/article/details/114767249?ops_request_misc=%7B%22request_id%22:%22163582490616780261970410%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582490616780261970410&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-114767249.pc_search_ecpm_flag&utm_term=rosbag&spm=1018.2226.3001.4187">(59条消息) Rosbag详细操作_Sun的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/newbeixue/article/details/110082489?ops_request_misc=%7B%22request_id%22:%22163582694116780271519523%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582694116780271519523&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-110082489.pc_search_ecpm_flag&utm_term=rosbag+play+--clock&spm=1018.2226.3001.4187">rosbag –clock_newbeixue的博客-CSDN博客</a></p>
<h2 id="Rosbag基础使用"><a href="#Rosbag基础使用" class="headerlink" title="Rosbag基础使用"></a>Rosbag基础使用</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存所有topic</span></span><br><span class="line">rosbag record -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只记录某些感兴趣的 topic</span></span><br><span class="line">rosbag record /topic_name1 /topic_name2 /topic_name3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定生成数据包的名字，则用-O /-o 参数</span></span><br><span class="line">rosbag record -O filename.bag /topic_name1</span><br><span class="line"><span class="meta">#</span><span class="bash"> launch 文件中使用 rosbag record 命令</span></span><br><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure>

<h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag info filename.bag</span><br><span class="line">rosbag info -y filename.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">xiaohu@xiaohu:~/bagfiles$  rosbag info -y 1.bag</span><br><span class="line">path: 1.bag</span><br><span class="line">version: 2.0</span><br><span class="line">duration: 3.295966</span><br><span class="line">start: 1566653873.351150</span><br><span class="line">end: 1566653876.647117</span><br><span class="line">size: 8103</span><br><span class="line">messages: 20</span><br><span class="line">indexed: True</span><br><span class="line">compression: none</span><br><span class="line">types:</span><br><span class="line">    - type: geometry_msgs/Twist</span><br><span class="line">      md5: 9f195f881246fdfa2798d1d3eebca84a</span><br><span class="line">topics:</span><br><span class="line">    - topic: /turtle1/cmd_vel</span><br><span class="line">      type: geometry_msgs/Twist</span><br><span class="line">      messages: 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rosbag-play"><a href="#rosbag-play" class="headerlink" title="rosbag play"></a>rosbag play</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 简单播放</span></span><br><span class="line">rosbag play &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 2 表示2倍速播放</span></span><br><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环播放</span></span><br><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只播放一部分topic</span></span><br><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始播放立刻暂停，按空格继续</span></span><br><span class="line">rosbag play --pause record.bag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rosbag-–clock"><a href="#rosbag-–clock" class="headerlink" title="rosbag –clock"></a>rosbag –clock</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag play --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -k， --keep-alive</span></span><br><span class="line">rosbag play -k  --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r FACTOR, --rate=FACTOR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。</span></span><br><span class="line">rosbag play -r 0.1 --clock recorded1.bag</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosparam set /use_sim_time true</span><br><span class="line">rosbag play --pause  --clock -k scan_odom.bag --topic /topic1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>time</title>
    <url>/blog/2022/04/26/ros_time/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_41035283/article/details/120697331?ops_request_misc=%7B%22request_id%22:%22165093841216782390592381%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165093841216782390592381&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-120697331.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=ros%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4&spm=1018.2226.3001.4187">(128条消息) ROS学习八、ros中的时间Time,Duration,Timer和Rate（2）_RuiH.AI的博客-CSDN博客_ros时间</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><p>Time和Duration的数据类型相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">int32 sec</span><br><span class="line">int32 nsec</span><br></pre></td></tr></table></figure>

<p>获取当前时间:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::Time::<span class="built_in">init</span>();</span><br><span class="line">ros::Time start = ros::Time::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>

<p>转化为ms/s</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为ms</span></span><br><span class="line"><span class="keyword">double</span> t_ms = t.<span class="built_in">toNSec</span>();</span><br><span class="line"><span class="comment">// 转为s</span></span><br><span class="line"><span class="keyword">double</span> t_s = t.<span class="built_in">toSec</span>();</span><br></pre></td></tr></table></figure>

<p>时间间隔:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::Duration + ros::Duration = ros::Duration</span><br><span class="line">ros::Duration - ros::Duration = ros::Duration</span><br><span class="line">ros::Time + ros::Duration = ros::Time</span><br><span class="line">ros::Time - ros::Time = ros::Duration</span><br></pre></td></tr></table></figure>

<p>sleep:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用方法：</span></span><br><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">2.5</span>).<span class="built_in">sleep</span>(); </span><br></pre></td></tr></table></figure>

<p>ros::rate循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10Hz</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(ros::ok())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	r.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros安装</title>
    <url>/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu18.04</span><br><span class="line">ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list.d/ros-latest.list</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic main</span><br><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install ros-melodic-desktop-full</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line">sudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="一行代码安装ros（包含问题处理）"><a href="#一行代码安装ros（包含问题处理）" class="headerlink" title="一行代码安装ros（包含问题处理）"></a>一行代码安装ros（包含问题处理）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<p>参考视频：</p>
<p><a href="https://mp.weixin.qq.com/s/8hTrKL0N5y9i6s9ujhp0UA">玩着游戏听着歌，就把ROS装好了！一行代码搞定系列！ (qq.com)</a></p>
<h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><p><code>rosdep init</code>不成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove --purge ros-melodic</span><br><span class="line"><span class="meta">#</span><span class="bash"> 先卸载包</span></span><br><span class="line">sudo apt-get purge ros-*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后删除依赖，配置</span></span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd ~/catkin_ws/</span><br><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>打开新窗口执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>

<p>出现小乌龟则安装完成。</p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>scan_context</title>
    <url>/blog/2022/03/06/scan_context/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_46181372/article/details/116130105">(112条消息) Scan Context 学习记录_春至冬去-CSDN博客_scancontext</a> </p>
<p> <a href="https://zhuanlan.zhihu.com/p/359523177">Lidar定位：Scan Context - 知乎 (zhihu.com)</a> </p>
<p> <a href="https://github.com/irapkaist/scancontext">irapkaist/scancontext: Global LiDAR descriptor for place recognition and long-term localization </a> </p>
<p> <a href="https://www.bilibili.com/read/cv10348019">原创投稿 | ScanContext 论文详解 - 用途：Lidar SLAM 回环检测、空间描述符 - 哔哩哔哩 (bilibili.com)</a> </p>
<p> <a href="https://blog.csdn.net/weixin_35536487/article/details/113545839">(112条消息) 激光闭环检测Scancontext_weixin_35536487的博客-CSDN博客_scancontext</a> </p>
<p> <a href="https://github.com/softdream/Slam-Project-Of-MyOwn/tree/master/src">Slam-Project-Of-MyOwn/src at master · softdream/Slam-Project-Of-MyOwn (github.com)</a> </p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://s2.loli.net/2022/03/06/L8eBVCXyU4ZGT15.png" alt="1646575561_1_.png"></p>
<ul>
<li><p><strong>给定一帧点云，划分成20个环，每个环分成60等份，一共1200个格子</strong></p>
</li>
<li><p><strong>每个格子存里面点的最大高度值（z值），这样一帧点云就用一个二维图像表示了，想象成一个带高度的俯视图，或者地形图，记为scan context</strong></p>
</li>
<li><p><strong>scan context进一步计算列的均值，得到一个1x60的向量，记为ring key；计算行的均值，得到一个20x1的向量，记为sector key</strong></p>
</li>
<li><p><strong>用ring key构造kd-tree，并且执行knn搜索</strong></p>
</li>
<li><p><strong>对于候选匹配scan context，首先要左右循环偏移一下，对齐，实际会用sector key去对齐，得到一个偏移量</strong></p>
</li>
<li><p><strong>对候选匹配scan context，施加偏移量，然后作比较</strong></p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="make-scanContext"><a href="#make-scanContext" class="headerlink" title="make scanContext"></a>make scanContext</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一帧点云生成scan context</span></span><br><span class="line"><span class="function">MatrixXd <span class="title">SCManager::makeScancontext</span><span class="params">( pcl::PointCloud&lt;SCPointType&gt; &amp; _scan_down )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 激光点数量</span></span><br><span class="line">    <span class="keyword">int</span> num_pts_scan_down = _scan_down.points.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NO_POINT = <span class="number">-1000</span>;</span><br><span class="line">    <span class="comment">// 这里矩阵的记法跟paper的示意图是一致的</span></span><br><span class="line">    MatrixXd desc = NO_POINT * MatrixXd::Ones(PC_NUM_RING, PC_NUM_SECTOR);</span><br><span class="line"></span><br><span class="line">    SCPointType pt;</span><br><span class="line">    <span class="keyword">float</span> azim_angle, azim_range; <span class="comment">// wihtin 2d plane</span></span><br><span class="line">    <span class="keyword">int</span> ring_idx, sctor_idx;</span><br><span class="line">    <span class="comment">// 遍历激光点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pt_idx = <span class="number">0</span>; pt_idx &lt; num_pts_scan_down; pt_idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        pt.x = _scan_down.points[pt_idx].x; </span><br><span class="line">        pt.y = _scan_down.points[pt_idx].y;</span><br><span class="line">        <span class="comment">// 让高度大于0，所有点的高度都加2，不影响匹配结果</span></span><br><span class="line">        pt.z = _scan_down.points[pt_idx].z + LIDAR_HEIGHT; <span class="comment">// naive adding is ok (all points should be &gt; 0).</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离</span></span><br><span class="line">        azim_range = <span class="built_in">sqrt</span>(pt.x * pt.x + pt.y * pt.y);</span><br><span class="line">        <span class="comment">// 角度，0~360°</span></span><br><span class="line">        azim_angle = xy2theta(pt.x, pt.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离超过80米的点不考虑了</span></span><br><span class="line">        <span class="keyword">if</span>( azim_range &gt; PC_MAX_RADIUS )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这个点落在哪个bin里面，下标从1开始数</span></span><br><span class="line">        ring_idx = <span class="built_in">std</span>::max( <span class="built_in">std</span>::min( PC_NUM_RING, <span class="keyword">int</span>(<span class="built_in">ceil</span>( (azim_range / PC_MAX_RADIUS) * PC_NUM_RING )) ), <span class="number">1</span> );</span><br><span class="line">        sctor_idx = <span class="built_in">std</span>::max( <span class="built_in">std</span>::min( PC_NUM_SECTOR, <span class="keyword">int</span>(<span class="built_in">ceil</span>( (azim_angle / <span class="number">360.0</span>) * PC_NUM_SECTOR )) ), <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用z值，也就是高度来更新这个格子，存最大的高度；</span></span><br><span class="line">        <span class="keyword">if</span> ( desc(ring_idx<span class="number">-1</span>, sctor_idx<span class="number">-1</span>) &lt; pt.z ) <span class="comment">// -1 means cpp starts from 0</span></span><br><span class="line">            desc(ring_idx<span class="number">-1</span>, sctor_idx<span class="number">-1</span>) = pt.z; <span class="comment">// update for taking maximum value at that bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reset no points to zero (for cosine dist later)</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> row_idx = <span class="number">0</span>; row_idx &lt; desc.rows(); row_idx++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> col_idx = <span class="number">0</span>; col_idx &lt; desc.cols(); col_idx++ )</span><br><span class="line">            <span class="keyword">if</span>( desc(row_idx, col_idx) == NO_POINT )</span><br><span class="line">                desc(row_idx, col_idx) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="make-Ringkey"><a href="#make-Ringkey" class="headerlink" title="make Ringkey"></a>make Ringkey</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由scan context计算ring key，Nx1</span></span><br><span class="line"><span class="function">MatrixXd <span class="title">SCManager::makeRingkeyFromScancontext</span><span class="params">( Eigen::MatrixXd &amp;_desc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每行计算一个均值</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">invariant_key</span><span class="params">(_desc.rows(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> row_idx = <span class="number">0</span>; row_idx &lt; _desc.rows(); row_idx++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::MatrixXd curr_row = _desc.row(row_idx);</span><br><span class="line">        invariant_key(row_idx, <span class="number">0</span>) = curr_row.mean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invariant_key;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="make-Sectorkey"><a href="#make-Sectorkey" class="headerlink" title="make Sectorkey"></a>make Sectorkey</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由scan context计算sector key，1xM</span></span><br><span class="line"><span class="function">MatrixXd <span class="title">SCManager::makeSectorkeyFromScancontext</span><span class="params">( Eigen::MatrixXd &amp;_desc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每列计算一个均值</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">variant_key</span><span class="params">(<span class="number">1</span>, _desc.cols())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> col_idx = <span class="number">0</span>; col_idx &lt; _desc.cols(); col_idx++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::MatrixXd curr_col = _desc.col(col_idx);</span><br><span class="line">        variant_key(<span class="number">0</span>, col_idx) = curr_col.mean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> variant_key;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="调整偏移-获得偏移量"><a href="#调整偏移-获得偏移量" class="headerlink" title="调整偏移,获得偏移量"></a>调整偏移,获得偏移量</h2><p>按列均值,目的是,便于通过调整偏移量来实现对scanContext进行比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _vkey1、_vkey2是两个sector key</span></span><br><span class="line"><span class="comment">// 对_vkey2做循环偏移，计算与_vkey1最佳匹配时的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SCManager::fastAlignUsingVkey</span><span class="params">( MatrixXd &amp; _vkey1, MatrixXd &amp; _vkey2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> argmin_vkey_shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> min_veky_diff_norm = <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> shift_idx = <span class="number">0</span>; shift_idx &lt; _vkey1.cols(); shift_idx++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 矩阵的列，循环右移shift个单位</span></span><br><span class="line">        MatrixXd vkey2_shifted = circshift(_vkey2, shift_idx);</span><br><span class="line">        <span class="comment">// 直接相减，sector key是1xN的矩阵</span></span><br><span class="line">        MatrixXd vkey_diff = _vkey1 - vkey2_shifted;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 范数</span></span><br><span class="line">        <span class="keyword">double</span> cur_diff_norm = vkey_diff.norm();</span><br><span class="line">        <span class="comment">// 记录距离最小时对应的循环偏移量</span></span><br><span class="line">        <span class="keyword">if</span>( cur_diff_norm &lt; min_veky_diff_norm )</span><br><span class="line">        &#123;</span><br><span class="line">            argmin_vkey_shift = shift_idx;</span><br><span class="line">            min_veky_diff_norm = cur_diff_norm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> argmin_vkey_shift;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="闭环检测"><a href="#闭环检测" class="headerlink" title="闭环检测"></a>闭环检测</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口二，执行闭环检测</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; <span class="title">SCManager::detectLoopClosureID</span> <span class="params">( <span class="keyword">void</span> )</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 计算两个scan context之间的距离</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="title">SCManager::distanceBtnScanContext</span><span class="params">( MatrixXd &amp;_sc1, MatrixXd &amp;_sc2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. fast align using variant key (not in original IROS18)</span></span><br><span class="line">    <span class="comment">// 计算sector Key,也就是sector最大高度均值组成的数组，1xN</span></span><br><span class="line">    MatrixXd vkey_sc1 = makeSectorkeyFromScancontext( _sc1 );</span><br><span class="line">    MatrixXd vkey_sc2 = makeSectorkeyFromScancontext( _sc2 );</span><br><span class="line">    <span class="comment">// 这里将_vkey2循环右移，然后跟_vkey1作比较，找到一个最相似（二者做差最小）的时候，记下循环右移的量</span></span><br><span class="line">    <span class="keyword">int</span> argmin_vkey_shift = fastAlignUsingVkey( vkey_sc1, vkey_sc2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面用sector key匹配，找到一个初始的偏移量，但肯定不是准确的，再在这个偏移量左右扩展一下搜索空间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SEARCH_RADIUS = round( <span class="number">0.5</span> * SEARCH_RATIO * _sc1.cols() ); <span class="comment">// a half of search range </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shift_idx_search_space &#123; argmin_vkey_shift &#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt; SEARCH_RADIUS + <span class="number">1</span>; ii++ )</span><br><span class="line">    &#123;</span><br><span class="line">        shift_idx_search_space.push_back( (argmin_vkey_shift + ii + _sc1.cols()) % _sc1.cols() );</span><br><span class="line">        shift_idx_search_space.push_back( (argmin_vkey_shift - ii + _sc1.cols()) % _sc1.cols() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(shift_idx_search_space.begin(), shift_idx_search_space.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. fast columnwise diff </span></span><br><span class="line">    <span class="keyword">int</span> argmin_shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> min_sc_dist = <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> num_shift: shift_idx_search_space )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把scan context循环右移一下</span></span><br><span class="line">        MatrixXd sc2_shifted = circshift(_sc2, num_shift);</span><br><span class="line">        <span class="comment">// 计算两个scan context之间的距离</span></span><br><span class="line">        <span class="keyword">double</span> cur_sc_dist = distDirectSC( _sc1, sc2_shifted );</span><br><span class="line">        <span class="keyword">if</span>( cur_sc_dist &lt; min_sc_dist )</span><br><span class="line">        &#123;</span><br><span class="line">            argmin_shift = num_shift;</span><br><span class="line">            min_sc_dist = cur_sc_dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小scan context距离，偏移量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(min_sc_dist, argmin_shift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>scanContext方法只是用于简单的位姿对比,对于精确位姿还需要最后使用更加精确的手段进行定位,比如icp,scantomap,图优化都可以.</p>
<h1 id="简单介绍回环检测与图优化结合方式"><a href="#简单介绍回环检测与图优化结合方式" class="headerlink" title="简单介绍回环检测与图优化结合方式"></a>简单介绍回环检测与图优化结合方式</h1><ul>
<li>首先通过sccan_to_map检测是否超过一定距离与角度,若是,设为关键帧</li>
<li>将关键帧保存数组</li>
<li>生成scanContext并加入图优化顶点</li>
<li>检测是否有回环,若有,则根据记录下来的顶点,scan,运动坐标进行图优化,更新坐标</li>
<li>重新建图:先删除之前所有建图信息, 根据估计的关键姿态重建地图 </li>
</ul>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>scan_to_map</title>
    <url>/blog/2022/03/03/scan_to_map/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/tu-darmstadt-ros-pkg/hector_slam/tree/noetic-devel/hector_mapping/include/hector_slam_lib/matcher">hector_slam</a> </p>
<p> <a href="https://github.com/Forrest-Z/Slam-Project-Of-MyOwn">Forrest-Z/Slam-Project-Of-MyOwn</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> 和ICP方法不同，当前帧的激光雷达扫描数据与已建好的历史占据栅格地图进行匹配，根据激光雷达观测点在地图上占据栅格的概率值的和来建立误差方程，使用高斯牛顿法求解方程使得占据概率值的和最大，得到最佳的机器人位姿坐标变换。此外还使用了双线性插值方法(Bilinear Interpolation)来计算当前帧激光雷达数据在地图上对应点的占据概率，提高匹配精准度。 </p>
<p>最常见的就是hector的前端里程计了.</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://s2.loli.net/2022/03/03/blISEpqZtzs7yOx.png" alt="scca_to_map.png"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scanMatch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define TERMINAL_LOG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> slam &#123;</span><br><span class="line"></span><br><span class="line">ScanMatchMethod::ScanMatchMethod() : mP00( <span class="number">0</span> ), </span><br><span class="line">				     mP11( <span class="number">0</span> ),</span><br><span class="line">				     mP01( <span class="number">0</span> ),</span><br><span class="line">				     mP10(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScanMatchMethod::~ScanMatchMethod()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ScanMatchMethod::bilinearInterpolation</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap, <span class="keyword">const</span> Eigen::Vector2f &amp;coords )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1. judge weather out of range</span></span><br><span class="line">	<span class="keyword">if</span>( occuMap.isPointOutOfRange( coords ) )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">	&#125;		</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. map coords are always positive, floor them by casting to int</span></span><br><span class="line">	<span class="function">Eigen::Vector2i <span class="title">indMin</span><span class="params">( coords.cast&lt;<span class="keyword">int</span>&gt;() )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. factor0 = ( x - x0 )</span></span><br><span class="line">	<span class="comment">//    factor1 = ( y - y0 )</span></span><br><span class="line">	<span class="keyword">float</span> factor0 = coords[<span class="number">0</span>] - <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;( indMin[<span class="number">0</span>] );</span><br><span class="line">	<span class="keyword">float</span> factor1 = coords[<span class="number">1</span>] - <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;( indMin[<span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. find p(m) point in map coordinate</span></span><br><span class="line">	<span class="keyword">int</span> sizeX = occuMap.getSizeX();</span><br><span class="line">	<span class="keyword">int</span> index = indMin[<span class="number">1</span>] * sizeX + indMin[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. get the probability of the four points</span></span><br><span class="line">	mP00 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line">	index ++;</span><br><span class="line">	mP10 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line">	index += sizeX - <span class="number">1</span>;</span><br><span class="line">	mP01 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line">	index ++;</span><br><span class="line">	mP11 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. factorInv0 = 1 - ( x - x0 )</span></span><br><span class="line">	<span class="comment">//    factorInv1 = 1 - ( y - y0 )</span></span><br><span class="line">	<span class="keyword">float</span> factorInv0 = <span class="number">1.0f</span> - factor0;</span><br><span class="line">	<span class="keyword">float</span> factorInv1 = <span class="number">1.0f</span> - factor1; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. M(Pm) = (y - y0) * &#123; (x - x0) * M(P11) + [1 - (x - x0)] * M(P01) &#125; + [1 - (y - y0)] * &#123; (x - x0) * M(P10) + [1 - (x - x0)] * M(P00) &#125;</span></span><br><span class="line">	<span class="keyword">return</span> ( factor1 * ( factor0 * mP11 + factorInv0 * mP01 ) ) + ( factorInv1 * ( factor0 * mP10 + factorInv0 * mP00 ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">ScanMatchMethod::bilinearInterpolationWithDerivative</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap, <span class="keyword">const</span> Eigen::Vector2f &amp;coords )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// M(Pm) = (y-y0)/(y1-y0) * &#123; [(x-x0)/(x1-x0)] * M(P11) + [(x1-x)/(x1-x0)] * M(P01) &#125;</span></span><br><span class="line">	<span class="comment">//	  +(y1-y)/(y1-y0) * &#123; [(x-x0)/(x1-x0)] * M(P10) + [(x1-x)/(x1-x0)] * M(P00) &#125;</span></span><br><span class="line">	<span class="comment">// among them:</span></span><br><span class="line">	<span class="comment">// y1 - y0 = 1</span></span><br><span class="line">	<span class="comment">// x1 - x0 = 1</span></span><br><span class="line">	<span class="comment">// x1 - x = 1 - ( x - x0 )</span></span><br><span class="line">	<span class="comment">// y1 - y = 1 - ( y - y0 )</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// M(Pm) = (y-y0) * &#123; (x-x0) * M(P11) + (1-(x-x0)) * M(P01) &#125; </span></span><br><span class="line">	<span class="comment">//	  +(1-(y-y0)) * &#123; (x-x0) * M(P10) + (1-(x-x0)) * M(P00) &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// dM(Pm)/dx = (y-y0)/(y1-y0) * &#123; M(P11) - M(P01) &#125;</span></span><br><span class="line">	<span class="comment">//	      +(y1-y)/(y1-y0) * &#123; M(P10) - M(P00) &#125;</span></span><br><span class="line">	<span class="comment">//	     = (y-y0) * &#123; M(P11) - M(P01) &#125; + (1-(y-y0)) * &#123; M(P10) - M(P00) &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// dM(Pm)/dy = (x-x0)/(x1-x0) * &#123; M(P11) - M(P10) &#125;</span></span><br><span class="line">        <span class="comment">//            +(x1-x)/(x1-x0) * &#123; M(P01) - M(P00) &#125;</span></span><br><span class="line">	<span class="comment">//	     = (x-x0) * &#123; M(P11) - M(P10) &#125; + (1-(x-x0)) * &#123; M(P01) - M(P00) &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// dM(Pm)/dPm = &#123; dM(Pm)/dx, dM(Pm)/dy &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. judge weather out of range</span></span><br><span class="line">        <span class="keyword">if</span>( occuMap.isPointOutOfRange( coords ) )&#123;</span><br><span class="line">                <span class="keyword">return</span> Eigen::Vector3f( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. map coords are always positive, floor them by casting to int</span></span><br><span class="line">        <span class="function">Eigen::Vector2i <span class="title">indMin</span><span class="params">( coords.cast&lt;<span class="keyword">int</span>&gt;() )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intergerMin = &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;indMin&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. factor0 = ( x - x0 )</span></span><br><span class="line">        <span class="comment">//    factor1 = ( y - y0 )</span></span><br><span class="line">        <span class="keyword">float</span> factor0 = coords[<span class="number">0</span>] - <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;( indMin[<span class="number">0</span>] );</span><br><span class="line">        <span class="keyword">float</span> factor1 = coords[<span class="number">1</span>] - <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;( indMin[<span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. find p(m) point in map coordinate</span></span><br><span class="line">        <span class="keyword">int</span> sizeX = occuMap.getSizeX(); </span><br><span class="line">        <span class="keyword">int</span> index = indMin[<span class="number">1</span>] * sizeX + indMin[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. get the probability of the four points</span></span><br><span class="line">        mP00 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Mp(00) = &quot;</span>&lt;&lt;mP00&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        index ++;</span><br><span class="line">        mP10 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Mp(10) = &quot;</span>&lt;&lt;mP10&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        index += sizeX - <span class="number">1</span>;</span><br><span class="line">        mP01 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Mp(01) = &quot;</span>&lt;&lt;mP01&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        index ++;</span><br><span class="line">        mP11 = occuMap.getCellOccupiedProbability( index );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Mp(11) = &quot;</span>&lt;&lt;mP11&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 6. factorInv0 = 1 - ( x - x0 )</span></span><br><span class="line">        <span class="comment">//    factorInv1 = 1 - ( y - y0 )</span></span><br><span class="line">        <span class="keyword">float</span> factorInv0 = <span class="number">1.0f</span> - factor0;</span><br><span class="line">        <span class="keyword">float</span> factorInv1 = <span class="number">1.0f</span> - factor1;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 7. M(Pm) = (y - y0) * &#123; (x - x0) * M(P11) + [1 - (x - x0)] * M(P01) &#125; + [1 - (y - y0)] * &#123; (x - x0) * M(P10) + [1 - (x - x0)] * M(P00) &#125;</span></span><br><span class="line">	<span class="comment">// ---------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">// d(M(Pm)) / dx = (y - y0) * [M(P11) - M(P01)] + (1 - (y - y0)) * [M(P10) - M(P00)]</span></span><br><span class="line">	<span class="comment">// ---------------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">// d(M(Pm)) / dy = (x - x0) * [M(P11) - M(P10)] + (1 - (x - x0)) * [M(P01) - M(P00)]</span></span><br><span class="line">	<span class="keyword">return</span> Eigen::Vector3f( ( ( factor1 * ( factor0 * mP11 + factorInv0 * mP01 ) ) + ( factorInv1 * ( factor0 * mP10 + factorInv0 * mP00 ) ) ), </span><br><span class="line">				( factor1 * ( mP11 - mP01 ) + factorInv1 * ( mP10 - mP00 ) ),</span><br><span class="line">				( factor0 * ( mP11 - mP10 ) + factorInv0 * ( mP01 - mP00 ) ) </span><br><span class="line">			      );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScanMatchMethod::getHessianDerivative</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap,</span></span></span><br><span class="line"><span class="params"><span class="function">					    Eigen::Vector3f &amp;robotPoseInWorld,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   	    <span class="keyword">const</span> ScanContainer &amp;scanPoints, </span></span></span><br><span class="line"><span class="params"><span class="function">                                   	    Eigen::Matrix3f &amp;H,  </span></span></span><br><span class="line"><span class="params"><span class="function">                                   	    Eigen::Vector3f &amp;dTr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// H = Sigma(i = 1 to n)&#123; Nabla( Si(cauchy) ) * [( d(Si(cauchy)) )/( d(cauchy) )] &#125;^2</span></span><br><span class="line">	<span class="comment">// n is the number of the scan points</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Si(cauchy) = | cosRot -sinRot | * | x_i | + | Px |</span></span><br><span class="line">	<span class="comment">// 		| sinRot  cosRot |   | y_i |   | Py |</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// among them:</span></span><br><span class="line">	<span class="comment">// ( x_i, y_i ) is the point that lidar has observed in map coordinate, i = 0, 1, 2, ..., n;</span></span><br><span class="line">	<span class="comment">// ( Px, Py ) is the Translation vector</span></span><br><span class="line">	<span class="comment">// | cosRot -sinRot | </span></span><br><span class="line">	<span class="comment">// | sinRot  cosRot | is the Rotation Matrix</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// d(Si(cauchy)) / d(cauchy) = | 1	0	-sinRot * x_i - cosRot * y_i |</span></span><br><span class="line">	<span class="comment">//			       | 0	1	 cosRot * x_i - sinRot * y_i |</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Nabla( Si(cauchy) = dM(Pm)/dPm = &#123; dM(Pm)/dx, dM(Pm)/dy &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// dTr = Sigma(i = 1 to n)&#123; Nabla( Si(cauchy) ) * [( d(Si(cauchy)) )/( d(cauchy) )] &#125; * &#123; 1 - M( Si(cauchy) ) &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> size = scanPoints.getSize();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> sinRot = ::<span class="built_in">sin</span>( robotPoseInWorld[<span class="number">2</span>] );</span><br><span class="line">	<span class="keyword">float</span> cosRot = ::<span class="built_in">cos</span>( robotPoseInWorld[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sinRot = &quot;</span>&lt;&lt;sinRot&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;cosRot = &quot;</span>&lt;&lt;cosRot&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	H = Eigen::Matrix3f::Zero();</span><br><span class="line">	dTr = Eigen::Vector3f::Zero();	</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;size&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )&#123;</span><br><span class="line">		<span class="comment">// 1. get the current point in laser coordinate</span></span><br><span class="line">		<span class="function">Eigen::Vector2f <span class="title">currPointInLaser</span><span class="params">( scanPoints.getIndexData( i ) )</span></span>;</span><br><span class="line">		<span class="function">Eigen::Vector2f <span class="title">currPointInScaleLaser</span><span class="params">( scanPoints.getIndexData( i ) * occuMap.getScale() )</span></span>;	</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 2. Transform the End Point from Laser Coordinate to World Coordinate</span></span><br><span class="line">		<span class="function">Eigen::Vector2f <span class="title">currPointInWorld</span><span class="params">( occuMap.observedPointPoseLaser2World( currPointInLaser, robotPoseInWorld ) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;currPointInWorld: &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;currPointInWorld&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;		</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. Transform the End Point from World Coordinate to Map Coordinate</span></span><br><span class="line">		<span class="function">Eigen::Vector2f <span class="title">currPointInMap</span><span class="params">( occuMap.observedPointPoseWorld2Map( currPointInWorld ) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;currPointInMap: &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;currPointInMap&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;		</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. get the M(Pm), d(M(Pm))/dx, d(M(Pm))/dy</span></span><br><span class="line">		<span class="function">Eigen::Vector3f <span class="title">interpolatedValue</span><span class="params">( bilinearInterpolationWithDerivative( occuMap, currPointInMap ) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;interpolatedValue: &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;interpolatedValue&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 5. the Objective Function: f(x) = 1 - M(Pm)</span></span><br><span class="line">		<span class="keyword">float</span> funcValue = <span class="number">1.0f</span> - interpolatedValue[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 6. </span></span><br><span class="line">		dTr[<span class="number">0</span>] += interpolatedValue[<span class="number">1</span>] * funcValue;</span><br><span class="line">		dTr[<span class="number">1</span>] += interpolatedValue[<span class="number">2</span>] * funcValue;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7. </span></span><br><span class="line">		<span class="keyword">float</span> rotDeriv = ( interpolatedValue[<span class="number">1</span>] * ( -sinRot * currPointInScaleLaser[<span class="number">0</span>] - cosRot * currPointInScaleLaser[<span class="number">1</span>] ) ) + ( interpolatedValue[<span class="number">2</span>] * ( cosRot * currPointInScaleLaser[<span class="number">0</span>] - sinRot * currPointInScaleLaser[<span class="number">1</span>] ) );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 8. </span></span><br><span class="line">		dTr[<span class="number">2</span>] += rotDeriv * funcValue;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 9. </span></span><br><span class="line">		H( <span class="number">0</span>, <span class="number">0</span> ) += sqr( interpolatedValue[<span class="number">1</span>] );</span><br><span class="line">		H( <span class="number">1</span>, <span class="number">1</span> ) += sqr( interpolatedValue[<span class="number">2</span>] );</span><br><span class="line">		H( <span class="number">2</span>, <span class="number">2</span> ) += sqr( rotDeriv );</span><br><span class="line"></span><br><span class="line">		H( <span class="number">0</span>, <span class="number">1</span> ) += interpolatedValue[<span class="number">1</span>] * interpolatedValue[<span class="number">2</span>];</span><br><span class="line">		H( <span class="number">0</span>, <span class="number">2</span> ) += interpolatedValue[<span class="number">1</span>] * rotDeriv;</span><br><span class="line">		H( <span class="number">1</span>, <span class="number">2</span> ) += interpolatedValue[<span class="number">2</span>] * rotDeriv;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 10. </span></span><br><span class="line">	H( <span class="number">1</span>, <span class="number">0</span> ) = H( <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">	H( <span class="number">2</span>, <span class="number">0</span> ) = H( <span class="number">0</span>, <span class="number">2</span> );</span><br><span class="line">	H( <span class="number">2</span>, <span class="number">1</span> ) = H( <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ScanMatchMethod::estimateTransformationOnce</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 Eigen::Vector3f &amp;estimateInWorld,  </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> ScanContainer &amp;scanPoints )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	getHessianDerivative( occuMap, estimateInWorld, scanPoints, H, dTr );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hessian : &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;H&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;dTr: &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;dTr&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( ( H(<span class="number">0</span>, <span class="number">0</span>) != <span class="number">0.0f</span> ) &amp;&amp; ( H(<span class="number">1</span>, <span class="number">1</span>) != <span class="number">0.0f</span> ) )&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// delta(cauchy) = H.inverse() * dTr;</span></span><br><span class="line">		<span class="function">Eigen::Vector3f <span class="title">deltaCauchy</span><span class="params">( H.inverse() * dTr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TERMINAL_LOG</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;delata Cauchy: &quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;deltaCauchy&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>		</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( deltaCauchy[<span class="number">2</span>] &gt; <span class="number">0.2f</span> )&#123;</span><br><span class="line">			deltaCauchy[<span class="number">2</span>] = <span class="number">0.2f</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;delta Cauchy angle change too large&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( deltaCauchy[<span class="number">2</span>] &lt; <span class="number">-0.2f</span> )&#123;</span><br><span class="line">			deltaCauchy[<span class="number">2</span>] = <span class="number">-0.2f</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;delta Cauchy angle change too small&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		updateEstimatedPose( occuMap, estimateInWorld, deltaCauchy );</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScanMatchMethod::updateEstimatedPose</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap, Eigen::Vector3f &amp;estimateInWorld, Eigen::Vector3f &amp;delta )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Eigen::Vector3f <span class="title">estimateInMap</span><span class="params">( occuMap.robotPoseWorld2Map( estimateInWorld ) )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pose[t_time] = pose[(t - 1)_time] + delta( cauchy );</span></span><br><span class="line">	estimateInMap += delta;</span><br><span class="line">	</span><br><span class="line">	estimateInWorld = occuMap.robotPoseMap2World( estimateInMap );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">ScanMatchMethod::scanToMap</span><span class="params">( <span class="keyword">const</span> OccupiedMap &amp;occuMap, </span></span></span><br><span class="line"><span class="params"><span class="function">                        Eigen::Vector3f &amp;beginEstimatedPoseInWorld, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> ScanContainer &amp;scanPoints, </span></span></span><br><span class="line"><span class="params"><span class="function">                        Eigen::Matrix3f &amp;covarinceMatrix, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span> maxInterations )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//std::cout&lt;&lt;&quot;-----------------------------------LOGGGGG ---- OccupiedMap.getSizeX(): &quot;&lt;&lt;occuMap.getSizeX()&lt;&lt;std::endl;</span></span><br><span class="line">		</span><br><span class="line">	<span class="function">Eigen::Vector3f <span class="title">estimatePose</span><span class="params">( beginEstimatedPoseInWorld )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( scanPoints.getSize() == <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> beginEstimatedPoseInWorld;</span><br><span class="line">	&#125;		</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. first iteration</span></span><br><span class="line">	estimateTransformationOnce( occuMap, estimatePose, scanPoints );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. multiple iterations</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxInterations - <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">		estimateTransformationOnce( occuMap, estimatePose, scanPoints );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3. normalize the angle [-PI ~ PI]</span></span><br><span class="line">	estimatePose[<span class="number">2</span>] = normalize_angle( estimatePose[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. get the covariance matrix</span></span><br><span class="line">	covarinceMatrix = Eigen::Matrix3f::Zero();</span><br><span class="line"></span><br><span class="line">	covarinceMatrix = H;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5. return the estimated pose in world coordinate</span></span><br><span class="line">	<span class="keyword">return</span> estimatePose;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>ros教程</title>
    <url>/blog/2021/11/13/ros%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><strong>古月居21讲</strong></p>
<p><a href="https://www.guyuehome.com/blog/index">博客 - 古月居 (guyuehome.com)</a></p>
<p><strong>创客智造</strong></p>
<p><a href="https://www.ncnynl.com/archives/201608/496.html">ROS入门教程-目录 - 创客智造 (ncnynl.com)</a></p>
<p><a href="https://blog.csdn.net/wuzhishiwo/category_10362422.html">(70条消息) ros机器人_wuzhishiwo的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/zhangjiali12011/article/details/91885148?ops_request_misc=%7B%22request_id%22:%22162976489016780269870400%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162976489016780269870400&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-27-91885148.pc_search_similar&utm_term=%E5%8F%A4%E6%9C%88%E5%B1%85ros%E8%AF%BE%E7%A8%8B&spm=1018.2226.3001.4187">ROS资源整理-学习ROS用得到的一些资料（持续更新）_Jiali Zhang的博客-CSDN博客</a></p>
<p><strong>国外教程(需要科学上网)</strong>,可在线模拟,有开源代码</p>
<p><a href="https://app.theconstructsim.com/en/signup/#/LearningPaths">Learn Robotics from Zero - Robotics &amp; ROS Online Courses (theconstructsim.com)</a></p>
<p><strong>很现成的模拟</strong>舒爽</p>
<p><a href="https://www.icourse163.org/course/NUDT-1205969803">智能机器人系统_国防科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>
<p><strong>外文教程</strong></p>
<p><a href="https://cyberbotics.com/doc/guide/tutorial-8-using-ros">Webots: tutorial- (cyberbotics.com)</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>通过<code>WSL</code>+<code>melodic</code>+<code>vscode</code>+<code>xlaunch</code>实现<code>ros</code>环境模拟</p>
<p><code>wsl安装</code>:<a href="https://peitianyu.github.io/blog/2021/10/19/wsl/">wsl安装与使用 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>melodic安装</code>:<a href="https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/">ros安装 | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>vscode安装</code>:<a href="https://peitianyu.github.io/blog/2021/11/13/vscode/">vscode | 某飞行员的随笔 (peitianyu.github.io)</a></p>
<p><code>vscode配置ros:</code>安装<em>C/C++<em>，</em>CMake</em>，<em>CMake Tools</em>，<em>Code Runner</em>，<em>ROS</em>，<em>Chinese</em> 这些插件</p>
<p><a href="https://blog.csdn.net/qq_42688495/article/details/107750466?ops_request_misc=%7B%22request_id%22:%22163676717216780274154447%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676717216780274154447&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107750466.pc_search_mgc_flag&utm_term=vscode+ros&spm=1018.2226.3001.4187">使用VScode搭建ROS开发环境_白鸟无言的博客-CSDN博客</a></p>
<p><code>xlaunch安装</code>:<a href="https://blog.csdn.net/beyond9305/article/details/95494863?ops_request_misc=%7B%22request_id%22:%22163676668916780255220278%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163676668916780255220278&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-95494863.pc_search_mgc_flag&utm_term=xlaunch&spm=1018.2226.3001.4187">(https://windows.podnova.com/software/3151375.htm)</a></p>
<p>下载好之后,配置<code>~/.bashrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入编辑文件,在最后添加上</span></span><br><span class="line">export DISPLAY=localhost:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> CTRL+S + CTRL+X保存退出</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h1><h2 id="古月居二十一讲"><a href="#古月居二十一讲" class="headerlink" title="古月居二十一讲"></a>古月居二十一讲</h2><p>这一步需要每一个实验都过一遍,编译一遍,不必要太过详尽,重在了解ros流程,之后回来重新复习</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1L44y167ox?p=3">古月居二十一讲视频</a></li>
<li><a href="https://blog.csdn.net/weixin_48395629/article/details/109022916?ops_request_misc=%7B%22request_id%22:%22162968965016780255230305%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162968965016780255230305&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109022916.pc_search_similar&utm_term=%E5%8F%A4%E6%9C%88%E5%B1%85ros%E5%85%A5%E9%97%A821%E8%AE%B2&spm=1018.2226.3001.4187">古月居二十一讲笔记</a></li>
<li><a href="https://pan.baidu.com/s/1E5jvjjGtjhaeT7ivmySfAg">古月居二十一讲讲义与代码</a> 密码:4n76</li>
<li><a href="https://www.guyuehome.com/blog/index/category/11">ROS探索总结 - 古月居 </a></li>
</ul>
<h2 id="ROS-Academy-for-Beginners"><a href="#ROS-Academy-for-Beginners" class="headerlink" title="ROS-Academy-for-Beginners"></a>ROS-Academy-for-Beginners</h2><ul>
<li><p><a href="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/">中国大学MOOC《机器人操作系统入门》讲义</a></p>
</li>
<li><p><a href="https://github.com/DroidAITech/ROS-Academy-for-Beginners">中国大学MOOC《机器人操作系统入门》课程代码示例</a></p>
</li>
</ul>
<p>注意下载自<code>己需要的版本</code>,别下错了,然后有显示的问题,可以试试</p>
<p><code>rosdep install --from-paths src --ignore-src --rosdistro=melodic -y</code></p>
<h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><ul>
<li><p><a href="https://www.zhihu.com/column/ros-nav">ros navigation stack源码学习 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://github.com/meiqua/navigation"> ROS Navigation stack源码</a></p>
</li>
</ul>
<h2 id="激光slam"><a href="#激光slam" class="headerlink" title="激光slam"></a>激光slam</h2><p>根据以下的几种尝试看源码</p>
<ul>
<li><a href="https://www.cnblogs.com/li-yao7758258/p/8213578.html">对比几种在ROS中常用的几种SLAM算法</a></li>
<li><a href="https://blog.csdn.net/m0_37604894/article/details/89207705?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%BF%80%E5%85%89SLAM&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-89207705.pc_search_insert_js_new&spm=1018.2226.3001.4187"> 激光SLAM学习</a></li>
<li><a href="https://blog.csdn.net/m0_37340621/category_9607656.html"> 移动机器人_少磊的博客</a></li>
</ul>
<h2 id="路径参考"><a href="#路径参考" class="headerlink" title="路径参考"></a>路径参考</h2><p><a href="https://mp.weixin.qq.com/s/-UHXkgg_CjaPW0yXzE4VuA">记得收藏丨ROS开发工程师学习指南 (qq.com)</a></p>
<h1 id="几款适合copy的源码"><a href="#几款适合copy的源码" class="headerlink" title="几款适合copy的源码"></a>几款适合copy的源码</h1><p><a href="https://github.com/ros/ros_tutorials">ros_tutorials</a></p>
<p><a href="https://github.com/ROBOTIS-GIT/ros_tutorials">ros_tutorials: ROS Tutorials for beginner</a></p>
<p><a href="https://github.com/guyuehome/ros_basic_tutorials">ros_basic_tutorials</a></p>
<p><a href="https://github.com/guyuehome/ros_advanced_tutorials">ROS进阶攻略系列视频课程</a></p>
<p><a href="https://github.com/ros-planning/navigation_tutorials">Tutorials about using the ROS Navigation stack</a></p>
<p><a href="https://github.com/RobotnikAutomation/agvs_sim">Agvs robot simulation packages for ROS </a></p>
]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros错误集锦</title>
    <url>/blog/2021/10/19/ros%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="“cv-bridge“解决办法"><a href="#“cv-bridge“解决办法" class="headerlink" title="“cv_bridge“解决办法"></a>“cv_bridge“解决办法</h2><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题:"></a>出现问题:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package):</span><br><span class="line">Could not find a package configuration file provided by “cv_bridge” with</span><br><span class="line">any of the following names:</span><br><span class="line"></span><br><span class="line">cv_bridgeConfig.cmake</span><br><span class="line">cv_bridge-config.cmake</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><p><a href="https://www.it610.com/article/1282152021410988032.htm">CMake Error ：Could not find a package configuration file provided by “cv_bridge“解决办法</a></p>
<h2 id="WSL-Ubuntu18-03环境下gazebo9视图黑屏问题的解决"><a href="#WSL-Ubuntu18-03环境下gazebo9视图黑屏问题的解决" class="headerlink" title="WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决"></a>WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 卸载gazebo与ros</span><br><span class="line">sudo apt-get remove gazebo11 gazebo11-*</span><br><span class="line">sudo apt-get purge ros-*</span><br><span class="line">sudo apt-get install ros-melodic-desktop-full</span><br><span class="line"># 卸载gazebo9</span><br><span class="line">sudo apt-get remove gazebo9 gazebo9-common gazebo9-plugin-base libgazebo9:amd64 libgazebo9-dev:amd64 ros-melodic-gazebo-*  </span><br><span class="line"># 查看</span><br><span class="line">dpkg -l | grep gazebo</span><br><span class="line"># 清楚残余包</span><br><span class="line">sudo dpkg --purge gazebo9</span><br><span class="line"># 安装gazebo11</span><br><span class="line">sudo apt-get install gazebo11 -y</span><br><span class="line">sudo apt-get install libgazebo11-dev</span><br><span class="line">gazebo</span><br></pre></td></tr></table></figure>

<p>通过重新安装的方式绕过</p>
<p><a href="https://blog.csdn.net/weixin_53266173/article/details/110817750?ops_request_misc=%7B%22request_id%22:%22162985238916780261959221%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162985238916780261959221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-12-110817750.pc_search_similar&utm_term=gazebo%E9%BB%91%E5%B1%8F&spm=1018.2226.3001.4187">WSL折腾记录之三：WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决与升级安装gazebo11</a></p>
<h3 id="rosdep-init不成功"><a href="#rosdep-init不成功" class="headerlink" title="rosdep init不成功"></a>rosdep init不成功</h3><p>命令行输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<h2 id="Could-not-find-a-package-configuration-file-provided-by-“xxxx”"><a href="#Could-not-find-a-package-configuration-file-provided-by-“xxxx”" class="headerlink" title="Could not find a package configuration file provided by “xxxx”"></a>Could not find a package configuration file provided by “xxxx”</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-xxxx </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>Mk60+shell_letter</title>
    <url>/blog/2021/11/26/shell_letter/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/Mculover666/article/details/105141286?ops_request_misc=%7B%22request_id%22:%22163790121416780357282944%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163790121416780357282944&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-105141286.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8Fshell&spm=1018.2226.3001.4187">letter-shell | 一个功能强大的嵌入式shell_Mculover666的博客（嵌入式）-CSDN博客_letter shell</a></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell_port.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief	shell移植到STM32L431时的接口实现</span></span><br><span class="line"><span class="comment"> * @author	mculover666</span></span><br><span class="line"><span class="comment"> * @date	2020/03/27 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 创建shell对象，开辟shell缓冲区 */</span></span><br><span class="line">Shell shell;</span><br><span class="line"><span class="keyword">char</span> shell_buffer[<span class="number">512</span>];</span><br><span class="line"><span class="comment">/* 2. 自己实现shell写函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shell写函数原型：typedef void (*shellWrite)(const char);</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用户shell写</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param data 数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return short 实际写入的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">userShellWrite</span><span class="params">(<span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">short</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				UART_WriteByte(HW_UART0, data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 编写初始化函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">User_Shell_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册自己实现的写函数</span></span><br><span class="line">    shell.write = userShellWrite;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用shell初始化函数</span></span><br><span class="line">    shellInit(&amp;shell, shell_buffer, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shell_port.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SHELL_PORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	_SHELL_PORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将shell定义为外部变量，在串口中断回调函数中还要使用 */</span></span><br><span class="line"><span class="keyword">extern</span> Shell shell;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明自己编写的初始化函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">User_Shell_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _SHELL_PORT_H_ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cpuidy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> recv_buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> ch, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input int: %d, char: %c, string: %s\r\n&quot;</span>, i, ch, str);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UART_RX_ISR</span><span class="params">(<span class="keyword">uint16_t</span> byteReceived)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//调用shell处理数据的接口</span></span><br><span class="line">		recv_buf = byteReceived;</span><br><span class="line">		shellHandler(&amp;shell, recv_buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    <span class="keyword">uint32_t</span> instance = GPIO_QuickInit(HW_GPIOE, <span class="number">0</span>, kGPIO_Mode_OPP);</span><br><span class="line">    UART_QuickInit(UART0_RX_PA01_TX_PA02, <span class="number">115200</span>);</span><br><span class="line">    <span class="comment">/*  配置UART 中断配置 打开接收中断 安装中断回调函数 */</span></span><br><span class="line">    UART_CallbackRxInstall(HW_UART0, UART_RX_ISR);</span><br><span class="line">    <span class="comment">/* 打开串口接收中断功能 IT 就是中断的意思*/</span></span><br><span class="line">    UART_ITDMAConfig(HW_UART0, kUART_IT_Rx, <span class="literal">true</span>);</span><br><span class="line">    User_Shell_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 闪烁小灯 */</span></span><br><span class="line">        GPIO_ToggleBit(HW_GPIOE, <span class="number">0</span>);</span><br><span class="line">        DelayMs(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出到命令列表里</span></span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), test, test, test);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>shm</title>
    <url>/blog/2021/11/23/shm/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ypt523/article/details/79958188?ops_request_misc=%7B%22request_id%22:%22163767553616780274114023%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767553616780274114023&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79958188.pc_search_mgc_flag&utm_term=%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98+%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1&spm=1018.2226.3001.4187">进程间通信——共享内存（Shared Memory）_ypt-CSDN博客_共享内存</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//comm.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMM_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 0x6666</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateShm</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//comm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CommShm</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">key_t</span> key = ftok(PATHNAME,PROJ_ID);</span><br><span class="line">	<span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> shmid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key,size,flags)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateShm</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CommShm(size,IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CommShm(size,IPC_CREAT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获得共享内存的id</span></span><br><span class="line">	<span class="keyword">int</span> shmid = GetShm(<span class="number">4096</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 将共享内存映射到本进程的地址空间</span></span><br><span class="line">	<span class="keyword">char</span> *addr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">26</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		addr[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">		i++;</span><br><span class="line">		addr[i] = <span class="number">0</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存从本进程的地址空间中卸载</span></span><br><span class="line">	shmdt(addr);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;comm.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建并获得共享内存的id</span></span><br><span class="line">	<span class="keyword">int</span> shmid = CreateShm(<span class="number">4096</span>);</span><br><span class="line">	<span class="comment">// 将共享内存映射到本进程的地址空间</span></span><br><span class="line">	<span class="keyword">char</span> *addr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i++ &lt; <span class="number">26</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;client# %s\n&quot;</span>,addr);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存从本进程的地址空间中卸载</span></span><br><span class="line">	shmdt(addr);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 删除共享内存</span></span><br><span class="line">	DestroyShm(shmid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">//Makefile</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:server client</span></span><br><span class="line"> </span><br><span class="line"><span class="section">client:client.c comm.c</span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">server:server.c comm.c</span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f client server</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>strcpy重写</title>
    <url>/blog/2021/11/25/strcpy%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/m0_57304511/article/details/121503898">什么？面试官让我写strcpy()函数_m0_57304511的博客-CSDN博客</a></p>
<h1 id="strpy"><a href="#strpy" class="headerlink" title="strpy"></a>strpy</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"><span class="comment">//const可以防止源字符串被改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用断言避免传入空指针</span></span><br><span class="line">	<span class="built_in">assert</span>( dest &amp;&amp; src );</span><br><span class="line">	<span class="keyword">char</span>* ret = dest;</span><br><span class="line">    <span class="comment">// 按地址复制,直到为空</span></span><br><span class="line">	<span class="keyword">while</span>(*dest++ = *src++)</span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> arr1[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> arr2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">my_strcpy</span>(arr1, arr2));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mempy"><a href="#mempy" class="headerlink" title="mempy"></a>mempy</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> ((src == <span class="literal">NULL</span>) || (dest == <span class="literal">NULL</span>))  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (count--)  </span><br><span class="line">        *dest++ = *src++;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">return</span> dest;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程</title>
    <url>/blog/2021/10/20/socket/</url>
    <content><![CDATA[<h3 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h3><p><a href="https://github.com/peitianyu/TcpIpBook">peitianyu/TcpIpBook: TCP/IP网络编程 (github.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV1eg411G7pW?from=search&seid=9546660162554024003&spm_id_from=333.337.0.0">TCP/IP网络通信之Socket编程入门_哔哩哔哩_bilibili</a></p>
<h3 id="套接字操作"><a href="#套接字操作" class="headerlink" title="套接字操作"></a>套接字操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"># 创建套接字</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 分配地址信息</span><br><span class="line">int bind(int sockfd, struct sockaddr* pSockAddr, socklen_t addrLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 设置监听</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 受理连接</span><br><span class="line">int accept(int sockfd, struct sockaddr* pSockAddr, socklen_t* pAddrLen);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 请求连接</span><br><span class="line">int connect(in sockfd, struct sockaddr* pSockAddr, socklen_t sockLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int open(const char* path, int flag);</span><br><span class="line">//成功时返回文件描述符， 失败时返回-1</span><br><span class="line"># 关闭文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 写入文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int sockfd, const void* buf, size_t nBytes);</span><br><span class="line">//成功时返回写入的字节数，失败时返回-1</span><br><span class="line"># 读取文件</span><br><span class="line">ssize_t read(int sockfd, void* buf, size_t nBytes);</span><br><span class="line">//成功时返回读到的字节数（若遇到文件结尾则返回0），失败时返回-1</span><br><span class="line"></span><br><span class="line">#include&lt;sys/uio.h&gt;</span><br><span class="line"># 写文件</span><br><span class="line">ssize_t writev(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"># 读文件</span><br><span class="line">ssize_t readv(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"></span><br><span class="line">// TCP</span><br><span class="line">// 发送文件</span><br><span class="line">ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line">// 接收文件</span><br><span class="line">ssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1</span><br><span class="line">// UDP接收发送</span><br><span class="line">ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">	           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">ssize_t recvfrom(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">	           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回接收的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">struct iovec</span><br><span class="line">&#123;</span><br><span class="line">    void* iov_base; //缓冲地址</span><br><span class="line">    size_t iov_len; //缓冲大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 断开连接</span><br><span class="line">int shutdown(int sock, int howto);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure>

<h3 id="套接字的可选项和IO缓冲大小"><a href="#套接字的可选项和IO缓冲大小" class="headerlink" title="套接字的可选项和IO缓冲大小"></a>套接字的可选项和IO缓冲大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">int getsockopt(int sock, int level, int optname,void* optval,socklen_t* optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br><span class="line">int setsockopt(int sock, int level, int optname, void* optval,socklen_t optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sock = socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">int optval;</span><br><span class="line">socklen_t optlen;</span><br><span class="line">int state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,(void*)&amp;optval, &amp;optlen);</span><br><span class="line"></span><br><span class="line">optval = 1024*3;</span><br><span class="line">optlen = sizeof(optval);</span><br><span class="line">state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,(void*)&amp;optval,optlen);</span><br></pre></td></tr></table></figure>

<h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><ul>
<li><code>FD_ZERO(fd_set* fdset)</code>: 将fdset变量的所有位初始化位0</li>
<li><code>FD_SET(int fd, fd_set* fdset)</code>: 向fdset变量中注册文件描述符fd</li>
<li><code>FD_CLR(int fd, fd_set* fdset)</code>: 清除fdset变量中的文件描述符fd</li>
<li><code>FD_ISSET(int fd, fd_set* fdset)</code>: fdset变量中是否存在fd文件描述符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置监视范围及超时</span><br><span class="line">#include&lt;sys/select.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int maxfd, fd_set* readset, </span><br><span class="line">            fd_set* writeset,fd_set* exceptset, </span><br><span class="line">            const struct timeval* timeout</span><br><span class="line">            );</span><br><span class="line">//失败时返回-1，超时返回0，成功时返回发生事件的文件描述符数量</span><br><span class="line"></span><br><span class="line">struct timeval</span><br><span class="line">&#123;</span><br><span class="line">    long tv_sec;</span><br><span class="line">    long tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>maxfd: 监视的文件描述符数量（最大的文件描述符+1）</li>
<li>readset: 将关注“是否存在待读取数据”的文件描述符存放在readset变量中</li>
<li>writeset: 将关注”是否可写“的文件描述符存放在writeset变量中</li>
<li>exceptset: 将关注”是否有异常“的文件描述符放在exceptset变量中 -timeout: 为了防止调用select函数后陷入无限阻塞状态，可以传递超时信息</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>几款terminal</title>
    <url>/blog/2021/10/19/terminal/</url>
    <content><![CDATA[<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><code>Powershell</code>,<code>Windows terminal</code>,<code>wsl-terminal</code>,<code>fluent terminal</code>,<code>xshell</code>,<code>Mobaxterm</code>,<code>putty</code></p>
<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>最基础的远程终端,只需要通过ssh指令连接远程终端即可.如,<code>ssh.exe pty@192.168.30.100</code></p>
<h3 id="Windows-terminal"><a href="#Windows-terminal" class="headerlink" title="Windows terminal"></a>Windows terminal</h3><p>同样可以用指令打开,同时也可以配置,打开wsl,ssh都比较方便,点击即用.但有些丑.当然也可以配置网上教程挺多,再次不做过多介绍.</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># powershell输入</span></span><br><span class="line">winget install --id=Microsoft.WindowsTerminal -e</span><br><span class="line"><span class="comment"># 通过Chocolatey</span></span><br><span class="line">choco upgrade microsoft-windows-terminal</span><br></pre></td></tr></table></figure>

<h4 id="右键打开windows-terimnal-未测试"><a href="#右键打开windows-terimnal-未测试" class="headerlink" title="右键打开windows terimnal(未测试)"></a>右键打开windows terimnal(未测试)</h4><p>保存为<code>install.bat</code>文件打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Windows Terminal]</span><br><span class="line">; 右键菜单中显示的名称</span><br><span class="line">@=<span class="string">&quot;Windows Terminal&quot;</span></span><br><span class="line">; 右键菜单中显示的图标</span><br><span class="line"><span class="string">&quot;Icon&quot;</span>=<span class="string">&quot;C:\\Toolkits\\Icons\\App\\WindowsTerminal.ico&quot;</span></span><br><span class="line">; 仅支持在按住Shift+右键的时候才显示</span><br><span class="line"><span class="string">&quot;Extended&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">; </span><br><span class="line"><span class="string">&quot;NoWorkingDirectory&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">; 在菜单中显示或隐藏</span><br><span class="line"><span class="string">&quot;ShowBasedOnVelocityId&quot;</span>=dword:00639bc8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Windows Terminal\Command]</span><br><span class="line">@=<span class="string">&quot;C:\\Users\\xyz\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -d \&quot;%V\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="fluent-terminal"><a href="#fluent-terminal" class="headerlink" title="fluent terminal"></a>fluent terminal</h3><p>好看但没有<code>windows terminal</code>那么方便,不过可以设置快捷键,也还行.</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install fluent-terminal</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载zip文件解压安装</span></span><br><span class="line">https://github.com/felixse/FluentTerminal/releases</span><br></pre></td></tr></table></figure>

<p>下载完毕后解压，选择 <code>Install.ps1</code> 文件，右键使用 powershell 运行。</p>
<h4 id="右键打开"><a href="#右键打开" class="headerlink" title="右键打开"></a>右键打开</h4><p>保存为<code>install.bat</code>文件打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\Directory\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%1\&quot;&quot; /f</span><br><span class="line"></span><br><span class="line">reg add &quot;HKCU\Software\Classes\Directory\Background\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%V\&quot;&quot; /f</span><br><span class="line"></span><br><span class="line">reg add &quot;HKCU\Software\Classes\LibraryFolder\Background\shell\Open Fluent Terminal here\command&quot; /d &quot;\&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\flute.exe\&quot; new \&quot;%%V\&quot;&quot; /f</span><br></pre></td></tr></table></figure>

<h4 id="右键关闭"><a href="#右键关闭" class="headerlink" title="右键关闭"></a>右键关闭</h4><p>保存为<code>Uninstall.bat</code>文件打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKCU\Software\Classes\Directory\shell\Open Fluent Terminal here&quot; /f</span><br><span class="line"></span><br><span class="line">reg delete &quot;HKCU\Software\Classes\Directory\Background\shell\Open Fluent Terminal here&quot; /f</span><br><span class="line">reg delete &quot;HKCU\Software\Classes\LibraryFolder\Background\shell\Open Fluent Terminal here&quot; /f</span><br></pre></td></tr></table></figure>

<h3 id="wsl-terminal"><a href="#wsl-terminal" class="headerlink" title="wsl-terminal"></a>wsl-terminal</h3><p>加u个人使用而言,如果多个wsl,则没那么舒爽.当然也可以像powershell那样<code>wsl -d Ubuntu</code>这样切换版本</p>
<h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/ly50247/article/details/80131656?ops_request_misc=%7B%22request_id%22:%22163481452216780366511110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481452216780366511110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-80131656.pc_search_ecpm_flag&utm_term=open-wsl&spm=1018.2226.3001.4187">使用 wsl-terminal 更好地体验 Win 10 WSL 终端环境</a></p>
<p>写的比较详细就不具体赘述了</p>
<h3 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h3><p>是一款集合ssh,串口的远程软件,但每次都需要开启后配置参数,对于懒人不友好.</p>
<h4 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/weixin_40705360/article/details/104008419?ops_request_misc=%7B%22request_id%22:%22163481518116780366579230%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481518116780366579230&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104008419.pc_search_ecpm_flag&utm_term=putty%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">putty使用教程(总结)</a></p>
<h3 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h3><p>具有putty相似的功能,同时还有<strong>stfp</strong>文件传输,只需点击即可使用.但对于需要调试gui程序而言,需要购买正式版,嗯…………大佬随意.</p>
<h4 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/hxy1625309592/article/details/110356421?ops_request_misc=%7B%22request_id%22:%22163481523916780269886657%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481523916780269886657&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-110356421.pc_search_ecpm_flag&utm_term=xhsell&spm=1018.2226.3001.4187">Xshell使用基础教程_</a></p>
<h3 id="Mobaxterm"><a href="#Mobaxterm" class="headerlink" title="Mobaxterm"></a>Mobaxterm</h3><p>集百家之长于一身,因此使用起来没那么方便,但使用后非常舒爽.值得一提的是,远程文件是可以根据终端实时更新的,同时<strong>支持拖拽文件,新建文件,文件夹,本地编辑文件</strong>,这就很爽了.</p>
<h4 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://blog.csdn.net/qq_28721869/article/details/114652520?ops_request_misc=%7B%22request_id%22:%22163481551616780269883117%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163481551616780269883117&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114652520.pc_search_ecpm_flag&utm_term=Mobaxterm&spm=1018.2226.3001.4187">全能终端神器mobaxterm入坑指南</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>tf转换</title>
    <url>/blog/2022/02/17/tf%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://blog.csdn.net/tiancailx/article/details/111593526?spm=1001.2014.3001.5501">(109条消息) 从零开始搭二维激光SLAM — 基于PL-ICP的激光雷达里程计_李想的博客-CSDN博客_base_to_laser</a> </p>
<p> <a href="https://blog.csdn.net/qq_43481884/article/details/105429655">(109条消息) ROS小白学习历程-map/odom/base_link坐标系的关系及其转换_kuai-的博客-CSDN博客</a> </p>
<h1 id="常见坐标系"><a href="#常见坐标系" class="headerlink" title="常见坐标系"></a>常见坐标系</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map: 地图坐标系，也被称为世界坐标系，是静止不动的</span><br><span class="line">odom: 里程计坐标系，相对于map来说一般情况下是静止的，有些情况下会变动（定位节点为了修正机器人的位姿从而改变了map-&gt;odom间的坐标变换）</span><br><span class="line">base_link: 代表机器人的旋转中心的坐标系，相对于odom来说base_link是运动的</span><br><span class="line">laser_link: 激光雷达的坐标系，相对于base_link来说是静止的，因为雷达装在机器人上，雷达不会自己飞起来</span><br><span class="line">一般依赖关系为:map -&gt; odom -&gt; base_link -&gt; laser_link</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, odom一般相对于map是静止的但由于odom有累计误差,所以还是会有偏移,并且map与odom之间存在父子关系</span><br><span class="line">2, 参照系紧紧粘在移动机器人基座上的任何一个位置和角度,一般我取控制中心</span><br><span class="line">3, odom到base_link的坐标转换是从运动源计算出来广播的。</span><br><span class="line">4, map到base_link的坐标转换是被定位模块计算出来的. 但定位模块并不发布map到base_link的转换. 相反它先接受		从odom到base_link的转换, 再计算并广播map到odom的位置转换关系。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu14</title>
    <url>/blog/2021/11/23/ubuntu14/</url>
    <content><![CDATA[<h1 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装服务</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ssh服务是否启动</span></span><br><span class="line">sudo ps -e |grep ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ssh服务</span></span><br><span class="line">sudo service ssh start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置服务</span></span><br><span class="line">sudo gedit /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面相关配置：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin prohibit-password</span><br><span class="line">StrictModes yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">更改为：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line"><span class="meta">#</span><span class="bash">PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh</span></span><br><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak </span><br><span class="line">sudo nano /etc/apt/sources.list </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h1 id="右键没有terminal"><a href="#右键没有terminal" class="headerlink" title="右键没有terminal"></a>右键没有terminal</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nautilus-open-terminal </span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/blog/2021/10/19/ssh/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%7B%22request_id%22:%22163464883116780261940241%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163464883116780261940241&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82810342.pc_search_ecpm_flag&utm_term=ssh&spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法_德prince-CSDN博客_ssh</a></li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-client </span><br><span class="line">sudo apt-get install openssh-server </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动情况</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 停止 重启</span></span><br><span class="line">sudo /etc/init.d/ssh start </span><br><span class="line">sudo /etc/init.d/ssh stop  #server停止ssh服务 </span><br><span class="line">sudo /etc/init.d/ssh restart  #server重启ssh服务</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基础登录</span></span><br><span class="line">ssh ldz@192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用图形界面</span></span><br><span class="line">ssh -X ldz@192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果客户机的用户名和服务器的用户名相同，登录时可以省略用户名。</span></span><br><span class="line">ssh 192.168.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> -p修改端口,默认22端口</span></span><br><span class="line">ssh -p 1234 ldz@192.168.0.1</span><br></pre></td></tr></table></figure>

<p>第一次连时需要确认连接,选yes,即可成功</p>
<p>遇到问题:</p>
<p><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOT</code></p>
<p>bug解决:</p>
<p>ssh-keygen -R 192.168.0.1</p>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p><code>Ctrl+d</code>或者<code>exit</code></p>
<h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><h5 id="在本机生成密钥对"><a href="#在本机生成密钥对" class="headerlink" title="在本机生成密钥对"></a>在本机生成密钥对</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa   #-t表示类型选项，这里采用rsa加密算法</span><br></pre></td></tr></table></figure>

<h5 id="将公钥复制到远程主机"><a href="#将公钥复制到远程主机" class="headerlink" title="将公钥复制到远程主机"></a>将公钥复制到远程主机</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id ldz@192.168.0.1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18查看磁盘占用</title>
    <url>/blog/2022/03/30/ubuntu18%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/cym_anhui/article/details/82736198?ops_request_misc=%7B%22request_id%22:%22164861859916782089375824%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164861859916782089375824&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82736198.142%5Ev5%5Earticle_score_rank,143%5Ev6%5Econtrol&utm_term=ubuntu%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8&spm=1018.2226.3001.4187">(121条消息) ubuntu查看磁盘占用和分配情况_forAllforMe的博客-CSDN博客_ubuntu 查看磁盘占用</a> </p>
<h1 id="df-hl"><a href="#df-hl" class="headerlink" title="df  -hl"></a>df  -hl</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            978M     0  978M   0% /dev</span><br><span class="line">tmpfs           200M  3.6M  197M   2% /run</span><br><span class="line">/dev/sda5        28G   12G   15G  45% /</span><br><span class="line">tmpfs          1000M  216K  999M   1% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs          1000M     0 1000M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           200M   52K  200M   1% /run/user/1000</span><br></pre></td></tr></table></figure>

<h1 id="sudo-fdisk-l"><a href="#sudo-fdisk-l" class="headerlink" title="sudo fdisk -l"></a>sudo fdisk -l</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Disk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x0b032873</span><br><span class="line"></span><br><span class="line">Device     Boot    Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *        2046 60547071 60545026 28.9G  5 Extended</span><br><span class="line">/dev/sda5           2048 58593279 58591232   28G 83 Linux</span><br><span class="line">/dev/sda6       58595328 60547071  1951744  953M 82 Linux swap / Solaris</span><br></pre></td></tr></table></figure>

<h1 id="free-m-查看内存"><a href="#free-m-查看内存" class="headerlink" title="free -m  查看内存"></a>free -m  查看内存</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lostman@lostman-MS-6702E:~/桌面$ free -m</span><br><span class="line">                      total       used       free     shared    buffers     cached</span><br><span class="line">Mem:               496        457         38          0          8            104</span><br><span class="line">-/+ buffers/cache:           344        151</span><br><span class="line">Swap:              510        156        354</span><br></pre></td></tr></table></figure>

<h1 id="top-查看内存与cpu"><a href="#top-查看内存与cpu" class="headerlink" title="top 查看内存与cpu"></a>top 查看内存与cpu</h1>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18源</title>
    <url>/blog/2021/10/19/ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    <content><![CDATA[<h4 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h4><p>参考网址：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563">Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源</a></p>
<h5 id="阿里源-（Ubuntu-18-04）"><a href="#阿里源-（Ubuntu-18-04）" class="headerlink" title="阿里源 （Ubuntu 18.04）"></a>阿里源 （Ubuntu 18.04）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h5 id="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"><a href="#西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）" class="headerlink" title="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"></a>西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="网易源"><a href="#网易源" class="headerlink" title="网易源"></a>网易源</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h5 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##中科大源</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="树莓派更换国内源"><a href="#树莓派更换国内源" class="headerlink" title="树莓派更换国内源"></a>树莓派更换国内源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加入,Ctrl+s保存,Ctrl+X退出.</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改系统更新源</span></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sud apt upgrade</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu18换回原来源"><a href="#Ubuntu18换回原来源" class="headerlink" title="Ubuntu18换回原来源"></a>Ubuntu18换回原来源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to use the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide useful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#x27;s</span><br><span class="line">## &#x27;partner&#x27; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu users.</span><br><span class="line"># deb http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"># deb-src http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"></span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br><span class="line"># deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux使用</title>
    <url>/blog/2021/10/19/tmux/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
</li>
<li><p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></p>
</li>
<li><p><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></p>
</li>
<li><p><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></p>
</li>
</ul>
<h3 id="便捷快捷键"><a href="#便捷快捷键" class="headerlink" title="便捷快捷键"></a>便捷快捷键</h3><p>注意前缀键<code>Ctrl+b</code>按完后松开，再按下其他键。</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl+d</td>
<td align="center">退出</td>
</tr>
<tr>
<td align="center">Ctrl+b s</td>
<td align="center">列出所有会话</td>
</tr>
<tr>
<td align="center">Ctrl+b %</td>
<td align="center">划分左右两个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b “</td>
<td align="center">划分上下两个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b o</td>
<td align="center">切换到下一个窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b x</td>
<td align="center">关闭当前窗格</td>
</tr>
<tr>
<td align="center">Ctrl+b c</td>
<td align="center">创建一个新窗口</td>
</tr>
<tr>
<td align="center">Ctrl+b n</td>
<td align="center">切换到下一个窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>win11关闭防火墙</title>
    <url>/blog/2022/02/15/win11%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://jingyan.baidu.com/article/f00622282d18b5bad3f0c89c.html">Windows11如何关闭防火墙-百度经验 (baidu.com)</a> </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>搜索框搜索:  Windows defender 防火墙 </li>
<li>进入防火墙后,找到[ 启用或关闭Windows defender 防火墙 ],设置</li>
</ul>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode</title>
    <url>/blog/2021/11/13/vscode/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_48468423/article/details/118950592?ops_request_misc=%7B%22request_id%22:%22163676464916780262571699%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676464916780262571699&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118950592.pc_search_mgc_flag&utm_term=vscode&spm=1018.2226.3001.4187">VsCode安装和配置c/c++环境（超完整，小白专用）_黄化的多多-CSDN博客_vscode配置c++环境</a></p>
<p><a href="https://blog.csdn.net/iceboy314159/article/details/107886801?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107886801.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">vscode 与 WSL 进行linux开发_从零开始-CSDN博客_vscode wsl</a></p>
<p><a href="https://blog.csdn.net/reeeeein/article/details/104628415?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104628415.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">在WSL中安装并配置VSCode_reeeeein的博客-CSDN博客_wsl安装vscode</a></p>
<p><a href="https://blog.csdn.net/weixin_43876113/article/details/105261577?ops_request_misc=%7B%22request_id%22:%22163676572516780271510489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163676572516780271510489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-105261577.pc_search_mgc_flag&utm_term=vscode+wsl&spm=1018.2226.3001.4187">WIN10安装WSL并使用VScode连接WSL_作业君的博客-CSDN博客_vscode wsl</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>vscode</code>配置<code>wsl</code></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="下载安装vscode"><a href="#下载安装vscode" class="headerlink" title="下载安装vscode:"></a>下载安装<code>vscode</code>:</h2><p><a href="https://code.visualstudio.com/Download">Download Visual Studio Code - Mac, Linux, Windows</a></p>
<p>安装<code>win</code>版,一直下一步,注意改一下安装位置</p>
<h2 id="连接wsl"><a href="#连接wsl" class="headerlink" title="连接wsl"></a>连接<code>wsl</code></h2><p><code>ctrl + shift + x</code>打开应用商店,输入<code>Remote - WSL</code>安装由于事先安装好<code>wsl</code>了</p>
<p>打开左侧小电脑图标,点击进入即可进入<code>wsl</code>终端,可以通过点击左下角⚪,▲进入终端命令行</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl+docker+ssh+mobaxterm</title>
    <url>/blog/2022/04/16/wsl+docker+ssh+mobaxterm/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/wooyang2018/article/details/113090465">(124条消息) Docker容器使用MobaXterm连接_wooyang2018的博客-CSDN博客_mobaxterm 连接docker</a> </p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装与使用</title>
    <url>/blog/2021/10/19/wsl/</url>
    <content><![CDATA[<h3 id="wsl安装"><a href="#wsl安装" class="headerlink" title="wsl安装"></a>wsl安装</h3><p>参考网址：</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/terminal/get-started">Windows 终端安装 | Microsoft Docs</a></p>
<p><a href="https://hengyumo.blog.csdn.net/article/details/102544521">玩转Linux(1)——安装Windows亲儿子Linux系统之WSL之最全攻略之最佳体验之究极无敌舒服_衡与墨的博客-CSDN博客</a></p>
<p>管理员身份运行Powershell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br><span class="line"> wsl --install -d Ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="wsl使用"><a href="#wsl使用" class="headerlink" title="wsl使用"></a>wsl使用</h3><ul>
<li><h4 id="进入linux系统"><a href="#进入linux系统" class="headerlink" title="进入linux系统"></a>进入linux系统</h4></li>
</ul>
<p>命令行输入<code>wsl</code>或者<code>bash</code>，进入linux系统</p>
<ul>
<li><h4 id="linux初始配置"><a href="#linux初始配置" class="headerlink" title="linux初始配置"></a>linux初始配置</h4></li>
</ul>
<h5 id="添加sudo，这样就不用输密码了"><a href="#添加sudo，这样就不用输密码了" class="headerlink" title="添加sudo，这样就不用输密码了"></a>添加sudo，这样就不用输密码了</h5><p><img src="https://img-blog.csdnimg.cn/20191014120116452.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191014142719338.png" alt="在这里插入图片描述"></p>
<p>修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">sudo ALL=(ALL:ALL) ALL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改为</span></span><br><span class="line"><span class="meta">%</span><span class="bash">sudo ALL=(ALL:ALL) NOPASSWD:ALL</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4></li>
</ul>
<p>参考网址：</p>
<p><a href="https://blog.csdn.net/Alisebeast/article/details/106680267">WSL2运行图像应用或图形界面_Alisebeast的博客-CSDN博客_wsl2 图形界面</a></p>
<p><a href="https://blog.csdn.net/qq_45036130/article/details/105623451">在WSL中打开与显示图片的简单方法_neetneves的博客-CSDN博客</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;export DISPLAY=localhost:0&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>测试查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $DISPLAY</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">xclock</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h4></li>
</ul>
<p>参考网址：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563">Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源</a></p>
<ul>
<li><h4 id="wsl命令详解"><a href="#wsl命令详解" class="headerlink" title="wsl命令详解"></a>wsl命令详解</h4></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wsl或bash</td>
<td align="center">打开默认子系统</td>
</tr>
<tr>
<td align="center">wsl -d Ubuntu18</td>
<td align="center">打开Ubuntu18子系统</td>
</tr>
<tr>
<td align="center">wsl -l -o</td>
<td align="center">可安装的有效分发的列表</td>
</tr>
<tr>
<td align="center">wsl –install -d Ubuntu</td>
<td align="center">安装默认Ubuntu</td>
</tr>
<tr>
<td align="center">wsl –shutdown</td>
<td align="center">关闭子系统</td>
</tr>
<tr>
<td align="center">wsl –import Ubuntu-20.04 e:\ubuntu d:\ubuntu20.04.tar –version 2</td>
<td align="center">导入已存的操作系统</td>
</tr>
<tr>
<td align="center">wsl –export Ubuntu-20.04 e:\ubuntu20.04.tar</td>
<td align="center">导出操作子系统</td>
</tr>
<tr>
<td align="center">wsl -l -v</td>
<td align="center">显示所有子系统</td>
</tr>
<tr>
<td align="center">wsl -s Ubuntu-20.04</td>
<td align="center">将分发版设置为默认值</td>
</tr>
<tr>
<td align="center">bash -c “ls”</td>
<td align="center">windows命令提示符</td>
</tr>
<tr>
<td align="center">wsl –unregister Ubuntu-20.04</td>
<td align="center">注销分发版</td>
</tr>
<tr>
<td align="center">wslconfig /s Ubuntu-18.04</td>
<td align="center">修改默认子系统</td>
</tr>
</tbody></table>
<ul>
<li><h4 id="wsl-terminal"><a href="#wsl-terminal" class="headerlink" title="wsl-terminal"></a><em>wsl</em>-terminal</h4></li>
</ul>
<p>参考网址：</p>
<p><a href="https://github.com/mskyaxl/wsl-terminal">mskyaxl/wsl-terminal: Terminal emulator for Windows Subsystem for Linux (WSL) (github.com)</a></p>
<p>最常用的依旧是<code>Windows Terminal</code>参考网址</p>
<p>[Windows Terminal配置_人间世-CSDN博客](<a href="https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows">https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows</a> terminal&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-111354738.pc_search_ecpm_flag&amp;spm=1018.2226.3001.4187)</p>
<p><a href="https://blog.csdn.net/c13232906050/article/details/90698772?ops_request_misc=%7B%22request_id%22:%22163439638216780261990702%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163439638216780261990702&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-90698772.pc_search_ecpm_flag&utm_term=windows+terminal%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载</a></p>
<h5 id="Windows-Terminal安装"><a href="#Windows-Terminal安装" class="headerlink" title="Windows Terminal安装"></a>Windows Terminal安装</h5><p>方式一：</p>
<p>微软商店安装</p>
<p><a href="https://www.microsoft.com/zh-cn/p/windows-terminal/9n0dx20hk701?rtc=1&activetab=pivot:overviewtab">购买 Windows Terminal - Microsoft Store zh-CN</a></p>
<p>方式二：</p>
<p><a href="https://blog.csdn.net/c13232906050/article/details/90698772?ops_request_misc=%7B%22request_id%22:%22163439638216780261990702%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163439638216780261990702&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-90698772.pc_search_ecpm_flag&utm_term=windows+terminal%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载</a></p>
<p>方式三：</p>
<p><a href="https://github.com/microsoft/Terminal">https://github.com/microsoft/Terminal</a> </p>
<p>使用Visual Studio打开构建运行</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl2+docker+carto</title>
    <url>/blog/2022/04/16/wsl2+docker+carto/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/vippomelo/article/details/121136484?ops_request_misc=%7B%22request_id%22:%22165008013316782094873918%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165008013316782094873918&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121136484.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=wsl%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">(124条消息) 【亲测有效】离线安装WSL windows 10子系统Ubuntu 20.04方法_青柚创客的博客-CSDN博客_wsl 离线安装</a> </p>
<p> <a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">Ubuntu - Docker — 从入门到实践 (gitbook.io)</a> </p>
<p>  <a href="https://my.oschina.net/u/4154543/blog/5312374">Docker快速搭建cartographer/cartographer_ros编译开发环境 - AustinZ的个人空间 - OSCHINA - 中文开源技术交流社区</a> </p>
<h1 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h1><ul>
<li>配置好wsl2环境( <a href="https://peitianyu.github.io/blog/2021/10/19/wsl/">wsl安装</a> ),离线下载<a href="https://aka.ms/wsl-ubuntu-1804">ubuntu18</a></li>
<li>下载完成后,双击安装</li>
</ul>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置http</span></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置docker下载安装环境</span>    </span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">  $</span><span class="bash">(lsb_release -cs) stable<span class="string">&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 安装</span></span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 启动</span></span></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<h1 id="安装docker-carto"><a href="#安装docker-carto" class="headerlink" title="安装docker_carto"></a>安装docker_carto</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> ubuntu18.04</span></span><br><span class="line">	docker pull fdko11/ros:bionic-melodic-cartographer</span><br><span class="line"><span class="meta">	#</span><span class="bash"> ubuntu20.04</span></span><br><span class="line">	docker pull fdko11/ros:focal-noetic-cartographer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行并创建docker</span></span><br><span class="line">	docker run -it --name=&quot;carto&quot; --net=host -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix fdko11/ros:bionic-melodic-cartographer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户名:carto 密码:123456 有sudo权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要在容器中手动进行一次abseil库编译安装</span></span><br><span class="line">su carto</span><br><span class="line">cd /home/carto/carto_ws/abseil-cpp/</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G Ninja   -DCMAKE_BUILD_TYPE=Release   -DCMAKE_POSITION_INDEPENDENT_CODE=ON   -DCMAKE_INSTALL_PREFIX=/usr/local/stow/absl   ..</span><br><span class="line">sudo ninja install</span><br><span class="line">cd /usr/local/stow</span><br><span class="line">sudo stow absl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译carto</span></span><br><span class="line">su carto</span><br><span class="line">cd /home/carto/carto_ws</span><br><span class="line">source /opt/ros/melodic/setup.bash</span><br><span class="line">catkin_make_isolated --install --use-ninja</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl使用串口</title>
    <url>/blog/2021/12/01/wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/chentuo2000/article/details/116447956?ops_request_misc=&request_id=&biz_id=102&utm_term=wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-116447956.pc_search_mgc_flag&spm=1018.2226.3001.4187">Win10的Linux子系统Ubuntu使用串口_晨之清风-CSDN博客</a></p>
<p><a href="https://www.scivision.dev/usb-tty-windows-subsystem-for-linux/">WSL | 上的 USB 到串行适配器科学计算|科学视讯 (scivision.dev)</a></p>
<p>由于本人技术原因usb转串行没成功</p>
<p><a href="https://blog.csdn.net/yanhuan136675/article/details/82766466?ops_request_misc=%7B%22request_id%22:%22163832358116780269848091%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163832358116780269848091&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-82766466.pc_search_mgc_flag&utm_term=linux%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1&spm=1018.2226.3001.4187">Linux下串口收发通信_颜言研的博客-CSDN博客_linux串口通信</a></p>
<h1 id="minicom使用"><a href="#minicom使用" class="headerlink" title="minicom使用"></a>minicom使用</h1><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装minicom</span></span><br><span class="line">sudo apt-get install minicom</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置串口,主要该串口号ttyS1,以及将硬件流改为no</span></span><br><span class="line">sudo minicom -s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存</span></span><br><span class="line">Save setup as df1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">sudo minicom</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+A E:回显</span><br><span class="line">Ctrl+A W：当显示的内容超过一行之后自动换行</span><br><span class="line">Ctrl+A C：清屏</span><br><span class="line">Ctrl+A O：打开配置选项</span><br><span class="line">Ctrl+A X：退出minicom</span><br></pre></td></tr></table></figure>

<h1 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usart.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  _USART_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _USART_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//串口相关的头文件    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">/*标准输入输出定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">/*标准函数库定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">/*Unix 标准函数定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>      <span class="comment">/*文件控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;termios.h&gt;</span>    <span class="comment">/*PPSIX 终端控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">/*错误号定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>    </span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//宏定义    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE  -1    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE   0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Open</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>*port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART0_Close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Set</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Init</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Recv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *rcv_buf,<span class="keyword">int</span> data_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *send_buf,<span class="keyword">int</span> data_len)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usart.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Open  </span></span><br><span class="line"><span class="comment">*功能：             打开串口并返回串口设备文件描述  </span></span><br><span class="line"><span class="comment">*入口参数：         fd      文件描述符</span></span><br><span class="line"><span class="comment">                    port    串口号(ttyS0,ttyS1,ttyS2)  </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Open</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>*port)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    fd = open( port, O_RDWR|O_NOCTTY|O_NDELAY);    </span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;Can&#x27;t Open Serial Port&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//恢复串口为阻塞状态                                   </span></span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, <span class="number">0</span>) &lt; <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl failed!\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl=%d\n&quot;</span>,fcntl(fd, F_SETFL,<span class="number">0</span>));    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//测试是否为终端设备        </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == isatty(STDIN_FILENO))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;standard input is not a terminal device\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>(FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;isatty success!\n&quot;</span>);    </span><br><span class="line">    &#125;                  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd-&gt;open=%d\n&quot;</span>,fd);    </span><br><span class="line">    <span class="keyword">return</span> fd;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Close  </span></span><br><span class="line"><span class="comment">*功能：             关闭串口并返回串口设备文件描述  </span></span><br><span class="line"><span class="comment">*入口参数：         fd          文件描述符   </span></span><br><span class="line"><span class="comment">                    port        串口号(ttyS0,ttyS1,ttyS2)  </span></span><br><span class="line"><span class="comment">*出口参数：void  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART0_Close</span><span class="params">(<span class="keyword">int</span> fd)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    close(fd);    </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：             UART0_Set  </span></span><br><span class="line"><span class="comment">*功能：             设置串口数据位，停止位和效验位  </span></span><br><span class="line"><span class="comment">*入口参数：         fd          串口文件描述符</span></span><br><span class="line"><span class="comment">*                   speed       串口速度  </span></span><br><span class="line"><span class="comment">*                   flow_ctrl   数据流控制  </span></span><br><span class="line"><span class="comment">*                   databits    数据位   取值为 7 或者8  </span></span><br><span class="line"><span class="comment">*                   stopbits    停止位   取值为 1 或者2  </span></span><br><span class="line"><span class="comment">*                   parity      效验类型 取值为N,E,O,,S  </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Set</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">int</span>   i;    </span><br><span class="line">    <span class="keyword">int</span>   status;    </span><br><span class="line">    <span class="keyword">int</span>   speed_arr[] = &#123; B115200, B19200, B9600, B4800, B2400, B1200, B300&#125;;    </span><br><span class="line">    <span class="keyword">int</span>   name_arr[] = &#123;<span class="number">115200</span>,  <span class="number">19200</span>,  <span class="number">9600</span>,  <span class="number">4800</span>,  <span class="number">2400</span>,  <span class="number">1200</span>,  <span class="number">300</span>&#125;;    </span><br><span class="line">             </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">options</span>;</span>    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">/*  tcgetattr(fd,&amp;options)得到与fd指向对象的相关参数，并将它们保存于options,该函数还可以测试配置是否正确，</span></span><br><span class="line"><span class="comment">        该串口是否可用等。若调用成功，函数返回值为0，若调用失败，函数返回值为1.  */</span>    </span><br><span class="line">    <span class="keyword">if</span>( tcgetattr( fd,&amp;options)  !=  <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;SetupSerial 1&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span>(FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设置串口输入波特率和输出波特率    </span></span><br><span class="line">    <span class="keyword">for</span> ( i= <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(speed_arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);  i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>  (speed == name_arr[i])    </span><br><span class="line">        &#123;                 </span><br><span class="line">            cfsetispeed(&amp;options, speed_arr[i]);     </span><br><span class="line">            cfsetospeed(&amp;options, speed_arr[i]);      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;         </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//修改控制模式，保证程序不会占用串口    </span></span><br><span class="line">    options.c_cflag |= CLOCAL;    </span><br><span class="line">    <span class="comment">//修改控制模式，使得能够从串口中读取输入数据    </span></span><br><span class="line">    options.c_cflag |= CREAD;    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设置数据流控制    </span></span><br><span class="line">    <span class="keyword">switch</span>(flow_ctrl)    </span><br><span class="line">    &#123;    </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :<span class="comment">//不使用流控制    </span></span><br><span class="line">              options.c_cflag &amp;= ~CRTSCTS;    </span><br><span class="line">              <span class="keyword">break</span>;       </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :<span class="comment">//使用硬件流控制    </span></span><br><span class="line">              options.c_cflag |= CRTSCTS;    </span><br><span class="line">              <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> :<span class="comment">//使用软件流控制    </span></span><br><span class="line">              options.c_cflag |= IXON | IXOFF | IXANY;    </span><br><span class="line">              <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//设置数据位    </span></span><br><span class="line">    <span class="comment">//屏蔽其他标志位    </span></span><br><span class="line">    options.c_cflag &amp;= ~CSIZE;    </span><br><span class="line">    <span class="keyword">switch</span> (databits)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>    :    </span><br><span class="line">                     options.c_cflag |= CS5;    </span><br><span class="line">                     <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>    :    </span><br><span class="line">                     options.c_cflag |= CS6;    </span><br><span class="line">                     <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>    :        </span><br><span class="line">                 options.c_cflag |= CS7;    </span><br><span class="line">                 <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:        </span><br><span class="line">                 options.c_cflag |= CS8;    </span><br><span class="line">                 <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:       </span><br><span class="line">                 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported data size\n&quot;</span>);    </span><br><span class="line">                 <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//设置校验位    </span></span><br><span class="line">    <span class="keyword">switch</span> (parity)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">//无奇偶校验位。    </span></span><br><span class="line">                 options.c_cflag &amp;= ~PARENB;     </span><br><span class="line">                 options.c_iflag &amp;= ~INPCK;        </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:      </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:<span class="comment">//设置为奇校验        </span></span><br><span class="line">                 options.c_cflag |= (PARODD | PARENB);     </span><br><span class="line">                 options.c_iflag |= INPCK;                 </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:     </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:<span class="comment">//设置为偶校验      </span></span><br><span class="line">                 options.c_cflag |= PARENB;           </span><br><span class="line">                 options.c_cflag &amp;= ~PARODD;           </span><br><span class="line">                 options.c_iflag |= INPCK;          </span><br><span class="line">                 <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">//设置为空格     </span></span><br><span class="line">                 options.c_cflag &amp;= ~PARENB;    </span><br><span class="line">                 options.c_cflag &amp;= ~CSTOPB;    </span><br><span class="line">                 <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">default</span>:      </span><br><span class="line">                 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported parity\n&quot;</span>);        </span><br><span class="line">                 <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">// 设置停止位     </span></span><br><span class="line">    <span class="keyword">switch</span> (stopbits)    </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:       </span><br><span class="line">                 options.c_cflag &amp;= ~CSTOPB; <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:       </span><br><span class="line">                 options.c_cflag |= CSTOPB; <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">default</span>:       </span><br><span class="line">                       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unsupported stop bits\n&quot;</span>);     </span><br><span class="line">                       <span class="keyword">return</span> (FALSE);    </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//修改输出模式，原始数据输出    </span></span><br><span class="line">    options.c_oflag &amp;= ~OPOST;    </span><br><span class="line">      </span><br><span class="line">    options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);    </span><br><span class="line">    <span class="comment">//options.c_lflag &amp;= ~(ISIG | ICANON);    </span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">//设置等待时间和最小接收字符    </span></span><br><span class="line">    options.c_cc[VTIME] = <span class="number">1</span>; <span class="comment">/* 读取一个字符等待1*(1/10)s */</span>      </span><br><span class="line">    options.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">/* 读取字符的最少个数为1 */</span>    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//如果发生数据溢出，接收数据，但是不再读取 刷新收到的数据但是不读    </span></span><br><span class="line">    tcflush(fd,TCIFLUSH);    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//激活配置 (将修改后的termios数据设置到串口中）    </span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd,TCSANOW,&amp;options) != <span class="number">0</span>)      </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;com set error!\n&quot;</span>);      </span><br><span class="line">        <span class="keyword">return</span> (FALSE);     </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> (TRUE);     </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">*名称：                UART0_Init()  </span></span><br><span class="line"><span class="comment">*功能：                串口初始化  </span></span><br><span class="line"><span class="comment">*入口参数：            fd         文件描述符    </span></span><br><span class="line"><span class="comment">*                      speed      串口速度  </span></span><br><span class="line"><span class="comment">*                      flow_ctrl  数据流控制  </span></span><br><span class="line"><span class="comment">*                      databits   数据位   取值为 7 或者8  </span></span><br><span class="line"><span class="comment">*                      stopbits   停止位   取值为 1 或者2  </span></span><br><span class="line"><span class="comment">*                      parity     效验类型 取值为N,E,O,,S  </span></span><br><span class="line"><span class="comment">*                        </span></span><br><span class="line"><span class="comment">*出口参数：正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Init</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> speed,<span class="keyword">int</span> flow_ctrl,<span class="keyword">int</span> databits,<span class="keyword">int</span> stopbits,<span class="keyword">int</span> parity)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err;    </span><br><span class="line">    <span class="comment">//设置串口数据帧格式    </span></span><br><span class="line">    <span class="keyword">if</span> (UART0_Set(fd,<span class="number">115200</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>) == FALSE)    </span><br><span class="line">    &#123;                                                             </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span>  TRUE;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="comment">/*******************************************************************  </span></span><br><span class="line"><span class="comment">* 名称：            UART0_Recv  </span></span><br><span class="line"><span class="comment">* 功能：            接收串口数据  </span></span><br><span class="line"><span class="comment">* 入口参数：        fd         文件描述符      </span></span><br><span class="line"><span class="comment">*                   rcv_buf    接收串口中数据存入rcv_buf缓冲区中  </span></span><br><span class="line"><span class="comment">*                   data_len   一帧数据的长度  </span></span><br><span class="line"><span class="comment">* 出口参数：        正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Recv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *rcv_buf,<span class="keyword">int</span> data_len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len,fs_sel;    </span><br><span class="line">    fd_set fs_read;    </span><br><span class="line">       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    </span><br><span class="line">       </span><br><span class="line">    FD_ZERO(&amp;fs_read);    </span><br><span class="line">    FD_SET(fd,&amp;fs_read);    </span><br><span class="line">       </span><br><span class="line">    time.tv_sec = <span class="number">10</span>;    </span><br><span class="line">    time.tv_usec = <span class="number">0</span>;    </span><br><span class="line">       </span><br><span class="line">    <span class="comment">//使用select实现串口的多路通信    </span></span><br><span class="line">    fs_sel = select(fd+<span class="number">1</span>,&amp;fs_read,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;time);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs_sel = %d\n&quot;</span>,fs_sel);    </span><br><span class="line">    <span class="keyword">if</span>(fs_sel)    </span><br><span class="line">    &#123;    </span><br><span class="line">        len = read(fd,rcv_buf,data_len);    </span><br><span class="line">        <span class="keyword">return</span> len;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/********************************************************************  </span></span><br><span class="line"><span class="comment">* 名称：            UART0_Send  </span></span><br><span class="line"><span class="comment">* 功能：            发送数据  </span></span><br><span class="line"><span class="comment">* 入口参数：        fd           文件描述符      </span></span><br><span class="line"><span class="comment">*                   send_buf     存放串口发送数据  </span></span><br><span class="line"><span class="comment">*                   data_len     一帧数据的个数  </span></span><br><span class="line"><span class="comment">* 出口参数：        正确返回为1，错误返回为0  </span></span><br><span class="line"><span class="comment">*******************************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART0_Send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *send_buf,<span class="keyword">int</span> data_len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;    </span><br><span class="line">       </span><br><span class="line">    len = write(fd,send_buf,data_len);    </span><br><span class="line">    <span class="keyword">if</span> (len == data_len )    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send data is %s\n&quot;</span>,send_buf);  </span><br><span class="line">        <span class="keyword">return</span> len;    </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">else</span>       </span><br><span class="line">    &#123;    </span><br><span class="line">                   </span><br><span class="line">        tcflush(fd,TCOFLUSH);    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">/*标准输入输出定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">/*标准函数库定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">/*Unix 标准函数定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>      <span class="comment">/*文件控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;termios.h&gt;</span>    <span class="comment">/*PPSIX 终端控制定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">/*错误号定义*/</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;           <span class="comment">//文件描述符，先定义一个与程序无关的值，防止fd为任意值导致程序出bug    </span></span><br><span class="line">    <span class="keyword">int</span> err;               <span class="comment">//返回调用函数的状态    </span></span><br><span class="line">    <span class="keyword">int</span> len;                            </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> rcv_buf[<span class="number">256</span>];             </span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">     fd = UART0_Open(fd,<span class="string">&quot;ttyS1&quot;</span>); <span class="comment">//打开串口，返回文件描述符   </span></span><br><span class="line">     <span class="keyword">do</span>  </span><br><span class="line">    &#123;    </span><br><span class="line">        err = UART0_Init(fd,<span class="number">115200</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>);    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set Port Exactly!\n&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);   </span><br><span class="line">    &#125;<span class="keyword">while</span>(FALSE == err || FALSE == fd);    </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>)    <span class="comment">//开发板向pc发送数据的模式</span></span><br><span class="line">    &#123;   </span><br><span class="line">        send_buf = (<span class="keyword">char</span>*) <span class="string">&quot;hello world!&quot;</span>; </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">        &#123;    </span><br><span class="line">            len = UART0_Send(fd,send_buf,<span class="number">40</span>);    </span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send data successful\n&quot;</span>);   </span><br><span class="line">            sleep(<span class="number">1</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">        UART0_Close(fd);                 </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">//开发板收到pc发送的数据的模式                 </span></span><br><span class="line">    &#123;                                          </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//循环读取数据    </span></span><br><span class="line">        &#123;   </span><br><span class="line">            len = UART0_Recv(fd, rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));    </span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>)    </span><br><span class="line">            &#123;    </span><br><span class="line">                rcv_buf[len] = <span class="string">&#x27;\0&#x27;</span>;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;receive data is %s\n&quot;</span>,rcv_buf);    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cannot receive data\n&quot;</span>);    </span><br><span class="line">            &#125;    </span><br><span class="line">            sleep(<span class="number">1</span>);    </span><br><span class="line">        &#125;                </span><br><span class="line">        UART0_Close(fd);     </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>tool</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>win自启动程序</title>
    <url>/blog/2021/10/19/win%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="记事本写入脚本"><a href="#记事本写入脚本" class="headerlink" title="记事本写入脚本"></a>记事本写入脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time  /t  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>  %username%  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>  %computername%  &gt;&gt;c:\<span class="built_in">test</span>\log1.log</span><br></pre></td></tr></table></figure>

<p>另存为<code>start.bat</code>，无人见类型为所有类型</p>
<h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><p>点击<code>运行</code>，输入<code>gpedit.msc</code>,具体操作如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190304120752202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h3><p>可以发现，脚本运行了</p>
<p><img src="https://img-blog.csdnimg.cn/20190304120752279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>一种嵌入式设计模式</title>
    <url>/blog/2021/12/22/%E4%B8%80%E7%A7%8D%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用<code>set</code>与<code>get</code>方式实现的金字塔型架构,最下层仅提供函数调用,例如tcp,udp,uart,gpio等,第二层是模块层,这一层通过pthread线程实现自循环式模块实现,通过get与set对模块数据进行获取与设置.最后是逻辑层,仅对下层数据进行逻辑操作,不做模块实现.</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcontrolcan.so</span><br><span class="line">└── src</span><br><span class="line">    ├── GROUND_PANEL</span><br><span class="line">    │   ├── Driver</span><br><span class="line">    │   │   ├── Driver.h</span><br><span class="line">    │   │   ├── Driver_utils.cpp</span><br><span class="line">    │   │   ├── Driver_utils.h</span><br><span class="line">    │   │   ├── Gpio.cpp</span><br><span class="line">    │   │   ├── Gpio.h</span><br><span class="line">    │   │   ├── controlcan.cpp</span><br><span class="line">    │   │   ├── controlcan.h</span><br><span class="line">    │   │   ├── socketCAN.cpp</span><br><span class="line">    │   │   ├── socketCAN.h</span><br><span class="line">    │   │   ├── tcp_cilent.cpp</span><br><span class="line">    │   │   ├── tcp_cilent.h</span><br><span class="line">    │   │   ├── usart.cpp</span><br><span class="line">    │   │   └── usart.h</span><br><span class="line">    │   ├── Math</span><br><span class="line">    │   │   ├── Math.h</span><br><span class="line">    │   │   ├── pid_control.cpp</span><br><span class="line">    │   │   └── pid_control.h</span><br><span class="line">    │   ├── ThirdParts</span><br><span class="line">    │   │   ├── CFG_ini.cpp</span><br><span class="line">    │   │   ├── CFG_ini.h</span><br><span class="line">    │   │   ├── ModBUS</span><br><span class="line">    │   │   │   ├── ascii</span><br><span class="line">    │   │   │   │   ├── mbascii.c</span><br><span class="line">    │   │   │   │   └── mbascii.h</span><br><span class="line">    │   │   │   ├── functions</span><br><span class="line">    │   │   │   │   ├── mbfunccoils.c</span><br><span class="line">    │   │   │   │   ├── mbfuncdiag.c</span><br><span class="line">    │   │   │   │   ├── mbfuncdisc.c</span><br><span class="line">    │   │   │   │   ├── mbfuncholding.c</span><br><span class="line">    │   │   │   │   ├── mbfuncinput.c</span><br><span class="line">    │   │   │   │   ├── mbfuncother.c</span><br><span class="line">    │   │   │   │   └── mbutils.c</span><br><span class="line">    │   │   │   ├── include</span><br><span class="line">    │   │   │   │   ├── mb.h</span><br><span class="line">    │   │   │   │   ├── mbconfig.h</span><br><span class="line">    │   │   │   │   ├── mbframe.h</span><br><span class="line">    │   │   │   │   ├── mbfunc.h</span><br><span class="line">    │   │   │   │   ├── mbport.h</span><br><span class="line">    │   │   │   │   ├── mbproto.h</span><br><span class="line">    │   │   │   │   └── mbutils.h</span><br><span class="line">    │   │   │   ├── mb.c</span><br><span class="line">    │   │   │   ├── port</span><br><span class="line">    │   │   │   │   ├── port.h</span><br><span class="line">    │   │   │   │   ├── portevent.c</span><br><span class="line">    │   │   │   │   ├── portother.c</span><br><span class="line">    │   │   │   │   ├── portserial.c</span><br><span class="line">    │   │   │   │   └── porttimer.c</span><br><span class="line">    │   │   │   ├── rtu</span><br><span class="line">    │   │   │   │   ├── mbcrc.c</span><br><span class="line">    │   │   │   │   ├── mbcrc.h</span><br><span class="line">    │   │   │   │   ├── mbrtu.c</span><br><span class="line">    │   │   │   │   └── mbrtu.h</span><br><span class="line">    │   │   │   └── tcp</span><br><span class="line">    │   │   │       ├── mbtcp.c</span><br><span class="line">    │   │   │       └── mbtcp.h</span><br><span class="line">    │   │   ├── cJSON.c</span><br><span class="line">    │   │   ├── cJSON.h</span><br><span class="line">    │   │   ├── tinyxml2.cpp</span><br><span class="line">    │   │   └── tinyxml2.h</span><br><span class="line">    │   └── param</span><br><span class="line">    │       ├── AGVParameter.h</span><br><span class="line">    │       ├── CFG.c</span><br><span class="line">    │       ├── CFG.h</span><br><span class="line">    │       ├── env_configure.c</span><br><span class="line">    │       └── env_configure.h</span><br><span class="line">    ├── Module</span><br><span class="line">    │   ├── ActionCTRL</span><br><span class="line">    │   │   ├── ActionCTRL.cpp</span><br><span class="line">    │   │   ├── ActionCTRL.h</span><br><span class="line">    │   │   └── ActionCTRLData.h</span><br><span class="line">    │   ├── Battery</span><br><span class="line">    │   │   ├── Battery.cpp</span><br><span class="line">    │   │   ├── Battery.h</span><br><span class="line">    │   │   ├── BatteryData.h</span><br><span class="line">    │   │   ├── EIKTO_battery.cpp</span><br><span class="line">    │   │   ├── EIKTO_battery.h</span><br><span class="line">    │   │   ├── FR_battery.cpp</span><br><span class="line">    │   │   └── FR_battery.h</span><br><span class="line">    │   ├── CommWithPC</span><br><span class="line">    │   │   ├── CommWithPC.cpp</span><br><span class="line">    │   │   ├── CommWithPC.h</span><br><span class="line">    │   │   └── CommWithPCData.h</span><br><span class="line">    │   ├── Encoder</span><br><span class="line">    │   │   ├── Encoder.cpp</span><br><span class="line">    │   │   ├── Encoder.h</span><br><span class="line">    │   │   ├── EncoderData.h</span><br><span class="line">    │   │   ├── TOFI_encoder.cpp</span><br><span class="line">    │   │   └── TOFI_encoder.h</span><br><span class="line">    │   ├── HandShank</span><br><span class="line">    │   │   ├── HandShank.cpp</span><br><span class="line">    │   │   ├── HandShank.h</span><br><span class="line">    │   │   ├── HandShankData.h</span><br><span class="line">    │   │   ├── Logitech_controller.cpp</span><br><span class="line">    │   │   └── Logitech_controller.h</span><br><span class="line">    │   ├── IoBoard</span><br><span class="line">    │   │   ├── IoBoard.cpp</span><br><span class="line">    │   │   ├── IoBoard.h</span><br><span class="line">    │   │   └── IoBoardData.h</span><br><span class="line">    │   ├── Location</span><br><span class="line">    │   │   ├── Location.cpp</span><br><span class="line">    │   │   ├── Location.h</span><br><span class="line">    │   │   └── LocationData.h</span><br><span class="line">    │   ├── Map</span><br><span class="line">    │   │   ├── LaserMAP.cpp</span><br><span class="line">    │   │   ├── LaserMAP.h</span><br><span class="line">    │   │   ├── Map.cpp</span><br><span class="line">    │   │   ├── Map.h</span><br><span class="line">    │   │   └── MapData.h</span><br><span class="line">    │   ├── Module.cpp</span><br><span class="line">    │   ├── Module.h</span><br><span class="line">    │   ├── MoveCTRL</span><br><span class="line">    │   │   ├── Kunhou</span><br><span class="line">    │   │   │   ├── Kunhou_cJSON.cpp</span><br><span class="line">    │   │   │   └── Kunhou_cJSON.h</span><br><span class="line">    │   │   ├── MoveCTRL.cpp</span><br><span class="line">    │   │   ├── MoveCTRL.h</span><br><span class="line">    │   │   ├── MoveCtrlData.h</span><br><span class="line">    │   │   └── Tongyi_Diff_Drive</span><br><span class="line">    │   │       ├── Tongyi_Driver.cpp</span><br><span class="line">    │   │       ├── Tongyi_Driver.h</span><br><span class="line">    │   │       ├── diff_control.cpp</span><br><span class="line">    │   │       └── diff_control.h</span><br><span class="line">    │   ├── log.cpp</span><br><span class="line">    │   └── log.h</span><br><span class="line">    ├── Task</span><br><span class="line">    │   ├── ModbusHMI.cpp</span><br><span class="line">    │   ├── ModbusHMI.h</span><br><span class="line">    │   ├── Music_Led.cpp</span><br><span class="line">    │   ├── Music_Led.h</span><br><span class="line">    │   ├── Safety.cpp</span><br><span class="line">    │   ├── Safety.h</span><br><span class="line">    │   ├── Task.cpp</span><br><span class="line">    │   ├── Task.h</span><br><span class="line">    │   ├── autoCtrl.cpp</span><br><span class="line">    │   ├── autoCtrl.h</span><br><span class="line">    │   ├── manualCtrl.cpp</span><br><span class="line">    │   └── manualCtrl.h</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>需要注意的一点是每个特定模块又三个对外文件,<code>module.cpp</code> <code>module.h</code> <code>moduleData.h</code></p>
<p>模块使用,只有使用时初始化线程,如果不使用则注释掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;HandShank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_HandShank</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Logitech_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>三维空间内旋转</title>
    <url>/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ahelloyou/article/details/108903506?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108903506.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">旋转矩阵_ahelloyou的博客-CSDN博客_旋转矩阵</a></p>
<p><a href="https://blog.csdn.net/u012424737/article/details/106269229?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-106269229.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">机器人运动学基础——旋转矩阵_太初有泪的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/hongbin_xu/article/details/78929006?ops_request_misc=%7B%22request_id%22:%22163585334816780366567178%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585334816780366567178&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78929006.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F&spm=1018.2226.3001.4187">三维重建学习(1)：基础知识：旋转矩阵与旋转向量_hongbin_xu的博客-CSDN博客_旋转向量</a></p>
<h1 id="简记"><a href="#简记" class="headerlink" title="简记"></a>简记</h1><p><img src="https://i.loli.net/2021/11/02/dxrQGvqahi5YN2I.jpg" alt="三位空间内的旋转"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>代码注释</title>
    <url>/blog/2022/05/03/%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_31445217/article/details/107606652?ops_request_misc=&request_id=&biz_id=102&utm_term=fixme&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-107606652.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">(130条消息) 编程规范: 代码中特殊注释TODO、FIXME、XXX 的含义_nohysiwe的博客-CSDN博客_golang 注释todo</a></p>
<p><a href="https://blog.csdn.net/weixin_43251037/article/details/120074702?ops_request_misc=%7B%22request_id%22:%22165156589416782425165154%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=165156589416782425165154&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-16-120074702.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=fixme&spm=1018.2226.3001.4187">(130条消息) Java XXX,TODO,FIXME 使用说明_聪鸟后飞的博客-CSDN博客</a></p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOTE: &lt;说明&gt;</span><br><span class="line">对代码如何工作的描述(当它不是不言自明时)。</span><br><span class="line">TODO: &lt;说明&gt;</span><br><span class="line">通常写在一些函数的上方或者内部，当然，实际上你可想写哪儿就写哪儿。它表示该注释标识处，有一些代码功能还未实现，未来会实现，&lt;说明&gt; 中应该简单描述下该功能。</span><br><span class="line">FIXME: &lt;说明&gt;</span><br><span class="line">该注释表示该注释标记处的代码有问题或者是错误的，有可能无法正常工作，需要修复，&lt;说明&gt; 中应该简单描述下如何修复该问题。</span><br><span class="line">XXX: &lt;说明&gt;</span><br><span class="line">该注释表示该注释标记处的代码功能虽然实现了，但是实现的方式可能并不那么的好，可以进行一些改进优化，&lt;说明&gt; 中应该简单描述下改进优化的策略。</span><br><span class="line">HACK: &lt;说明&gt;</span><br><span class="line">没有很好地编写或不规范的代码来规避问题/bug。应该被用作HACK:FIXME:</span><br><span class="line">BUG: &lt;说明&gt;</span><br><span class="line">这里有个大bug</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发中各种开发模型的优缺点</title>
    <url>/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/57187282">软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com)</a></p>
<p>可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。</p>
<p>但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。</p>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191209214003673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0MDY2Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。</li>
<li>比较适用于前期的软件开发与小型软件系统的开发中。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>无法评估项目进度。因为不知道哪个阶段会造成项目的延期</li>
<li>无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果</li>
</ul>
<h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzNzQwMDAxNWZjYTAyNjgwMzU0LmpwZw?x-oss-process=image/format,png" alt="http://img2.mukewang.com/5d78b37400015fca02680354.jpg"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>解决需求不明确带来的风险，适用于不能提前确定项目需求的项目</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不利于开发人员对产品进行扩展</li>
</ul>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzN2MwMDAxZTFlMjAzOTEwMTcxLmpwZw?x-oss-process=image/format,png" alt="http://img4.mukewang.com/5d78b37c0001e1e203910171.jpg"></p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>第一个可交付版本的软件所需的成本与时间较小</li>
<li>能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。</li>
<li>最终集成各个组件时，可能会出现集成失败的风险。</li>
</ul>
<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzODUwMDAxOTYwOTAyNTcwMjI5LmpwZw?x-oss-process=image/format,png" alt="img"></p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul>
<li>支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。</li>
</ul>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。</li>
<li>大量开发人员不利于项目的管理。</li>
<li>该模型需要严格管理文档，会增加审核的难度增大。</li>
</ul>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。<br>螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示：</p>
<p><img src="http://hiphotos.baidu.com/wlclass/pic/item/aad0ca9597169740d0135e27.jpg" alt="img"></p>
<p>该模型共有四个象限，每个象限的含义如下：</p>
<ul>
<li>制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</li>
<li>风险分析:评价所制订的实施方案，识别风险并消除风险。</li>
<li>实施工程:开发产品并进行验证。</li>
<li>客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</li>
</ul>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul>
<li>螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
<h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。<br>敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。<br>软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。<br>该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。</p>
<h5 id="敏捷开发模型的价值与原则"><a href="#敏捷开发模型的价值与原则" class="headerlink" title="敏捷开发模型的价值与原则"></a>敏捷开发模型的价值与原则</h5><ul>
<li>个体和交互重于过程和工具</li>
<li>可用软件重于完备文档</li>
<li>客户协作重于合同谈判</li>
<li>响应变化重于遵循计划</li>
</ul>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul>
<li>用户很快可以看到一个基线架构版的产品</li>
<li>敏捷注重市场快速反应能力，客户前期满意度高。</li>
</ul>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>注重人员的沟通</li>
<li>忽略文档的重要性</li>
<li>如果项目人员流动大太，会增加项目维护难度</li>
<li>软件之前版本的可重现性、可回溯性较低</li>
<li>对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。</li>
</ul>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>变量初始化多种操作</title>
    <url>/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ">嵌入式C语言编程时，变量、数组、指针初始化的多种操作</a></p>
<h1 id="数值初始化"><a href="#数值初始化" class="headerlink" title="数值初始化"></a>数值初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>    inum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span>  fnum = <span class="number">0.00f</span>;</span><br><span class="line"><span class="keyword">double</span> dnum = <span class="number">0.00</span>;</span><br></pre></td></tr></table></figure>

<h1 id="字符初始化"><a href="#字符初始化" class="headerlink" title="字符初始化"></a>字符初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>; </span><br></pre></td></tr></table></figure>

<h1 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h1><p>实际上就是将字符数组中的字符都初始化为<code>&#39;\0&#39;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用&quot;&quot;实现</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 使用memset</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line"><span class="comment">//使用循环</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般使用<code>memset</code>最合适,一般采用<code>+1</code>的方式参考:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> year[<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(year, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(year));</span><br><span class="line"><span class="built_in">strcpy</span>(year,<span class="string">&quot;2018&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><p>需要使用<code>malloc</code>申请动态内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;  </span><br><span class="line">p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory Allocated at: %x\n&quot;</span>,p);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not Enough Memory!\n&quot;</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>;   <span class="comment">//这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题</span></span><br></pre></td></tr></table></figure>

<h1 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU stu1;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1));</span><br><span class="line"><span class="comment">//  struct tm * tmp_time;</span></span><br><span class="line"><span class="comment">// memset(tmp_time, 0, sizeof(struct tm));</span></span><br><span class="line"><span class="comment">// task_send_data task_data;</span></span><br><span class="line"><span class="comment">// task_rcv_data rcv_data;</span></span><br><span class="line"><span class="comment">// memset(&amp;task_data, 0, sizeof(task_data));</span></span><br><span class="line"><span class="comment">// memset(&amp;rcv_data, 0, sizeof(rcv_data));</span></span><br></pre></td></tr></table></figure>

<p>注意初始化结构体数组时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STU stus[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stus)); <span class="comment">//正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU));  <span class="comment">//错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU)*<span class="number">10</span>);  <span class="comment">//正确，效果与第一个是一样的</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0x00</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1)); <span class="comment">//正确,效果与第一个是一样的</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>分支定界法</title>
    <url>/blog/2022/03/04/%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://www.bilibili.com/video/BV1o3411a7Rk?from=search&seid=11315131370414161915&spm_id_from=333.337.0.0">【运筹学】-整数线性规划(一)(分支定界法)_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://blog.csdn.net/m0_51197424/article/details/116864477?ops_request_misc=%7B%22request_id%22:%22164638609416780261946811%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=164638609416780261946811&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-116864477.nonecase&utm_term=%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95+c%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4450">(111条消息) 基于C语言的分支限界法_Mr.zhou_Zxy-CSDN博客_c语言分支限界法</a> </p>
<p> [(111条消息) 学习C/C++的第三十二天 五大常规算法——5.分支定界法_w707577314的博客-CSDN博客](<a href="https://blog.csdn.net/w707577314/article/details/103827880?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95">https://blog.csdn.net/w707577314/article/details/103827880?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=分支定界法</a> c语言&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>blog</del>sobaiduweb~default-3-103827880.nonecase&amp;spm=1018.2226.3001.4450) </p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>前轮反馈控制(stanley)</title>
    <url>/blog/2022/03/16/%E5%89%8D%E8%BD%AE%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6(stanley)/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://www.bilibili.com/video/BV1EA411T7wT?from=search&seid=17264326952115523860&spm_id_from=333.337.0.0">路径规划与轨迹跟踪系列算法学习_第11讲_Stanley法_哔哩哔哩_bilibili</a> </p>
<p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<p> [(116条消息) Stanley轨迹跟踪算法Python/Matlab算法实现_gophae的博客-CSDN博客_stanley算法](<a href="https://blog.csdn.net/gophae/article/details/102765091?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stanley%E7%AE%97%E6%B3%95">https://blog.csdn.net/gophae/article/details/102765091?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stanley算法</a> c实现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-3-102765091.142^v2^article_score_rank,143^v4^control&amp;spm=1018.2226.3001.4187) </p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>通过前轮反馈控制,采用航向偏差与横向偏差(<strong>err = err_phi + err_y</strong>)</p>
<p><img src="https://s2.loli.net/2022/03/20/RFxqaQTSHsmnECv.png" alt="1647750568_1_.png"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="获得最近点index"><a href="#获得最近点index" class="headerlink" title="获得最近点index"></a>获得最近点index</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[error, ind]</span> = <span class="title">calc_target_index</span><span class="params">(x,y,yaw, cx,cy,L)</span></span></span><br><span class="line">x = x + L * <span class="built_in">cos</span>(yaw);</span><br><span class="line">y = y + L * <span class="built_in">sin</span>(yaw);</span><br><span class="line">N =  <span class="built_in">length</span>(cx);</span><br><span class="line">Distance = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">Distance(<span class="built_in">i</span>) =  <span class="built_in">sqrt</span>((cx(<span class="built_in">i</span>)-x)^<span class="number">2</span> + (cy(<span class="built_in">i</span>)-y)^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[value, location]= <span class="built_in">min</span>(Distance);</span><br><span class="line">ind = location;</span><br><span class="line">  <span class="keyword">if</span> y&lt;cy(ind) </span><br><span class="line">        error = -value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error = value;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="stanley"><a href="#stanley" class="headerlink" title="stanley"></a>stanley</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[delta]</span> = <span class="title">stanley_control</span><span class="params">(x,y,yaw,v,cx,cy,cyaw, ind,ck,L, error)</span></span></span><br><span class="line">    tx = cx(ind + <span class="number">5</span>);</span><br><span class="line">    ty = cy(ind + <span class="number">5</span>);</span><br><span class="line">    delta_yaw = v * <span class="number">0.1</span> * <span class="built_in">sin</span>(yaw) / L;</span><br><span class="line"><span class="comment">%     th_e = pipi(yaw + delta_yaw - cyaw(ind));</span></span><br><span class="line">    alpha = pipi(<span class="built_in">atan</span>((ty-y)/(tx-x)) -yaw);</span><br><span class="line">    gain_k  = <span class="number">1</span>;</span><br><span class="line">    theta = <span class="built_in">atan</span>(gain_k* error/v);</span><br><span class="line">    delta = alpha + theta;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="纵向控制"><a href="#纵向控制" class="headerlink" title="纵向控制"></a>纵向控制</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[a]</span> = <span class="title">PIDcontrol</span><span class="params">(target_v, current_v, Kp)</span></span></span><br><span class="line">	a = Kp * (target_v - current_v);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>path_tracking</category>
      </categories>
      <tags>
        <tag>path_tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>图优化</title>
    <url>/blog/2022/03/21/%E5%9B%BE%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/weixin_43540678/article/details/83831548">(116条消息) 图优化一_a4zhangfei的博客-CSDN博客_图优化</a> </p>
<p> <a href="https://github.com/AtsushiSakai/PythonRobotics">AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com)</a> </p>
<h1 id="图优化理解"><a href="#图优化理解" class="headerlink" title="图优化理解"></a>图优化理解</h1><p>通过顶点与边构成相互约束,从而构建残差方程,然后通过最小二乘求解坐标</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> Rot</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Simulation parameter</span></span><br><span class="line">Q_sim = np.diag([<span class="number">0.2</span>, np.deg2rad(<span class="number">1.0</span>)]) ** <span class="number">2</span></span><br><span class="line">R_sim = np.diag([<span class="number">0.1</span>, np.deg2rad(<span class="number">10.0</span>)]) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">DT = <span class="number">2.0</span>  <span class="comment"># time tick [s]</span></span><br><span class="line">SIM_TIME = <span class="number">100.0</span>  <span class="comment"># simulation time [s]</span></span><br><span class="line">MAX_RANGE = <span class="number">30.0</span>  <span class="comment"># maximum observation range</span></span><br><span class="line">STATE_SIZE = <span class="number">3</span>  <span class="comment"># State size [x,y,yaw]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance parameter of Graph Based SLAM</span></span><br><span class="line">C_SIGMA1 = <span class="number">0.1</span></span><br><span class="line">C_SIGMA2 = <span class="number">0.1</span></span><br><span class="line">C_SIGMA3 = np.deg2rad(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">MAX_ITR = <span class="number">20</span>  <span class="comment"># Maximum iteration</span></span><br><span class="line"></span><br><span class="line">show_graph_d_time = <span class="number">20.0</span>  <span class="comment"># [s]</span></span><br><span class="line">show_animation = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.e = np.zeros((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">        self.omega = np.zeros((<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># information matrix</span></span><br><span class="line">        self.d1 = <span class="number">0.0</span></span><br><span class="line">        self.d2 = <span class="number">0.0</span></span><br><span class="line">        self.yaw1 = <span class="number">0.0</span></span><br><span class="line">        self.yaw2 = <span class="number">0.0</span></span><br><span class="line">        self.angle1 = <span class="number">0.0</span></span><br><span class="line">        self.angle2 = <span class="number">0.0</span></span><br><span class="line">        self.id1 = <span class="number">0</span></span><br><span class="line">        self.id2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_observation_sigma</span>():</span></span><br><span class="line">    sigma = np.zeros((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    sigma[<span class="number">0</span>, <span class="number">0</span>] = C_SIGMA1 ** <span class="number">2</span></span><br><span class="line">    sigma[<span class="number">1</span>, <span class="number">1</span>] = C_SIGMA2 ** <span class="number">2</span></span><br><span class="line">    sigma[<span class="number">2</span>, <span class="number">2</span>] = C_SIGMA3 ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sigma</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_rotational_matrix</span>(<span class="params">angle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Rot.from_euler(<span class="string">&#x27;z&#x27;</span>, angle).as_matrix()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_edge</span>(<span class="params">x1, y1, yaw1, x2, y2, yaw2, d1,</span></span></span><br><span class="line"><span class="params"><span class="function">              angle1, d2, angle2, t1, t2</span>):</span></span><br><span class="line">    edge = Edge()</span><br><span class="line"></span><br><span class="line">    tangle1 = pi_2_pi(yaw1 + angle1)</span><br><span class="line">    tangle2 = pi_2_pi(yaw2 + angle2)</span><br><span class="line">    tmp1 = d1 * math.cos(tangle1)</span><br><span class="line">    tmp2 = d2 * math.cos(tangle2)</span><br><span class="line">    tmp3 = d1 * math.sin(tangle1)</span><br><span class="line">    tmp4 = d2 * math.sin(tangle2)</span><br><span class="line"></span><br><span class="line">    edge.e[<span class="number">0</span>, <span class="number">0</span>] = x2 - x1 - tmp1 + tmp2</span><br><span class="line">    edge.e[<span class="number">1</span>, <span class="number">0</span>] = y2 - y1 - tmp3 + tmp4</span><br><span class="line">    edge.e[<span class="number">2</span>, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    Rt1 = calc_rotational_matrix(tangle1)</span><br><span class="line">    Rt2 = calc_rotational_matrix(tangle2)</span><br><span class="line"></span><br><span class="line">    sig1 = cal_observation_sigma()</span><br><span class="line">    sig2 = cal_observation_sigma()</span><br><span class="line"></span><br><span class="line">    edge.omega = np.linalg.inv(Rt1 @ sig1 @ Rt1.T + Rt2 @ sig2 @ Rt2.T)</span><br><span class="line"></span><br><span class="line">    edge.d1, edge.d2 = d1, d2</span><br><span class="line">    edge.yaw1, edge.yaw2 = yaw1, yaw2</span><br><span class="line">    edge.angle1, edge.angle2 = angle1, angle2</span><br><span class="line">    edge.id1, edge.id2 = t1, t2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> edge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_edges</span>(<span class="params">x_list, z_list</span>):</span> <span class="comment"># 计算边,并构建残差方程</span></span><br><span class="line">    edges = []</span><br><span class="line">    cost = <span class="number">0.0</span></span><br><span class="line">    z_ids = <span class="built_in">list</span>(itertools.combinations(<span class="built_in">range</span>(<span class="built_in">len</span>(z_list)), <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t1, t2) <span class="keyword">in</span> z_ids:</span><br><span class="line">        x1, y1, yaw1 = x_list[<span class="number">0</span>, t1], x_list[<span class="number">1</span>, t1], x_list[<span class="number">2</span>, t1]</span><br><span class="line">        x2, y2, yaw2 = x_list[<span class="number">0</span>, t2], x_list[<span class="number">1</span>, t2], x_list[<span class="number">2</span>, t2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> z_list[t1] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> z_list[t2] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># No observation</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> iz1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(z_list[t1][:, <span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">for</span> iz2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(z_list[t2][:, <span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> z_list[t1][iz1, <span class="number">3</span>] == z_list[t2][iz2, <span class="number">3</span>]:</span><br><span class="line">                    d1 = z_list[t1][iz1, <span class="number">0</span>]</span><br><span class="line">                    angle1, phi1 = z_list[t1][iz1, <span class="number">1</span>], z_list[t1][iz1, <span class="number">2</span>]</span><br><span class="line">                    d2 = z_list[t2][iz2, <span class="number">0</span>]</span><br><span class="line">                    angle2, phi2 = z_list[t2][iz2, <span class="number">1</span>], z_list[t2][iz2, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                    edge = calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1,</span><br><span class="line">                                     angle1, d2, angle2, t1, t2)</span><br><span class="line"></span><br><span class="line">                    edges.append(edge)</span><br><span class="line">                    cost += (edge.e.T @ edge.omega @ edge.e)[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cost:&quot;</span>, cost, <span class="string">&quot;,n_edge:&quot;</span>, <span class="built_in">len</span>(edges))</span><br><span class="line">    <span class="keyword">return</span> edges</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_jacobian</span>(<span class="params">edge</span>):</span></span><br><span class="line">    t1 = edge.yaw1 + edge.angle1</span><br><span class="line">    A = np.array([[-<span class="number">1.0</span>, <span class="number">0</span>, edge.d1 * math.sin(t1)],</span><br><span class="line">                  [<span class="number">0</span>, -<span class="number">1.0</span>, -edge.d1 * math.cos(t1)],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    t2 = edge.yaw2 + edge.angle2</span><br><span class="line">    B = np.array([[<span class="number">1.0</span>, <span class="number">0</span>, -edge.d2 * math.sin(t2)],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1.0</span>, edge.d2 * math.cos(t2)],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A, B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_H_and_b</span>(<span class="params">H, b, edge</span>):</span></span><br><span class="line">    A, B = calc_jacobian(edge) <span class="comment"># 计算jacobian矩阵</span></span><br><span class="line"></span><br><span class="line">    id1 = edge.id1 * STATE_SIZE</span><br><span class="line">    id2 = edge.id2 * STATE_SIZE</span><br><span class="line"></span><br><span class="line">    H[id1:id1 + STATE_SIZE, id1:id1 + STATE_SIZE] += A.T @ edge.omega @ A</span><br><span class="line">    H[id1:id1 + STATE_SIZE, id2:id2 + STATE_SIZE] += A.T @ edge.omega @ B</span><br><span class="line">    H[id2:id2 + STATE_SIZE, id1:id1 + STATE_SIZE] += B.T @ edge.omega @ A</span><br><span class="line">    H[id2:id2 + STATE_SIZE, id2:id2 + STATE_SIZE] += B.T @ edge.omega @ B</span><br><span class="line"></span><br><span class="line">    b[id1:id1 + STATE_SIZE] += (A.T @ edge.omega @ edge.e)</span><br><span class="line">    b[id2:id2 + STATE_SIZE] += (B.T @ edge.omega @ edge.e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">graph_based_slam</span>(<span class="params">x_init, hz</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start graph based slam&quot;</span>)</span><br><span class="line"></span><br><span class="line">    z_list = copy.deepcopy(hz)</span><br><span class="line"></span><br><span class="line">    x_opt = copy.deepcopy(x_init)</span><br><span class="line">    nt = x_opt.shape[<span class="number">1</span>]</span><br><span class="line">    n = nt * STATE_SIZE</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 高斯牛顿法迭代结果</span></span><br><span class="line">    <span class="keyword">for</span> itr <span class="keyword">in</span> <span class="built_in">range</span>(MAX_ITR):</span><br><span class="line">        edges = calc_edges(x_opt, z_list)</span><br><span class="line"></span><br><span class="line">        H = np.zeros((n, n))</span><br><span class="line">        b = np.zeros((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            H, b = fill_H_and_b(H, b, edge) <span class="comment"># 计算H矩阵和b矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># to fix origin</span></span><br><span class="line">        H[<span class="number">0</span>:STATE_SIZE, <span class="number">0</span>:STATE_SIZE] += np.identity(STATE_SIZE)</span><br><span class="line"></span><br><span class="line">        dx = - np.linalg.inv(H) @ b <span class="comment"># 计算残差方程的解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nt):</span><br><span class="line">            x_opt[<span class="number">0</span>:<span class="number">3</span>, i] += dx[i * <span class="number">3</span>:i * <span class="number">3</span> + <span class="number">3</span>, <span class="number">0</span>] <span class="comment"># 更新状态</span></span><br><span class="line"></span><br><span class="line">        diff = dx.T @ dx</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;iteration: %d, diff: %f&quot;</span> % (itr + <span class="number">1</span>, diff))</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">1.0e-5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_opt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_input</span>():</span></span><br><span class="line">    v = <span class="number">1.0</span>  <span class="comment"># [m/s]</span></span><br><span class="line">    yaw_rate = <span class="number">0.1</span>  <span class="comment"># [rad/s]</span></span><br><span class="line">    u = np.array([[v, yaw_rate]]).T</span><br><span class="line">    <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">observation</span>(<span class="params">xTrue, xd, u, RFID</span>):</span></span><br><span class="line">    xTrue = motion_model(xTrue, u)<span class="comment"># 获得预测状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># add noise to gps x-y</span></span><br><span class="line">    z = np.zeros((<span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(RFID[:, <span class="number">0</span>])):</span><br><span class="line"></span><br><span class="line">        dx = RFID[i, <span class="number">0</span>] - xTrue[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        dy = RFID[i, <span class="number">1</span>] - xTrue[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">        d = math.hypot(dx, dy) <span class="comment"># 计算距离</span></span><br><span class="line">        angle = pi_2_pi(math.atan2(dy, dx)) - xTrue[<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">        phi = pi_2_pi(math.atan2(dy, dx))</span><br><span class="line">        <span class="keyword">if</span> d &lt;= MAX_RANGE:</span><br><span class="line">            dn = d + np.random.randn() * Q_sim[<span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># add noise 添加状态噪声</span></span><br><span class="line">            angle_noise = np.random.randn() * Q_sim[<span class="number">1</span>, <span class="number">1</span>] <span class="comment"># add noise</span></span><br><span class="line">            angle += angle_noise</span><br><span class="line">            phi += angle_noise</span><br><span class="line">            zi = np.array([dn, angle, phi, i])<span class="comment"># 观测值</span></span><br><span class="line">            z = np.vstack((z, zi)) <span class="comment"># 将观测值添加到z中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># add noise to input 添加控制噪声</span></span><br><span class="line">    ud1 = u[<span class="number">0</span>, <span class="number">0</span>] + np.random.randn() * R_sim[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ud2 = u[<span class="number">1</span>, <span class="number">0</span>] + np.random.randn() * R_sim[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    ud = np.array([[ud1, ud2]]).T</span><br><span class="line"></span><br><span class="line">    xd = motion_model(xd, ud) <span class="comment"># 预测RFID状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xTrue, z, xd, ud <span class="comment"># 车体真实值，观测RFID状态,预测车体状态，控制噪声</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">motion_model</span>(<span class="params">x, u</span>):</span> <span class="comment"># 状态方程,运动模型</span></span><br><span class="line">    F = np.array([[<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>]])</span><br><span class="line"></span><br><span class="line">    B = np.array([[DT * math.cos(x[<span class="number">2</span>, <span class="number">0</span>]), <span class="number">0</span>],</span><br><span class="line">                  [DT * math.sin(x[<span class="number">2</span>, <span class="number">0</span>]), <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0.0</span>, DT]])</span><br><span class="line"></span><br><span class="line">    x = F @ x + B @ u</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_2_pi</span>(<span class="params">angle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (angle + math.pi) % (<span class="number">2</span> * math.pi) - math.pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(__file__ + <span class="string">&quot; start!!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># RFID positions [x, y, yaw]</span></span><br><span class="line">    RFID = np.array([[<span class="number">10.0</span>, -<span class="number">2.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                     [<span class="number">15.0</span>, <span class="number">10.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                     [<span class="number">3.0</span>, <span class="number">15.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                     [-<span class="number">5.0</span>, <span class="number">20.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                     [-<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>]</span><br><span class="line">                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># State Vector [x y yaw v]&#x27;</span></span><br><span class="line">    xTrue = np.zeros((STATE_SIZE, <span class="number">1</span>))</span><br><span class="line">    xDR = np.zeros((STATE_SIZE, <span class="number">1</span>))  <span class="comment"># Dead reckoning 航位推测法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># history</span></span><br><span class="line">    hxTrue = []</span><br><span class="line">    hxDR = []</span><br><span class="line">    hz = []</span><br><span class="line">    d_time = <span class="number">0.0</span></span><br><span class="line">    init = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> SIM_TIME &gt;= time:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> init:</span><br><span class="line">            hxTrue = xTrue</span><br><span class="line">            hxDR = xTrue</span><br><span class="line">            init = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hxDR = np.hstack((hxDR, xDR))</span><br><span class="line">            hxTrue = np.hstack((hxTrue, xTrue))</span><br><span class="line"></span><br><span class="line">        time += DT</span><br><span class="line">        d_time += DT</span><br><span class="line">        u = calc_input()<span class="comment"># 输入控制量(v, w)</span></span><br><span class="line"></span><br><span class="line">        xTrue, z, xDR, ud = observation(xTrue, xDR, u, RFID)<span class="comment"># 车体真实值，观测RFID状态,预测车体状态，控制噪声</span></span><br><span class="line"></span><br><span class="line">        hz.append(z)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d_time &gt;= show_graph_d_time:</span><br><span class="line">            x_opt = graph_based_slam(hxDR, hz)<span class="comment"># 输入,航测推测位姿值与观测RFID值</span></span><br><span class="line">            d_time = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> show_animation:  <span class="comment"># pragma: no cover</span></span><br><span class="line">                plt.cla()</span><br><span class="line">                <span class="comment"># for stopping simulation with the esc key.</span></span><br><span class="line">                plt.gcf().canvas.mpl_connect(</span><br><span class="line">                    <span class="string">&#x27;key_release_event&#x27;</span>,</span><br><span class="line">                    <span class="keyword">lambda</span> event: [exit(<span class="number">0</span>) <span class="keyword">if</span> event.key == <span class="string">&#x27;escape&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span>])</span><br><span class="line">                plt.plot(RFID[:, <span class="number">0</span>], RFID[:, <span class="number">1</span>], <span class="string">&quot;*k&quot;</span>)</span><br><span class="line"></span><br><span class="line">                plt.plot(hxTrue[<span class="number">0</span>, :].flatten(),</span><br><span class="line">                         hxTrue[<span class="number">1</span>, :].flatten(), <span class="string">&quot;-b&quot;</span>)</span><br><span class="line">                plt.plot(hxDR[<span class="number">0</span>, :].flatten(),</span><br><span class="line">                         hxDR[<span class="number">1</span>, :].flatten(), <span class="string">&quot;-k&quot;</span>)</span><br><span class="line">                plt.plot(x_opt[<span class="number">0</span>, :].flatten(),</span><br><span class="line">                         x_opt[<span class="number">1</span>, :].flatten(), <span class="string">&quot;-r&quot;</span>)</span><br><span class="line">                plt.axis(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">                plt.grid(<span class="literal">True</span>)</span><br><span class="line">                plt.title(<span class="string">&quot;Time&quot;</span> + <span class="built_in">str</span>(time)[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line">                plt.pause(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数</title>
    <url>/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/baidu_38172402/article/details/95119014?ops_request_misc=%7B%22request_id%22:%22163409375616780261926822%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163409375616780261926822&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-95119014.pc_search_ecpm_flag&utm_term=c%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">c语言回调函数</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 函数指针结构体</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OP</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_add)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_sub)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_mul)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_div)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">&#125; OP; </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 加减乘除函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADD</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SUB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MUL</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">DIV</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 初始化函数指针</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_op</span><span class="params">(OP *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op-&gt;p_add = ADD;</span><br><span class="line">    op-&gt;p_sub = SUB;</span><br><span class="line">    op-&gt;p_mul = &amp;MUL;</span><br><span class="line">    op-&gt;p_div = &amp;DIV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 库函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_sub_mul_div</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> (*op_func)(<span class="keyword">float</span>, <span class="keyword">float</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*op_func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OP *op = (OP *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(OP)); </span><br><span class="line">    <span class="built_in">init_op</span>(op);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 直接使用函数指针调用函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, (op-&gt;p_add)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_sub)(<span class="number">1.3</span>, <span class="number">2.2</span>), </span><br><span class="line">            (op-&gt;p_mul)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_div)(<span class="number">1.3</span>, <span class="number">2.2</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 调用回调函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, ADD), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, SUB), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, MUL), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, DIV));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>在线好用软件</title>
    <url>/blog/2022/03/01/%E5%9C%A8%E7%BA%BF%E5%A5%BD%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="在线代码对比工具"><a href="#在线代码对比工具" class="headerlink" title="在线代码对比工具:"></a>在线代码对比工具:</h1><p> <a href="https://www.json.cn/json/jsoncompare.html">在线代码对比/合并工具|代码对比 - JSON.cn</a> </p>
<p>这里包含了关于<strong>编译器</strong>,<strong>json解析工具</strong>,<strong>ip工具</strong>,<strong>电子计算器</strong>,<strong>图片压缩</strong>,<strong>代码对比</strong>等丰富资源</p>
<h1 id="crc校验工具"><a href="#crc校验工具" class="headerlink" title="crc校验工具"></a>crc校验工具</h1><p> <a href="https://www.lammertbies.nl/comm/info/crc-calculation">On-line CRC calculation and free library - Lammert Bies</a> </p>
<h1 id="在线公式生成工具"><a href="#在线公式生成工具" class="headerlink" title="在线公式生成工具"></a>在线公式生成工具</h1><p> <a href="https://editor.codecogs.com/">Online LaTeX Equation Editor - create, integrate and download online. (codecogs.com)</a> </p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p> <a href="https://app.diagrams.net/">diagrams.net</a> </p>
<h1 id="跨平台文件传输"><a href="#跨平台文件传输" class="headerlink" title="跨平台文件传输"></a>跨平台文件传输</h1><p> <a href="https://airportal.cn/">AirPortal 空投快传</a> </p>
<h1 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h1><p> <a href="https://jiasu8.pink/clientarea.php">用户中心 - JiaSu8 Pink</a> </p>
<h1 id="pdf转cad"><a href="#pdf转cad" class="headerlink" title="pdf转cad"></a>pdf转cad</h1><p> <a href="http://app.xunjiepdf.com/pdf2cad">PDF转换成CAD – 在线PDF转CAD – 迅捷PDF转换器在线免费版 (xunjiepdf.com)</a> </p>
<h1 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h1><p> <a href="https://onlineconvertfree.com/zh/convert-format/pgm-to-png/">在线将PGM 转换成 PNG 。 免费将.PGM 转换成.PNG 。 (onlineconvertfree.com)</a> </p>
<h1 id="在线计算器"><a href="#在线计算器" class="headerlink" title="在线计算器"></a>在线计算器</h1><p> <a href="https://www.geogebra.org/">GeoGebra</a> </p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>在melodic下使用opencv巡线</title>
    <url>/blog/2022/02/10/%E5%9C%A8melodic%E4%B8%8B%E4%BD%BF%E7%94%A8opencv%E5%B7%A1%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/sudrag/line_follower_turtlebot">sudrag/line_follower_turtlebot: A repo created to simulate a line following turtlebot in Gazebo environment using ROS (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/qty2898734013/article/details/114217366">(105条消息) ROS-Melodic下 Gazebo+Turtlebot安装_qty2898734013的博客-CSDN博客_melodic安装gazebo</a> </p>
<p>另一位大佬的,不过没有我运行成功</p>
<p> <a href="https://zenanlin1999.github.io/2021/05/10/ROS%E5%BC%80%E5%8F%916%E2%80%94%E2%80%94opencv+ROS%E5%9B%BE%E5%83%8F%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B/">ROS开发6——Gazebo环境下ROS+OpenCV搭建机器人图像开发案例 | Zenan’s Blog (zenanlin1999.github.io)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>参考的是以为大佬的github项目,基本环境如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROS Kinetic</span><br><span class="line">Catkin</span><br><span class="line">roscpp package</span><br><span class="line">std_msgs package</span><br><span class="line">message_generation package</span><br><span class="line">OpenCV</span><br></pre></td></tr></table></figure>

<p>但由于melodic并没有办法直接安装turtlebot_gazebo所以需要先手动安装turtlebot_gazebo</p>
<p>方法如下</p>
<h1 id="安装turtlebot-gazebo"><a href="#安装turtlebot-gazebo" class="headerlink" title="安装turtlebot_gazebo"></a>安装turtlebot_gazebo</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装gazebo</span></span><br><span class="line">sudo apt-get install ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">sudo nano ~/.ignition/fuel/config.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释掉,并加入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url: https://api.ignitionfuel.org</span></span><br><span class="line">url: https://api.ignitionrobotics.org</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是vmare虚拟机,需要加入</span></span><br><span class="line">export SVGA_VGPU10=0</span><br><span class="line">echo &quot;export SVGA_VGPU10=0&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">gazebo</span><br></pre></td></tr></table></figure>

<h2 id="a-安装依赖包"><a href="#a-安装依赖包" class="headerlink" title="a\安装依赖包"></a>a\安装依赖包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-kobuki-*</span><br><span class="line">sudo apt-get install ros-melodic-ecl-streams</span><br><span class="line">sudo apt-get install ros-melodic-bfl</span><br><span class="line">sudo apt-get install ros-melodic-map-server</span><br><span class="line">sudo apt-get install ros-melodic-move-base</span><br><span class="line">sudo apt-get install ros-melodic-amcl</span><br><span class="line">sudo apt-get install ros-melodic-dwa-local-planner</span><br><span class="line">sudo apt-get install libusb-dev</span><br><span class="line">sudo apt-get install libspnav-dev</span><br><span class="line">sudo apt-get install ros-melodic-joystick-drivers</span><br><span class="line">sudo apt-get install bluetooth</span><br><span class="line">sudo apt-get install libbluetooth-dev</span><br><span class="line">sudo apt-get install libcwiid-dev</span><br></pre></td></tr></table></figure>

<h2 id="b-新建工作空间，准备相关包"><a href="#b-新建工作空间，准备相关包" class="headerlink" title="b\新建工作空间，准备相关包"></a>b\新建工作空间，准备相关包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/turtlebot_ws/src </span><br><span class="line">cd ~/turtlebot_ws/src </span><br><span class="line">git clone git://github.com/turtlebot/turtlebot_simulator</span><br><span class="line">git clone git://github.com/turtlebot/turtlebot.git</span><br><span class="line">git clone git://github.com/turtlebot/turtlebot_apps.git</span><br><span class="line">git clone git://github.com/udacity/robot_pose_ekf</span><br><span class="line">git clone git://github.com/ros-perception/depthimage_to_laserscan.git </span><br><span class="line">git clone git://github.com/yujinrobot/kobuki_msgs.git</span><br><span class="line">git clone git://github.com/yujinrobot/kobuki_desktop.git</span><br><span class="line">git clone git://github.com/ncnynl/turtlebot_viz</span><br><span class="line">git clone git://github.com/turtlebot/turtlebot_create.git</span><br><span class="line">cd kobuki_desktop/</span><br><span class="line">rm -r kobuki_qtestsuite</span><br><span class="line">git clone git://github.com/toeklk/orocos-bayesian-filtering.git</span><br><span class="line">git clone git://github.com/turtlebot/turtlebot_msgs.git</span><br><span class="line">git clone git://github.com/ros-drivers/joystick_drivers.git</span><br></pre></td></tr></table></figure>

<h2 id="c-复制kobuki和yujin-ocs依赖库到turtlebot-ws-src工作空间下"><a href="#c-复制kobuki和yujin-ocs依赖库到turtlebot-ws-src工作空间下" class="headerlink" title="c\复制kobuki和yujin_ocs依赖库到turtlebot_ws/src工作空间下"></a>c\复制kobuki和yujin_ocs依赖库到turtlebot_ws/src工作空间下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/repos/</span><br><span class="line">cd ~/repos/</span><br><span class="line">git clone git://github.com/yujinrobot/kobuki.git</span><br><span class="line">cp -r kobuki/* ~/turtlebot_ws/src/</span><br><span class="line">git clone git://github.com/yujinrobot/yujin_ocs.git</span><br><span class="line">cp -r yujin_ocs/yocs_cmd_vel_mux/ yujin_ocs/yocs_controllers ~/turtlebot_ws/src/</span><br></pre></td></tr></table></figure>

<h2 id="d-编译与添加到环境变量"><a href="#d-编译与添加到环境变量" class="headerlink" title="d\编译与添加到环境变量"></a>d\编译与添加到环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/turtlebot_ws</span><br><span class="line">catkin_make</span><br><span class="line">echo &quot;source ~/turtlebot_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc </span><br></pre></td></tr></table></figure>

<h2 id="e-测试"><a href="#e-测试" class="headerlink" title="e\测试"></a>e\测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch turtlebot_gazebo turtlebot_world.launch</span><br></pre></td></tr></table></figure>

<h1 id="运行opencv巡线"><a href="#运行opencv巡线" class="headerlink" title="运行opencv巡线"></a>运行opencv巡线</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir catkin_ws</span><br><span class="line">cd catkin_ws</span><br><span class="line">mkdir src</span><br><span class="line">catkin_make</span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">git clone https://github.com/sudrag/line_follower_turtlebot.git</span><br><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch line_follower_turtlebot lf.launch</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ros</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>学写2d激光slam-lesson1</title>
    <url>/blog/2022/02/11/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch">xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx?spm=1011.2124.3001.5113">李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主</a> </p>
<h1 id="lesson1"><a href="#lesson1" class="headerlink" title="lesson1"></a>lesson1</h1><h2 id="了解激光雷达数据"><a href="#了解激光雷达数据" class="headerlink" title="了解激光雷达数据"></a>了解激光雷达数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># rosmsg show sensor_msgs/LaserScan</span></span><br><span class="line"></span><br><span class="line">std_msgs/Header header	<span class="comment">//　数据的消息头</span></span><br><span class="line">  uint32 seq			<span class="comment">//　数据的序号</span></span><br><span class="line">  time stamp			<span class="comment">//　数据的时间戳</span></span><br><span class="line">  <span class="built_in">string</span> frame_id		<span class="comment">//　数据的坐标系</span></span><br><span class="line">float32 angle_min		<span class="comment">//　雷达数据的起始角度（最小角度）</span></span><br><span class="line">float32 angle_max		<span class="comment">//　雷达数据的终止角度（最大角度）</span></span><br><span class="line">float32 angle_increment	<span class="comment">//　雷达数据的角度分辨率（角度增量）</span></span><br><span class="line">float32 time_increment	<span class="comment">//　雷达数据每个数据点的时间间隔</span></span><br><span class="line">float32 scan_time		<span class="comment">//　当前帧数据与下一帧数据的时间间隔</span></span><br><span class="line">float32 range_min		<span class="comment">//　雷达数据的最小值</span></span><br><span class="line">float32 range_max		<span class="comment">//　雷达数据的最大值</span></span><br><span class="line">float32[] ranges		<span class="comment">//　雷达数据每个点对应的在极坐标系下的距离值</span></span><br><span class="line">float32[] intensities	<span class="comment">//　雷达数据每个点对应的强度值</span></span><br></pre></td></tr></table></figure>

<h2 id="对数据进行简单处理"><a href="#对数据进行简单处理" class="headerlink" title="对数据进行简单处理"></a>对数据进行简单处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第5个点的欧式坐标为</span></span><br><span class="line"><span class="keyword">double</span> range = scan_msg-&gt;ranges[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">double</span> angle = scan_msg-&gt;angle_min + scan_msg-&gt;angle_increment * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> x = range * <span class="built_in">cos</span>(angle);</span><br><span class="line"><span class="keyword">double</span> y = range * <span class="built_in">sin</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ranges中数据的个数进行雷达数据的遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scan_msg-&gt;ranges.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;range[i]=%f &quot;</span>,scan_msg-&gt;ranges[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LIO-SLAM特征点提取"><a href="#LIO-SLAM特征点提取" class="headerlink" title="LIO_SLAM特征点提取"></a>LIO_SLAM特征点提取</h2><p>简介:主要是提取特征角点</p>
<h3 id="剔除-inf-或者-nan-点"><a href="#剔除-inf-或者-nan-点" class="headerlink" title="剔除  inf 或者 nan 点"></a>剔除  <strong>inf 或者 nan</strong> 点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::isfinite ：输入的值是有效值，返回true</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">std</span>::isfinite(scan_msg-&gt;ranges[i]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; scan_msg-&gt;ranges[i];</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算曲率"><a href="#计算曲率" class="headerlink" title="计算曲率"></a>计算曲率</h3><p>实际上是比较该点与前后各五个点之间差距,大于一定阈值认为是角点,也就是特侦点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 计算曲率值, 通过当前点前后5个点距离值的偏差程度来代表曲率</span><br><span class="line">// 如果是球面, 则当前点周围的10个点的距离之和 减去 当前点距离的10倍 应该等于0</span><br><span class="line">for (int i = 5; i &lt; count - 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">    float diff_range = new_scan[i - 5] + new_scan[i - 4] +</span><br><span class="line">                       new_scan[i - 3] + new_scan[i - 2] +</span><br><span class="line">                       new_scan[i - 1] - new_scan[i] * 10 +</span><br><span class="line">                       new_scan[i + 1] + new_scan[i + 2] +</span><br><span class="line">                       new_scan[i + 3] + new_scan[i + 4] +</span><br><span class="line">                       new_scan[i + 5];</span><br><span class="line">    // diffX * diffX + diffY * diffY</span><br><span class="line">    scan_curvature_[i] = diff_range * diff_range;</span><br><span class="line">    scan_smoothness_[i].value = scan_curvature_[i];</span><br><span class="line">    scan_smoothness_[i].index = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特侦点提取"><a href="#特侦点提取" class="headerlink" title="特侦点提取"></a>特侦点提取</h3><p>使用sort()对于scan_smoothness_进行排序,分成6组,从大到小每组最多选20个点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行角点的提取,将完整的scan分成6部分,每部分提取20个角点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> start_index = (<span class="number">0</span> * (<span class="number">6</span> - j) + count * j) / <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> end_index = (<span class="number">0</span> * (<span class="number">5</span> - j) + count * (j + <span class="number">1</span>)) / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;start_index: &quot; &lt;&lt; start_index &lt;&lt; &quot; end_index: &quot; &lt;&lt; end_index &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start_index &gt;= end_index)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这段点云按照曲率从小到大进行排序</span></span><br><span class="line">        <span class="built_in">std</span>::sort(scan_smoothness_.begin() + start_index,</span><br><span class="line">                  scan_smoothness_.begin() + end_index, by_value());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> largestPickedNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后的点 的曲率最大，如果满足条件，就是角点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = end_index; k &gt;= start_index; k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = scan_smoothness_[k].index;</span><br><span class="line">            <span class="keyword">if</span> (scan_smoothness_[k].value &gt; edge_threshold_)&#123;</span><br><span class="line">                <span class="comment">// 每一段最多只取20个角点</span></span><br><span class="line">                largestPickedNum++;</span><br><span class="line">                <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">                    corner_scan.ranges[map_index[index]] = scan_msg-&gt;ranges[map_index[index]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>坐标变换</title>
    <url>/blog/2022/03/06/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/lewif/category_7297027.html">坐标变换</a></p>
<p><a href="https://www.bilibili.com/video/BV1MP4y1K7Yn?spm_id_from=333.337.search-card.all.click">由一道周作业题想到的坐标系变换_哔哩哔哩_bilibili</a></p>
<h1 id="不同坐标系变换"><a href="#不同坐标系变换" class="headerlink" title="不同坐标系变换"></a>不同坐标系变换</h1><figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function">Pose2D <span class="title">TransformFrom</span><span class="params">(<span class="keyword">const</span> Pose2D&amp; pose_new)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = pose_new.x - x;</span><br><span class="line">    <span class="keyword">float</span> dy = pose_new.y - y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pose2d</span>(dx*std::<span class="built_in">cos</span>(theta)+dy*std::<span class="built_in">sin</span>(theta),</span><br><span class="line">                -dx*std::<span class="built_in">sin</span>(theta)+dy*std::<span class="built_in">cos</span>(theta),</span><br><span class="line">                pose_new.theta - theta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function">Pose2D <span class="title">TransformAdd</span><span class="params">(<span class="keyword">const</span> Pose2D&amp; pose_delta)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = pose_delta.x*std::<span class="built_in">cos</span>(theta)-pose_delta.y*std::<span class="built_in">sin</span>(theta);</span><br><span class="line">    <span class="keyword">float</span> dy = pose_delta.x*std::<span class="built_in">sin</span>(theta)+pose_delta.y*std::<span class="built_in">cos</span>(theta);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pose2d</span>(x+dx, y+dy, theta+pose_delta.theta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>学写2d激光slam-lesson2</title>
    <url>/blog/2022/02/12/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson2/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch">xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx?spm=1011.2124.3001.5113">李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主</a> </p>
<p> <a href="https://blog.csdn.net/weixin_41170972/article/details/120015410?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.2&utm_relevant_index=4">(107条消息) ROS中点云学习（九）：sensor_msgs::LaserScan转sensor_msgs::PointCloud2_00 2的博客-CSDN博客</a> </p>
<h1 id="lesson2"><a href="#lesson2" class="headerlink" title="lesson2"></a>lesson2</h1><h3 id="格式转换-sensor-msgs-LaserScan-gt-sensor-msgs-PointCloud2"><a href="#格式转换-sensor-msgs-LaserScan-gt-sensor-msgs-PointCloud2" class="headerlink" title="格式转换(sensor_msgs/LaserScan -&gt; sensor_msgs/PointCloud2 )"></a>格式转换(sensor_msgs/LaserScan -&gt; sensor_msgs/PointCloud2 )</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sensor_msgs/LaserScan</span></span><br><span class="line">std_msgs/Header header</span><br><span class="line">float32 angle_min</span><br><span class="line">float32 angle_max</span><br><span class="line">float32 angle_increment</span><br><span class="line">float32 time_increment</span><br><span class="line">float32 scan_time</span><br><span class="line">float32 range_min</span><br><span class="line">float32 range_max</span><br><span class="line">float32[] ranges</span><br><span class="line">float32[] intensities</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sensor_msgs/PointCloud2</span></span><br><span class="line">std_msgs/Header header</span><br><span class="line"><span class="meta">#</span><span class="bash"> width  - 以点数指定点云数据集的宽度。 WIDTH有两个含义：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  - 它可以为 无组织数据集 指定云中的总点数;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  - 它可以指定 有组织的点云数据集 的宽度（一行中的总点数）.</span></span><br><span class="line">uint32 height</span><br><span class="line"><span class="meta">#</span><span class="bash"> height  - 以点数指定点云数据集的高度。HEIGHT有两个含义：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    * - 对于 无组织数据集，它设置为1（因此用于检查数据集是否ordered）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    * - 它可以指定 有组织的点云数据集 的高度（总行数）;</span></span><br><span class="line">uint32 width</span><br><span class="line"><span class="meta">#</span><span class="bash"> 描述二进制数据blob中的通道及其布局。</span></span><br><span class="line">sensor_msgs/PointField[] fields</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是大端数据格式吗?</span></span><br><span class="line">bool is_bigendian</span><br><span class="line"><span class="meta">#</span><span class="bash">  以字节为单位的点的长度</span></span><br><span class="line">uint32 point_step</span><br><span class="line"><span class="meta">#</span><span class="bash">  行的长度（以字节为单位）</span></span><br><span class="line">uint32 row_step</span><br><span class="line"><span class="meta">#</span><span class="bash">  实际数据（二进制的数据流），大小为（row_step * height）</span></span><br><span class="line">uint8[] data</span><br><span class="line"><span class="meta">#</span><span class="bash">  如果包含Inf / NaN值，则为<span class="literal">false</span>，否则为真</span></span><br><span class="line">bool is_dense</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换</span></span><br><span class="line">std_msgs/Header header</span><br><span class="line">uint32 height</span><br><span class="line">uint32 width</span><br><span class="line">PointT* point_tmp</span><br><span class="line">bool is_dense</span><br></pre></td></tr></table></figure>

<p>相对来说比较简单,就是将scan数据转化为PointT数据发布,且ros自带转化成pointcloud2功能,需要注意的是对于无效数据需要特殊处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，这里的发布器，发布的数据类型为 pcl::PointCloud&lt;PointT&gt;</span></span><br><span class="line"><span class="comment">// ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换</span></span><br><span class="line">pointcloud2_publisher_ = node_handle_.advertise&lt;PointCloudT&gt;(</span><br><span class="line">	<span class="string">&quot;pointcloud2_converted&quot;</span>, <span class="number">1</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>无效点处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 inf 与 nan 点 设置为无效点</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">std</span>::isfinite(range))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; scan_msg-&gt;ranges[i];</span></span><br><span class="line">    point_tmp = invalid_point_;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>point坐标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有些雷达驱动会将无效点设置成 range_max+1</span></span><br><span class="line"><span class="comment">// 所以要根据雷达的range_min与range_max进行有效值的判断</span></span><br><span class="line"><span class="keyword">if</span> (range &gt; scan_msg-&gt;range_min &amp;&amp; range &lt; scan_msg-&gt;range_max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取第i个点对应的角度</span></span><br><span class="line">    <span class="keyword">float</span> angle = scan_msg-&gt;angle_min + i * scan_msg-&gt;angle_increment;</span><br><span class="line">    <span class="comment">// 获取第i个点在笛卡尔坐标系下的坐标</span></span><br><span class="line">    point_tmp.x = range * <span class="built_in">cos</span>(angle);</span><br><span class="line">    point_tmp.y = range * <span class="built_in">sin</span>(angle);</span><br><span class="line">    point_tmp.z = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// 无效点</span></span><br><span class="line">	point_tmp = invalid_point_;</span><br></pre></td></tr></table></figure>

<p>发布</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> cloud_msg-&gt;width = scan_msg-&gt;ranges.size();</span><br><span class="line"> cloud_msg-&gt;height = 1;</span><br><span class="line"> cloud_msg-&gt;is_dense = false; // contains nans</span><br><span class="line"> // 将scan_msg的消息头 赋值到 PointCloudT的消息头</span><br><span class="line"> pcl_conversions::toPCL(scan_msg-&gt;header, cloud_msg-&gt;header);</span><br><span class="line"></span><br><span class="line">// 由于ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换</span><br><span class="line">// 所以这里直接发布 pcl::PointCloud&lt;PointT&gt; 即可</span><br><span class="line">pointcloud2_publisher_.publish(cloud_msg);</span><br></pre></td></tr></table></figure>

<h3 id="icp算法"><a href="#icp算法" class="headerlink" title="icp算法"></a>icp算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1,将scan转成点云数据</span></span><br><span class="line"><span class="comment">// 2,保存当前与上一次点云信息</span></span><br><span class="line"><span class="comment">// 3,pcl自带的icp算法</span></span><br><span class="line"><span class="comment">// ICP 输入数据,输出数据的设置,还可以进行参数配置,这里使用默认参宿</span></span><br><span class="line">icp_.setInputSource(last_pointcloud_);</span><br><span class="line">icp_.setInputTarget(current_pointcloud_);</span><br><span class="line"><span class="comment">// 开始迭代计算</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; unused_result;</span><br><span class="line">icp_.align(unused_result);</span><br><span class="line"><span class="comment">// 如果迭代没有收敛,不进行输出</span></span><br><span class="line"><span class="keyword">if</span> (icp_.hasConverged() == <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not Converged&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 收敛了之后, 获取坐标变换</span></span><br><span class="line">    Eigen::Affine3f transfrom;</span><br><span class="line">    transfrom = icp_.getFinalTransformation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Eigen::Affine3f转换成x, y, theta, 并打印出来</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z, roll, pitch, yaw;</span><br><span class="line">    pcl::getTranslationAndEulerAngles(transfrom, x, y, z, roll, pitch, yaw);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;transfrom: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; yaw * <span class="number">180</span> / M_PI &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">迭代最近点（Iterative Closest Point, 下简称ICP）算法是一种点云匹配算法。</span><br><span class="line"></span><br><span class="line">其求解思路为：</span><br><span class="line">首先对于一幅点云中的每个点，在另一幅点云中计算匹配点（最近点）</span><br><span class="line">极小化匹配点间的匹配误差，计算位姿</span><br><span class="line">然后将计算的位姿作用于点云</span><br><span class="line">再重新计算匹配点</span><br><span class="line">如此迭代，直到迭代次数达到阈值，或者极小化函数的变化量小于设定阈值</span><br><span class="line"></span><br><span class="line">首先，ICP对初值比较敏感，初值给的不好，就需要花费更多的迭代次数进行匹配．</span><br><span class="line">其次，由于它是迭代很多次的，所以其花费的时间很长，这一点是非常致命的，之后我会通过程序来让大家体验ICP的费时．</span><br><span class="line">再次，精度与速度是矛盾的，ICP算法理论上可以实现很高的精度，但是要很多很多的迭代次数，以及很长的时间．所以，当限制了迭代次数的情况下，精度就不一定能保证了．</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>对于slam整体流程的思考</title>
    <url>/blog/2022/03/07/%E5%AF%B9%E4%BA%8Eslam%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/lzj50002801/article/details/108432226">(112条消息) SLAM基本流程和算法框架_lzj50002801的博客-CSDN博客_slam基本框架</a> </p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://s2.loli.net/2022/03/07/gz3q4trXJBlFUEZ.png" alt="20200906153505547.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传感器信息读取:在视觉 SLAM 中主要为相机图像信息的读取和预处理。如果在机器人中，还可能有码盘、惯性传感器等信息的读取和同步。</span><br><span class="line"></span><br><span class="line">视觉里程计 (Visual Odometry, VO):视觉里程计任务是估算相邻图像间相机的运动，以及局部地图的样子。VO 又称为前端（Front End）。</span><br><span class="line"></span><br><span class="line">后端优化（Optimization）:后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。由于接在 VO 之后，又称为后端（Back End）。</span><br><span class="line"></span><br><span class="line">回环检测（Loop Closing）:回环检测判断机器人是否曾经到达过先前的位置。如果检测到回环，它会把信息提供给后端进行处理。</span><br><span class="line"></span><br><span class="line">建图（Mapping）:它根据估计的轨迹，建立与任务要求对应的地图。</span><br></pre></td></tr></table></figure>

<p>在图中很清晰的表现出了slam流程:</p>
<p>根据传感器信息获得初步的前端里程计,这时候同时进行回环检测,然后将两个数据都传给后端进行后端的非线性优化,最后通过非线性优化得到的坐标数据,进行最终建图.</p>
<h1 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h1><ul>
<li>odom:一般用于辅助前端定位作用</li>
<li>imu:由于其角度相较于odom更准,所以也会将其放做里程计角度数值,当然也会有用于ekf做传感器融合</li>
<li>scan:激光数据包括:ranges, intensities,数据</li>
</ul>
<h1 id="前端里程计"><a href="#前端里程计" class="headerlink" title="前端里程计"></a>前端里程计</h1><h2 id="滤波大法"><a href="#滤波大法" class="headerlink" title="滤波大法"></a>滤波大法</h2><h3 id="主要是ekf与pf两种-具体可参考"><a href="#主要是ekf与pf两种-具体可参考" class="headerlink" title="主要是ekf与pf两种,具体可参考:"></a>主要是ekf与pf两种,具体可参考:</h3><p><strong>gmapping,amcl,refletor_ekf_slam</strong></p>
<h2 id="非线性优化"><a href="#非线性优化" class="headerlink" title="非线性优化"></a>非线性优化</h2><ul>
<li><strong>icp</strong></li>
<li><strong>scan_to_map</strong></li>
<li><strong>scan_to_submap: Scan To SubMap方法只将当前帧激光雷达数据与历史前几帧数据进行匹配</strong> </li>
</ul>
<h1 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h1><ul>
<li><strong>通过特征点进行匹配(原特征,叫角特征,线特征)</strong></li>
<li><strong>通过icp进行的暴力匹配</strong></li>
<li><strong>scan_context</strong></li>
</ul>
<h1 id="后端优化-图优化"><a href="#后端优化-图优化" class="headerlink" title="后端优化(图优化)"></a>后端优化(图优化)</h1><p> <strong>图优化的目的是从整体上对所有已估计到的并且在回环上的位姿进行优化，减小误差。普遍有两种:</strong></p>
<ul>
<li> <strong>图优化的思路是将位姿作为图(Graph)的顶点(Vertex),位姿间的坐标变换关系作为边(Edge), 顶点为优化变量，边为优化约束，构建出一个位姿图(Pose Graph)。</strong> </li>
<li> <strong>将雷达观测点也作为图的顶点，观测点与机器人的位姿之间的关系也作为边构建出一个图，这种情况下称之为Bundle Adjustment(BA)问题</strong> </li>
</ul>
<p><strong>具体非线性优化可以参考g2o与之前的手撸高斯牛顿,以此得到较为不错的估计坐标</strong></p>
<h1 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h1><p><strong>这方面,其实可以参考的有很多,比如hector的建图,以及深蓝学院的建图都比较简单容易移植.</strong></p>
<h1 id="全局定位"><a href="#全局定位" class="headerlink" title="全局定位"></a>全局定位</h1><ul>
<li>最常用且传统的方式是amcl,采用贝叶斯滤波的方式实现,包括比较固定的里程计模型,还有就是根据不同传感器写的不同观测模型,对于2d激光slam来讲,scan是最常见的观测方式,当然再此基础上结合gps结合反光板,结合多激光头进行多传感器融合也同样常见,原理类似</li>
<li>scan_to_map是比较常用的纯定位方式,缺点是由于重定位比较麻烦,一般对于车体初始位姿要求比较高</li>
<li>采用carto的scan_to_submap,首先在各个子图中搜索,然后再查找,不过同样的面临着一开始需要很长时间进行搜索定位的过程,所以一般做法依旧是选择较好的初始位姿.</li>
<li>基于特征匹配进行的全局定位,如scan_context或者是角特征,线特征,原特征等</li>
<li>最粗暴的方法,使用icp进行暴力穷举,我相信那一定是很让人难忘的方式</li>
</ul>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab简单教程</title>
    <url>/blog/2022/02/22/matlab%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://ww2.mathworks.cn/help/matlab/getting-started-with-matlab.html">MATLAB 快速入门 - MathWorks 中国</a> </p>
<p> <a href="https://blog.csdn.net/weixin_46125998/article/details/118991929?ops_request_misc=%7B%22request_id%22:%22164551230116780366574080%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164551230116780366574080&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118991929.pc_search_insert_es_download&utm_term=matlab&spm=1018.2226.3001.4187">(109条消息) 零基础入门Matlab（一篇两个小时就能学完的入门博客）<em>灯火阑珊</em>-CSDN博客_matlab</a> </p>
<h1 id="注释与窗口命令"><a href="#注释与窗口命令" class="headerlink" title="注释与窗口命令"></a>注释与窗口命令</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 独占一行的注释（有上下横线分割）</span></span><br><span class="line">clear all <span class="comment">% 普通注释, 清除Workspace中的所有变量（右侧工作区）</span></span><br><span class="line">clc <span class="comment">% 清除Command Window中的所有命令</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数字</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">4</span></span><br><span class="line"><span class="number">10</span><span class="number">-7</span></span><br><span class="line"><span class="number">3</span>*<span class="number">5</span></span><br><span class="line"><span class="number">8</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p> 字符与字符串 </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">s = ‘a’ （单引号表示字符串）</span><br><span class="line">==<span class="built_in">abs</span>(s)==ASCII码</span><br><span class="line">char(<span class="number">97</span>) 输出 a （ASCII码转字符串）</span><br><span class="line">num2str(<span class="number">65</span>) 输出数字<span class="number">65</span></span><br><span class="line">str=‘I love MATLAB &amp; Machine Learning’</span><br><span class="line"><span class="built_in">length</span>(str) 字符串长度</span><br><span class="line">doc num2str</span><br></pre></td></tr></table></figure>

<p> 矩阵 </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line"><span class="comment">% 转置</span></span><br><span class="line">B = A&#x27;</span><br><span class="line"><span class="comment">% 竖向展开</span></span><br><span class="line">C = A(</span><br><span class="line"><span class="comment">% 逆矩阵</span></span><br><span class="line">D = inv(A)</span><br><span class="line"><span class="comment">% 创建三维全零矩阵(由三个二维矩阵组成)</span></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">% 随机分布(0~1)</span></span><br><span class="line">E(:,:,<span class="number">1</span>) = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">% 均匀分布</span></span><br><span class="line">E(:,:,<span class="number">2</span>) = randi(<span class="number">5</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">% 正态分布</span></span><br><span class="line">E(:,:,<span class="number">3</span>) = <span class="built_in">randn</span>(<span class="number">10</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h1 id="元胞数组与结构体"><a href="#元胞数组与结构体" class="headerlink" title="元胞数组与结构体"></a>元胞数组与结构体</h1><h2 id="元胞数组-gt-类"><a href="#元胞数组-gt-类" class="headerlink" title="元胞数组 -&gt; 类"></a>元胞数组 -&gt; 类</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%元胞数组</span></span><br><span class="line">A = cell(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">A&#123;<span class="number">2</span>&#125; = <span class="built_in">eye</span>(<span class="number">3</span>) <span class="comment">%2021版本前的matlab下标从1开始</span></span><br><span class="line">A&#123;<span class="number">5</span>&#125; = <span class="built_in">magic</span>(<span class="number">5</span>)</span><br><span class="line">B = A&#123;<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%结构体</span></span><br><span class="line">books = struct(<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;Machine Learning&#x27;</span>,<span class="string">&#x27;Data Mining&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">books.name <span class="comment">%属性</span></span><br><span class="line">books.name(<span class="number">1</span>)</span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span> <span class="comment">%第二个参数为步长，不可缺省</span></span><br><span class="line">B = <span class="number">1</span>:<span class="number">3</span>:<span class="number">9</span></span><br><span class="line">C = <span class="built_in">repmat</span>(B,<span class="number">3</span>,<span class="number">2</span>) <span class="comment">%重复执行3行2列</span></span><br><span class="line">D = <span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">4</span>) <span class="comment">%生成一个2行4列的全1矩阵</span></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">4</span>)<span class="comment">%生成一个2行4列的全0矩阵</span></span><br></pre></td></tr></table></figure>

<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>; <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">B = [<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span>; <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">C = A + B</span><br><span class="line">D = A - B</span><br><span class="line">E = A * B&#x27;</span><br><span class="line">F = A .* B <span class="comment">% .*表示对应项相乘</span></span><br><span class="line">G = A / B <span class="comment">%相当于A*B的逆 G*B = A  G*B*pinv(B) = A*pinv(B)  G = A*pinv(B),相当于A乘B</span></span><br><span class="line">H = A ./ B <span class="comment">% ./表示对应项相除</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵下标"><a href="#矩阵下标" class="headerlink" title="矩阵下标"></a>矩阵下标</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">magic</span>(<span class="number">5</span>)</span><br><span class="line">B = A(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">C = A(<span class="number">3</span>,:) <span class="comment">% :为取全部,那么这条语句表示取第三行</span></span><br><span class="line">D = A(:,<span class="number">4</span>) <span class="comment">%取第四列</span></span><br><span class="line">[m,n] = <span class="built_in">find</span>(A &gt; <span class="number">20</span>) <span class="comment">%找到大于20的序号值/矩阵</span></span><br><span class="line"><span class="comment">%取的是索引值</span></span><br></pre></td></tr></table></figure>

<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="if……else……end"><a href="#if……else……end" class="headerlink" title="if……else……end"></a>if……else……end</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = randi(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">30</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &lt; <span class="number">80</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;medium&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;large&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="switch……case"><a href="#switch……case" class="headerlink" title="switch……case"></a>switch……case</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[dayNum, dayString] = weekday(date, <span class="string">&#x27;long&#x27;</span>, <span class="string">&#x27;en_US&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> dayString</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;Monday&#x27;</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Start of the work week&#x27;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;Tuesday&#x27;</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Day 2&#x27;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;Wednesday&#x27;</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Day 3&#x27;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Day 4&#x27;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;Friday&#x27;</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Last day of the work week&#x27;</span>)</span><br><span class="line">   <span class="keyword">otherwise</span></span><br><span class="line">      <span class="built_in">disp</span>(<span class="string">&#x27;Weekend!&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n = <span class="number">3</span>:<span class="number">32</span></span><br><span class="line">   r(n) = rank(<span class="built_in">magic</span>(n));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="while-注意-break-continue-return"><a href="#while-注意-break-continue-return" class="headerlink" title="while(注意:break,continue,return)"></a>while(注意:break,continue,return)</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0</span>; fa = -Inf;</span><br><span class="line">b = <span class="number">3</span>; fb = Inf;</span><br><span class="line"><span class="keyword">while</span> b-a &gt; <span class="built_in">eps</span>*b</span><br><span class="line">   x = (a+b)/<span class="number">2</span>;</span><br><span class="line">   fx = x^<span class="number">3</span><span class="number">-2</span>*x<span class="number">-5</span>;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">sign</span>(fx) == <span class="built_in">sign</span>(fa)</span><br><span class="line">      a = x; fa = fx;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      b = x; fb = fx;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%1.二维平面绘图</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span> <span class="comment">%定义x的范围，第二个参数表示步长</span></span><br><span class="line">y = <span class="built_in">sin</span>(x)</span><br><span class="line"><span class="built_in">figure</span> <span class="comment">%建立一个幕布</span></span><br><span class="line"><span class="built_in">plot</span>(x,y) <span class="comment">%绘制当前二维平面图</span></span><br><span class="line">title(<span class="string">&#x27;y = sin(x)&#x27;</span>) <span class="comment">%标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">%x轴</span></span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>) <span class="comment">%y轴</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span>]) <span class="comment">% x坐标值的范围</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%2.多个二维平面绘图</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1 = <span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,H1,H2] = plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>); <span class="comment">%共用一个x的坐标系，在y上有不同的取值</span></span><br><span class="line"><span class="comment">%设置相应的标签</span></span><br><span class="line">set(get(AX(<span class="number">1</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Slow Decay&#x27;</span>)</span><br><span class="line">set(get(AX(<span class="number">2</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Fast Decay&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(\musec)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Multiple Decay Rates&#x27;</span>)</span><br><span class="line">set(H1,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">set(H2,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%3.三维立体绘图</span></span><br><span class="line">t = <span class="number">0</span>: <span class="built_in">pi</span>/<span class="number">50</span>: <span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">sin</span>(t),<span class="built_in">cos</span>(t),t)</span><br><span class="line">xlabel(<span class="string">&#x27;sin(t)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;cos(t)&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"><span class="comment">%hold on</span></span><br><span class="line"><span class="comment">%hold off %不保留当前操作</span></span><br><span class="line">grid on <span class="comment">%把图片绘制出来，在图片中加一些网格线</span></span><br><span class="line">axis square <span class="comment">%使整个图（连同坐标系）呈方体</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>学写2d激光slam-lesson3</title>
    <url>/blog/2022/02/13/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson3/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch">xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx?spm=1011.2124.3001.5113">李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主</a> </p>
<p> <a href="https://blog.csdn.net/weixin_41170972/article/details/120015410?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.2&utm_relevant_index=4">(107条消息) ROS中点云学习（九）：sensor_msgs::LaserScan转sensor_msgs::PointCloud2_00 2的博客-CSDN博客</a> </p>
<h1 id="lesson3-PLICP"><a href="#lesson3-PLICP" class="headerlink" title="lesson3-PLICP"></a>lesson3-PLICP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 使用点到线距离最小的方式进行ICP的计算，收敛速度快很多，同时精度也更高一些． </p>
<h2 id="常见坐标系"><a href="#常见坐标系" class="headerlink" title="常见坐标系"></a>常见坐标系</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">map: 地图坐标系，也被称为世界坐标系，是静止不动的</span><br><span class="line">odom: 里程计坐标系，相对于map来说一般情况下是静止的，有些情况下会变动（定位节点为了修正机器人的位姿从而改变了map-&gt;odom间的坐标变换）</span><br><span class="line">base_link: 代表机器人的旋转中心的坐标系，相对于odom来说base_link是运动的</span><br><span class="line">laser_link: 激光雷达的坐标系，相对于base_link来说是静止的，因为雷达装在机器人上，雷达不会自己飞起来</span><br><span class="line">根据依赖关系:map -&gt; odom -&gt; base_link -&gt; laser_link</span><br></pre></td></tr></table></figure>

<h2 id="基于PL-ICP的帧间匹配"><a href="#基于PL-ICP的帧间匹配" class="headerlink" title="基于PL-ICP的帧间匹配"></a>基于PL-ICP的帧间匹配</h2><p>作者在做此实验时采用的是csm库,代码中表现为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input_.laser_ref = prev_ldp_scan_;</span><br><span class="line">input_.laser_sens = curr_ldp_scan;</span><br><span class="line">sm_icp(&amp;input_, &amp;output_);</span><br></pre></td></tr></table></figure>

<h2 id="基于PL-ICP的里程计"><a href="#基于PL-ICP的里程计" class="headerlink" title="基于PL-ICP的里程计"></a>基于PL-ICP的里程计</h2><p>由pl-icp匹配得到delta_x,delta_y,delta_theta乘以时间,并加入匀速模型,得到里程计,这里值得注意的是关于tf转换的使用,尤其麻烦.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScanMatchPLICP::ScanMatchWithPLICP</span><span class="params">(LDP &amp;curr_ldp_scan, <span class="keyword">const</span> ros::Time &amp;time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CSM is used in the following way:</span></span><br><span class="line">    <span class="comment">// The scans are always in the laser frame</span></span><br><span class="line">    <span class="comment">// The reference scan (prevLDPcan_) has a pose of [0, 0, 0]</span></span><br><span class="line">    <span class="comment">// The new scan (currLDPScan) has a pose equal to the movement</span></span><br><span class="line">    <span class="comment">// of the laser in the laser frame since the last scan</span></span><br><span class="line">    <span class="comment">// The computed correction is then propagated using the tf machinery</span></span><br><span class="line"></span><br><span class="line">    prev_ldp_scan_-&gt;odometry[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;odometry[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;odometry[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    prev_ldp_scan_-&gt;estimate[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;estimate[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;estimate[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    prev_ldp_scan_-&gt;true_pose[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;true_pose[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">    prev_ldp_scan_-&gt;true_pose[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    input_.laser_ref = prev_ldp_scan_;</span><br><span class="line">    input_.laser_sens = curr_ldp_scan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匀速模型，速度乘以时间，得到预测的odom坐标系下的位姿变换</span></span><br><span class="line">    <span class="keyword">double</span> dt = (time - last_icp_time_).toSec();</span><br><span class="line">    <span class="keyword">double</span> pr_ch_x, pr_ch_y, pr_ch_a;</span><br><span class="line">    GetPrediction(pr_ch_x, pr_ch_y, pr_ch_a, dt);</span><br><span class="line"></span><br><span class="line">    tf2::Transform prediction_change;</span><br><span class="line">    CreateTfFromXYTheta(pr_ch_x, pr_ch_y, pr_ch_a, prediction_change);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// account for the change since the last kf, in the fixed frame</span></span><br><span class="line">    <span class="comment">// 将odom坐标系下的坐标变换 转换成 base_in_odom_keyframe_坐标系下的坐标变换</span></span><br><span class="line">    prediction_change = prediction_change * (base_in_odom_ * base_in_odom_keyframe_.inverse());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the predicted change of the laser&#x27;s position, in the laser frame</span></span><br><span class="line">    <span class="comment">// 将base_link坐标系下的坐标变换 转换成 雷达坐标系下的坐标变换</span></span><br><span class="line">    tf2::Transform prediction_change_lidar;</span><br><span class="line">    prediction_change_lidar = laser_to_base_ * base_in_odom_.inverse() * prediction_change * base_in_odom_ * base_to_laser_;</span><br><span class="line"></span><br><span class="line">    input_.first_guess[<span class="number">0</span>] = prediction_change_lidar.getOrigin().getX();</span><br><span class="line">    input_.first_guess[<span class="number">1</span>] = prediction_change_lidar.getOrigin().getY();</span><br><span class="line">    input_.first_guess[<span class="number">2</span>] = tf2::getYaw(prediction_change_lidar.getRotation());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If they are non-Null, free covariance gsl matrices to avoid leaking memory</span></span><br><span class="line">    <span class="keyword">if</span> (output_.cov_x_m)</span><br><span class="line">    &#123;</span><br><span class="line">        gsl_matrix_free(output_.cov_x_m);</span><br><span class="line">        output_.cov_x_m = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output_.dx_dy1_m)</span><br><span class="line">    &#123;</span><br><span class="line">        gsl_matrix_free(output_.dx_dy1_m);</span><br><span class="line">        output_.dx_dy1_m = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output_.dx_dy2_m)</span><br><span class="line">    &#123;</span><br><span class="line">        gsl_matrix_free(output_.dx_dy2_m);</span><br><span class="line">        output_.dx_dy2_m = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    start_time_ = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="comment">// 调用csm进行plicp计算</span></span><br><span class="line">    sm_icp(&amp;input_, &amp;output_);</span><br><span class="line"></span><br><span class="line">    end_time_ = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    time_used_ = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end_time_ - start_time_);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;PLICP计算用时: &quot; &lt;&lt; time_used_.count() &lt;&lt; &quot; 秒。&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    tf2::Transform corr_ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_.valid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 雷达坐标系下的坐标变换</span></span><br><span class="line">        tf2::Transform corr_ch_l;</span><br><span class="line">        CreateTfFromXYTheta(output_.x[<span class="number">0</span>], output_.x[<span class="number">1</span>], output_.x[<span class="number">2</span>], corr_ch_l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将雷达坐标系下的坐标变换 转换成 base_link坐标系下的坐标变换</span></span><br><span class="line">        corr_ch = base_to_laser_ * corr_ch_l * laser_to_base_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 base_link 在 odom 坐标系下 的坐标</span></span><br><span class="line">        base_in_odom_ = base_in_odom_keyframe_ * corr_ch;</span><br><span class="line"></span><br><span class="line">        latest_velocity_.linear.x = corr_ch.getOrigin().getX() / dt;</span><br><span class="line">        latest_velocity_.angular.z = tf2::getYaw(corr_ch.getRotation()) / dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_WARN(<span class="string">&quot;not Converged&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布tf与odom话题</span></span><br><span class="line">    PublishTFAndOdometry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要更新关键帧坐标</span></span><br><span class="line">    <span class="keyword">if</span> (NewKeyframeNeeded(corr_ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新关键帧坐标</span></span><br><span class="line">        ld_free(prev_ldp_scan_);</span><br><span class="line">        prev_ldp_scan_ = curr_ldp_scan;</span><br><span class="line">        base_in_odom_keyframe_ = base_in_odom_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ld_free(curr_ldp_scan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_icp_time_ = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>学写2d激光slam</title>
    <url>/blog/2022/02/11/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch">xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com)</a> </p>
<p> <a href="https://blog.csdn.net/tiancailx?spm=1011.2124.3001.5113">李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主</a> </p>
<p> <a href="https://blog.csdn.net/YMWM_/article/details/101601345">(105条消息) 在linux ubuntu18.04版本中安装ceres solver_YMWM_的博客-CSDN博客_linux 安装ceres</a> </p>
<p> <a href="https://blog.csdn.net/jz1570551401/article/details/78207208?ops_request_misc=%7B%22request_id%22:%22164456963316780269873261%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164456963316780269873261&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-78207208.pc_search_result_control_group&utm_term=%E5%AE%89%E8%A3%85ceres&spm=1018.2226.3001.4187">(105条消息) 在Ubuntu16.04下安装Ceres_江南古镇的博客-CSDN博客_ceres安装</a> </p>
<p> <a href="https://blog.csdn.net/slzlincent/article/details/86555166?ops_request_misc=%7B%22request_id%22:%22164457025816780271978715%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164457025816780271978715&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86555166.pc_search_result_control_group&utm_term=g2o%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">(105条消息) ubuntu16.04安装g2o_slzlincent的博客-CSDN博客_安装g2o</a> </p>
<p> <a href="https://blog.csdn.net/lun55423/article/details/109036995">(105条消息) 【已解决】error: no matching function for call to ‘g2o::BlockSolver…_Bungehurst-CSDN博客</a> </p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>melodic</li>
<li>ceres</li>
<li>g2o</li>
<li>gtsam</li>
<li>ubuntu18</li>
</ul>
<h2 id="ubuntu18安装ros1"><a href="#ubuntu18安装ros1" class="headerlink" title="ubuntu18安装ros1"></a>ubuntu18安装ros1</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list.d/ros-latest.list</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic main</span><br><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install ros-melodic-desktop-full</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line">sudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>使用小于解决rosdep问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros</span><br></pre></td></tr></table></figure>

<h2 id="下载github并安装必要库"><a href="#下载github并安装必要库" class="headerlink" title="下载github并安装必要库"></a>下载github并安装必要库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get clone https://ghproxy.com/https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch</span><br></pre></td></tr></table></figure>

<h3 id="ceres安装"><a href="#ceres安装" class="headerlink" title="ceres安装"></a>ceres安装</h3><p>依赖安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br><span class="line">sudo apt-get install libgoogle-glog-dev</span><br><span class="line">sudo apt-get install libatlas-base-dev</span><br><span class="line">sudo apt-get install libeigen3-dev</span><br><span class="line">sudo apt-get install libsuitesparse-dev</span><br><span class="line">sudo apt-get install libgtest-dev</span><br><span class="line">sudo add-apt-repository ppa:bzindovic/suitesparse-bugfix-1319687</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libsuitesparse-dev</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Creating-2D-laser-slam-from-scratch/TrirdParty/ceres-solver-1.13.0</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="g2o安装"><a href="#g2o安装" class="headerlink" title="g2o安装"></a>g2o安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/RainerKuemmerle/g2o.git</span><br><span class="line">sudo apt-get install libeigen3-dev</span><br><span class="line">sudo apt-get install libsuitesparse-dev</span><br><span class="line">sudo apt-get install qtdeclarative5-dev</span><br><span class="line">sudo apt-get install qt5-qmake</span><br><span class="line">sudo apt-get install libqglviewer-dev</span><br><span class="line">cd g2o</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="gtsam安装"><a href="#gtsam安装" class="headerlink" title="gtsam安装"></a>gtsam安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Creating-2D-laser-slam-from-scratch/TrirdParty/gtsam</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="修改源文件"><a href="#修改源文件" class="headerlink" title="修改源文件"></a>修改源文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/Creating-2D-laser-slam-from-scratch/lesson6/src/g2o_solver/g2o_solver.cc中</span></span><br><span class="line"><span class="comment">// 修改为如下</span></span><br><span class="line">G2oSolver::<span class="built_in">G2oSolver</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 第1步：创建一个线性求解器LinearSolver</span></span><br><span class="line">  SlamLinearSolver *linearSolver = <span class="keyword">new</span> <span class="built_in">SlamLinearSolver</span>();</span><br><span class="line">  linearSolver-&gt;<span class="built_in">setBlockOrdering</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 第2步：创建BlockSolver。并用上面定义的线性求解器初始化</span></span><br><span class="line">  SlamBlockSolver *blockSolver = <span class="keyword">new</span> <span class="built_in">SlamBlockSolver</span>(std::unique_ptr&lt;SlamLinearSolver&gt;(linearSolver));</span><br><span class="line">  linearSolver-&gt;<span class="built_in">setBlockOrdering</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 第3步：创建总求解器solver。并从GN, LM, DogLeg 中选一个，再用上述块求解器BlockSolver初始化</span></span><br><span class="line">  g2o::OptimizationAlgorithmLevenberg *solver =</span><br><span class="line">      <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(std::unique_ptr&lt;SlamBlockSolver&gt;(blockSolver));</span><br><span class="line">  <span class="comment">// 第4步：创建稀疏优化器（SparseOptimizer）</span></span><br><span class="line">  mOptimizer.<span class="built_in">setAlgorithm</span>(solver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p catkin_ws/src</span><br><span class="line">cd catkin_ws/src</span><br><span class="line">git clone https://ghproxy.com/https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch</span><br><span class="line">cd .. &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式业务逻辑</title>
    <url>/blog/2021/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/aa120515692/article/details/104990729?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-104990729.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">嵌入式架构到底有多重要？看完惊呆了_连志安-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/aa120515692/article/details/104274547?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-21-104274547.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">史上最详细！嵌入式系统知识和接口技术总结_连志安-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ybhuangfugui/article/details/115388269?ops_request_misc=%7B%22request_id%22:%22163585931016780261966695%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163585931016780261966695&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-26-115388269.pc_search_mgc_flag&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&spm=1018.2226.3001.4187">嵌入式开发中为什么很少用设计模式？_strongerHuang-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/nh5431313/article/details/104922035?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-104922035.pc_search_mgc_flag&spm=1018.2226.3001.4187">嵌入式架构_分享嵌入式,移动端,智能应用,数据库等专业板块,记录知识碎片！！！-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ITLearnHall/article/details/82985480?ops_request_misc=%7B%22request_id%22:%22163586126216780265434712%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163586126216780265434712&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82985480.pc_search_mgc_flag&utm_term=%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84&spm=1018.2226.3001.4187">应用架构、业务架构、技术架构和业务流程图详解_代码帮-CSDN博客_业务架构</a></p>
<p><a href="https://www.eet-china.com/mp/a69844.html">提高RTOS应用程序稳定可靠的几点技巧-面包板社区 (eet-china.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_42616791/article/details/108548128?ops_request_misc=%7B%22request_id%22:%22163576619116780366553575%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163576619116780366553575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-108548128.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">RTOS 是如何进行任务划分的？_wenzi嵌入式软件的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_35021496/article/details/81035750?ops_request_misc=%7B%22request_id%22:%22163576619116780271563446%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163576619116780271563446&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81035750.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">UCOS 等 RTOS的任务划分原则（转载整理）_Dr树树的博客-CSDN博客</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TmhxU21PQkpDd1dOMkZDT2ljdW5XNnk3STFsd3BZR2Y1NFNUSkYwejNKaWJUNzFYTXdNQjh5TktESjZ3ZFNiTTRWM0VDWmZVYWU2ZzdnLzY0MA?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TmhxU21PQkpDd1dOMkZDT2ljdW5XNnl6TFhzQlNJUzY3cDJKZ0hkNEdSUUVpY0c4UWF0aWIzUFJtTDNMajBrMGx0b1dXQ1ZFeGh5N0x5QS82NDA?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9NTGZTVG5jQzN0TkJjaWFpYmRoaWNOcmg3OEJmcFdKM3JaOFFyUHFPVzBlVk12UzdoWDZMMGtiWGdNdXlzNEFKaWNUb1pkQVZ5S3dySldVQ1A1TFUzbUExWXcvNjQw?x-oss-process=image/format,png" alt="img"><img src="https://img-blog.csdnimg.cn/2021010409370574.gif" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180115133844637?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><img src="https://i.loli.net/2021/11/23/7UcLHNskClj6Y12.png" alt="image-20211123223940120.png"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式分层</title>
    <url>/blog/2022/01/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/wxg_wuchujie88/article/details/85992064">(94条消息) 例解嵌入式系统分层结构_和风化雨-CSDN博客_嵌入式系统分层</a> </p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p> 分层的目的主要:1,是降低系统开发难度；2,是为了复用。 </p>
<h1 id="两层结构-硬件层-软件层"><a href="#两层结构-硬件层-软件层" class="headerlink" title="两层结构[硬件层, 软件层]"></a>两层结构[硬件层, 软件层]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      P1_1=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">      P1_1=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三层结构-硬件层，-驱动层，应用层"><a href="#三层结构-硬件层，-驱动层，应用层" class="headerlink" title="三层结构[ 硬件层， 驱动层，应用层 ]"></a>三层结构[ 硬件层， 驱动层，应用层 ]</h1><p>虽然简单但很有逻辑,可以参考</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************驱动头文件 driver.h***********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_on</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_off</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*******************驱动源文件 driver.c************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;driver.h&quot;</span></span></span><br><span class="line"><span class="comment">/*延时函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_on</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   P1_1=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_off</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   P1_1=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************应用系统****************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>“../driver/driver.h”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123; </span><br><span class="line">       led_on();</span><br><span class="line">       delay();</span><br><span class="line">       led_off();</span><br><span class="line">       delay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四层结构-硬件层，驱动层，操作系统层，应用层"><a href="#四层结构-硬件层，驱动层，操作系统层，应用层" class="headerlink" title="四层结构[ 硬件层，驱动层，操作系统层，应用层 ]"></a>四层结构[ 硬件层，驱动层，操作系统层，应用层 ]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************驱动****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kerel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm/h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_cleanup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_open</span><span class="params">(struct inode *,struct file*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_release</span><span class="params">(struct inode *,struct file*)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> device _write(struct file*,<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">size_t</span>,<span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_model</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_ops</span>=</span>&#123;</span><br><span class="line">.owner=THIS_MODULE,</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> led_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> led_cleanup()</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> device_open(struct inode * inode ,struct file* file)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> device_release(struct inode *inode,struct file* file)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> device _write(struct file *file,<span class="keyword">const</span> <span class="keyword">char</span> * buffer,<span class="keyword">size_t</span> length,<span class="keyword">loff_t</span> *offset)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line"><span class="keyword">int</span> init_model(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br><span class="line">modele_init(led_init);</span><br><span class="line">module_exit(led_cleanup);</span><br><span class="line">MODULE_LICENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="comment">/******************************应用****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED  <span class="meta-string">&quot;/dev/led&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    File *fp=fopen(LED,RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ioctl(fp,<span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        ioctl(fp,<span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>微雪树莓派安装ubuntu18_server</title>
    <url>/blog/2022/03/30/%E5%BE%AE%E9%9B%AA%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://www.waveshare.net/wiki/CM4_Burn_EMMC">CM4 Burn EMMC - Waveshare Wiki</a> </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>安装 <a href="https://www.waveshare.net/w/upload/f/f3/Rpiboot_setup.zip">rpiboot 软件</a></li>
<li>将 BOOT开关拨至ON </li>
<li>打开 rpiboot软件,会出现如下,说明已经连接上树莓派</li>
</ul>
<p> <img src="https://www.waveshare.net/w/upload/0/06/CM4_Burn_EMMC_5.png" alt="CM4 Burn EMMC 5.png"></p>
<ul>
<li>安装<a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">树莓派镜像烧录器</a></li>
<li>下载[ubuntu8_server]( <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/">Index of /ubuntu-cdimage/ubuntu/releases/18.04.5/release/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a> )</li>
<li>使用树莓派烧录器安装ubuntu18_server</li>
<li>完成后重启树莓派,修改boot下<code>network-config</code>与<code>user-data</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: 2</span><br><span class="line">ethernets:</span><br><span class="line">  eth0:</span><br><span class="line">    dhcp4: false</span><br><span class="line">    addresses: [192.168.8.110/24]</span><br><span class="line">  eth1:</span><br><span class="line">    dhcp4: false</span><br><span class="line">    addresses: [192.168.8.111/24]</span><br><span class="line">wifis:</span><br><span class="line">  wlan0:</span><br><span class="line">    access-points:</span><br><span class="line">      HUAWEI_PTY:</span><br><span class="line">        password: pty123456787</span><br><span class="line">    dhcp4: true                         </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh_pwauth: true</span><br><span class="line">chpasswd:</span><br><span class="line">  expire: false</span><br><span class="line">  list:</span><br><span class="line">  - ubuntu:ubuntu</span><br></pre></td></tr></table></figure>

<ul>
<li> USB2.0 默认是关闭的，如需打开需要在config.txt中添加 dtoverlay=dwc2,dr_mode=host </li>
<li>将 BOOT开关拨至OFF,连接显示屏查看ip</li>
<li>使用<code>sudo systemctl enable ssh</code>与<code>sudo systemctl start ssh</code>启动ssh</li>
<li>通过ssh <a href="mailto:&#x75;&#98;&#x75;&#x6e;&#116;&#117;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#56;&#46;&#56;&#46;&#49;&#49;&#48;">&#x75;&#98;&#x75;&#x6e;&#116;&#117;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#56;&#46;&#56;&#46;&#49;&#49;&#48;</a>连接树莓派</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>思维导图与流程图</title>
    <url>/blog/2022/02/22/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B8%8E%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://app.diagrams.net/">diagrams.net</a> </p>
<p> <a href="https://processflow.sharehoo.cn/diagrams#recommend">ProcessFlow - 免费在线作图，思维导图，流程图，实时协作 (sharehoo.cn)</a> </p>
<p> <a href="https://www.edrawmax.cn/online/zh/">亿图图示在线 (edrawmax.cn)</a> </p>
<p> <a href="http://www.ddooo.com/softdown/185993.htm">xmind2020中文破解版</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最强大的莫过于diagrams,但如果论好用便捷的话当属亿图,但有限制(土豪除外),prosessflow需要vip咱用不起,不过看样子挺好用的,当然还有破解版的xmind也不错,</p>
<h1 id="diagrams"><a href="#diagrams" class="headerlink" title="diagrams"></a>diagrams</h1><p>基本上能想到的都可以使用里边的插图也非常多,白嫖党最爱</p>
<h1 id="prossesflow"><a href="#prossesflow" class="headerlink" title="prossesflow"></a>prossesflow</h1><p>没使用过</p>
<h1 id="亿图在线"><a href="#亿图在线" class="headerlink" title="亿图在线"></a>亿图在线</h1><p>很好使用就是不是vip有限制,这就很折磨人了,后果断转diagrams,毕竟github开源王道</p>
<h1 id="xmind"><a href="#xmind" class="headerlink" title="xmind"></a>xmind</h1><p>思维导图神器,非常便于使用,学习,记录思路都用这个</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式相关的开源项目</title>
    <url>/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw">https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw</a></p>
<h2 id="1-Avem"><a href="#1-Avem" class="headerlink" title="1.Avem"></a>1.<a href="https://github.com/avem-labs/Avem">Avem</a></h2><p>这是一个轻量级无人机飞控项目。</p>
<h1 id="2-Awesome-Embedded"><a href="#2-Awesome-Embedded" class="headerlink" title="2.Awesome-Embedded"></a>2.<a href="https://github.com/nhivp/Awesome-Embedded">Awesome-Embedded</a></h1><p>这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源：</p>
<h1 id="3-soft-and-hard"><a href="#3-soft-and-hard" class="headerlink" title="3.soft-and-hard"></a>3.<a href="https://github.com/alwxkxk/soft-and-hard">soft-and-hard</a></h1><p>这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。</p>
<h1 id="4-FreeModbus"><a href="#4-FreeModbus" class="headerlink" title="4.FreeModbus"></a>4.<a href="https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32">FreeModbus</a></h1><p>FreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要<strong>收费</strong>的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。</p>
<h1 id="5-EmbedSummary"><a href="#5-EmbedSummary" class="headerlink" title="5. EmbedSummary"></a>5.<strong><a href="https://github.com/zhengnianli/EmbedSummary"> EmbedSummary</a></strong></h1><p>精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>手撸高斯牛顿</title>
    <url>/blog/2022/03/01/%E6%89%8B%E6%92%B8%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://github.com/gaoxiang12/slambook2/tree/master/ch6">slambook2/ch6 at master · gaoxiang12/slambook2 (github.com)</a> </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>给定初值x0.</li>
<li>对于k次迭代,求出当前雅可比矩阵J(xk)和误差发(xk).</li>
<li>求解增量方程:Hdxk=g.</li>
<li>若dxk足够小则停止.否则,令xk+1 = xk +dx,返回第2步.</li>
</ul>
<h1 id="高翔博士的"><a href="#高翔博士的" class="headerlink" title="高翔博士的"></a>高翔博士的</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">  <span class="comment">// 给定初值</span></span><br><span class="line">  <span class="keyword">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;        <span class="comment">// 估计参数值</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">100</span>;                                 <span class="comment">// 数据点</span></span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;                        <span class="comment">// 噪声Sigma值</span></span><br><span class="line">  <span class="keyword">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;            <span class="comment">// 噪声的逆</span></span><br><span class="line">  cv::RNG rng;                                 <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line">  <span class="comment">// 产生真实值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">    x_data.push_back(x); <span class="comment">// 在x_data最后边存放x值</span></span><br><span class="line">    y_data.push_back(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); <span class="comment">//产生一个高斯噪声</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始Gauss-Newton迭代</span></span><br><span class="line">  <span class="keyword">int</span> iterations = <span class="number">100</span>;    <span class="comment">// 迭代次数</span></span><br><span class="line">  <span class="keyword">double</span> cost = <span class="number">0</span>, lastCost = <span class="number">0</span>;  <span class="comment">// 本次迭代的cost和上一次迭代的cost</span></span><br><span class="line"></span><br><span class="line">  chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> iter = <span class="number">0</span>; iter &lt; iterations; iter++) &#123;</span><br><span class="line"></span><br><span class="line">    Matrix3d H = Matrix3d::Zero();             <span class="comment">// Hessian = J^T W^&#123;-1&#125; J in Gauss-Newton</span></span><br><span class="line">    Vector3d b = Vector3d::Zero();             <span class="comment">// bias</span></span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">double</span> xi = x_data[i], yi = y_data[i];  <span class="comment">// 第i个数据点</span></span><br><span class="line">      <span class="comment">// 对误差项error做最小二乘</span></span><br><span class="line">      <span class="keyword">double</span> error = yi - <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);</span><br><span class="line">      Vector3d J; <span class="comment">// 雅可比矩阵(Jacobian可以通过matlab求解)</span></span><br><span class="line">      J[<span class="number">0</span>] = -xi * xi * <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/da</span></span><br><span class="line">      J[<span class="number">1</span>] = -xi * <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/db</span></span><br><span class="line">      J[<span class="number">2</span>] = -<span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/dc</span></span><br><span class="line"></span><br><span class="line">      H += inv_sigma * inv_sigma * J * J.transpose();</span><br><span class="line">      b += -inv_sigma * inv_sigma * error * J;</span><br><span class="line"></span><br><span class="line">      cost += error * error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解线性方程 Hx=b</span></span><br><span class="line">    Vector3d dx = H.ldlt().solve(b);</span><br><span class="line">    <span class="keyword">if</span> (isnan(dx[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is nan!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter &gt; <span class="number">0</span> &amp;&amp; cost &gt;= lastCost) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost: &quot;</span> &lt;&lt; cost &lt;&lt; <span class="string">&quot;&gt;= last cost: &quot;</span> &lt;&lt; lastCost &lt;&lt; <span class="string">&quot;, break.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ae += dx[<span class="number">0</span>];</span><br><span class="line">    be += dx[<span class="number">1</span>];</span><br><span class="line">    ce += dx[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    lastCost = cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total cost: &quot;</span> &lt;&lt; cost &lt;&lt; <span class="string">&quot;, \t\tupdate: &quot;</span> &lt;&lt; dx.transpose() &lt;&lt;</span><br><span class="line">         <span class="string">&quot;\t\testimated params: &quot;</span> &lt;&lt; ae &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; be &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ce &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">  chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.count() &lt;&lt; <span class="string">&quot; seconds. &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;estimated abc = &quot;</span> &lt;&lt; ae &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; be &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ce &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用matlab实现一次"><a href="#用matlab实现一次" class="headerlink" title="用matlab实现一次"></a>用matlab实现一次</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all; close all; clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一组符合高斯噪声的,exp(1*X^2+2*x+1)的随机数</span></span><br><span class="line">ar=<span class="number">1</span>;</span><br><span class="line">br=<span class="number">2</span>;</span><br><span class="line">cr=<span class="number">1</span>;</span><br><span class="line">n = <span class="number">100</span>;    <span class="comment">% 样本数</span></span><br><span class="line">w_sigma = <span class="number">1</span>;<span class="comment">% 噪声值</span></span><br><span class="line">inv_sigma = <span class="number">1</span>/w_sigma;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    x(<span class="built_in">i</span>) = <span class="built_in">i</span>/n;</span><br><span class="line">    y(<span class="built_in">i</span>) = <span class="built_in">exp</span>(ar*x(<span class="built_in">i</span>)^<span class="number">2</span>+br*x(<span class="built_in">i</span>)+cr)+normrnd(<span class="number">0</span>,w_sigma);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置x0初值</span></span><br><span class="line">ae = <span class="number">2.0</span>;be=<span class="number">-1.0</span>;ce=<span class="number">5.0</span>;</span><br><span class="line">cost = <span class="number">0</span>;lastcost=<span class="number">0</span>;</span><br><span class="line">iterations = <span class="number">100</span>;<span class="comment">% 迭代次数</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:iterations</span><br><span class="line">    H = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    g = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    J = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        error = y(<span class="built_in">j</span>) - <span class="built_in">exp</span>(ae*x(<span class="built_in">j</span>)^<span class="number">2</span>+be*x(<span class="built_in">j</span>)+ce);</span><br><span class="line"></span><br><span class="line">        J(<span class="number">1</span>) = -x(<span class="built_in">j</span>) * x(<span class="built_in">j</span>) * <span class="built_in">exp</span>(ae * x(<span class="built_in">j</span>) * x(<span class="built_in">j</span>) + be * x(<span class="built_in">j</span>) + ce); <span class="comment">% ae</span></span><br><span class="line">        J(<span class="number">2</span>) = -x(<span class="built_in">j</span>) * <span class="built_in">exp</span>(ae * x(<span class="built_in">j</span>) * x(<span class="built_in">j</span>) + be * x(<span class="built_in">j</span>) + ce); <span class="comment">% be</span></span><br><span class="line">        J(<span class="number">3</span>) = -<span class="built_in">exp</span>(ae * x(<span class="built_in">j</span>) * x(<span class="built_in">j</span>) + be * x(<span class="built_in">j</span>) + ce); <span class="comment">% ce</span></span><br><span class="line"></span><br><span class="line">        H = H+inv_sigma^<span class="number">2</span>*J*J&#x27;;</span><br><span class="line">        g = g-inv_sigma^<span class="number">2</span>*J*error;</span><br><span class="line"></span><br><span class="line">        cost = cost + error^<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 求解Hx=g</span></span><br><span class="line">    deltax = inv(H)*g;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> iter&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">abs</span>(cost-lastcost)&lt;<span class="number">0.001</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;cost:&#x27;</span>+cost);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    ae = ae+deltax(<span class="number">1</span>);</span><br><span class="line">    be = be+deltax(<span class="number">2</span>);</span><br><span class="line">    ce = ce+deltax(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lastcost = cost;</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;iter: &#x27;</span>,num2str(iter),<span class="string">&#x27; &#x27;</span>, num2str(ae),<span class="string">&#x27; &#x27;</span>,num2str(be),<span class="string">&#x27; &#x27;</span>,num2str(ce)]);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f = <span class="built_in">exp</span>(ae*x.^<span class="number">2</span>+be*x+ce);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;bo&#x27;</span>,x,f,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索网站</title>
    <url>/blog/2022/03/01/%E6%90%9C%E7%B4%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://zhuanlan.zhihu.com/p/60840594">15个好用的百度网盘搜索引擎 - 知乎 (zhihu.com)</a> </p>
<h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><p><strong>1、云铺子 - 百度网盘搜索引擎</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.yunpz.net/">http://www.yunpz.net/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★★★</li>
<li>备注：聚合类，体验好，<strong>推荐！</strong></li>
</ul>
<p><strong>2、橘子盘搜-好用的影视资源搜索引擎</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.nmme.cc/">https://www.nmme.cc/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★★★</li>
<li>备注：专攻影视搜索，度盘、迅雷、阿里，体验好，<strong>推荐！</strong></li>
</ul>
<p><strong>3、优聚搜</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://ujuso.com/">https://ujuso.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★★★</li>
<li>备注：支持度盘、蓝奏、阿里，体验好，<strong>推荐！</strong></li>
</ul>
<p><strong>4、蓝瘦网盘在线搜索网页版</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.sixyin.com/disk-search">http://www.sixyin.com/disk-search</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★★☆</li>
<li>备注：蓝奏云搜索，<strong>推荐！</strong></li>
</ul>
<p><strong>5、阿里盘搜 - 阿里云盘资源搜索神器</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.alipanso.com/">https://www.alipanso.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★★☆</li>
<li>备注：阿里盘搜索，<strong>推荐！</strong></li>
</ul>
<p><strong>6、懒盘搜索聚合官网</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://lzpan.com/">https://lzpan.com/</a></li>
<li>查看方式：各种都有</li>
<li>推荐指数：★★★★☆</li>
<li>备注：聚合类，含16个搜索引擎</li>
</ul>
<p><strong>7、超能搜 - 百度网盘搜索神器</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.chaonengso.com/">http://www.chaonengso.com/</a></li>
<li>查看方式：各种都有</li>
<li>推荐指数：★★★★☆</li>
<li>备注：聚合类，含18个搜索引擎</li>
</ul>
<p><strong>8、万网搜 - 资源搜索聚合神器</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.wanwangsou.com/">http://www.wanwangsou.com/</a></li>
<li>查看方式：各种都有</li>
<li>推荐指数：★★★★☆</li>
<li>备注：聚合类，含15个搜索引擎</li>
</ul>
<p><strong>9、云盘狗-百度云网盘搜索</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.yunpangou.com/">http://www.yunpangou.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
<p><strong>10、学搜搜</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.xuesousou.com/">http://www.xuesousou.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
<li>备注：学习资源搜索</li>
</ul>
<p><strong>11、盘131 - 云盘资源搜索引擎</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.pan131.com/">https://www.pan131.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
<p><strong>12、58网盘搜索</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.58wangpan.com/">https://www.58wangpan.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
<p><strong>13、56网盘搜索</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.56wangpan.net/">https://www.56wangpan.net/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
<p><strong>14、一个好用的网盘搜索引擎 - 乌鸦搜</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=https://www.wuyasou.com/">https://www.wuyasou.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
<p><strong>15、bdy搜</strong></p>
<ul>
<li>地址：<a href="https://link.zhihu.com/?target=http://www.bdyso.com/">http://www.bdyso.com/</a></li>
<li>查看方式：直接打开</li>
<li>推荐指数：★★★☆☆</li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>查看程序使用情况</title>
    <url>/blog/2021/12/01/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a href="https://blog.csdn.net/mayue_web/article/details/105388617">Linux下查看某个进程所占用的资源_mayue_web的博客-CSDN博客_查看进程占用资源</a></p>
<h1 id="shell例程"><a href="#shell例程" class="headerlink" title="shell例程"></a>shell例程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改这里的./Tungray运行程序,用于查看pid</span></span><br><span class="line">ps -aux | grep ./Tungray &gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取第一行,并解析pid</span></span><br><span class="line">pid=`awk &#x27;NR==1&#123;print $2&#125;&#x27; pid`</span><br><span class="line"></span><br><span class="line">cat /proc/$pid/status &gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取第一行,并解析pid</span></span><br><span class="line">state=`awk &#x27;NR==2&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;state:&quot;$state`awk &#x27;NR==2&#123;print $3&#125;&#x27; pid`</span><br><span class="line">VmSize=`awk &#x27;NR==12&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;VmSize:&quot;$VmSize`awk &#x27;NR==12&#123;print $3&#125;&#x27; pid`</span><br><span class="line">VmRSS=`awk &#x27;NR==15&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;VmRSS:&quot;$VmRSS`awk &#x27;NR==15&#123;print $3&#125;&#x27; pid`</span><br><span class="line">Threads=`awk &#x27;NR==21&#123;print $2&#125;&#x27; pid`</span><br><span class="line">echo &quot;Threads:&quot;$Threads</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Name 应用程序或命令的名字 </span><br><span class="line">State 任务的状态，运行/睡眠/僵死/ </span><br><span class="line">SleepAVG 任务的平均等待时间(以nanosecond为单位)，交互式任务因为休眠次数多、时间长，它们的 sleep_avg 也会相应地更大一些，所以计算出来的优先级也会相应高一些。 </span><br><span class="line">Tgid 线程组号 </span><br><span class="line">Pid 任务ID </span><br><span class="line">Ppid 父进程ID </span><br><span class="line">TracerPid 接收跟踪该进程信息的进程的ID号 </span><br><span class="line">Uid Uid euid suid fsuid </span><br><span class="line">Gid Gid egid sgid fsgid </span><br><span class="line">FDSize 文件描述符的最大个数，file-&gt;fds </span><br><span class="line">Groups </span><br><span class="line">VmSize(KB) 任务虚拟地址空间的大小 (total_vm-reserved_vm)，其中total_vm为进程的地址空间的大小，reserved_vm：进程在预留或特殊的内存间的物理页 </span><br><span class="line">VmLck(KB) 任务已经锁住的物理内存的大小。锁住的物理内存不能交换到硬盘 (locked_vm) </span><br><span class="line">VmRSS(KB) 应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss) </span><br><span class="line">VmData(KB) 程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据； (total_vm-shared_vm-stack_vm) </span><br><span class="line">VmStk(KB) 任务在用户态的栈的大小 (stack_vm) </span><br><span class="line">VmExe(KB) 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库 (end_code-start_code) </span><br><span class="line">VmLib(KB) 被映像到任务的虚拟内存空间的库的大小 (exec_lib) </span><br><span class="line">VmPTE 该进程的所有页表的大小，单位：kb </span><br><span class="line">Threads 共享使用该信号描述符的任务的个数，在POSIX多线程序应用程序中，线程组中的所有线程使用同一个信号描述符。 </span><br><span class="line">SigQ 待处理信号的个数 </span><br><span class="line">SigPnd 屏蔽位，存储了该线程的待处理信号 </span><br><span class="line">ShdPnd 屏蔽位，存储了该线程组的待处理信号 </span><br><span class="line">SigBlk 存放被阻塞的信号 </span><br><span class="line">SigIgn 存放被忽略的信号 </span><br><span class="line">SigCgt 存放被俘获到的信号 </span><br><span class="line">CapInh Inheritable，能被当前进程执行的程序的继承的能力 </span><br><span class="line">CapPrm Permitted，进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的，CapEff是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性 </span><br><span class="line">CapEff Effective，进程的有效能力 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>时间触发嵌入式系统设计模式</title>
    <url>/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/wowocpp/article/details/82887244">时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式</a></p>
<p><a href="https://github.com/yzhong52/SimpleTimer">SimpleTimer</a></p>
<p>[Linux下C实现的自定义定时器](<a href="https://github.com/voidAspire/Timer">voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)</a>)</p>
<p>[CppTimer](<a href="https://github.com/berndporr/cppTimer">berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)</a>)</p>
<p>[simple-timer-for-c-language](<a href="https://github.com/ielife/simple-timer-for-c-language">ielife/simple-timer-for-c-language: high performance timer for linux (github.com)</a>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// GPIO_LED : GPIO output to control an on-board red LED</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// EVB : Nu-LB-NUC140</span></span><br><span class="line"><span class="comment">// MCU : NUC140VE3CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// low-active output control by GPC12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NUC100Series.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MCU_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SYS_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	SCH_Update();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSysTickClk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	SCH_Init();</span><br><span class="line">    </span><br><span class="line">	SysTick-&gt;LOAD = <span class="number">1000</span> *CyclesPerUs <span class="number">-1</span>;</span><br><span class="line">	SysTick-&gt;VAL  = (<span class="number">0x00</span>);</span><br><span class="line">	</span><br><span class="line">	NVIC_EnableIRQ(SysTick_IRQn);</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_Update</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_TOGGLE(PC14);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_UpdateD</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_TOGGLE(PC12);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYS_Init(); 	 </span><br><span class="line">		UART_Open(UART0, <span class="number">115200</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello World \r\n&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">        GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);</span><br><span class="line">		GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);</span><br><span class="line">		GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);</span><br><span class="line">			</span><br><span class="line">		InitSysTickClk();</span><br><span class="line">        SCH_Add_Task(LED_Flash_Update, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">		SCH_Add_Task(LED_Flash_UpdateD, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      SCH_Dispatch_Tasks();</span><br><span class="line">   &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scheduler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SCHEDULER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SCHEDULER_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的函数原型 -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器内核函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (*) (<span class="keyword">void</span>), <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的常数 -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间任一时刻请求的任务最大数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间</span></span><br><span class="line"><span class="comment">// 每个新建项目都必须调整</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCH_MAX_TASKS   (3)   </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scheduler.c</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   SCH51.C (v1.00) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   /// 这里是调度器内核函数 ///</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 这里是调度器内核函数 ***</span></span><br><span class="line"><span class="comment">   --- 这些函数可以用于所有 8051 芯片 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** hSCH_MAX_TASKS 必须由用户设置 ***</span></span><br><span class="line"><span class="comment">   --- 参见 &quot;Sch51.h&quot; ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 包括省电模式***</span></span><br><span class="line"><span class="comment">   --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----）</span></span><br><span class="line"><span class="comment">   --- 诸如 c515c, c509,等等才需要 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> tByte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  tWord;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tLong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_TOO_MANY_TASKS (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CANNOT_DELETE_TASK (2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_LOST_SLAVE (5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CAN_BUS_ERROR (6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE (10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE (11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE_AT24C64 (12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE_AT24C64 (13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_DS1621 (14)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_TI (21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_WRITE_CHAR (22)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_X25_TIMEOUT (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_MAX1110_TIMEOUT (33)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_ADC_MAX150_TIMEOUT (44)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_NORMAL  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ERROR   1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用变量定义 ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用数据类型声明 ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果可能的话，存储在 DATA 区, 以供快速存取  </span></span><br><span class="line"><span class="comment">// 每个任务的存储器总和是 7个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数)</span></span><br><span class="line">   <span class="keyword">void</span> (* pTask)(<span class="keyword">void</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//延迟 (时标) 直到函数将 (下一次) 运行</span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task()</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  Delay;       </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在连续的运行之间的间隔 (时标) </span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task() </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> Period;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当任务需要运行时 (由调度器) 加1</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> RunMe;  </span><br><span class="line">	</span><br><span class="line">&#125; sTask; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line">sTask SCH_tasks_G[SCH_MAX_TASKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来显示错误代码</span></span><br><span class="line"><span class="comment">// 错误代码的详细资料参见 Main.H </span></span><br><span class="line"><span class="comment">// 关于错误端口的详细资料参见 Port.H </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Error_code_G = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有函数原型  ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有变量 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟踪自从上一次记录错误以来的时间 (见下文)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  Error_tick_count_G;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上次的错误代码 (在1分钟之后复位)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Last_error_code_G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Dispatch_Tasks()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这是“调度”函数.  当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它.</span></span><br><span class="line"><span class="comment">  这个函数必须被主循环 (重复)调用.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调度 (运行) 下一个任务 (如果有任务就绪)</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line">		 <span class="keyword">if</span> (SCH_tasks_G[Index].RunMe &gt; <span class="number">0</span>) </span><br><span class="line">      &#123;</span><br><span class="line">         (*SCH_tasks_G[Index].pTask)();  <span class="comment">// 运行任务</span></span><br><span class="line"></span><br><span class="line">         SCH_tasks_G[Index].RunMe -= <span class="number">1</span>;   <span class="comment">//  RunMe 标志复位/减1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性的任务将自动的再次运行</span></span><br><span class="line">         <span class="comment">// - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除</span></span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Period == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            SCH_Delete_Task(Index);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 报告系统状况</span></span><br><span class="line">   SCH_Report_Status();  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里调度器进行空闲模式  </span></span><br><span class="line">   SCH_Go_To_Sleep();          </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Add_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  Fn_P  - 将被调度的函数的名称.</span></span><br><span class="line"><span class="comment">          注意: 所有被调度的函数必须是 &#x27;void, void&#x27; -</span></span><br><span class="line"><span class="comment">          即函数没有参数, 并且返回类型为 void </span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">  DELAY   - 在任务第一次被运行之前的间隔（时标）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  PERIOD   -  &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次.</span></span><br><span class="line"><span class="comment">              &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些）</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  //PERIOD</span></span><br><span class="line"><span class="comment">  返回值 :   返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中</span></span><br><span class="line"><span class="comment">           (空间不够).  如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          注意: 如果以后要删除任务, 将需要这个返回值，参见  SCH_Delete_Task().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  例子:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,1000,0,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 在1000 个调度器时标之后运行一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,0,1000,1);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个调度器时标运行一次</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,300,1000,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标，</span></span><br><span class="line"><span class="comment">   2300个时标 ，等等            </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (* pFunction)(), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DELAY, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> PERIOD)</span>    </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 首先在队列中找到一个空隙(如果有的话)</span></span><br><span class="line">   <span class="keyword">while</span> ((SCH_tasks_G[Index].pTask != <span class="number">0</span>) &amp;&amp; (Index &lt; SCH_MAX_TASKS))</span><br><span class="line">      &#123;</span><br><span class="line">      Index++;</span><br><span class="line">      &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 是否已经到达队列的结尾 ？？   </span></span><br><span class="line">   <span class="keyword">if</span> (Index == SCH_MAX_TASKS)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 任务队列已满</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_TOO_MANY_TASKS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同时返回错误代码</span></span><br><span class="line">      <span class="keyword">return</span> SCH_MAX_TASKS;  </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 如果能运行到这里，说明任务队列中有空间</span></span><br><span class="line">   SCH_tasks_G[Index].pTask  = pFunction;</span><br><span class="line">     </span><br><span class="line">   SCH_tasks_G[Index].Delay  = DELAY;</span><br><span class="line">   SCH_tasks_G[Index].Period = PERIOD;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[Index].RunMe  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Index; <span class="comment">// 返回任务的位置 (以便以后删除)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Delete_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  从调度器删除任务.  注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 </span></span><br><span class="line"><span class="comment">  参数:   TASK_INDEX - 任务索引.  由 SCH_Add_Task()提供. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回值:  RETURN_ERROR or RETURN_NORMAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>  <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> tByte TASK_INDEX)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Return_code;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SCH_tasks_G[TASK_INDEX].pTask == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 这里没有任务</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ...同时返回错误代码</span></span><br><span class="line">      Return_code = RETURN_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      Return_code = RETURN_NORMAL;</span><br><span class="line">      &#125;      </span><br><span class="line">   </span><br><span class="line">   SCH_tasks_G[TASK_INDEX].pTask   = <span class="number">0x0000</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Delay   = <span class="number">0</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Period  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[TASK_INDEX].RunMe   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Return_code;       <span class="comment">// 返回状态</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Report_Status()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  用来显示错误代码的简单的函数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个版本将在连接到端口的LED上显示错误代码，</span></span><br><span class="line"><span class="comment">  如果需要的话，可以修改为通过串行连接等方式报告错误。</span></span><br><span class="line"><span class="comment">  错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。).</span></span><br><span class="line"><span class="comment">  此后错误代码被复位为0. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  更加详尽的资料参见第10章。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SCH_REPORT_ERRORS</span></span><br><span class="line">   <span class="comment">// 只在需要报告错误时适用</span></span><br><span class="line">   <span class="comment">// 检查新的错误代码</span></span><br><span class="line">   <span class="keyword">if</span> (Error_code_G != Last_error_code_G)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 假定LED采用负逻辑</span></span><br><span class="line">      Error_port = <span class="number">255</span> - Error_code_G;</span><br><span class="line">      </span><br><span class="line">      Last_error_code_G = Error_code_G;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Error_code_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">60000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> (Error_tick_count_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">if</span> (--Error_tick_count_G == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            Error_code_G = <span class="number">0</span>; <span class="comment">// 复位错误代码</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Go_To_Sleep()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。</span></span><br><span class="line"><span class="comment">  注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。</span></span><br><span class="line"><span class="comment">  然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计</span></span><br><span class="line"><span class="comment">  调度器的性能。这方面的例子参见第14章。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 如果使用看门狗的话，可能需要禁止这个功能 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 根据硬件的需要修改 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Update  中断调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   这是调度器的中断服务程序.  初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。</span></span><br><span class="line"><span class="comment">   这个版本由定时器1中断触发</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   tByte Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重装定时器</span></span><br><span class="line">   <span class="comment">// 注意：计算单位为“时标”（不是毫秒）</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 检测这里是否有任务</span></span><br><span class="line">      <span class="keyword">if</span> (SCH_tasks_G[Index].pTask)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Delay == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">// 任务需要运行</span></span><br><span class="line">            SCH_tasks_G[Index].RunMe += <span class="number">1</span>;  <span class="comment">//  &#x27;RunMe&#x27; 标志加1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SCH_tasks_G[Index].Period)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调度定期的任务再次运行</span></span><br><span class="line">               SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//还没有准备好运行，延迟减 1</span></span><br><span class="line">            SCH_tasks_G[Index].Delay -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;         </span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"> &#125; 	 </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">		 <span class="keyword">unsigned</span> <span class="keyword">char</span>  i;</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SCH_MAX_TASKS; i++) </span><br><span class="line">		 &#123;</span><br><span class="line">				SCH_Delete_Task(i);	</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">// 复位全局错误变量</span></span><br><span class="line">		 <span class="comment">// - SCH_Delete_Task() 将产生一个错误代码 </span></span><br><span class="line">		 <span class="comment">//   (因为任务队列是空的)</span></span><br><span class="line">		 Error_code_G = <span class="number">0</span>;</span><br><span class="line">		 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派CAN</title>
    <url>/blog/2021/12/10/%E6%A0%91%E8%8E%93%E6%B4%BECAN/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/j353838430/article/details/119486631?ops_request_misc=%7B%22request_id%22:%22163877530616780271559996%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163877530616780271559996&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-119486631.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEmcp2515&spm=1018.2226.3001.4187">树莓派CAN通讯教程 - MCP2515_j353838430的博客-CSDN博客_树莓派can通信</a></p>
<p><a href="https://blog.csdn.net/csshuke/article/details/113186248?ops_request_misc=&request_id=&biz_id=102&utm_term=mcp2515%E5%8E%9F%E7%90%86%E5%9B%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-113186248.pc_search_mgc_flag&spm=1018.2226.3001.4187">(86条消息) SPI协议、MCP2515裸机驱动详解—-主流SPI总线接口原理_csshuke的专栏-CSDN博客_mcp2515 spi极性</a></p>
<p>mcp2515模块资料:<a href="http://pan.baidu.com/s/1hsi3I4k">http://pan.baidu.com/s/1hsi3I4k</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用mcp2515实现的spi转can通信</p>
<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://s2.loli.net/2021/12/10/UYg8ehqIX3EOAkb.png" alt="image-20211210213025816.png"></p>
<p>需要注意的是这里的片选,也就是说可以通过片选CS信号实现一个spi转多个can通信,INT引脚用于中断缓存数据,当接收到数据时会将数据先放入缓冲区</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装cantools</span></span><br><span class="line">sudo apt install can-utils</span><br><span class="line">pip3 install cantools</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测挂载</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否进入<span class="built_in">read</span>状态</span></span><br><span class="line">sudo ip -s -d link show can0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使能树莓派SPI并加载MCP2515内核驱动</span></span><br><span class="line">dtparam=spi=on</span><br><span class="line">dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25</span><br><span class="line">dtoverlay=spi1-1cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">sudo reboot -h now</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭can0</span></span><br><span class="line">sudo ip link set can0 down</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置波特率</span></span><br><span class="line">sudo ip link set can0 type can bitrate 1000000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启can0</span></span><br><span class="line">sudo ip link set can0 up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">sudo ip -s -d link show can0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收报文</span></span><br><span class="line">candump any,0:0,#FFFFFFFF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤</span></span><br><span class="line">candump can0,620:1fffffff,255:7ff</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送报文</span></span><br><span class="line">cansend can0 123#1122334455667788</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置回环 波特率 250K ,用于测试can通路,在没有其它硬件连接测试的情况下，可以设定成回环，自发自收</span></span><br><span class="line">sudo ip link set can0 type can bitrate 500000 loopback on</span><br></pre></td></tr></table></figure>

<h1 id="C语言使用"><a href="#C语言使用" class="headerlink" title="C语言使用"></a>C语言使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> command <span class="meta-string">&quot;ip link set can0 type can bitrate 1000000&quot;</span><span class="comment">//将CAN0波特率设置为500K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up <span class="meta-string">&quot;ifconfig can0 up&quot;</span><span class="comment">//打开CAN0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> down <span class="meta-string">&quot;ifconfig can0 down&quot;</span><span class="comment">//关闭CAN0</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//关闭CAN设备，设置波特率后，重新打开CAN设备</span></span><br><span class="line">    <span class="built_in">system</span>(down);</span><br><span class="line">    <span class="built_in">system</span>(command);</span><br><span class="line">    <span class="built_in">system</span>(up);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_send</span><span class="params">(can_frame frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, nbytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span> );</span><br><span class="line">    <span class="comment">//指定 can0 设备</span></span><br><span class="line">    <span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr); </span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="comment">//将套接字与 can0 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(s, (struct sockaddr *)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">    <span class="comment">//发送 frame[0]</span></span><br><span class="line">    nbytes = <span class="built_in">write</span>(s, &amp;frame, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="keyword">if</span>(nbytes != <span class="built_in"><span class="keyword">sizeof</span></span>(frame))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Send Error frame[0]\n!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_receive</span><span class="params">(struct can_frame * r_frame,<span class="keyword">unsigned</span> <span class="keyword">int</span> filter_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, nbytes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> <span class="title">rfilter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initial fram</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span> );</span><br><span class="line">    <span class="comment">//指定 can0 设备</span></span><br><span class="line">    <span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr); </span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="comment">//将套接字与 can0 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(s, (struct sockaddr *)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">    <span class="comment">//设置过滤规则，取消当前注释为禁用过滤规则，即不接收所有报文，</span></span><br><span class="line">    <span class="comment">// 不设置此项（即如当前代码被注释）为接收所有ID的报文。</span></span><br><span class="line">    <span class="keyword">if</span> (filter_id != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rfilter.can_id   = <span class="number">0x123</span>;</span><br><span class="line">        <span class="comment">// CAN_EFF_MASK | CAN_SFF_MASK</span></span><br><span class="line">        rfilter.can_mask = CAN_SFF_MASK;</span><br><span class="line">        <span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, <span class="built_in"><span class="keyword">sizeof</span></span>(rfilter));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//接收总线上的报文保存在frame中</span></span><br><span class="line">        nbytes = <span class="built_in">read</span>(s, &amp;frame, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    &#125;</span><br><span class="line">    *r_frame = frame;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MSG_DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the nbytes:%d\n&quot;</span>, nbytes);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length:%d&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID=0x%X DLC=%d\n&quot;</span>, frame.can_id, frame.can_dlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data0=0x%02x\n&quot;</span>,frame.data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1=0x%02x\n&quot;</span>,frame.data[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2=0x%02x\n&quot;</span>,frame.data[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data3=0x%02x\n&quot;</span>,frame.data[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data4=0x%02x\n&quot;</span>,frame.data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data5=0x%02x\n&quot;</span>,frame.data[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data6=0x%02x\n&quot;</span>,frame.data[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data7=0x%02x\n&quot;</span>,frame.data[<span class="number">7</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_ctl_on</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    frame.can_id = <span class="number">0x101</span>;</span><br><span class="line">    frame.can_dlc = <span class="number">8</span>;</span><br><span class="line">    frame.data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">can_send</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">led_ctl_off</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    frame.can_id = <span class="number">0x101</span>;</span><br><span class="line">    frame.can_dlc = <span class="number">8</span>;</span><br><span class="line">    frame.data[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">can_send</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">can_get_vol</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> vol_vle = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;frame, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(can_frame));</span><br><span class="line">    <span class="comment">// wait until can frame 100 received</span></span><br><span class="line">    <span class="built_in">can_receive</span>(&amp;frame,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;###############################\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length:%d&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(frame));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID=0x%X DLC=%d\n&quot;</span>, frame.can_id, frame.can_dlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data0=0x%02x\n&quot;</span>,frame.data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1=0x%02x\n&quot;</span>,frame.data[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2=0x%02x\n&quot;</span>,frame.data[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data3=0x%02x\n&quot;</span>,frame.data[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data4=0x%02x\n&quot;</span>,frame.data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data5=0x%02x\n&quot;</span>,frame.data[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data6=0x%02x\n&quot;</span>,frame.data[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data7=0x%02x\n&quot;</span>,frame.data[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    vol_vle = (<span class="keyword">float</span>)frame.data[<span class="number">0</span>]/<span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span> vol_vle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> control_str[<span class="number">15</span>]; </span><br><span class="line">    <span class="keyword">float</span> vol_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can_control service_type\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    example: ./can_control led_off/led_on/get_vol\n&quot;</span></span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(control_str,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Argc : %d\n&quot;</span>,argc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Argv : %s\n , %s\n&quot;</span>,argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// can_init();</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;led_off&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">led_ctl_off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;led_on&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">led_ctl_on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(control_str,<span class="string">&quot;get_vol&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vol_val = <span class="built_in">can_get_vol</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Voltage is : %5.2f V\n&quot;</span>, vol_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Do nothing */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派GPIO</title>
    <url>/blog/2021/12/06/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/hu7850/article/details/51785560">树莓派GPIO控制–C语言篇_hu7850的博客-CSDN博客_树莓派c语言控制gpio</a></p>
<h1 id="IO表示"><a href="#IO表示" class="headerlink" title="IO表示"></a>IO表示</h1><p><img src="https://s2.loli.net/2021/12/10/wLfgq9kbRzoZD2a.png" alt="image-20211210165211671.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~/Cmake/build$ gpio readall</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |</span><br><span class="line"> |   2 |   8 |   SDA.1 | ALT0 | 1 |  3 || 4  |   |      | 5v      |     |     |</span><br><span class="line"> |   3 |   9 |   SCL.1 | ALT0 | 1 |  5 || 6  |   |      | 0v      |     |     |</span><br><span class="line"> |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | ALT5 | TxD     | 15  | 14  |</span><br><span class="line"> |     |     |      0v |      |   |  9 || 10 | 1 | ALT5 | RxD     | 16  | 15  |</span><br><span class="line"> |  17 |   0 | GPIO. 0 |   IN | 1 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |</span><br><span class="line"> |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |</span><br><span class="line"> |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |</span><br><span class="line"> |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |</span><br><span class="line"> |  10 |  12 |    MOSI | ALT0 | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line"> |   9 |  13 |    MISO | ALT0 | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line"> |  11 |  14 |    SCLK | ALT0 | 0 | 23 || 24 | 1 | OUT  | CE0     | 10  | 8   |</span><br><span class="line"> |     |     |      0v |      |   | 25 || 26 | 1 | OUT  | CE1     | 11  | 7   |</span><br><span class="line"> |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |</span><br><span class="line"> |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |</span><br><span class="line"> |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |</span><br><span class="line"> |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |</span><br><span class="line"> |  19 |  24 | GPIO.24 |   IN | 1 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |</span><br><span class="line"> |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |</span><br><span class="line"> |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+</span><br></pre></td></tr></table></figure>

<h1 id="wiringpi"><a href="#wiringpi" class="headerlink" title="wiringpi"></a><code>wiringpi</code></h1><h2 id="安装wiring"><a href="#安装wiring" class="headerlink" title="安装wiring"></a>安装wiring</h2><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://git.drogon.net/wiringPi</span><br><span class="line">cd wiringPi</span><br><span class="line">./build</span><br><span class="line">build脚本会帮助你编译和安装wiringPi</span><br></pre></td></tr></table></figure>

<p>或者通过此[下载](<a href="https://github.com/WiringPi/WiringPi">WiringPi/WiringPi: Gordon’s Arduino wiring-like WiringPi Library for the Raspberry Pi (Unofficial Mirror for WiringPi bindings) (github.com)</a>)安装</p>
<h3 id="raspbian上安装"><a href="#raspbian上安装" class="headerlink" title="raspbian上安装"></a>raspbian上安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wiringpi</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>github</strong>上有<strong>examples</strong>可以测试</p>
<h2 id="cmake使用wiringpi库"><a href="#cmake使用wiringpi库" class="headerlink" title="cmake使用wiringpi库"></a><strong>cmake使用wiringpi</strong>库</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(display)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(WIRINGPI_LIBRARIES NAMES wiringPi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(display display.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(display <span class="variable">$&#123;WIRINGPI_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://code.google.com/p/raspberry-gpio-python/</span><br></pre></td></tr></table></figure>

<h1 id="BCM2835-C-Library"><a href="#BCM2835-C-Library" class="headerlink" title="BCM2835 C Library"></a>BCM2835 C Library</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.35.tar.gz</span><br><span class="line">tar xvzf bcm2835-1.35.tar.gz</span><br><span class="line">cd bcm2835-1.35</span><br><span class="line">./configure make</span><br><span class="line">sudo make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><strong>可以使用examples测试</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>win11安装</title>
    <url>/blog/2022/05/05/win11%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/shr105/article/details/122802235?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-122802235-blog-122299782.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-122802235-blog-122299782.pc_relevant_default&utm_relevant_index=1">一步强制升级windows11_沃特陌的博客-CSDN博客_win11强制升级</a> </p>
<h1 id="下载win11镜像-multi-edition"><a href="#下载win11镜像-multi-edition" class="headerlink" title="下载win11镜像(multi-edition)"></a>下载win11镜像(multi-edition)</h1><p> <a href="https://www.microsoft.com/zh-cn/software-download/windows11/">Download Windows 11 (microsoft.com)</a> </p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="进入resources-找到appraiserres-dll-剪切出来-新建一个空白相同文件放进去"><a href="#进入resources-找到appraiserres-dll-剪切出来-新建一个空白相同文件放进去" class="headerlink" title="进入resources,找到appraiserres.dll,剪切出来,新建一个空白相同文件放进去"></a>进入resources,找到appraiserres.dll,剪切出来,新建一个空白相同文件放进去</h2><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="setup-exe-运行"><a href="#setup-exe-运行" class="headerlink" title="setup.exe,运行"></a>setup.exe,运行</h2><h2 id="检测满足-扫描完成后，会提示你满足，可以下一步，这时候，再把那个appraiserres-dll文件放回去。然后继续进行即可"><a href="#检测满足-扫描完成后，会提示你满足，可以下一步，这时候，再把那个appraiserres-dll文件放回去。然后继续进行即可" class="headerlink" title="检测满足, 扫描完成后，会提示你满足，可以下一步，这时候，再把那个appraiserres.dll文件放回去。然后继续进行即可"></a>检测满足, 扫描完成后，会提示你满足，可以下一步，这时候，再把那个appraiserres.dll文件放回去。然后继续进行即可</h2>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>文件同步工具</title>
    <url>/blog/2022/04/25/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://www.bilibili.com/video/BV19S4y117sL/?spm_id_from=pageDriver">敢和 Edge 争高下？99%的人没听说过的宝藏浏览器！_哔哩哔哩_bilibili</a></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>不同设备之间同步,比如</p>
<p><img src="https://s2.loli.net/2022/04/25/uB3YhNkXGEqSpoJ.png" alt="1650895594_1_.png"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="https://s2.loli.net/2022/04/25/julpyMRQmsVXZnU.png" alt="1650895766_1_.png"></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派串口通信</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/benchuspx/article/details/112571880?ops_request_misc=%7B%22request_id%22:%22163054521616780274150518%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163054521616780274150518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-112571880.pc_search_insert_download&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEubuntu+20%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF%E8%B0%83%E8%AF%95&spm=1018.2226.3001.4187">树莓派4b ubuntu系统开启串口_benchuspx的博客-CSDN博客</a></p>
<p><a href="https://www.pianshen.com/article/3825828971/">树莓派4B如何使用串口与外部进行通信 - 程序员大本营 (pianshen.com)</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>树莓派原本的抽是用于<strong>串口控制台</strong>的,即<code>/ttyAMA0</code>,且此硬件串口也与蓝牙连接到一块,因此需要将<strong>控制台</strong>与<strong>蓝牙</strong>关闭才能使用</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>/boot/firmware/nobtcmd.tx</code>t里删除<code>console = /ttyAMA 921600</code>从而禁用串口控制台.这个<code>txt文件</code>也可以用读卡器把sd卡插到windows系统里在<code>system-boot</code>里找到</p>
</li>
<li><p><code>/boot/firmware/config.txt</code> 里设置<code>enable_uart=1</code>（默认就是）.如果=0表示启用minicom串口，而不是这个硬件串口.</p>
</li>
<li><p><code>/boot/firmware/config.txt</code> 里加入一行<code>dtoverlay=disable-bt</code>从而禁用蓝牙.</p>
</li>
<li><p><code>sudo systemctl disable bluetooth</code>…… 禁用掉和蓝牙有关的开机启动项.直到桌面不再显示蓝牙标志，但是还有<code>/ttyAMA0</code>存在.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派入门</title>
    <url>/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="树莓派入门"><a href="#树莓派入门" class="headerlink" title="树莓派入门"></a>树莓派入门</h2><h3 id="1、树莓派安装"><a href="#1、树莓派安装" class="headerlink" title="1、树莓派安装"></a>1、树莓派安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">教程网站：https://blog.csdn.net/bhniunan/article/details/104783321</span><br><span class="line">    	https://blog.csdn.net/W17330937835/article/details/105351273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603417716780255273810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161603417716780255273810&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-105351273.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b</span><br><span class="line">		</span><br><span class="line">https://ubuntu-mate.org/</span><br><span class="line">noobs安装系统：https://blog.csdn.net/diandianxiyu_geek/article/details/78949393</span><br><span class="line"></span><br><span class="line">https://shumeipai.nxez.com/download</span><br><span class="line">https://make.quwj.com/member/2/bookmarks?category=36</span><br></pre></td></tr></table></figure>

<h3 id="2、汉化Raspbian操作系统"><a href="#2、汉化Raspbian操作系统" class="headerlink" title="2、汉化Raspbian操作系统"></a>2、汉化Raspbian操作系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/bhniunan/article/details/104842773</span><br><span class="line">中文输入法：https://blog.csdn.net/qq_33475105/article/details/113488707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161605416616780261948746%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161605416616780261948746&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-113488707.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95</span><br></pre></td></tr></table></figure>

<h3 id="3、树莓派gpio控制"><a href="#3、树莓派gpio控制" class="headerlink" title="3、树莓派gpio控制"></a>3、树莓派gpio控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wiki.jikexueyuan.com/project/raspberry-pi/gpio.html</span><br></pre></td></tr></table></figure>

<h3 id="4、树莓派命令行连接wifi"><a href="#4、树莓派命令行连接wifi" class="headerlink" title="4、树莓派命令行连接wifi"></a>4、树莓派命令行连接wifi</h3><p><a href="https://blog.csdn.net/u010875635/article/details/70170145">https://blog.csdn.net/u010875635/article/details/70170145</a></p>
<h3 id="5、树莓派用rc-local设置开机启动"><a href="#5、树莓派用rc-local设置开机启动" class="headerlink" title="5、树莓派用rc.local设置开机启动"></a>5、树莓派用rc.local设置开机启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入etc/rc.local</span><br><span class="line">编辑需要打开的设置，直接编辑命令</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派备份</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://zhuanlan.zhihu.com/p/299844978?utm_source=wechat_session">收藏！最简单的树莓派系统备份方法！ - 知乎 (zhihu.com)</a></p>
<p><a href="https://post.smzdm.com/p/apzkgne7/">树莓派学习笔记 篇四：树莓派4B 的系统备份方法大全（全卡+压缩备份）_其他智能设备_什么值得买 (smzdm.com)</a></p>
<p><a href="https://blog.csdn.net/sinat_16643223/article/details/109006150">烧写之前备份过的树莓派镜像到SD卡，证明这样备份恢复是可行的！！！！！！！_TYINY的博客-CSDN博客</a></p>
<h1 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h1><p><code>win10</code>下新建一个<code>.img</code>格式文件,通过<code>Win32DiskImager</code>,<code>read</code>插入卡的系统,<code>read</code>完就备份好了</p>
<p><img src="https://qnam.smzdm.com/201912/08/5ded02bcc031f2090.jpg_e1080.jpg" alt="树莓派4B 的系统备份方法大全（全卡+压缩备份）"></p>
<h1 id="脚本方式-推荐"><a href="#脚本方式-推荐" class="headerlink" title="脚本方式(推荐)"></a>脚本方式(推荐)</h1><p><a href="https://github.com/BigBubbleGum/RaspberryBackup"> 在Linux系统中一键备份树莓派系统SD卡的脚本 (github.com)</a></p>
<ul>
<li>下载下来脚本<code>rpi-backup.sh</code>放入到<code>Linux</code>系统</li>
<li>插入需备份的树莓派系统,用<code>df -h</code>命令查询SD卡设备名</li>
<li>运行<code>sudo chmod +x rpi-backup.sh</code>后,运行<code>./rpi-backup.sh /dev/sdb1 /dev/sdb2</code></li>
<li>注意第一个参数是树莓派SD卡<code>/boot</code>分区的设备名：/dev/sdb1，第二个参数是<code>/</code>分区的设备名：/dev/sdb2，视情况修改）</li>
<li>终 img 文件会生成在<code>~/backupimg/</code>文件夹下</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派备份</title>
    <url>/blog/2022/02/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><h1 id="新树莓派安装低版本ubuntu"><a href="#新树莓派安装低版本ubuntu" class="headerlink" title="新树莓派安装低版本ubuntu"></a>新树莓派安装低版本ubuntu</h1><ul>
<li><h3 id="先烧录简单的ubuntu18"><a href="#先烧录简单的ubuntu18" class="headerlink" title="先烧录简单的ubuntu18"></a>先烧录简单的ubuntu18</h3></li>
<li><h3 id="将已有文件拷贝覆盖到-boo目录下"><a href="#将已有文件拷贝覆盖到-boo目录下" class="headerlink" title="将已有文件拷贝覆盖到 boo目录下"></a>将已有文件拷贝覆盖到 boo目录下</h3></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装Ubuntu18_server</title>
    <url>/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_36628778/article/details/105056549?ops_request_misc=%7B%22request_id%22:%22163048418216780264057617%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163048418216780264057617&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-105056549.pc_search_insert_download&utm_term=ubuntu18.04+server+wlan0&spm=1018.2226.3001.4187">树莓派raspberry 安装ubuntu18.04 server + desktop + ros1_越来越胖了_mengleijin的博客-CSDN博客</a></p>
<p><a href="https://www.freesion.com/article/3758800537/">树莓派4b安装带桌面的ubuntu18.04 server和ROS melodic系统 - 灰信网（软件开发博客聚合） (freesion.com)</a></p>
<p><a href="https://blog.csdn.net/m0_52364631/article/details/112439570?ops_request_misc=%7B%22request_id%22:%22163867892516780261940219%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163867892516780261940219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-112439570.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu18&spm=1018.2226.3001.4187">树莓派4B安装Ubuntu18.04 + vnc远程桌面_我是大一菜鸡-CSDN博客</a></p>
<h1 id="img镜像下载"><a href="#img镜像下载" class="headerlink" title="img镜像下载"></a>img镜像下载</h1><p>pi烧录软件:<a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">https://downloads.raspberrypi.org/imager/imager_latest.exe</a></p>
<p><a href="https://www.lxx1.com/3779">树莓派操作系统镜像下载地址</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/releases/bionic/release/ubuntu-18.04.5-preinstalled-server-arm64%2Braspi4.img.xz">ubuntu18_server</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/</a></p>
<h1 id="将系统烧入SD卡"><a href="#将系统烧入SD卡" class="headerlink" title="将系统烧入SD卡"></a>将系统烧入SD卡</h1><p>使用<strong>win32diskimager</strong>或者<strong>balenaetcher</strong>烧录进去</p>
<p><img src="https://img-blog.csdnimg.cn/20210507104309422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTcwMDI1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200603191826555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDU4NDYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="启动树莓派"><a href="#启动树莓派" class="headerlink" title="启动树莓派"></a>启动树莓派</h1><p>将SD卡插入树莓派，并为树莓派连接好电源，显示器，鼠标，键盘，网线。启动树莓派，默认用户名密码都是<code>ubuntu</code>，之后需要马上修改密码，按提示操作即可。</p>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="打开-system-boot-磁盘下根目录的-network-config-文件"><a href="#打开-system-boot-磁盘下根目录的-network-config-文件" class="headerlink" title="打开 system-boot 磁盘下根目录的 network-config 文件"></a>打开 <code>system-boot</code> 磁盘下根目录的 <code>network-config</code> 文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file contains a netplan-compatible configuration <span class="built_in">which</span> cloud-init</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will apply on first-boot. Please refer to the cloud-init documentation and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the netplan reference <span class="keyword">for</span> full details:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># https://cloudinit.readthedocs.io/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://netplan.io/reference</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Some additional examples are commented out below</span></span></span><br><span class="line"></span><br><span class="line">version: 2</span><br><span class="line">ethernets:</span><br><span class="line">  eth0:</span><br><span class="line">    dhcp4: false</span><br><span class="line">    addresses: [192.168.30.110/24]</span><br><span class="line">wifis:</span><br><span class="line">  wlan0:</span><br><span class="line">    access-points:</span><br><span class="line">      HUAWEI_PTY:</span><br><span class="line">        password: pty123456787</span><br><span class="line">    dhcp4: true                         </span><br></pre></td></tr></table></figure>

<h2 id="修改在相同目录下的-user-data-文件，expire：后改成false。"><a href="#修改在相同目录下的-user-data-文件，expire：后改成false。" class="headerlink" title="修改在相同目录下的 user-data 文件，expire：后改成false。"></a>修改在相同目录下的 <code>user-data</code> 文件，<code>expire：</code>后改成<code>false</code>。</h2><p><img src="https://s2.loli.net/2021/12/06/6Jked1uLC9oYIfN.png" alt="image-20211205144213769.png"></p>
<h2 id="启动树莓派-1"><a href="#启动树莓派-1" class="headerlink" title="启动树莓派"></a>启动树莓派</h2><p>如果是刷完固件后第一次启动，因为第一次需要进行系统配置，所以第一次不会自动连接。第一次上电过两分钟后重新上电稍等片刻就会自动连接wifi了。</p>
<h1 id="连网"><a href="#连网" class="headerlink" title="连网"></a>连网</h1><p>可以参考:</p>
<p><a href="https://blog.csdn.net/zyr920425/article/details/93351457">Ubuntu Server 18.04 连接 WIFI_zyr920425的博客-CSDN博客</a></p>
<p>编辑,注意需要使用<code>Tab</code>键对齐,建议使用能看到对其线的对其工具,比如<code>sublime</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/netplan/xxxxxxx.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file is generated from information provided by the datasource.  Changes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to it will not persist across an instance reboot.  To <span class="built_in">disable</span> cloud-init<span class="string">&#x27;s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> network configuration capabilities, write a file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> network: &#123;config: disabled&#125;</span></span></span><br><span class="line">network:</span><br><span class="line">    version: 2</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: false</span><br><span class="line">            addresses: [192.168.8.110/24]</span><br><span class="line">    wifis:</span><br><span class="line">        wlan0:</span><br><span class="line">            access-points:</span><br><span class="line">                HUAWEI_PTY:</span><br><span class="line">                    password: pty123456787</span><br><span class="line">            dhcp4: true</span><br><span class="line">            optional: true</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>



<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano  /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>参考:<a href="https://blog.csdn.net/lovely_yoshino/article/details/109448556?ops_request_misc=%7B%22request_id%22:%22163867892516780261940219%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163867892516780261940219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-109448556.pc_search_mgc_flag&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu18&spm=1018.2226.3001.4187">树莓派4安装 18.04ubuntu server（2020.11.2）_lovely_yoshino的博客-CSDN博客_树莓派ubuntu18.04</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse</span><br><span class="line"> </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h1><p>网线连接好,通过<code>ip a</code>查看是否配置好,然后在物理机上尝试<code>ping</code>通后连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh.exe ubuntu@192.168.xx.xx</span><br></pre></td></tr></table></figure>

<h1 id="安装gcc与g"><a href="#安装gcc与g" class="headerlink" title="安装gcc与g++"></a>安装gcc与g++</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/blog/2022/04/15/%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_33271192/article/details/108696138?ops_request_misc=%7B%22request_id%22:%22165087445316780357261380%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165087445316780357261380&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108696138.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7&spm=1018.2226.3001.4187">(128条消息) 内存泄漏检查工具_comochris的博客-CSDN博客_内存泄露检测工具</a></p>
<p><a href="https://blog.csdn.net/caijiwyj/article/details/99188644?ops_request_misc=%7B%22request_id%22:%22165087584116782246457244%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165087584116782246457244&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99188644.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=Valgrind&spm=1018.2226.3001.4187">(128条消息) valgrind简介与使用_WuYuJun’s blog的博客-CSDN博客_valgrind</a></p>
<p><a href="https://blog.csdn.net/cym64039/article/details/9049621?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=2">(128条消息) 几种内存泄露检测工具的比较_cym64039的博客-CSDN博客</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载(https://valgrind.org/downloads/current.html#current)</span></span><br><span class="line"><span class="comment"># https://sourceware.org/pub/valgrind/valkyrie-2.0.0.tar.bz2</span></span><br><span class="line"><span class="comment"># https://sourceware.org/pub/valgrind/valgrind-3.19.0.tar.bz2</span></span><br><span class="line">wget https://sourceware.org/pub/valgrind/valgrind-3.19.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> valgrind-3.19.0</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="简单使用-注意-gcc-g-都需要加上-g选项"><a href="#简单使用-注意-gcc-g-都需要加上-g选项" class="headerlink" title="简单使用:注意(gcc/g++都需要加上-g选项)"></a>简单使用:注意(gcc/g++都需要加上-g选项)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// valgrind_test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    x [<span class="number">10</span>] = <span class="number">0</span>; <span class="comment">//问题1：堆块溢出</span></span><br><span class="line">&#125; <span class="comment">//问题2：内存泄漏 -  x未释放</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g valgrind_test.c -o valgrind_test</span><br><span class="line">valgrind --leak-check=yes ./valgrind_test</span><br></pre></td></tr></table></figure>

<h1 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h1><p><a href="https://blog.csdn.net/qq_33271192/article/details/108696138?ops_request_misc=%7B%22request_id%22:%22165087445316780357261380%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165087445316780357261380&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108696138.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7&spm=1018.2226.3001.4187">具体参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 动态内存泄露；</span><br><span class="line">2. 资源泄露，比如文件指针不关闭；</span><br><span class="line">3. 动态内存越界；</span><br><span class="line">4.数组内存越界；</span><br><span class="line">5.动态内存double free；</span><br><span class="line">6.使用野指针，即未初始化的指针；</span><br><span class="line">7.释放野指针，即未初始化的指针。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>修改和校正树莓派时间</title>
    <url>/blog/2021/12/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%A0%A1%E6%AD%A3%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/github_38111866/article/details/76057237">修改和校正树莓派时间_胡嘿嘿-CSDN博客_树莓派修改时间</a></p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改时区</span></span><br><span class="line">sudo dpkg-reconfigure tzdata</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择亚洲时区 Asia</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择上海时间 Shanghai</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否设置成功</span></span><br><span class="line">date</span><br><span class="line"><span class="meta">#</span><span class="bash"> 校正时间</span></span><br><span class="line">sudo ntpd -s -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制设置时间</span></span><br><span class="line">sudo date  --s=&quot;2017-07-25 10:43:00&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">(60条消息) 高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lusongno1/article/details/80558684">信赖域狗腿（dogleg）方法_LSEC小陆的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_30463341/article/details/94809554?ops_request_misc=%7B%22request_id%22:%22163611474316780357221244%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163611474316780357221244&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-94809554.pc_search_mgc_flag&utm_term=%E5%88%97%E6%96%87%E4%BC%AF%E6%A0%BC-%E9%A9%AC%E5%A4%B8%E5%B0%94%E7%89%B9%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B&spm=1018.2226.3001.4187">高斯牛顿(Gauss Newton)、列文伯格-马夸尔特(Levenberg-Marquardt)最优化算法与VSLAM_weixin_30463341的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/a6333230/article/details/83304098">LM算法——列文伯格-马夸尔特算法（最速下降法，牛顿法，高斯牛顿法）（完美解释负梯度方向）_三眼二郎-CSDN博客_lm算法</a></p>
<h1 id="从上倒下为梯度下降法的前世今生已经未来的演化："><a href="#从上倒下为梯度下降法的前世今生已经未来的演化：" class="headerlink" title="从上倒下为梯度下降法的前世今生已经未来的演化："></a>从上倒下为梯度下降法的前世今生已经未来的演化：</h1><p><strong>最速下降法（一阶梯度法）</strong><br><strong>牛顿法（二阶梯度法）</strong><br><strong>高斯牛顿法</strong><br><strong>列文伯格法</strong><br><strong>马夸尔特法</strong></p>
<p>梯度下降主要用于slam中的非线性优化,实际上就是对一个最小二乘问题的求解,这也是上述几种方法的用途.</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://img-blog.csdnimg.cn/202010261811320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM4NjYy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="最速下降-一阶梯度法"><a href="#最速下降-一阶梯度法" class="headerlink" title="最速下降(一阶梯度法)"></a>最速下降(一阶梯度法)</h1><p><strong>最速下降法</strong>（一阶梯度法）就是保留泰勒展开的一阶项用来近似非线性函数**F ( x )**，即：<br>$$<br>F(xk​+Δxk​)≈F(xk​)+J(xk​)TΔxk<br>$$</p>
<p>$$<br>Δxk​=−J(xk)<br>$$</p>
<p>**缺点:**由于仅保留一阶的雅可比矩阵,该方法过于贪心，容易走出锯齿线，反而增加迭代次数。</p>
<h1 id="牛顿法和阻尼牛顿法（二阶梯度法）"><a href="#牛顿法和阻尼牛顿法（二阶梯度法）" class="headerlink" title="牛顿法和阻尼牛顿法（二阶梯度法）"></a>牛顿法和阻尼牛顿法（二阶梯度法）</h1><p>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =−J(x<br>k<br>​<br> )<br>$$</p>
<p>**牛顿法的缺点:**海塞矩阵H计算量太大</p>
<p><strong>阻尼牛顿法</strong>(可以看成是牛顿法与最速法的结合)</p>
<p>阻尼牛顿法就是在使用牛顿法获得增量方向后，进一步对最优步长进行搜索：</p>
<h1 id="高斯牛顿法-仅用于最小二乘"><a href="#高斯牛顿法-仅用于最小二乘" class="headerlink" title="高斯牛顿法(仅用于最小二乘)"></a>高斯牛顿法(仅用于最小二乘)</h1><h3 id="原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开"><a href="#原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开" class="headerlink" title="原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)"></a>原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)</h3><p><strong>增量方程:</strong><br>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>算法流程:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.给定初始值X0</span><br><span class="line">2.对于第k次迭代,求出当前雅可比矩阵J与误差f(x)</span><br><span class="line">3.求解增量方程:H*deltaxk=g</span><br><span class="line">4.若的了他xk足够小,则停止,否则,xk+1 = xk + deltaxk</span><br></pre></td></tr></table></figure>

<p><strong>缺点:</strong></p>
<p>由于是通过雅各比矩阵做的JH(海瑟矩阵)的近似,因此会遇见奇异矩阵与病态矩阵,可能出现算法不收敛.</p>
<h1 id="L-M方法，阻尼牛顿法"><a href="#L-M方法，阻尼牛顿法" class="headerlink" title="L-M方法，阻尼牛顿法"></a>L-M方法，阻尼牛顿法</h1><p><strong>列文伯格-马夸尔特方法的思想</strong><br>针对高斯牛顿法的不足，L-M方法做了两点改进：</p>
<ul>
<li><p>在求解增量Δ xk 时，对其设置了信赖区域</p>
</li>
<li><p>在求得增量Δ xk对其近似效果进行了量化，并根据量化结果对信赖区域进行调整，</p>
<p>再从新计算增量Δ x k，直到近似效果量化结果达到阈值。</p>
</li>
</ul>
<p><strong>增量方程</strong><br>$$<br>(H+λD<br>T<br> D)Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>近似程度的量化</strong><br>$$<br>ρ=<br>(f(xk​+Δx k​)−f(x k​ ))/(J(x k​)TΔxk​)​<br>$$</p>
<ul>
<li>当ρ接近1时，近似效果好；</li>
<li>当ρ太小时，实际减小的值远小于近似函数减小的值，近似效果差，需要缩小近似范围μ</li>
<li>当ρ较大时，实际减小的值大于近似函数减小的值，近似效果差，需要增大近似范围μ </li>
</ul>
<p><strong>算法流程:</strong></p>
<p><img src="https://img-blog.csdn.net/20170712180312420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YmFvaHVhX2J1cHQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>概率机器人</title>
    <url>/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://gaoyichao.com/Xiaotu/?book=probabilistic_robotics&title=index">概率机器人</a></p>
<h1 id="5-机器人运动模型"><a href="#5-机器人运动模型" class="headerlink" title="5.机器人运动模型"></a>5.机器人运动模型</h1><h2 id="速度模型-概率运动规划"><a href="#速度模型-概率运动规划" class="headerlink" title="速度模型(概率运动规划)"></a>速度模型(概率运动规划)</h2><h3 id="闭式算法"><a href="#闭式算法" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p>
<h3 id="采样算法"><a href="#采样算法" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p>
<h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><h4 id="精确运动"><a href="#精确运动" class="headerlink" title="精确运动"></a>精确运动</h4><p><img src="https://i.loli.net/2021/10/28/q6Bp1FfriNSYJOm.png" alt="image-20211028195757782.png"></p>
<h4 id="真实运动"><a href="#真实运动" class="headerlink" title="真实运动"></a>真实运动</h4><p>加入扰动,模型表达为</p>
<p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p>
<p>加入噪声,求得概率公式为:</p>
<p><img src="https://i.loli.net/2021/10/28/dSyQKWDwZokC31L.png" alt="image-20211028200012951.png"></p>
<h2 id="里程计模型-估计"><a href="#里程计模型-估计" class="headerlink" title="里程计模型(估计)"></a>里程计模型(估计)</h2><p>模型为:</p>
<p><img src="https://i.loli.net/2021/10/28/SlTo9XeFOgYc5mV.png" alt="image-20211028200122122.png"></p>
<h3 id="闭式算法-1"><a href="#闭式算法-1" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/NIADHiMonhT1Kme.png" alt="image-20211028200230307.png"></p>
<h3 id="采样算法-1"><a href="#采样算法-1" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/c48vqLlKwirNEuF.png" alt="image-20211028200258350.png"></p>
<h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导"></a>数学推导</h3><p>三次转换:</p>
<p><img src="https://i.loli.net/2021/10/28/mpeJFAc3E2dYTUB.png" alt="image-20211028200511164.png"></p>
<p>加入噪声:</p>
<p><img src="https://i.loli.net/2021/10/28/zWb12u97LjVsfEt.png" alt="image-20211028200548403.png"></p>
<p>求出坐标:</p>
<p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p>
<p>求得最终概率:</p>
<p><img src="https://i.loli.net/2021/10/28/JMKtbz5W2ErdQCO.png" alt="image-20211028200832805.png"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>状态空间表达式</title>
    <url>/blog/2022/02/07/%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_42680785/article/details/106378414?ops_request_misc=%7B%22request_id%22:%22164419471716780265454857%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164419471716780265454857&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-106378414.nonecase&utm_term=%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B&spm=1018.2226.3001.4450">(104条消息) 现控笔记（二）：状态空间表达式_sdhdwyx的博客-CSDN博客_状态空间表达式</a> </p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>对于二阶空间方程而言</p>
<p><img src="https://s2.loli.net/2022/02/07/Vhra9fS5xpiec2g.jpg" alt="be1378b91a992e82d575de43ef22137.jpg"></p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo模板</title>
    <url>/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/blog/2021/11/23/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/daocaokafei/article/details/108922604?ops_request_misc=%7B%22request_id%22:%22163767858216780366532578%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163767858216780366532578&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108922604.pc_search_mgc_flag&utm_term=%E7%8A%B6%E6%80%81%E6%9C%BA&spm=1018.2226.3001.4187">什么是状态机？用C语言实现进程5状态模型_一口Linux的专栏-CSDN博客</a></p>
<h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stateMachine.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  sta_origin=<span class="number">0</span>,</span><br><span class="line">  sta_running,</span><br><span class="line">  sta_owencpu,</span><br><span class="line">  sta_sleep_int,</span><br><span class="line">  sta_sleep_unint</span><br><span class="line">&#125;State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span>  <span class="keyword">char</span> *statename[]=&#123;</span><br><span class="line">	<span class="string">&quot;origin&quot;</span>,</span><br><span class="line">	<span class="string">&quot;running&quot;</span>,</span><br><span class="line">	<span class="string">&quot;owencpu&quot;</span>,</span><br><span class="line">	<span class="string">&quot;sleep_int&quot;</span>,</span><br><span class="line">	<span class="string">&quot;sleep_unint&quot;</span>,	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">  evt_fork=<span class="number">0</span>,</span><br><span class="line">  evt_sched,</span><br><span class="line">  evt_wait,</span><br><span class="line">  evt_wait_unint,</span><br><span class="line">  evt_wake_up,</span><br><span class="line">  evt_wake, </span><br><span class="line">&#125;EventID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span> <span class="params">(*CallBack)</span><span class="params">(<span class="keyword">void</span> *)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  State curState;<span class="comment">//当前状态</span></span><br><span class="line">  EventID eventId;<span class="comment">//事件ID</span></span><br><span class="line">  State nextState;<span class="comment">//下个状态</span></span><br><span class="line">  CallBack action;<span class="comment">//回调函数</span></span><br><span class="line">&#125;StateTransform ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">State globalState = sta_origin;</span><br><span class="line"><span class="keyword">pthread_t</span> pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">action_callback</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StateTransform *statTran = (StateTransform *)arg;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(statename[statTran-&gt;curState] == statename[statTran-&gt;nextState])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid event,state not change\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;call back state from %s --&gt; %s\n&quot;</span>,</span><br><span class="line">			statename[statTran-&gt;curState],</span><br><span class="line">			statename[statTran-&gt;nextState]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*origin*/</span></span><br><span class="line">StateTransform stateTran_0[]=&#123;</span><br><span class="line">	&#123;sta_origin,evt_fork,         sta_running,action_callback&#125;,</span><br><span class="line">	&#123;sta_origin,evt_sched,      sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wait,        sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wait_unint,sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wake_up,   sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_origin,evt_wake,        sta_origin,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*running*/</span></span><br><span class="line">StateTransform stateTran_1[]=&#123;</span><br><span class="line">	&#123;sta_running,evt_fork,         sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_sched,      sta_owencpu,action_callback&#125;,</span><br><span class="line">	&#123;sta_running,evt_wait,        sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wait_unint,sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wake_up,   sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_running,evt_wake,        sta_running,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*owencpu*/</span></span><br><span class="line">StateTransform stateTran_2[]=&#123;</span><br><span class="line">	&#123;sta_owencpu,evt_fork,         sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_sched,      sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wait,        sta_sleep_int,action_callback&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wait_unint,sta_sleep_unint,action_callback&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wake_up,   sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_owencpu,evt_wake,        sta_owencpu,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*sleep_int*/</span></span><br><span class="line">StateTransform stateTran_3[]=&#123;</span><br><span class="line">	&#123;sta_sleep_int,evt_fork,         sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_sched,      sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wait,        sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wait_unint,sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wake_up,   sta_sleep_int,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_int,evt_wake,        sta_running,action_callback&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*sleep_unint*/</span></span><br><span class="line">StateTransform stateTran_4[]=&#123;</span><br><span class="line">	&#123;sta_sleep_unint,evt_fork,         sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_sched,      sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wait,        sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wait_unint,sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wake_up,   sta_running,action_callback&#125;,</span><br><span class="line">	&#123;sta_sleep_unint,evt_wake,        sta_sleep_unint,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_machine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	globalState = sta_origin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*显示当前状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">show_stat</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cur stat:%s\n&quot;</span>,statename[globalState]);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATETRANS(n)  (stateTran_##n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*change state &amp; call callback()*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_action</span><span class="params">(StateTransform *statTran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == statTran)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;statTran is NULL\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	globalState = statTran-&gt;nextState;</span><br><span class="line">	<span class="keyword">if</span>(statTran-&gt;action != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		statTran-&gt;action((<span class="keyword">void</span>*)statTran);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid event,state not change\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_happen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(globalState)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> sta_origin:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">0</span>)[event]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_running:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">1</span>)[event]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_owencpu:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">2</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_sleep_int:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">3</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> sta_sleep_unint:</span><br><span class="line">			do_action(&amp;STATETRANS(<span class="number">4</span>)[event]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;state is invalid\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init_machine();</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;pid, <span class="literal">NULL</span>,show_stat, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_fork);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_sched);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_sched);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_wait);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	event_happen(evt_wake);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o main stateMachine.c -pthread -g</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>项目模板</title>
    <url>/blog/2021/10/19/%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="天穹飞控项目"><a href="#天穹飞控项目" class="headerlink" title="天穹飞控项目"></a>天穹飞控项目</h3><p>将模块细分非常细致值得嵌入式借鉴</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRC# tree</span><br><span class="line">.</span><br><span class="line">├── CONTROL</span><br><span class="line">│   ├── flightControl.c</span><br><span class="line">│   ├── flightControl.h</span><br><span class="line">│   ├── missionControl.c</span><br><span class="line">│   ├── missionControl.h</span><br><span class="line">│   ├── motor.c</span><br><span class="line">│   ├── motor.h</span><br><span class="line">│   ├── rc.c</span><br><span class="line">│   ├── rc.h</span><br><span class="line">│   ├── safeControl.c</span><br><span class="line">│   ├── safeControl.h</span><br><span class="line">│   ├── userControl.c</span><br><span class="line">│   ├── userControl.h</span><br><span class="line">│   ├── waypointControl.c</span><br><span class="line">│   └── waypointControl.h</span><br><span class="line">├── DRIVER</span><br><span class="line">│   ├── board.c</span><br><span class="line">│   ├── board.h</span><br><span class="line">│   ├── boardConfigBlueSkyV3.h</span><br><span class="line">│   ├── drv_adc.c</span><br><span class="line">│   ├── drv_adc.h</span><br><span class="line">│   ├── drv_can.c</span><br><span class="line">│   ├── drv_can.h</span><br><span class="line">│   ├── drv_flash.c</span><br><span class="line">│   ├── drv_flash.h</span><br><span class="line">│   ├── drv_i2c_soft.c</span><br><span class="line">│   ├── drv_i2c_soft.h</span><br><span class="line">│   ├── drv_ppm.c</span><br><span class="line">│   ├── drv_ppm.h</span><br><span class="line">│   ├── drv_pwm.c</span><br><span class="line">│   ├── drv_pwm.h</span><br><span class="line">│   ├── drv_sbus.c</span><br><span class="line">│   ├── drv_sbus.h</span><br><span class="line">│   ├── drv_spi.c</span><br><span class="line">│   ├── drv_spi.h</span><br><span class="line">│   ├── drv_usart.c</span><br><span class="line">│   ├── drv_usart.h</span><br><span class="line">│   ├── drv_usb.c</span><br><span class="line">│   └── drv_usb.h</span><br><span class="line">├── LOG</span><br><span class="line">│   ├── logger.c</span><br><span class="line">│   ├── logger.h</span><br><span class="line">│   ├── ulog.c</span><br><span class="line">│   ├── ulog.h</span><br><span class="line">│   ├── ulog_data.c</span><br><span class="line">│   └── ulog_data.h</span><br><span class="line">├── MATH</span><br><span class="line">│   ├── LevenbergMarquardt.c</span><br><span class="line">│   ├── LevenbergMarquardt.h</span><br><span class="line">│   ├── declination.c</span><br><span class="line">│   ├── declination.h</span><br><span class="line">│   ├── kalman3.c</span><br><span class="line">│   ├── kalman3.h</span><br><span class="line">│   ├── kalmanVel.c</span><br><span class="line">│   ├── kalmanVel.h</span><br><span class="line">│   ├── lowPassFilter.c</span><br><span class="line">│   ├── lowPassFilter.h</span><br><span class="line">│   ├── mathTool.c</span><br><span class="line">│   ├── mathTool.h</span><br><span class="line">│   ├── matrix3.c</span><br><span class="line">│   ├── matrix3.h</span><br><span class="line">│   ├── matrix6.c</span><br><span class="line">│   ├── matrix6.h</span><br><span class="line">│   ├── pid.c</span><br><span class="line">│   ├── pid.h</span><br><span class="line">│   ├── quaternion.c</span><br><span class="line">│   ├── quaternion.h</span><br><span class="line">│   ├── rotation.c</span><br><span class="line">│   ├── rotation.h</span><br><span class="line">│   ├── vector3.c</span><br><span class="line">│   └── vector3.h</span><br><span class="line">├── MESSAGE</span><br><span class="line">│   ├── bsklink.c</span><br><span class="line">│   ├── bsklink.h</span><br><span class="line">│   ├── bsklinkDecode.c</span><br><span class="line">│   ├── bsklinkDecode.h</span><br><span class="line">│   ├── bsklinkSend.c</span><br><span class="line">│   ├── bsklinkSend.h</span><br><span class="line">│   ├── mavlinkDecode.c</span><br><span class="line">│   ├── mavlinkDecode.h</span><br><span class="line">│   ├── mavlinkNotice.c</span><br><span class="line">│   ├── mavlinkNotice.h</span><br><span class="line">│   ├── mavlinkParam.c</span><br><span class="line">│   ├── mavlinkParam.h</span><br><span class="line">│   ├── mavlinkSend.c</span><br><span class="line">│   ├── mavlinkSend.h</span><br><span class="line">│   ├── message.c</span><br><span class="line">│   └── message.h</span><br><span class="line">├── MODULE</span><br><span class="line">│   ├── 2smpb.c</span><br><span class="line">│   ├── 2smpb.h</span><br><span class="line">│   ├── battery.c</span><br><span class="line">│   ├── battery.h</span><br><span class="line">│   ├── icm20602.c</span><br><span class="line">│   ├── icm20602.h</span><br><span class="line">│   ├── icm20689.c</span><br><span class="line">│   ├── icm20689.h</span><br><span class="line">│   ├── ist8310.c</span><br><span class="line">│   ├── ist8310.h</span><br><span class="line">│   ├── mmc3630.c</span><br><span class="line">│   ├── mmc3630.h</span><br><span class="line">│   ├── module.c</span><br><span class="line">│   ├── module.h</span><br><span class="line">│   ├── mpu6000.c</span><br><span class="line">│   ├── mpu6000.h</span><br><span class="line">│   ├── mpu6500.c</span><br><span class="line">│   ├── mpu6500.h</span><br><span class="line">│   ├── ms5611.c</span><br><span class="line">│   ├── ms5611.h</span><br><span class="line">│   ├── qmc5883.c</span><br><span class="line">│   ├── qmc5883.h</span><br><span class="line">│   ├── rgb.c</span><br><span class="line">│   ├── rgb.h</span><br><span class="line">│   ├── ublox.c</span><br><span class="line">│   └── ublox.h</span><br><span class="line">├── NAVIGATION</span><br><span class="line">│   ├── ahrs.c</span><br><span class="line">│   ├── ahrs.h</span><br><span class="line">│   ├── ahrsAux.c</span><br><span class="line">│   ├── ahrsAux.h</span><br><span class="line">│   ├── navigation.c</span><br><span class="line">│   └── navigation.h</span><br><span class="line">├── SENSOR</span><br><span class="line">│   ├── accelerometer.c</span><br><span class="line">│   ├── accelerometer.h</span><br><span class="line">│   ├── barometer.c</span><br><span class="line">│   ├── barometer.h</span><br><span class="line">│   ├── gps.c</span><br><span class="line">│   ├── gps.h</span><br><span class="line">│   ├── gyroscope.c</span><br><span class="line">│   ├── gyroscope.h</span><br><span class="line">│   ├── magnetometer.c</span><br><span class="line">│   ├── magnetometer.h</span><br><span class="line">│   ├── sensor.c</span><br><span class="line">│   └── sensor.h</span><br><span class="line">├── SYSTEM</span><br><span class="line">│   ├── faultDetect.c</span><br><span class="line">│   ├── faultDetect.h</span><br><span class="line">│   ├── flightStatus.c</span><br><span class="line">│   ├── flightStatus.h</span><br><span class="line">│   ├── parameter.c</span><br><span class="line">│   └── parameter.h</span><br><span class="line">├── TASK</span><br><span class="line">│   ├── TaskConfig.h</span><br><span class="line">│   ├── control_task.c</span><br><span class="line">│   ├── control_task.h</span><br><span class="line">│   ├── log_task.c</span><br><span class="line">│   ├── log_task.h</span><br><span class="line">│   ├── messageQueue.c</span><br><span class="line">│   ├── messageQueue.h</span><br><span class="line">│   ├── message_task.c</span><br><span class="line">│   ├── message_task.h</span><br><span class="line">│   ├── module_task.c</span><br><span class="line">│   ├── module_task.h</span><br><span class="line">│   ├── navigation_task.c</span><br><span class="line">│   ├── navigation_task.h</span><br><span class="line">│   ├── sensor_task.c</span><br><span class="line">│   └── sensor_task.h</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure>

<h3 id="待添加……"><a href="#待添加……" class="headerlink" title="待添加……"></a>待添加……</h3>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>注释软件</title>
    <url>/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/F2wN5Bbqqv_3R1gAlA19Pw">几款注释软件推荐</a></p>
<h1 id="javE"><a href="#javE" class="headerlink" title="javE"></a>javE</h1><p><strong><a href="http://www.jave.de/">http://www.jave.de/</a></strong></p>
<p>里边的字体,图片生成挺有意思,不过需要装java</p>
<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><strong><a href="https://josoansi.de/download.php">https://josoansi.de/download.php</a></strong></p>
<p><img src="https://josoansi.de/images/screenshot128.jpg" alt="Screenshot AACircuit 1.28"></p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><a href="http://www.ascii-art.de/">ascii-art</a></p>
<p>有很多有意思的注释,可知看一下直接复制粘贴,很舒爽</p>
<p><a href="https://www.codeproject.com/Articles/4514/CodePlotter-1-6-Add-and-edit-diagrams-in-your-code">CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject</a></p>
<p>类似于”Visio”的一款工具</p>
<p><img src="https://www.codeproject.com/KB/macros/codeplotter/CodePlotter.jpg" alt="Sample Image - CodePlotter.jpg"></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>由g2o引出的变换矩阵的思考</title>
    <url>/blog/2022/03/04/%E7%94%B1g2o%E5%BC%95%E5%87%BA%E7%9A%84%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/softdream/Slam-Project-Of-MyOwn/tree/master/test/slam_simulation_with_g2o">Slam-Project-Of-MyOwn</a> </p>
<p> <a href="https://github.com/gaoxiang12/slambook2">gaoxiang12/slambook2: edition 2 of the slambook (github.com)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于最近在看道锋大佬的slam代码,其中有这样一段关于g2o后端优化的程序,不太理解,于是找道锋大佬咨询</p>
<p>代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix3d information = <span class="number">1</span> * Eigen::Matrix3d::Identity(); <span class="comment">//information matrix</span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T1 = slam.v2t( robotPoseCurr );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T2 = slam.v2t( keyPoses[loopId] );</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; T = T1.inverse() * T2;<span class="comment">//这里T值得是转移矩阵</span></span><br><span class="line">Eigen::Vector3f V = slam.t2v( T );<span class="comment">// 矩阵转向量</span></span><br><span class="line">optimizer.addEdge( V, keyFrameCount, loopId, information ); <span class="comment">// add a loop constraint</span></span><br></pre></td></tr></table></figure>

<p>v2t与t2v代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里v是当前机器人位姿到回环点的位姿的位姿增量[dx,dy,dtheta],</span></span><br><span class="line"><span class="comment">// T是当前机器人位姿到回环点的位姿坐标变换矩阵（齐次坐标变换，就是由旋转矩阵加平移组成的）</span></span><br><span class="line"><span class="comment">// T = [R,t</span></span><br><span class="line"><span class="comment">// 		0,1] R为旋转矩阵,t为移动矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Eigen::Matrix&lt;<span class="keyword">float</span>, 3, 3&gt; <span class="title">SlamProcessor::v2t</span><span class="params">(<span class="keyword">const</span> Eigen::Vector3f &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> c = ::<span class="built_in">cos</span>( v(<span class="number">2</span>) );</span><br><span class="line">	<span class="keyword">float</span> s = ::<span class="built_in">sin</span>( v(<span class="number">2</span>) );</span><br><span class="line">	Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;</span><br><span class="line">    </span><br><span class="line">	A &lt;&lt; c, -s, v(<span class="number">0</span>),</span><br><span class="line">		s,  c, v(<span class="number">1</span>),</span><br><span class="line">		<span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Eigen::Vector3f <span class="title">SlamProcessor::t2v</span><span class="params">(<span class="keyword">const</span> Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Eigen::Vector3f v;</span><br><span class="line">        </span><br><span class="line">	v(<span class="number">0</span>) = A(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	v(<span class="number">1</span>) = A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	v(<span class="number">2</span>) = ::<span class="built_in">atan2</span>( A( <span class="number">1</span>, <span class="number">0</span> ), A(<span class="number">0</span>, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是翻出珍藏多年的slam14讲</p>
<p>首先:变换矩阵T表现为旋转矩阵R与平移矩阵t</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// T = [R,t</span><br><span class="line">// 		0,1] R为旋转矩阵,t为移动矩阵</span><br></pre></td></tr></table></figure>

<p>而这里的T1与T2分别为当前车体坐标与回环点坐标,将他们先转换为其次坐标之后做变换可得变换矩阵</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">T2 = T1*T ==&gt; inv(T1)*T1*T = inv(T1)*T2 ==&gt; T = inv(T1)*T2</span><br></pre></td></tr></table></figure>

<p>这也是齐次坐标的好处,便于做坐标转换</p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_通讯设计</title>
    <url>/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="CAN"><a href="#CAN" class="headerlink" title="CAN:"></a>CAN:</h1><p><img src="https://i.loli.net/2021/11/06/Cs8JxWr3kPG7efT.png" alt="image-20211106130338091-16361750226251.png"></p>
<p><img src="https://i.loli.net/2021/11/06/6BkYVPWyMIU5g1Z.png" alt="image-20211106133256690.png"></p>
<p>两张图用的都是<code>TJA1050</code>,速度<code>1Mbps</code>,不过后期的处理略有些不同,上图can信号分两路输出,而下图,为保护电路,加入了<code>fuse</code>(熔断器),<code>SMAJ30CA</code>(瞬态抑制二极管)</p>
<p><img src="https://i.loli.net/2021/11/06/tcjs9VvHAG8ENQX.png" alt="image-20211106140618661.png"></p>
<p>这张图用的是<code>max3051</code>3.3v供电,高速运行<code>1Mbps</code>,这里使用了<code>ACT45B</code>共模电感起<code>EMI</code>滤波的作用，用于抑制高速信号线产生的电磁波向外辐射发射.</p>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><p><img src="https://i.loli.net/2021/11/06/NuSOBZ4Yldot6wp.png" alt="image-20211106141453916.png"></p>
<p><img src="https://i.loli.net/2021/11/06/T8zrX3fUBA4Slc2.png" alt="image-20211106141550298.png"></p>
<p>由于采用<code>3.3v</code>供电,使用芯片为<code>sp3485</code>,参考图二,<code>5v</code>供电可更换为<code>max485</code>,电路设计上也还是同样,图一,采用<code>熔断器</code>与<code>瞬态一直二极管</code>保护电路</p>
<p><img src="https://i.loli.net/2021/11/06/QHouRcwMjXm7fFh.png" alt="image-20211106142404847"></p>
<p>这张图就是<code>max485</code>实现的<code>RS485</code>电路,同样对于电路保护也采用熔断器与瞬态一直二极管,同时采用电容进行进一步滤波.这里发送接收通过<code>EN</code>控制,三极管做开关功能,<code>EN</code>为0时接收,为1时发送.</p>
<h1 id="232"><a href="#232" class="headerlink" title="232"></a>232</h1><p><img src="https://i.loli.net/2021/11/06/J8CwfLA7H1uErT4.png" alt="image-20211106143625304"></p>
<p>数据手册:</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/max3232.pdf?ts=1636166679814">具有 ±15kV ESD 保护功能的 MAX3232 3V 至 5.5V 多通道 RS-232 线路驱动器和接收器 datasheet </a></p>
<p>布板参考:</p>
<p><img src="https://i.loli.net/2021/11/06/wghYLF1WtiadvNS.png" alt="image-20211106143955599.png"></p>
<h1 id="USB转串口"><a href="#USB转串口" class="headerlink" title="USB转串口"></a>USB转串口</h1><p><img src="https://i.loli.net/2021/11/06/oKLkuhrp9EUb43w.png" alt="image-20211106145617779.png"></p>
<p>这张图是type_c转串口的图,图中使用<code>CH340N</code>实现板子最小化,非常<strong>nice</strong></p>
<p>下面是他的开源链接:<a href="https://oshwhub.com/vcijj/TYPE-C-usbzhuai-chuan-kou">TYPE C usb转串口 - 立创EDA开源硬件平台 (oshwhub.com)</a></p>
<p>当然为了保护电路,我们也可以在上边加上<code>熔断</code>与<code>瞬时抑制二极管</code></p>
<h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p><strong>参考渡鸦卡发版设计</strong></p>
<p><img src="https://i.loli.net/2021/11/06/u3pGfIP86yELD4F.png" alt="image-20211106150109596.png"></p>
<p><strong>大佬的串口转以太网设计:</strong></p>
<p><a href="https://oshwhub.com/jixin/CH9121-4c2c4f99e2494eee8421dd23768820a1">串口转以太网模块-CH9121 - 立创EDA开源硬件平台 (oshwhub.com)</a></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_常见电路</title>
    <url>/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="驱动输出电路"><a href="#驱动输出电路" class="headerlink" title="驱动输出电路"></a>驱动输出电路</h1><p><img src="https://i.loli.net/2021/11/08/IcfBqFezTlgAm9b.png" alt="image-20211108152310283.png"></p>
<p>这里需要注意的是,<code>uln2803</code>是一种<code>npn</code>输出,输出低电平,因此在其输出端会有上拉电阻.在<code>uln2803</code>左侧接<code>gnd</code>右侧接<code>24v</code>.</p>
<p>这里的<code>74hct245</code>为<code>三态输出八路收发器</code>作用是增加单片机的驱动能力.</p>
<p>将同样用<code>74hct245</code>此电路改为<code>pnp</code>型输出,需要将<code>uln2803</code>换为<code>tbd62783</code>,需要注意输出端需要接<code>下拉电阻</code>.</p>
<p>**!注意:**由于改驱动芯片<code>uln2803</code>输出最大电流为<code>500ma</code>可能出现烧芯片的情况,可以加一个<code>500ma</code>熔断</p>
<h1 id="放大电路-opa2333"><a href="#放大电路-opa2333" class="headerlink" title="放大电路(opa2333)"></a>放大电路(opa2333)</h1><p><img src="https://i.loli.net/2021/11/08/cdPVFXozHa5hrxR.png" alt="image-20211108185457678.png"></p>
<p>这里通过<code>R64</code>,<code>R65</code>阻值的变化来实现放大,具体详细可参考:<a href="https://blog.csdn.net/cyousui/article/details/82936155">(61条消息) 基本运算放大器原理_小神兵之技术篇-CSDN博客_运算放大器</a></p>
<p>值得注意的是,由于是轨到轨的放大电路,输入<code>24v</code>,最大放大电压同样也可以达到<code>24v</code></p>
<h1 id="模拟量采样电路"><a href="#模拟量采样电路" class="headerlink" title="模拟量采样电路"></a>模拟量采样电路</h1><p><img src="https://i.loli.net/2021/11/08/PRZG7qv6kX3yQA9.png" alt="image-20211108191319100.png"></p>
<p>这里两个二极管用以防过压,电压大于<code>3.3v</code>小于<code>26.7v</code>时直接通过<code>+3.3v</code>,输出,而大于<code>26.7v</code>击穿二极管,直接导地.</p>
<p><img src="https://i.loli.net/2021/11/08/F1qsv4pESJwMUbN.png" alt="image-20211108191642356.png"></p>
<p>模拟量采集,还需要注意一点就是,对于电源要进行滤波处理,使电源信号更干净</p>
<h1 id="普通光耦-TLP290-4-与单向高速光耦-PC4D10"><a href="#普通光耦-TLP290-4-与单向高速光耦-PC4D10" class="headerlink" title="普通光耦(TLP290-4)与单向高速光耦(PC4D10)"></a>普通光耦(TLP290-4)与单向高速光耦(PC4D10)</h1><p><img src="https://i.loli.net/2021/11/08/Z6cxwFV4NLpevJK.png" alt="image-20211108192255515.png"></p>
<p><code>TLP290-4</code>为一种普通光耦,可以实现双向导通,这里原理图<code>左边部分有些出入</code>需要注意一下,输出为<code>npn</code>型输出,注意上拉电阻</p>
<p><img src="https://i.loli.net/2021/11/08/lESfhw24NsPrKpc.png" alt="image-20211108191804168.png"></p>
<p><code>pc4d10</code>为告诉光耦,实现的<code>npn</code>型输出,所以注意需要有上拉电阻.</p>
<h1 id="防反接电路"><a href="#防反接电路" class="headerlink" title="防反接电路"></a>防反接电路</h1><p>参考网址:<a href="https://blog.csdn.net/cgy8919/article/details/90909859?ops_request_misc=%7B%22request_id%22:%22163645288216780264054670%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163645288216780264054670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-90909859.pc_search_mgc_flag&utm_term=%E5%8D%95%E7%89%87%E6%9C%BA%E9%98%B2%E5%8F%8D%E6%8E%A5%E7%94%B5%E8%B7%AF&spm=1018.2226.3001.4187">(62条消息) 直流电源输入防反接保护电路总结_cgy8919的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_最小系统设计</title>
    <url>/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/little_ox/article/details/105056030">(60条消息) STM32最小系统设计_little_ox的博客-CSDN博客</a></p>
<h1 id="最小系统"><a href="#最小系统" class="headerlink" title="最小系统"></a>最小系统</h1><p>组成:<strong>主芯片</strong>,<strong>复位电路</strong>,<strong>时钟电路</strong>,<strong>电源电路</strong>,<strong>下载电路</strong></p>
<h2 id="主芯片"><a href="#主芯片" class="headerlink" title="主芯片"></a>主芯片</h2><p>根据自己需要的io数量,功能选择好主芯片</p>
<h2 id="复位电路-时钟电路-下载电路"><a href="#复位电路-时钟电路-下载电路" class="headerlink" title="复位电路,时钟电路,下载电路"></a>复位电路,时钟电路,下载电路</h2><p>由于低电平复位,因此可以通过上拉电阻实现,由于<strong>复位电路</strong>与<strong>时钟电路</strong>一般芯片都会提供参考电路或者查查资料都很容易找到,就不再赘述,<strong>下载电路</strong>的话直接<code>clk</code>,<code>dio</code>给他,通过<code>SWD</code>,或者<code>JTAG</code>下载,这里使用的时<code>SWD</code>下载</p>
<p><img src="https://i.loli.net/2021/11/06/uVUHSfX4Lt2Reiq.png" alt="image-20211106195658724.png"></p>
<p>**!注意:**一般芯片都会有电源滤波,因此在布线的过程中注意将电容尽量放的里芯片近些.</p>
<h2 id="晶振的选择"><a href="#晶振的选择" class="headerlink" title="晶振的选择"></a>晶振的选择</h2><p>有源晶振:自供电,有内部电路,精度会高些,当然价格也贵些</p>
<p>无源晶振:内部不供电,与芯片直接相连,精度差些,在对时钟要求没那么高的情况下一般够用</p>
<h2 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h2><p>比较麻烦的是电源电路,或者降压,或者稳压,根据需要实现.</p>
<p>这里提供一种从24v转3.3v的思路电源思路.这里使用<code>TPS5430</code>芯片实现的一种电源降压的方式,这里<code>D2</code>指的是<code>瞬态抑制</code>起到当电压超过24v(比如打火花)进来时,<code>D2</code>导通,24v直接接地,同事使用了F1保险丝做保护        </p>
<p><img src="https://i.loli.net/2021/11/06/OokdWnJcprP4uZV.png" alt="image-20211106200343212.png"></p>
<p><img src="https://i.loli.net/2021/11/06/SXDMrFs3iagZGBq.png" alt="image-20211106200412912.png"></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计_稚晖君机械臂</title>
    <url>/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E7%A8%9A%E6%99%96%E5%90%9B%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/peng-zhihui/Dummy-Robot">peng-zhihui/Dummy-Robot: 我的超迷你机械臂机器人项目。 (github.com)</a></p>
<h1 id="电源部分"><a href="#电源部分" class="headerlink" title="电源部分:"></a>电源部分:</h1><p>采用<code>TPS61040DBV</code>芯片实现的<code>5v</code>转<code>9v</code>电路,该芯片支持<code>1.8v</code>到<code>6v</code>输入,高达<code>28v</code>输出,同时还支持<code>400ma</code>的电流输出,具体可参考:</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/tps61040.pdf?ts=1636365714478">TPS6104x Low-Power DC-DC Boost Converter in SOT-23 and WSON Packages datasheet (Rev. J) (ti.com)</a></p>
<p><img src="https://i.loli.net/2021/11/08/S7a8ycYL5rbvmOe.png" alt="image-20211108201917859.png"></p>
<p><code>LP2992</code>线性稳压器,输入<code>2.2v</code>到<code>16v</code>输出<code>1.5v</code>到<code>5v</code>,指定250毫安输出电流</p>
<p><a href="https://www.ti.com/cn/lit/ds/symlink/lp2992.pdf?ts=1636360611776">LP2992 Micropower 250-mA Low-Noise Ultra-Low-Dropout Regulator in SOT-23 and WSON Packages Designed for Use With Very Low-ESR Output Capacitors datasheet (Rev. J) (ti.com)</a></p>
<p><img src="https://i.loli.net/2021/11/08/Pc1Nxinl3avWTtG.png" alt="image-20211108202522586.png"></p>
<p><code>ME3116</code> 是一款内部集成了 <code>MOSFET</code> 的异步整流降压型 稳压器。它在很宽的输入电压范围内（<code>4.75V-40V</code>）能够提供 高达 <code>1A</code> 的负载能力。</p>
<p><img src="https://i.loli.net/2021/11/08/nWz2I4P8y5dTol3.png" alt="image-20211108203139049.png"></p>
<p><code>ME6206</code>:降压稳压器,高精度输出电压：<code>±2%</code>   输出电压：<code>1.5V~5.0V</code>(步长 <code>0.1V</code>)  最大工作电压：<code>6V</code> 带载能力强：当 <code>Vin=4.3V</code> 且 <code>Vout=3.3V</code> 时 <code>Iout=300mA</code>  极低的输入输出电压差： <code>0.2V</code> at <code>90mA</code> and <code>0.40V</code> at <code>200mA</code></p>
<p><img src="https://i.loli.net/2021/11/08/XljkeHb6N1pcW4y.png" alt="image-20211108204012844.png"></p>
<p>这里使用了<code>ss54</code>实现防反接,<code>sy8303</code>降压型<code>dc-dc</code>芯片</p>
<p><img src="https://i.loli.net/2021/11/11/POs7cb8Yxo3TvEU.png" alt="image-20211111191014461.png"></p>
<h1 id="自动下载电路"><a href="#自动下载电路" class="headerlink" title="自动下载电路"></a>自动下载电路</h1><p>采用<code>cp2101</code>usb转串口芯片,通过三极管,实现串口自动下载</p>
<p><img src="https://i.loli.net/2021/11/11/U3pDMn8Qt1cTLvl.png" alt="image-20211111190423177.png"></p>
]]></content>
      <categories>
        <category>sch</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>sch</tag>
      </tags>
  </entry>
  <entry>
    <title>行为树</title>
    <url>/blog/2022/04/27/%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_30170949/article/details/118573085?ops_request_misc=%7B%22request_id%22:%22165102194816781432975965%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165102194816781432975965&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-118573085-null-null-2~all~sobaiduend~default-2-118573085.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E8%A1%8C%E4%B8%BA%E6%A0%91&spm=1018.2226.3001.4187">(128条消息) 行为树(Behavior trees)_念去去~的博客-CSDN博客_行为树</a></p>
<p><a href="https://blog.csdn.net/PresleyGo/article/details/104042749?ops_request_misc=%7B%22request_id%22:%22165095583516781483766333%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165095583516781483766333&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104042749.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E8%A1%8C%E4%B8%BA%E6%A0%91&spm=1018.2226.3001.4187">(128条消息) 状态机和行为树_PresleyGo的博客-CSDN博客_行为树和状态机区别</a></p>
<p><a href="https://blog.csdn.net/weixin_44806700/article/details/121555411?ops_request_misc=%7B%22request_id%22:%22165102194816781432975965%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165102194816781432975965&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-121555411-null-null-2~all~sobaiduend~default-3-121555411.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E8%A1%8C%E4%B8%BA%E6%A0%91&spm=1018.2226.3001.4187">(128条消息) 行为树概念_白霞的博客-CSDN博客_行为树</a></p>
<p><a href="https://github.com/devildevilson/tiny_behaviour">devildevilson/tiny_behaviour: Behaviour tree header only library (github.com)</a></p>
<h1 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h1><h2 id="Tree-nodes-description"><a href="#Tree-nodes-description" class="headerlink" title="Tree nodes description"></a>Tree nodes description</h2><p>BehaviorTreeBuilder class methods:</p>
<h3 id="Compositor-nodes"><a href="#Compositor-nodes" class="headerlink" title="Compositor nodes:"></a>Compositor nodes:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`sequence()` - updates all nodes until faces `Status::Failure` or `Status::Running`</span><br><span class="line">`selector()` - updates all nodes until faces `Status::Success` or `Status::Running`</span><br><span class="line">`parallel(minSuccess, minFail)` - updates all nodes, return `Status::Success` if `totalSuccess` &gt;= `minSuccess` or `Status::Failure` if `totalFails` &gt;= `minFail` else `Status::Running`</span><br><span class="line">`memSelector()` - updates all nodes until faces `Status::Success` or `Status::Running`, next updation will start from that node</span><br><span class="line">`memSequence()` - updates all nodes until faces `Status::Failure` or `Status::Running`, next updation will start from that node</span><br><span class="line">`random(seed)` - updates random (depends on seed) node</span><br><span class="line">`whiledo(predicate)` - updates all nodes while `condition == true`, returns `Status::Running` in this case, if `condition == false` does nothing and returns `Status::Failure</span><br></pre></td></tr></table></figure>

<h3 id="Binary-nodes"><a href="#Binary-nodes" class="headerlink" title="Binary nodes:"></a>Binary nodes:</h3><p>(<code>Status::Success</code> is <code>true</code>, <code>Status::Failure</code> is <code>false</code>)<br><code>conjunction()</code> - Status first &amp;&amp; Status second<br><code>disjunction()</code> - Status first || Status second<br><code>equality()</code> - Status first == Status second<br><code>implication()</code> - Status first -&gt; Status second (!(Status first) || Status second) (<code>Status::Running</code> = <code>Status::Failure</code>)<br><code>ifelse(predicate)</code> - if <code>contidion == true</code> updates first, else second</p>
<h3 id="Decorator-nodes"><a href="#Decorator-nodes" class="headerlink" title="Decorator nodes:"></a>Decorator nodes:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inverter()` - inverts `Status::Success` and `Status::Failure`, `Status::Running` ignored</span><br><span class="line">`repeater(limit)` - returns `Status::Running` `limit` times, then return node status and resets</span><br><span class="line">`limiter(limit)` - returns decorator&#x27;s child status `limit` times, then return `Status::Failure`</span><br><span class="line">`untilFail()` - returns only `Status::Running` or `Status::Failure`</span><br><span class="line">`untilSuccess()` - returns only `Status::Running` or `Status::Success`</span><br><span class="line">`failer()` - returns only `Status::Failure`</span><br><span class="line">`succeeder()` - returns only `Status::Success`</span><br><span class="line">`condition(predicate)` - updates child if `predicate == true` else returns `Status::Failure</span><br></pre></td></tr></table></figure>

<h3 id="Special-nodes"><a href="#Special-nodes" class="headerlink" title="Special nodes:"></a>Special nodes:</h3><p><code>action(action)</code> - userdefined action function, must return statuses</p>
<h3 id="Other-methods"><a href="#Other-methods" class="headerlink" title="Other methods:"></a>Other methods:</h3><p><code>end()</code> - use it after every Compositor or Binary nodes<br><code>add(node)</code> - adds nodes to the current tree, NOTE: adding trees is under construction<br><code>leaf(arguments)</code> - create userdefined action node <code>build()</code> - does some postworks and returns <code>BehaviorTree</code> pointer<br><code>debug(string)</code> - just prints the string<br><code>setDebugCallback(callback)</code> - set callback function for the error strings</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>编程规范</title>
    <url>/blog/2021/10/19/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><h4 id="1-原则"><a href="#1-原则" class="headerlink" title="1. 原则"></a>1. 原则</h4><ol>
<li>简洁明了，提高代码可读性，读的是代码而不是注释，注释永远都是辅助的。</li>
<li>零告警，严谨的语法才能保障代码表达和编译器理解的是一至的。</li>
</ol>
<h4 id="2-排版"><a href="#2-排版" class="headerlink" title="2. 排版"></a>2. 排版</h4><ol>
<li>程序块之间、变量声明之间，用空行分隔</li>
<li>突出语法关键字</li>
<li>一行不要太长，换行增加可读性</li>
<li>Tab键排版</li>
</ol>
<h4 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h4><ol>
<li><p>注释的目的是阐明意图目的，而不是翻译某行代码的动作</p>
</li>
<li><p>注释的原则是尽量代码自注释，代码越清晰，可读性越高</p>
</li>
<li><p>统一格式 **/* 注释内容 */**， *号与注释内容之间有一个空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*************************************************</span><br><span class="line">Copyright 	 //版权</span><br><span class="line">File name:	 // 文件名</span><br><span class="line">Author： 	//作者</span><br><span class="line">Version: 	 //版本号</span><br><span class="line">Description: // 用于详细说明此程序文件完成的主要功能，与其他模块</span><br><span class="line">			// 或函数的接口，输出值、取值范围、含义及参数间的控</span><br><span class="line">			// 制、顺序、独立或依赖等关系</span><br><span class="line">Others: 	// 其它内容的说明</span><br><span class="line">Log: 		// 修改日志，包括修改内容，日期，修改人等</span><br><span class="line">*************************************************/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*@ Description: 函数描述，描述本函数的基本功能</span><br><span class="line">* @param 1 – 参数 1.</span><br><span class="line">* @param 2 – 参数 2</span><br><span class="line">* @return – 返回值</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-定义"><a href="#4-定义" class="headerlink" title="4. 定义"></a>4. 定义</h4><ol>
<li><p>命名风格</p>
<ol>
<li>模块名+文件名+功能描述，之间采用短下划线分隔</li>
<li>功能描述部分，采用驼峰风格</li>
</ol>
<p>例如，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SAFE_LASER_setLaserShield</span><span class="params">(<span class="keyword">uint8_t</span> _EN)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>宏定义</p>
<ol>
<li>define 必须大写</li>
<li>typedef 可以小写</li>
</ol>
<p>例如，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASK_R200RXID1 		0x198 	<span class="comment">/* HEX格式 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> StackSize_t；   		<span class="comment">/* 仅用于堆栈 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型定义</p>
<p>使用linux自带类型定义规则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint8_t  	unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int8_t   	char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint16_t 	unsigned short</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int16_t  	short</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint32_t 	unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int32_t  	int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint64_t 	unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int64_t  	long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL  		0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h4><ol>
<li>变量通用规则<ol>
<li>采用驼峰风格,首字母大写</li>
<li>在函数开始是全部定义，不允许在函数中间定义</li>
<li>变量命名必须可以表示其含义</li>
<li>必须初始化</li>
</ol>
</li>
<li>局部变量<ol>
<li>本地局部变量必须用static关键字修饰</li>
</ol>
</li>
<li>全局变量<ol>
<li>全局变量必须以g开头</li>
</ol>
</li>
<li>函数变量<ol>
<li>变量必须以_开头</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static uint8_t SafeLaserSet = 0;</span><br><span class="line">uint8_t gSafeLaserSet = 0;</span><br><span class="line">static uint8_t _SafeLaserSet = 0;</span><br></pre></td></tr></table></figure>

<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h4><ol>
<li>函数名必须能够自注释，必要是需要增加注释写明意图</li>
<li>内部函数必须使用static定义，命名可以不加模块名</li>
<li>外部函数<ol>
<li>必须在头文件中声明，</li>
<li>命名时必须带模块名，</li>
<li>必须给出带注释，并写明函数意图，参数说明，返回值</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static uint_t SAFE_LASER_setLaseShield(uint8_t _EN);</span><br><span class="line">void SAFE_LASER_setLaseShield(uint8_t _EN);</span><br></pre></td></tr></table></figure>

<h4 id="7-文件"><a href="#7-文件" class="headerlink" title="7. 文件"></a>7. 文件</h4><ol>
<li><p>头文件</p>
<ol>
<li><p>命名规则模块名+功能，小写，例如os_task.h</p>
</li>
<li><p>格式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OS_TASK_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __OS_TASK_H__</span></span><br><span class="line"></span><br><span class="line">....<span class="comment">/* 开放的宏定义 */</span></span><br><span class="line">....<span class="comment">/* 开放的全局变量声明 */</span></span><br><span class="line">....<span class="comment">/* 开放的函数声明 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>源文件</p>
<ol>
<li><p>命名规则模块名+功能，小写，例如os_task.c</p>
</li>
<li><p>格式如下，举例只为说明源文件中，各元素的顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;- <span class="number">1</span> - 引用头文件 -&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;os_task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">2</span> - 定义本文件用到的宏 -&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASK_SWITCH_INTERVAL 10 	<span class="comment">/* 单位ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> StackSize_t ； 	 	<span class="comment">/* 仅用于堆栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">3</span> - 本地变量 -&gt;</span><br><span class="line"><span class="keyword">static</span> StackSize_t *TopStack = <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">4</span> - 开放的全局变量 -&gt;</span><br><span class="line"><span class="keyword">uint32_t</span> gOsTaskEventBitMap = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">5</span> - 本地函数，仅在本文件使用 -&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TASK_TaskSwitch</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;- <span class="number">6</span> - 开放的函数 -&gt;</span><br><span class="line"><span class="keyword">void</span> OS_TASK_TaskDelay(<span class="keyword">uint16_t</span> _ms)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">return</span>；   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="8-约定俗成简写"><a href="#8-约定俗成简写" class="headerlink" title="8.约定俗成简写"></a>8.约定俗成简写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addition           	add           		加</span><br><span class="line">subtraction 		sub              	减</span><br><span class="line">multiplication 		mul           		乘法</span><br><span class="line">division          	div             	除法</span><br><span class="line">answer            	ans           		响应、回答</span><br><span class="line">array               arr             	数组、集合</span><br><span class="line">average          	avg            		平均</span><br><span class="line">buffer              buf或buff   			缓冲区</span><br><span class="line">capture           	cap或capt  			捕获</span><br><span class="line">check              	chk            		检查</span><br><span class="line">count              	cnt            		计数器</span><br><span class="line">column            	col            		列</span><br><span class="line">control            	ctrl            	控制</span><br><span class="line">decode           	dec           		解码、译码</span><br><span class="line">define             	def           		定义</span><br><span class="line">delete             	del           		删除</span><br><span class="line">destination     	dst或dest 			目的</span><br><span class="line">display           	disp          		显示</span><br><span class="line">encode          	enc            		编码</span><br><span class="line">environment  		env           		环境</span><br><span class="line">error              	err             	错误</span><br><span class="line">float               flt              	浮动、浮点</span><br><span class="line">frequency      		freq           		频率</span><br><span class="line">header          	hdr            		开始、开头</span><br><span class="line">index             	idx            		索引、指示、</span><br><span class="line">image            	img           		影像、镜像</span><br><span class="line">increment      		inc            		增加、增量</span><br><span class="line">initalize         	init            	初始化</span><br><span class="line">iteration        	itr             	循环、迭代</span><br><span class="line">length           	len            		长度</span><br><span class="line">memory        		mem          		内存</span><br><span class="line">middle           	mid           		中值</span><br><span class="line">make             	mk            		制造、形成</span><br><span class="line">message       		msg          		消息</span><br><span class="line">number         		num         	 	数量、编号</span><br><span class="line">operand        		opnd        		操作数</span><br><span class="line">optimization  		opt           		最优</span><br><span class="line">operator       		optr          		操作</span><br><span class="line">packet          	pkt            		消息包</span><br><span class="line">positon         	pos           		位置</span><br><span class="line">previous       		pre或prev  			以前的</span><br><span class="line">pointer         	ptr             	指针</span><br><span class="line">record          	rcd             	记录</span><br><span class="line">receive         	recv           		收到、接收</span><br><span class="line">result           	res             	结果</span><br><span class="line">return          	ret              	返回</span><br><span class="line">source         		src              	源头</span><br><span class="line">stack           	stk              	栈</span><br><span class="line">string          	str               	字符串</span><br><span class="line">table           	tab              	表</span><br><span class="line">temporary   		tmp或temp  			临时</span><br><span class="line">total            	tot               	全部的</span><br><span class="line">time stamp  		ts                	时间戳</span><br><span class="line">value           	val              	值</span><br></pre></td></tr></table></figure>

<p>有互斥意义的变量或者动作相反的函数应该是用互斥词组命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add/remove  	begin/end 		create/destroy 		insert/delete </span><br><span class="line">first/last 		get/release 	increment/decrement put/get 		add/delete</span><br><span class="line">lock/unlock 	open/close 		min/max 			old/new </span><br><span class="line">start/stop 		next/previous 	source/target 		show/hide </span><br><span class="line">send/receive 	source/destination 					copy/paste 		up/down</span><br></pre></td></tr></table></figure>

<h4 id="9-模块"><a href="#9-模块" class="headerlink" title="9. 模块"></a>9. 模块</h4><ol>
<li><p>模块必须具有封装性，且对外提供尽量少的必要接口，接口必须提供详细的注释描述</p>
</li>
<li><p>模块的组织形式可以是文件夹形式，也可以是文件形式</p>
</li>
<li><p>文件都以小写命名</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">    ├── src <span class="comment">/* 应用层代码 */</span></span><br><span class="line">    │   ├── main.c <span class="comment">/* 应用入口 */</span></span><br><span class="line">    │   ├── test.c</span><br><span class="line">    │   ├── test1.c  </span><br><span class="line">    ├── include <span class="comment">/* 设备驱动代码 */</span></span><br><span class="line">    │   ├── test.h</span><br><span class="line">    │   ├── test1.h </span><br><span class="line">    ├── debug <span class="comment">/* 芯片厂家提供的库代码 */</span></span><br><span class="line">    │   ├── MakeFile</span><br><span class="line">    │   ├── CMake</span><br><span class="line">    │   └── main</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux程序开机启动与后台启动</title>
    <url>/blog/2021/12/27/%E8%87%AA%E5%90%AF%E5%8A%A8_%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_36328643/article/details/89359724?ops_request_misc=%7B%22request_id%22:%22164058731416780265430164%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164058731416780265430164&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-89359724.pc_search_insert_es_download&utm_term=ubuntu18%E8%87%AA%E5%90%AF%E5%8A%A8&spm=1018.2226.3001.4187">(91条消息) Ubuntu18.04 开机自启动脚本_cxh的博客-CSDN博客_ubuntu18.04开机自启动脚本</a> </p>
<p> <a href="https://blog.csdn.net/qq_42353939/article/details/89242941?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.nonecase">(91条消息) linux如何后台运行服务_六指黑侠i的博客-CSDN博客_linux 后台运行</a> </p>
<h1 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rc-local.service生成</span></span><br><span class="line">sudo nano /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionPathExists=/etc/rc.local  #脚本文件位置</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start  #配置的脚本文件rc.local为start</span><br><span class="line">TimeoutSec=0    </span><br><span class="line">StandardOutput=tty  #标准输出</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99  #优先级，当有多个开机启动文件时可以设置不同的值</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成rc.local</span></span><br><span class="line">sudo nano /etc/rc.local</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh -e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># rc.local</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Make sure that the script will <span class="string">&quot;exit 0&quot;</span> on success or any other</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> value on error.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># In order to enable or disable this script just change the execution</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># By default this script does nothing.</span></span></span><br><span class="line">echo &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.log</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给rc.local加上权限，启用服务，启动服务并检查状态</span></span><br><span class="line">sudo chmod +x /etc/rc.local</span><br><span class="line">sudo systemctl enable rc-local</span><br><span class="line">sudo systemctl start rc-local.service</span><br><span class="line">sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure>

<h1 id="不挂断后台启动"><a href="#不挂断后台启动" class="headerlink" title="不挂断后台启动"></a>不挂断后台启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>

<h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></span><br><span class="line">jobs -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死进程</span></span><br><span class="line">sudo kill 7889</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯滤波学习笔记</title>
    <url>/blog/2022/02/24/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p>  <a href="https://space.bilibili.com/287989852/video?tid=0&page=2&keyword=&order=pubdate">忠厚老实的老王的个人空间_哔哩哔哩_bilibili</a> </p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随机过程:(无法做随机试验)</span><br><span class="line"></span><br><span class="line">大数定律:(1,可重复2,可能已知3,结果不可预知)</span><br><span class="line">例如:股票  (不可重复 - 时间)</span><br><span class="line"></span><br><span class="line">主观概率:(贝叶斯学派)</span><br><span class="line">引入外部观测(证据,信息)</span><br><span class="line"></span><br><span class="line">主观概率(先验概率)-------外部观测-----&gt;相对客观概率(后验概率)</span><br><span class="line"></span><br><span class="line">&lt;概率机器人&gt; pdf与cdf 概率密度,概率分布混用</span><br><span class="line"></span><br><span class="line">X,Y 随机变量</span><br><span class="line">x,y 随机变量取值,代表可能结果</span><br><span class="line"></span><br><span class="line">测温: 今天多少度?</span><br><span class="line"></span><br><span class="line">先验概率分布 : </span><br><span class="line">&#123;</span><br><span class="line">	P(T=10) = 0.8</span><br><span class="line">	P(T=11) = 0.2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">温度计: Tm = 10.3</span><br><span class="line">			 因   果         果  因</span><br><span class="line">后验概率:  P(状态|观测) = nP(观测|状态)P(状态) pdf(概率密度)</span><br><span class="line">由果推测因	   后验         似然概率	   先验</span><br><span class="line"></span><br><span class="line">似然概率: 表示观测精度,误差(最有可能)</span><br><span class="line">由因推测果</span><br><span class="line"></span><br><span class="line">n = 求积分(1/(似然*先验))</span><br><span class="line"></span><br><span class="line">所以:P(T=10|Tm=10.3)=P(Tm=10.3|T=10)*P(T=10)/P(Tm=10.3)</span><br><span class="line">这里的1/P(Tm=10.3)=n 为常数</span><br><span class="line"></span><br><span class="line">推导:</span><br><span class="line">由于全概率公式:</span><br><span class="line">P(Tm=10.3) = P(T=10|Tm=10.3)*P(T=10)+P(T=11|Tm=10.3)*P(T=11)</span><br><span class="line">这里的似然是仪器误差是确定的,预测误差也是确定的,因此P(Tm=10.3)是一个常数</span><br><span class="line"></span><br><span class="line">&lt;概率论与数理统计&gt;</span><br><span class="line"></span><br><span class="line">连续随机变量下得贝叶斯公式 </span><br><span class="line"></span><br><span class="line">f(状态|观测) = nf(观测|状态)f(状态)   cdf(概率分布)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例:满足正太分布计算温度</span><br><span class="line">预测温度(10,1^2) 观测温度(9,0.2^2) 后验(9.0385,0.038^2)</span><br><span class="line"></span><br><span class="line">按照公式:f(状态|观测) = nf(观测|状态)*f(状态)</span><br><span class="line"></span><br><span class="line">先验概率:f(状态) = 1/(sqrt(2*pi)*1)*exp(-(x-10)^2/(2*1^2))</span><br><span class="line">似然概率:f(观测|状态) = 1/(sqrt(2*pi)*0.2)*exp(-(x-9)^2/(2*0.2^2))</span><br><span class="line">后验概率:f(状态|观测) = n*1/(2*pi*0.2)*exp(-0.5*((x-10)^2+((x-9)/2)^2))</span><br><span class="line">1/n = (积分)1/(2*pi*0.2)*exp(-0.5*((x-10)^2+((x-9)/2)^2))dx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更简单的方式,直接套用公式:后验N(Ex,Dx),这里使用s代替sigma u1代表预测值,u2代表测量值</span><br><span class="line">Ex = s2^2/(s1^2+s2^2)*u2+s1^2/(s1^2+s2^2)*u1</span><br><span class="line">Dx = s1^2*s2^2/(s1^2+s2^2)</span><br><span class="line"></span><br><span class="line">贝叶斯滤波完整算法:</span><br><span class="line"> - 设定初值</span><br><span class="line"> 	- x0pdf f0(x)</span><br><span class="line"> - 预测步</span><br><span class="line">	- fk_minus = (积分)fQk[x-f(v)]*fk-1_plus(v)dv</span><br><span class="line"> - 更新步</span><br><span class="line"> 	- fk_plus = nk*fRk[yk-h(x)]*fk_minus(x)</span><br><span class="line"> 	- nk = ((积分)(fRk[yk-h(x)])*fk_minus(x)dx)^-1</span><br><span class="line"> 	</span><br><span class="line">由于算法中由三个无穷积分,大多数情况下无解析解</span><br><span class="line">所以产生了很多骚操作</span><br><span class="line"></span><br><span class="line">解决方法:</span><br><span class="line">	1, 作假设:</span><br><span class="line">		- 假设f(xk-1),h(xk)为线性,Qk,Rk为正态分布:KF滤波</span><br><span class="line">		- f(-),h(-)为非线性,EKF,UKF</span><br><span class="line">	2,霸王硬上弓 - 直接对无穷积分做数值处理:</span><br><span class="line">		- 高斯积分(不常用)</span><br><span class="line">		- 蒙特卡洛积分(pf)</span><br><span class="line">		- 直方图滤波</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像源</title>
    <url>/blog/2021/12/12/%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>华为镜像源: <a href="https://mirrors.huaweicloud.com/home">https://mirrors.huaweicloud.com/home</a></p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符标签操作</title>
    <url>/blog/2022/01/03/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A0%87%E7%AD%BE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://blog.csdn.net/qq_38721302/article/details/82699934?ops_request_misc=%7B%22request_id%22:%22164121291816780261944453%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164121291816780261944453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-82699934.pc_search_insert_es_download&utm_term=c%E8%AF%AD%E8%A8%80%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">(94条消息) 嵌入式学习之C语言运算符标签操作_foolish的博客-CSDN博客</a> </p>
<h1 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=xxx； [<span class="number">0x12</span>] <span class="comment">//有一个int类型的指针，它的指针变量存储的地址为0x12。</span></span><br><span class="line">p=p+<span class="number">1</span>；<span class="comment">//指针加法,指向[0x13]</span></span><br></pre></td></tr></table></figure>

<h1 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符[]"></a>下标运算符[]</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(p+n)=p[n]; <span class="comment">//n为下标,相当于,数组下标</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>局部全局坐标转换</title>
    <url>/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="局部全局坐标转换"><a href="#局部全局坐标转换" class="headerlink" title="局部全局坐标转换"></a>局部全局坐标转换</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="https://i.loli.net/2021/10/29/QfTymrLqs7AG6a2.png" alt="image-20211029181117606.png"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h2><p><img src="https://i.loli.net/2021/10/29/7ht1yaPc3E26zBF.png" alt="image-20211029180943040.png"></p>
<h2 id="ROS-中里程计的计算代码理解"><a href="#ROS-中里程计的计算代码理解" class="headerlink" title="ROS 中里程计的计算代码理解"></a>ROS 中里程计的计算代码理解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dt = (current_time - last_time).<span class="built_in">toSec</span>();</span><br><span class="line"><span class="keyword">double</span> delta_x = (vx * <span class="built_in">cos</span>(th) - vy * <span class="built_in">sin</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_y = (vx * <span class="built_in">sin</span>(th) + vy * <span class="built_in">cos</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_th = vth * dt;</span><br><span class="line"></span><br><span class="line">x += delta_x;</span><br><span class="line">y += delta_y;</span><br><span class="line">th += delta_th;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>常用好用的论文网站</title>
    <url>/blog/2022/01/15/%E8%AE%BA%E6%96%87%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p> <a href="https://scholar.google.com/scholar?hl=zh-CN&as_sdt=0,5&q=Pure+pursuit+optimization+algorithm&oq=">Google 学术搜索</a> </p>
<p> <a href="https://sci-hub.mksa.top/">Sci-Hub (mksa.top)</a> </p>
<p> <a href="https://site.sciping.com/">科塔学术导航 - 最专业、准确、及时和全面的科研与学术资源导航平台 (sciping.com)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这里的几个网站中科塔网很全面,可以配合sci_hub使用,极易食用.</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab导入</title>
    <url>/blog/2022/02/24/matlab%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p>  <a href="https://blog.csdn.net/a1b2c3d4123456/article/details/45953087?ops_request_misc=%7B%22request_id%22:%22164570294216780261995670%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164570294216780261995670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-45953087.nonecase&utm_term=matlab%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE&spm=1018.2226.3001.4450">(110条消息) matlab 数据导入_哆啦A梦的博客-CSDN博客_matlab导入数据</a> </p>
<p> <a href="https://blog.csdn.net/OOFFrankDura/article/details/85046359?ops_request_misc=%7B%22request_id%22:%22164602516616780366543724%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164602516616780366543724&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-85046359.pc_search_insert_es_download&utm_term=matlab%E8%AF%BB%E5%8F%96pgm&spm=1018.2226.3001.4187">(110条消息) MATLAB-读取pgm图像_FrankDura的博客-CSDN博客_matlab读取pgm</a> </p>
<p> <a href="https://blog.csdn.net/freshair9/article/details/7078514?ops_request_misc=&request_id=&biz_id=102&utm_term=matlab%E8%AF%BB%E5%8F%96pgm&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-7-7078514.nonecase&spm=1018.2226.3001.4450">(110条消息) matlab读写pgm文件_freshair9的专栏-CSDN博客_matlab打开pgm文件</a> </p>
<h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Load the file to the matrix, M :</span></span><br><span class="line">M = load(<span class="string">&#x27;sample_file.txt&#x27;</span>)  </span><br></pre></td></tr></table></figure>

<h1 id="matlab读取pgm文件"><a href="#matlab读取pgm文件" class="headerlink" title="matlab读取pgm文件"></a>matlab读取pgm文件</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc,clear,close all;</span><br><span class="line">im1 = imread(‘<span class="number">1.</span>pgm’);</span><br><span class="line">imshow(im1)</span><br><span class="line"><span class="comment">% 可知im1时一个二维数组,254表白色,0表黑色,205表未知</span></span><br></pre></td></tr></table></figure>

<p>另一种方式</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function disp_ pgm( pgm_image_name)</span></span><br><span class="line"><span class="comment">%不支持文件中有注释</span></span><br><span class="line">pgm_image_name=<span class="string">&#x27;tmp. pgm&#x27;</span>;</span><br><span class="line">f = fopen( pgm_image_name,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> f == <span class="number">-1</span></span><br><span class="line">    error([<span class="string">&#x27;Could not open file &#x27;</span>, pgm_image_name]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[imgsize, num]=fscanf(f, <span class="string">&#x27;P5\n%d\n%d\n255\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> num~=<span class="number">2</span>,error(<span class="string">&#x27;error num&#x27;</span>);<span class="keyword">end</span></span><br><span class="line">image=[];</span><br><span class="line"><span class="keyword">for</span> h=<span class="number">1</span>:imgsize(<span class="number">2</span>)</span><br><span class="line">    image=[image fread(f,imgsize(<span class="number">1</span>),<span class="string">&#x27;uint8&#x27;</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">image=image.&#x27;;</span><br><span class="line">fclose(f);</span><br><span class="line">imshow(image);</span><br><span class="line">写文件</span><br><span class="line"><span class="comment">% Load image</span></span><br><span class="line"><span class="comment">% image = imread(imageFile);</span></span><br><span class="line"><span class="comment">% If you have the Image Processing Toolbox, you can uncomment the following</span></span><br><span class="line"><span class="comment">%   lines to allow input of color images, which will be converted to grayscale.</span></span><br><span class="line"><span class="keyword">if</span> isrgb(image)</span><br><span class="line">   image = rgb2gray(image);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[rows, cols] = <span class="built_in">size</span>(image);</span><br><span class="line"><span class="comment">% Convert into PGM imagefile, readable by &quot;keypoints&quot; executable</span></span><br><span class="line">f = fopen(<span class="string">&#x27;tmp. pgm&#x27;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> f == <span class="number">-1</span></span><br><span class="line">    error(<span class="string">&#x27;Could not create file tmp. pgm.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(f, <span class="string">&#x27;P5\n%d\n%d\n255\n&#x27;</span>, cols, rows);</span><br><span class="line">fwrite(f, image&#x27;, <span class="string">&#x27;uint8&#x27;</span>);</span><br><span class="line">fclose(f);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab正态分布常用函数</title>
    <url>/blog/2022/03/01/matlab%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>  <a href="https://blog.csdn.net/shanchuan2012/article/details/52901758?ops_request_misc=%7B%22request_id%22:%22164603310116780265432441%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164603310116780265432441&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-52901758.pc_search_insert_es_download&utm_term=normrnd&spm=1018.2226.3001.4187">(110条消息) 【Matlab】正态分布常用函数normpdf_normcdf_norminv_normrnd_normfit_Find your love-CSDN博客_matlab正态分布函数</a> </p>
<h1 id="normrnd"><a href="#normrnd" class="headerlink" title="normrnd"></a>normrnd</h1><p>用法</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">R = normrnd(mu,sigma)         <span class="comment">% 生成一个数</span></span><br><span class="line">R = normrnd(mu,sigma,m,n,...) <span class="comment">% 生成m*n列向量</span></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; normrnd(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">1.4122</span></span><br><span class="line">&gt;&gt; normrnd(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">0.0226</span>    <span class="number">0.9199</span>   <span class="number">-0.7777</span></span><br><span class="line">   <span class="number">-0.0479</span>    <span class="number">0.1498</span>    <span class="number">0.5667</span></span><br><span class="line">    <span class="number">1.7013</span>    <span class="number">1.4049</span>   <span class="number">-1.3826</span></span><br><span class="line">   <span class="number">-0.5097</span>    <span class="number">1.0341</span>    <span class="number">0.2445</span></span><br><span class="line">   <span class="number">-0.0029</span>    <span class="number">0.2916</span>    <span class="number">0.8084</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>通过项目学opencv</title>
    <url>/blog/2022/02/21/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E5%AD%A6opencv/</url>
    <content><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p> <a href="https://github.com/sudrag/line_follower_turtlebot">sudrag/line_follower_turtlebot: A repo created to simulate a line following turtlebot in Gazebo environment using ROS (github.com)</a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实际上是通过ros的一个巡线项目简单学习ros+c++中opencv的使用.</p>
<h1 id="lesson1-调用视频数据cv-bridge"><a href="#lesson1-调用视频数据cv-bridge" class="headerlink" title="lesson1[调用视频数据cv_bridge]"></a>lesson1[调用视频数据cv_bridge]</h1><h2 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址:"></a>参考网址:</h2><p> <a href="https://blog.csdn.net/weixin_40863346/article/details/82216462">(109条消息) ROS学习笔记–cv_bridge_喵喵三三的博客-CSDN博客_cv_bridge</a> </p>
<p> <a href="http://wiki.ros.org/cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages">cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages - ROS Wiki</a> </p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>src/line_follower_turtlebot/src/linedetect.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LineDetect::imageCallback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">  cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 总是复制，返回一个可变的CvImage</span></span><br><span class="line">    cv_ptr = cv_bridge::<span class="built_in">toCvCopy</span>(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    <span class="comment">// 将转换的数据存放到opencv矩阵格式的img中</span></span><br><span class="line">    img = cv_ptr-&gt;image;</span><br><span class="line">    <span class="comment">// cv::imshow(&quot;Image window&quot;, img);</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (cv_bridge::Exception&amp; e) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;</span>, msg-&gt;encoding.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> CvBridge提供几种用于转换为CvImage的函数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Case 1: 用于ros订阅复制使用</span></span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> std::string&amp; encoding = std::string())</span></span>;</span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> std::string&amp; encoding = std::string())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Case 2: 用于ros订阅共享使用</span></span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> std::string&amp; encoding = std::string())</span></span>;</span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> boost::shared_ptr&lt;<span class="keyword">void</span> <span class="keyword">const</span>&gt;&amp; tracked_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> std::string&amp; encoding = std::string())</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="完整简单实例"><a href="#完整简单实例" class="headerlink" title="完整简单实例"></a>完整简单实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;image_transport/image_transport.h&gt;</span><br><span class="line">#include &lt;cv_bridge/cv_bridge.h&gt;</span><br><span class="line">#include &lt;sensor_msgs/image_encodings.h&gt;</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line"> </span><br><span class="line">static const std::string OPENCV_WINDOW = &quot;Image window&quot;;</span><br><span class="line"> </span><br><span class="line">class ImageConverter</span><br><span class="line">&#123;</span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  image_transport::ImageTransport it_;</span><br><span class="line">  image_transport::Subscriber image_sub_;</span><br><span class="line">  image_transport::Publisher image_pub_;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">  ImageConverter()</span><br><span class="line">    : it_(nh_)</span><br><span class="line">  &#123;</span><br><span class="line">    // 订阅输入视频，发布输出视频</span><br><span class="line">    image_sub_ = it_.subscribe(&quot;/camera/image_raw&quot;, 1,</span><br><span class="line">      &amp;ImageConverter::imageCb, this);</span><br><span class="line">    image_pub_ = it_.advertise(&quot;/image_converter/output_video&quot;, 1);</span><br><span class="line"> 	// 创建OPENCV_WINDOWS窗口</span><br><span class="line">    cv::namedWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ~ImageConverter()</span><br><span class="line">  &#123;</span><br><span class="line">  	// 销毁OPENCV_WINDOWS窗口</span><br><span class="line">    cv::destroyWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  void imageCb(const sensor_msgs::ImageConstPtr&amp; msg)</span><br><span class="line">  &#123;</span><br><span class="line">    cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">    	// 转换图像到cv_ptr用于之后opencv的使用</span><br><span class="line">      	cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      	ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());</span><br><span class="line">      	return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 在视频流上画个圈</span><br><span class="line">    if (cv_ptr-&gt;image.rows &gt; 60 &amp;&amp; cv_ptr-&gt;image.cols &gt; 60)</span><br><span class="line">      cv::circle(cv_ptr-&gt;image, cv::Point(50, 50), 10, CV_RGB(255,0,0));</span><br><span class="line"> </span><br><span class="line">    // 更新并显示GUI界面</span><br><span class="line">    cv::imshow(OPENCV_WINDOW, cv_ptr-&gt;image);</span><br><span class="line">    cv::waitKey(3);</span><br><span class="line"> </span><br><span class="line">    // 输出修改后的视频流</span><br><span class="line">    image_pub_.publish(cv_ptr-&gt;toImageMsg());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">  // 初始化image_converter节点</span><br><span class="line">  ros::init(argc, argv, &quot;image_converter&quot;);</span><br><span class="line">  // 实例化类</span><br><span class="line">  ImageConverter ic;</span><br><span class="line">  ros::spin();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lesson2-对读取数据进行初步处理"><a href="#lesson2-对读取数据进行初步处理" class="headerlink" title="lesson2[对读取数据进行初步处理]"></a>lesson2[对读取数据进行初步处理]</h1><h2 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址:"></a>参考网址:</h2><p> <a href="https://blog.csdn.net/zhaitianbao/article/details/117784002?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.queryctrv4&spm=1001.2101.3001.4242.1&utm_relevant_index=3">(109条消息) OpenCV-高斯滤波cv::GaussianBlur_翟天保的博客-CSDN博客</a> </p>
<h2 id="高斯滤波处理"><a href="#高斯滤波处理" class="headerlink" title="高斯滤波处理"></a>高斯滤波处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianBlur</span><span class="params">( InputArray src, OutputArray dst, Size ksize,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">double</span> sigmaX, <span class="keyword">double</span> sigmaY = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int</span> borderType = BORDER_DEFAULT )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>InputArray类型的src，输入图像，如Mat类型。</li>
<li>OutputArray类型的dst，输出图像。</li>
<li>Size类型的ksize，高斯内核的大小。</li>
<li>double类型的sigmaX，高斯核函数在X方向的标准偏差。</li>
<li>double类型的sigmaY，高斯核函数在Y方向的标准偏差。</li>
<li>int类型的borderType，推断图像边缘像素的边界模式。</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">LineDetect::Gauss</span><span class="params">(cv::Mat input)</span> </span>&#123;</span><br><span class="line">  cv::Mat output;</span><br><span class="line"><span class="comment">// 使用高斯滤波对图像进行滤波</span></span><br><span class="line">  cv::<span class="built_in">GaussianBlur</span>(input, output, cv::<span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="comment">// cv::imshow(&quot;Gaussian&quot;, output);</span></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lesson3-实现巡线检测"><a href="#lesson3-实现巡线检测" class="headerlink" title="lesson3[实现巡线检测]"></a>lesson3[实现巡线检测]</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>转换颜色空间为hsv</li>
<li>检测判断黄色,并找出路线轮廓</li>
<li>计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的,并画出矩形</li>
<li>找出图像质心</li>
<li>判断质心在图像中间的左侧还是右侧,由此控制车体运动</li>
</ul>
<h2 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址"></a>参考网址</h2><p> <a href="https://blog.csdn.net/guduruyu/article/details/68941554?ops_request_misc=%7B%22request_id%22:%22164544832016780269849625%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164544832016780269849625&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-68941554.pc_search_insert_es_download&utm_term=cv::cvtColor&spm=1018.2226.3001.4187">(109条消息) 【OpenCV3】颜色空间转换——cv::cvtColor()详解_guduruyu的专栏-CSDN博客_cv.cvtcolor</a> </p>
<h2 id="具体样例"><a href="#具体样例" class="headerlink" title="具体样例"></a>具体样例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LineDetect::colorthresh</span><span class="params">(cv::Mat input)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initializaing variables</span></span><br><span class="line">  cv::Size s = input.<span class="built_in">size</span>();</span><br><span class="line">  std::vector&lt;std::vector&lt;cv::Point&gt;&gt; v;</span><br><span class="line">  <span class="keyword">auto</span> w = s.width;</span><br><span class="line">  <span class="keyword">auto</span> h = s.height;</span><br><span class="line">  <span class="keyword">auto</span> c_x = <span class="number">0.0</span>;</span><br><span class="line">  <span class="comment">// Detect all objects within the HSV range</span></span><br><span class="line">  <span class="comment">// 颜色空间转换 输入,输出,映射码</span></span><br><span class="line">  cv::<span class="built_in">cvtColor</span>(input, LineDetect::img_hsv, CV_BGR2HSV);</span><br><span class="line">  LineDetect::LowerYellow = &#123;<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">  LineDetect::UpperYellow = &#123;<span class="number">30</span>, <span class="number">255</span>, <span class="number">255</span>&#125;;</span><br><span class="line">  <span class="comment">// 检测黄线,判断颜色在&#123;20, 100, 100&#125;与&#123;30, 255, 255&#125;之间</span></span><br><span class="line">  <span class="comment">// 输出的img_mask为二值图像</span></span><br><span class="line">  cv::<span class="built_in">inRange</span>(LineDetect::img_hsv, LowerYellow,UpperYellow, LineDetect::img_mask);</span><br><span class="line">  <span class="comment">// cv::imshow(&quot;mask&quot;, LineDetect::img_mask);</span></span><br><span class="line">  <span class="comment">// 切掉图像上半部分</span></span><br><span class="line">  <span class="built_in">img_mask</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, w, <span class="number">0.8</span>*h)) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// cv::imshow(&quot;mask&quot;, LineDetect::img_mask);</span></span><br><span class="line">  <span class="comment">// Find contours for better visualization</span></span><br><span class="line">  <span class="comment">// 找到可视化轮廓</span></span><br><span class="line">  cv::<span class="built_in">findContours</span>(LineDetect::img_mask, v, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);</span><br><span class="line">  <span class="comment">// If contours exist add a bounding,Choosing contours with maximum area</span></span><br><span class="line">  <span class="comment">// 如果轮廓存在,则添加边界,选择包含最大面积的轮廓</span></span><br><span class="line">  <span class="keyword">if</span> (v.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// printf(&quot;%ld\n&quot;,v.size());</span></span><br><span class="line">  <span class="comment">// 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的</span></span><br><span class="line">  <span class="comment">// cv::Rect r = cv::boundingRect(v[0]);</span></span><br><span class="line">  <span class="comment">// c_x = r.x + r.width / 2;</span></span><br><span class="line">  <span class="comment">// // 把轮廓用方框框出来</span></span><br><span class="line">  <span class="comment">// cv::rectangle(LineDetect::img_mask, r, cv::Scalar(255, 255, 255), 2);</span></span><br><span class="line">  <span class="comment">// cv::imshow(&quot;mask&quot;, LineDetect::img_mask);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// v.size()表示轮廓的个数,v[count].size()表示轮廓面积</span></span><br><span class="line">  <span class="keyword">while</span> (count &lt; v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (area &lt; v[count].<span class="built_in">size</span>()) &#123;</span><br><span class="line">       idx = count;</span><br><span class="line">       area = v[count].<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">//  printf(&quot;%ld\n&quot;,v[count].size());</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的</span></span><br><span class="line">  <span class="comment">// rect: 格式为(x,y,w,h)</span></span><br><span class="line">  cv::Rect rect = <span class="built_in">boundingRect</span>(v[idx]);</span><br><span class="line">  cv::Point pt1, pt2, pt3;</span><br><span class="line">  <span class="comment">// 坐上角坐标</span></span><br><span class="line">  pt1.x = rect.x;</span><br><span class="line">  pt1.y = rect.y;</span><br><span class="line">  <span class="comment">// 右下角坐标</span></span><br><span class="line">  pt2.x = rect.x + rect.width;</span><br><span class="line">  pt2.y = rect.y + rect.height;</span><br><span class="line">  <span class="comment">// 向右向上移动5个像素</span></span><br><span class="line">  pt3.x = pt1.x+<span class="number">5</span>;</span><br><span class="line">  pt3.y = pt1.y<span class="number">-5</span>;</span><br><span class="line">  <span class="comment">// 画出矩形</span></span><br><span class="line">  cv::<span class="built_in">rectangle</span>(input, pt1, pt2, <span class="built_in">CV_RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 画出文本框</span></span><br><span class="line">  cv::<span class="built_in">putText</span>(input, <span class="string">&quot;Line Detected&quot;</span>, pt3,</span><br><span class="line">    CV_FONT_HERSHEY_COMPLEX, <span class="number">1</span>, <span class="built_in">CV_RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Mask image to limit the future turns affecting the output</span></span><br><span class="line">  <span class="comment">// 将左右两边0.3倍的图像清除</span></span><br><span class="line">  <span class="built_in">img_mask</span>(cv::<span class="built_in">Rect</span>(<span class="number">0.7</span>*w, <span class="number">0</span>, <span class="number">0.3</span>*w, h)) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">img_mask</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>*w, h)) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// cv::imshow(&quot;mask&quot;, LineDetect::img_mask);</span></span><br><span class="line">  <span class="comment">// Perform centroid detection of line</span></span><br><span class="line">  <span class="comment">// 质心检测</span></span><br><span class="line">  cv::Moments M = cv::<span class="built_in">moments</span>(LineDetect::img_mask);</span><br><span class="line">  <span class="keyword">if</span> (M.m00 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Calculating centroid</span></span><br><span class="line">    <span class="comment">// 计算质心坐标</span></span><br><span class="line">    <span class="function">cv::Point <span class="title">p1</span><span class="params">(M.m10/M.m00, M.m01/M.m00)</span></span>;</span><br><span class="line">    <span class="comment">// 画出质心</span></span><br><span class="line">    cv::<span class="built_in">circle</span>(LineDetect::img_mask, p1, <span class="number">10</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测的质心的横坐标</span></span><br><span class="line">  c_x = M.m10/M.m00;</span><br><span class="line">  <span class="comment">// Tolerance to chooise directions</span></span><br><span class="line">  <span class="comment">// 方向宽容度</span></span><br><span class="line">  <span class="keyword">auto</span> tol = <span class="number">15</span>;</span><br><span class="line">  <span class="comment">// 返回灰度值不为0的像素数，可用来判断图像是否全黑。若全黑，则返回0</span></span><br><span class="line">  <span class="keyword">auto</span> count = cv::<span class="built_in">countNonZero</span>(img_mask);</span><br><span class="line">  <span class="comment">// Turn left if centroid is to the left of the image center minus tolerance</span></span><br><span class="line">  <span class="comment">// Turn right if centroid is to the right of the image center plus tolerance</span></span><br><span class="line">  <span class="comment">// Go straight if centroid is near image center</span></span><br><span class="line">  <span class="keyword">if</span> (c_x &lt; w/<span class="number">2</span>-tol) &#123;</span><br><span class="line">    LineDetect::dir = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c_x &gt; w/<span class="number">2</span>+tol) &#123;</span><br><span class="line">    LineDetect::dir = <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LineDetect::dir = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Search if no line detected</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    LineDetect::dir = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Output images viewed by the turtlebot</span></span><br><span class="line">  cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Turtlebot View&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Turtlebot View&quot;</span>, input);</span><br><span class="line">  <span class="keyword">return</span> LineDetect::dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	cv::InputArray src, <span class="comment">// 输入序列</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArray dst, <span class="comment">// 输出序列</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> code, <span class="comment">// 颜色映射码</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> dstCn = <span class="number">0</span> <span class="comment">// 输出的通道数 (0=&#x27;automatic&#x27;)</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="程序样例"><a href="#程序样例" class="headerlink" title="程序样例"></a>程序样例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色空间转换 输入,输出,映射吗</span></span><br><span class="line">  cv::<span class="built_in">cvtColor</span>(input, LineDetect::img_hsv, CV_BGR2HSV);</span><br></pre></td></tr></table></figure>

<h2 id="检测黄线"><a href="#检测黄线" class="headerlink" title="检测黄线"></a>检测黄线</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型（C++）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inRange</span><span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="程序样例-1"><a href="#程序样例-1" class="headerlink" title="程序样例"></a>程序样例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  cv::Mat img_hsv;  </span><br><span class="line">  cv::Scalar LowerYellow;</span><br><span class="line">  cv::Scalar UpperYellow;</span><br><span class="line">  LineDetect::LowerYellow = &#123;<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">  LineDetect::UpperYellow = &#123;<span class="number">30</span>, <span class="number">255</span>, <span class="number">255</span>&#125;;</span><br><span class="line"><span class="comment">// 检测黄线,判断颜色在&#123;20, 100, 100&#125;与&#123;30, 255, 255&#125;之间</span></span><br><span class="line">  cv::<span class="built_in">inRange</span>(LineDetect::img_hsv, LowerYellow,UpperYellow, LineDetect::img_mask);</span><br></pre></td></tr></table></figure>

<h2 id="找出可视化轮廓"><a href="#找出可视化轮廓" class="headerlink" title="找出可视化轮廓"></a>找出可视化轮廓</h2><h3 id="参考网址-4"><a href="#参考网址-4" class="headerlink" title="参考网址:"></a>参考网址:</h3><p> <a href="https://blog.csdn.net/Ibelievesunshine/article/details/105208431?ops_request_misc=%7B%22request_id%22:%22164544925616780366547214%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164544925616780366547214&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-105208431.pc_search_insert_es_download&utm_term=cv::findContours(&spm=1018.2226.3001.4187">(109条消息) opencv cv.findContours 函数详解_Ibelievesunshine的博客-CSDN博客_cv.findcontours</a> </p>
<h3 id="两种调用方式"><a href="#两种调用方式" class="headerlink" title="两种调用方式:"></a>两种调用方式:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::findContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	cv::InputOutputArray image, <span class="comment">// 输入的8位单通道“二值”图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArrayOfArrays contours, <span class="comment">// 包含points的vectors的vector</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArray hierarchy, <span class="comment">// (可选) 拓扑信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> mode, <span class="comment">// 轮廓检索模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> method, <span class="comment">// 近似方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::Point offset = cv::Point() <span class="comment">// (可选) 所有点的偏移</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::findContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	cv::InputOutputArray image, <span class="comment">// 输入的8位单通道“二值”图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArrayOfArrays contours, <span class="comment">// 包含points的vectors的vector</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> mode, <span class="comment">// 轮廓检索模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> method, <span class="comment">// 近似方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::Point offset = cv::Point() <span class="comment">//  (可选) 所有点的偏移</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>cv::RETR_EXTERNAL：表示只提取最外面的轮廓；</p>
</li>
<li><p>cv::RETR_LIST：表示提取所有轮廓并将其放入列表；</p>
</li>
<li><p>cv::RETR_CCOMP:表示提取所有轮廓并将组织成一个两层结构，其中顶层轮廓是外部轮廓，第二层轮廓是“洞”的轮廓；</p>
</li>
<li><p>cv::RETR_TREE：表示提取所有轮廓并组织成轮廓嵌套的完整层级结构。</p>
</li>
</ul>
<h3 id="程序样例-2"><a href="#程序样例-2" class="headerlink" title="程序样例:"></a>程序样例:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv::findContours(LineDetect::img_mask, v, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);</span><br></pre></td></tr></table></figure>

<h2 id="计算轮廓的垂直边界最小矩形"><a href="#计算轮廓的垂直边界最小矩形" class="headerlink" title="计算轮廓的垂直边界最小矩形"></a>计算轮廓的垂直边界最小矩形</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的</span></span><br><span class="line"><span class="comment">// x, y, w, h = cv2.boundingRect(binary) x,y为左上角坐标</span></span><br><span class="line">  cv::Rect rect = <span class="built_in">boundingRect</span>(v[idx]);</span><br></pre></td></tr></table></figure>

<h2 id="找出质心"><a href="#找出质心" class="headerlink" title="找出质心"></a>找出质心</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">moments</span>(LineDetect::img_mask);</span><br><span class="line">(i,j)-&gt;(M.m10/M.m00, M.m01/M.m00)质心的图像坐标</span><br></pre></td></tr></table></figure>

<h3 id="参考网址-5"><a href="#参考网址-5" class="headerlink" title="参考网址"></a>参考网址</h3><p> <a href="https://blog.csdn.net/keith_bb/article/details/70197104">(109条消息) opencv学习(四十三)之图像的矩moments()_烟雨博客-CSDN博客_cv::moments</a> </p>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ros</tag>
      </tags>
  </entry>
</search>
