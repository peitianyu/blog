{"meta":{"title":"某飞行员的随笔","subtitle":"","description":"向西可剃度,向东可寻欢,但山野笨拙,我也笨拙.","author":"某飞行员","url":"https://peitianyu.github.io/blog","root":"/blog/"},"pages":[{"title":"简历","date":"2022-02-19T04:58:56.000Z","updated":"2022-02-19T06:50:40.289Z","comments":false,"path":"about/简历.html","permalink":"https://peitianyu.github.io/blog/about/%E7%AE%80%E5%8E%86.html","excerpt":"","text":"嵌入式经验2021年3月–至今 同日电控工程师3月 上海汇众项目简介:上海汇众是一家做汽车底盘的公司,需要agv将人工加工好的零件从工位上取走并取来空料架到工位上.采用是叉车加上磁条导航的方式实现 熟悉linux开发环境以及交叉编译等基础知识,包括但不限于linux文件传输,基础指令,网络配置,硬件配置,程序编译等 熟悉使用keil5对于mk60的开发 使用树莓派的can总线实现对于mk60 bootloader的烧录,期间包括can总线逻辑协议,crc16校验,以及bootloader上下文跳转,can总线程序的编写 创新性的将开发环境eclipse转为vscode并使用eclipse编写好的makefile文件编译程序,期间使用python程序实现了一部分的功能 5月 国富氢能项目简介:国富氢能是一家制作氢罐的公司,我们需要将制作好的氢罐放入库位,然后按需要出库.这里采用的是堆垛机加nav350有反导航 使用mk60对拉线编码器进行数据采集,数据处理,数据上传 熟悉一些常用模块的使用:光电,音乐盒,led等 树莓派上使用tcp对nav350坐标信息协议等处理 xml地图文件解析,并完成判断车辆所在段算法的编写 使用pid,pure pursuit对堆垛机进行运动控制 编写config读写程序 在原有log程序的基础上加入了一定日期删除log文件功能,以及记录当前错误信息所在行列功能 创新使用cmake实现对于程序框架的编译 创新使用xshell与mobaxterm进行开发 创新使用vscode+wsl的模式进行程序编程 参考一款risc_v的编程规范设计一款编程规范 8月 研发项目1项目简介:在对堆垛机上使用slam实现定位,并演示取放货过程 熟悉ros开发流程,基本套路,实现简单程序编写,比如下位机odom数据采集,stamp数据采集,获得坐标下发等 实现了hector,gmapping,navigation等常见激光雷达开源项目仿真 在agv上使用hector进行建图,以及地图保存 创新使用amcl实现agv的初始定位 进一步结合&lt;视觉slam14讲&gt;与&lt;概率机器人&gt;理解hector底层逻辑,包括非线性优化–高斯牛顿,双线性插值,以及通过 bresenham 划线法绘制地图 粒子滤波算法,包括里程计运动模型,激光雷达最大似然测量模型,蒙特卡洛算法,kld采样算法等 10月 研发项目2项目简介:坤厚是一家agv公司,它开放了硬件让我们实现对于slam定位导航的需求,我们以此加以测试与简单演示 使用坤厚开发套件进行开发,了解并简单使用boost库进行程序开发 使用usb_can模块实现对于同毅电机的控制 使用cJSON实现对于json文件的解析与生成 将其当作底盘与导航模块使用,进一步了解在实际使用中的一些细节问题,包括里程计校正,激光校正,车体控制校正等 理解在现场实施中反光板的使用以及项目规划流程重要性 编写罗技手柄控制程序 使用其套件基本完成项目演示 1月 裕同项目简介:裕同是一家制纸,印刷公司,我们需要将处理好的纸放到库位,并按需取用.采用三向叉车加堆垛车加自家的反光板定位算法实现. 测试并简单使用反光板定位算法程序 tcp读取r2000数据 编写拉线编码器,两种车体控制协议,两种电池协议 由于不满足于原有程序之间耦合性太高,程序逻辑到处飞的原因,参考一款飞控程序将原有程序进行拆分,实现一定意义上的模块化,低耦合.包括,抛弃原有大while单片机设计思路改用多线程编程,使用回调函数的形式,使程序实现松耦合,三层结构,使设计更加规范等. 期间设计了几款工具:使用id的方式记录线程所用时间,linux定时器等 将单舵轮,双舵轮,差分轮,全向轮,麦克拉姆轮,履带轮统合在一块,通过控制v,w控制所有种类小车,实现逻辑与实际控制间的分离 使用维纳算法将里程计与激光坐标融合"},{"title":"categories","date":"2021-10-24T06:02:33.000Z","updated":"2021-10-24T06:05:58.328Z","comments":true,"path":"categories/index.html","permalink":"https://peitianyu.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-24T06:04:32.000Z","updated":"2021-10-24T06:04:51.547Z","comments":true,"path":"tags/index.html","permalink":"https://peitianyu.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2021-10-24T05:07:09.649Z","comments":false,"path":"about/index.html","permalink":"https://peitianyu.github.io/blog/about/index.html","excerpt":"","text":"飞行员语录“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我QQ：1216582461 （嘀嘀~，麻烦让一下，我要开车了！）GitHub: https://github.com/peitianyu"}],"posts":[{"title":"addr2line","slug":"addr2line","date":"2022-05-11T04:30:12.000Z","updated":"2022-05-12T03:02:14.535Z","comments":true,"path":"2022/05/11/addr2line/","link":"","permalink":"https://peitianyu.github.io/blog/2022/05/11/addr2line/","excerpt":"","text":"参考网址: (132条消息) addr2line 输出为?:0可能原因_qq_23101811的博客-CSDN博客 (132条消息) addr2line命令_残阳的博客-CSDN博客_addr2line命令用法 (132条消息) Linux命令之dmesg命令_浪子吴天的博客-CSDN博客_dmesg (133条消息) addr2line排查地址_AK_Coffee的博客-CSDN博客_addr2line地址 使用流程123456789101112131415# 编译注意使用-g模式编译gcc -o test -g test.c#清除内核环形缓冲区(ring butter)dmesg -C #执行文件./test# 查看所有开机日志信息dmesg[3540868.730553] traps: test[4331] trap divide error ip:55d347e5067b sp:7ffdb3499f50 error:0[3540868.730567] in test[55d347e50000+1000]# 计算ipip: 55d347e5067b - 55d347e50000 = 067b# addr2line -e test 067b# addr2line -a -C -e libstagefright_omx.so -f 00023808/var/testhelper/programsymbols/tes.c:8","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"c++查看内存使用","slug":"C++查看内存使用","date":"2022-05-09T04:30:12.000Z","updated":"2022-05-10T01:14:32.616Z","comments":true,"path":"2022/05/09/C++查看内存使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/05/09/C++%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址: (131条消息) PROC系列之—/proc/pid/statm_沙漠里的海豚的博客-CSDN博客_proc statm 简介12cat /proc/self/statm654 57 44 0 0 334 0 解释123456789CPU 以及CPU0。。。的每行的每个参数意思（以第一行为例）为：参数 解释 /proc/ /statusSize (pages) 任务虚拟地址空间的大小 VmSize/4Resident(pages) 应用程序正在使用的物理内存的大小 VmRSS/4Shared(pages) 共享页数 0Trs(pages) 程序所拥有的可执行虚拟内存的大小 VmExe/4Lrs(pages) 被映像到任务的虚拟内存空间的库的大小 VmLib/4Drs(pages) 程序数据段和用户态的栈的大小 （VmData+ VmStk ）4dt(pages) 0 参考程序12345678910void dump_mem_usage()&#123; FILE* f = fopen(&quot;/proc/self/statm&quot;, &quot;rt&quot;); if (!f) return; char str[300]; size_t n = fread(str, 1, 200, f); str[n] = 0; printf(&quot;MEM: %s\\n&quot;, str); fclose(f);&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"nanoflann","slug":"nanoflann","date":"2022-05-09T04:30:12.000Z","updated":"2022-05-10T01:28:29.942Z","comments":true,"path":"2022/05/09/nanoflann/","link":"","permalink":"https://peitianyu.github.io/blog/2022/05/09/nanoflann/","excerpt":"","text":"参考网址: (131条消息) nanoflann库_Being_young的博客-CSDN博客 nanoflann: a C++11 header-only library for Nearest Neighbor (NN) search with KD-trees 使用12345678910111213141516// 1.构建kd-tree索引using my_kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt;num_t, PointCloud&lt;num_t&gt;&gt;, PointCloud&lt;num_t&gt;, 3 /* dim */ &gt;;my_kd_tree_t index(3 /*dim*/, cloud, &#123;10 /* max leaf */&#125;);// 2.knn 检索const size_t num_results = 1;size_t ret_index;num_t out_dist_sqr;nanoflann::KNNResultSet&lt;num_t&gt; resultSet(num_results);resultSet.init(&amp;ret_index, &amp;out_dist_sqr);index.findNeighbors(resultSet, &amp;query_pt[0], nanoflann::SearchParams(10));std::cout &lt;&lt; &quot;knnSearch(nn=&quot; &lt;&lt; num_results &lt;&lt; &quot;): \\n&quot;;std::cout &lt;&lt; &quot;ret_index=&quot; &lt;&lt; ret_index &lt;&lt; &quot; out_dist_sqr=&quot; &lt;&lt; out_dist_sqr &lt;&lt; std::endl;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"win11安装","slug":"win11安装","date":"2022-05-05T04:30:12.000Z","updated":"2022-05-08T12:27:19.756Z","comments":true,"path":"2022/05/05/win11安装/","link":"","permalink":"https://peitianyu.github.io/blog/2022/05/05/win11%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考网址: 一步强制升级windows11_沃特陌的博客-CSDN博客_win11强制升级 下载win11镜像(multi-edition) Download Windows 11 (microsoft.com) 准备进入resources,找到appraiserres.dll,剪切出来,新建一个空白相同文件放进去安装setup.exe,运行检测满足, 扫描完成后，会提示你满足，可以下一步，这时候，再把那个appraiserres.dll文件放回去。然后继续进行即可","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"ndt","slug":"ndt","date":"2022-04-29T04:30:12.000Z","updated":"2022-04-29T07:39:13.534Z","comments":true,"path":"2022/04/29/ndt/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/29/ndt/","excerpt":"","text":"参考网址:softdream/ndt-algorithm (github.com) 算法流程1231. caculateNDTByFirstScan:主要对前一祯数据做网格化,得到FirstmeanPose,与Pose_Cov2. estimateTransformationOnce:对当前scan做网格化,然后使用poseCov作为sigma噪声与得到FirstmeanPose做高斯牛顿,然后迭代3. angleNormalize:角度归一化 代码具体代码参考道峰大佬ndt","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"adb使用","slug":"adb使用","date":"2022-04-28T04:30:12.000Z","updated":"2022-04-28T09:01:27.308Z","comments":true,"path":"2022/04/28/adb使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/28/adb%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:(129条消息) 全网最全adb命令_autofelix的博客-CSDN博客 简单实用12345adb connect &quot;$ip&quot;adb shelladb push 本机文件 下机文件夹adb pull 下机文件 本机文件夹md5sum 文件 (对比文件是否相同)","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"VoxelGrid_filter","slug":"VoxelGrid_filter","date":"2022-04-27T04:30:12.000Z","updated":"2022-04-28T07:35:52.189Z","comments":true,"path":"2022/04/27/VoxelGrid_filter/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/27/VoxelGrid_filter/","excerpt":"","text":"参考网址:(129条消息) 体素栅格对点云下采样（从基础写起）——源码解析C++_weixin_44494725的博客-CSDN博客_体素栅格 nestormh/voxel_odometry: Voxel grid and particle filter based approach for estimating odometry. 简介所谓下采样是对点云的一种滤波，目的是减少点云数目,并尽可能保持点云原有形状，从而减少计算量。所谓体素栅格是将点云空间划分为一个个极小的格子，格子里包含几个点。对体素栅格里面的点取平均或者加权平均，得到一个点，代替原来的几个点。显然，栅格选的越大，滤波后点云点数越少，速度快，但是会对原来的点云过度模糊;栅格选的越小，作用反之。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162Mat samplePCByQuantization(Mat pc, float xrange[2], float yrange[2], float zrange[2], float sampleStep, int weightByCenter)&#123; std::vector&lt; std::vector&lt;int&gt; &gt; map;//map.size()为体素栅格个数//map[i].size()为当前体素栅格包含的点数，里面存的是pc的点索引 int numSamplesDim = (int)(1.0/sampleStep);//numSamplesDim：采样个数。sampleStep：相对采样长度//sampleStep×D=实际采样距离//同时，D/实际采样距离=采样个数=numSamplesDim float xr = xrange[1] - xrange[0];//包围盒子的边长 float yr = yrange[1] - yrange[0]; float zr = zrange[1] - zrange[0]; int numPoints = 0; map.resize((numSamplesDim+1)*(numSamplesDim+1)*(numSamplesDim+1));//此处resize的是map的size，表示体素栅格的个数//map.size():体素栅格的个数 // OpenMP might seem like a good idea, but it didn&#x27;t speed this up for me //#pragma omp parallel for for (int i=0; i&lt;pc.rows; i++)//遍历pc中每一个点i &#123; const float* point = pc.ptr&lt;float&gt;(i);//定义指针* point指向pc的第i个元素（六维） // quantize a point// xr/numSamplesDim=xr×sampleStep=实际采样距离//(point[0]-xrange[0])/实际采样距离：代表当前坐标point[0]在第(int) 几个采样距离处 const int xCell =(int) ((float)numSamplesDim*(point[0]-xrange[0])/xr); const int yCell =(int) ((float)numSamplesDim*(point[1]-yrange[0])/yr); const int zCell =(int) ((float)numSamplesDim*(point[2]-zrange[0])/zr); const int index = xCell*numSamplesDim*numSamplesDim+yCell*numSamplesDim+zCell; /*#pragma omp critical &#123;*/ map[index].push_back(i);//把具有相同xCell、yCell、zCell的点i存到同一个索引index下面//此时，map就是一个个体素栅格，里面包含了若干个点 // &#125; &#125; for (unsigned int i=0; i&lt;map.size(); i++) &#123; numPoints += (map[i].size()&gt;0); &#125;//把map[i]中所有的点数目统计起来，就是pc的总点数 Mat pcSampled = Mat(numPoints, pc.cols, CV_32F);//cols代表x,y,z,nx,ny,nz六列 int c = 0; for (unsigned int i=0; i&lt;map.size(); i++)//对每一个体素栅格 &#123; double px=0, py=0, pz=0;//下采样后的坐标 double nx=0, ny=0, nz=0;//下采样后的法线 std::vector&lt;int&gt; curCell = map[i];//curCell：向量包含当前体素栅格的所有点//map[i]里存的是PC中点的索引（int） int cn = (int)curCell.size();//cn:每个体素栅格包含的点数 if (cn&gt;0)//因为map[i]可能为空 &#123; if (weightByCenter)//体素栅格求重心 &#123; int xCell, yCell, zCell;//第几个cell double xc, yc, zc;//体素栅格的质心坐标 double weightSum = 0 ; zCell = i % numSamplesDim;//这个i是map的index，//index = xCell*numSamplesDim*numSamplesDim+yCell*numSamplesDim+zCell; yCell = ((i-zCell)/numSamplesDim) % numSamplesDim; xCell = ((i-zCell-yCell*numSamplesDim)/(numSamplesDim*numSamplesDim));//第几个cell//0.5 * (double)xr/numSamplesDim：半个格子的长度//(double)xr/numSamplesDim：一个格子的长度//xCell* (double)xr/numSamplesDim 前面所有整数个格子的长度 xc = ((double)xCell+0.5) * (double)xr/numSamplesDim + (double)xrange[0];//xc：体素栅格的重心坐标x yc = ((double)yCell+0.5) * (double)yr/numSamplesDim + (double)yrange[0]; zc = ((double)zCell+0.5) * (double)zr/numSamplesDim + (double)zrange[0]; for (int j=0; j&lt;cn; j++)//体素栅格中每一点 &#123; const int ptInd = curCell[j];//ptInd是pc中的点的索引 float* point = pc.ptr&lt;float&gt;(ptInd); const double dx = point[0]-xc; const double dy = point[1]-yc; const double dz = point[2]-zc;//计算体素栅格中每一点与质心的距离：d const double d = sqrt(dx*dx+dy*dy+dz*dz); double w = 0; if (d&gt;EPS) &#123; // it is possible to use different weighting schemes. // inverse weigthing was just good for me // exp( - (distance/h)**2 ) //const double w = exp(-d*d); w = 1.0/d;//由d计算权重，inverse weigthing &#125; //float weights[3]=&#123;1,1,1&#125;; px += w*(double)point[0]; py += w*(double)point[1]; pz += w*(double)point[2]; nx += w*(double)point[3]; ny += w*(double)point[4]; nz += w*(double)point[5]; weightSum+=w; &#125; px/=(double)weightSum; py/=(double)weightSum; pz/=(double)weightSum; nx/=(double)weightSum; ny/=(double)weightSum; nz/=(double)weightSum; &#125;//在一个体素栅格中：px=（x1*1/d1+x2*1/d2+...+xcn1/dcn）/（1/d1+1/d2+...1/dcn）//py，pz同理//得到加权质心 else &#123;//普通求平均的质心 for (int j=0; j&lt;cn; j++) &#123; const int ptInd = curCell[j]; float* point = pc.ptr&lt;float&gt;(ptInd); px += (double)point[0]; py += (double)point[1]; pz += (double)point[2]; nx += (double)point[3]; ny += (double)point[4]; nz += (double)point[5]; &#125; px/=(double)cn; py/=(double)cn; pz/=(double)cn; nx/=(double)cn; ny/=(double)cn; nz/=(double)cn; &#125;//定义指针pcData指向pcSampled的第c个元素 float *pcData = pcSampled.ptr&lt;float&gt;(c); pcData[0]=(float)px; pcData[1]=(float)py; pcData[2]=(float)pz; // 法向量标准化 double norm = sqrt(nx*nx+ny*ny+nz*nz); if (norm&gt;EPS) &#123; pcData[3]=(float)(nx/norm); pcData[4]=(float)(ny/norm); pcData[5]=(float)(nz/norm); &#125; //#pragma omp atomic c++; curCell.clear();//清空当前体素栅格 &#125; &#125; map.clear(); return pcSampled;&#125; 二维体素滤波 12345678910111213141516171819202122232425262728LaserScan Voxelfilter(LaserScan scan, float Resolution)&#123; float min_x = -10.0; float min_y = -10.0; float max_y = 10.0; int lenY = (int)(std::round((max_y - min_y) / Resolution)); std::map&lt;int,int&gt; rebuf; LaserScan result; for(auto&amp;point:scan) &#123; int x = point.x(); int y = point.y(); // 仅采用4m内scan数据 float dis = sqrt(x*x + y*y); if(dis &gt; 4.0) continue; int xGrid = (int)(std::round((point.x - min_x) / Resolution)); int yGrid = (int)(std::round((point.y - min_y) / Resolution)); int index = yGrid * lenY + xGrid; if(!rebuf[index]) &#123; rebuf[index] = 1; result.push_back(point); &#125; &#125; return result;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"行为树","slug":"行为树","date":"2022-04-27T04:30:12.000Z","updated":"2022-04-27T01:32:22.328Z","comments":true,"path":"2022/04/27/行为树/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/27/%E8%A1%8C%E4%B8%BA%E6%A0%91/","excerpt":"","text":"参考网址:(128条消息) 行为树(Behavior trees)_念去去~的博客-CSDN博客_行为树 (128条消息) 状态机和行为树_PresleyGo的博客-CSDN博客_行为树和状态机区别 (128条消息) 行为树概念_白霞的博客-CSDN博客_行为树 devildevilson/tiny_behaviour: Behaviour tree header only library (github.com) 基础定义Tree nodes descriptionBehaviorTreeBuilder class methods: Compositor nodes:1234567`sequence()` - updates all nodes until faces `Status::Failure` or `Status::Running``selector()` - updates all nodes until faces `Status::Success` or `Status::Running``parallel(minSuccess, minFail)` - updates all nodes, return `Status::Success` if `totalSuccess` &gt;= `minSuccess` or `Status::Failure` if `totalFails` &gt;= `minFail` else `Status::Running``memSelector()` - updates all nodes until faces `Status::Success` or `Status::Running`, next updation will start from that node`memSequence()` - updates all nodes until faces `Status::Failure` or `Status::Running`, next updation will start from that node`random(seed)` - updates random (depends on seed) node`whiledo(predicate)` - updates all nodes while `condition == true`, returns `Status::Running` in this case, if `condition == false` does nothing and returns `Status::Failure Binary nodes:(Status::Success is true, Status::Failure is false)conjunction() - Status first &amp;&amp; Status seconddisjunction() - Status first || Status secondequality() - Status first == Status secondimplication() - Status first -&gt; Status second (!(Status first) || Status second) (Status::Running = Status::Failure)ifelse(predicate) - if contidion == true updates first, else second Decorator nodes:12345678inverter()` - inverts `Status::Success` and `Status::Failure`, `Status::Running` ignored`repeater(limit)` - returns `Status::Running` `limit` times, then return node status and resets`limiter(limit)` - returns decorator&#x27;s child status `limit` times, then return `Status::Failure``untilFail()` - returns only `Status::Running` or `Status::Failure``untilSuccess()` - returns only `Status::Running` or `Status::Success``failer()` - returns only `Status::Failure``succeeder()` - returns only `Status::Success``condition(predicate)` - updates child if `predicate == true` else returns `Status::Failure Special nodes:action(action) - userdefined action function, must return statuses Other methods:end() - use it after every Compositor or Binary nodesadd(node) - adds nodes to the current tree, NOTE: adding trees is under constructionleaf(arguments) - create userdefined action node build() - does some postworks and returns BehaviorTree pointerdebug(string) - just prints the stringsetDebugCallback(callback) - set callback function for the error strings","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"evo使用","slug":"evo","date":"2022-04-26T04:30:12.000Z","updated":"2022-04-29T01:33:33.132Z","comments":true,"path":"2022/04/26/evo/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/26/evo/","excerpt":"","text":"参考网址:(128条消息) 如何获得gazebo仿真中的机器人位姿真值_寒墨阁的博客-CSDN博客_gazebo获取机器人位置 (128条消息) evo安装、evo使用方法详细介绍使用教程 (128条消息) evo评测VINS-MONO—代码修改、数据格式转换、数据测试_可即的博客-CSDN博客_vins测试 (128条消息) evo测评TUM数据集_dididada~的博客-CSDN博客_evo tum gazebo获得真实位姿12345678910111213&lt;!-- 在gazebo仿真模型文件中添加： --&gt;&lt;gazebo&gt; &lt;plugin name=&quot;p3d_base_controller&quot; filename=&quot;libgazebo_ros_p3d.so&quot;&gt; &lt;alwaysOn&gt;true&lt;/alwaysOn&gt; &lt;updateRate&gt;50.0&lt;/updateRate&gt; &lt;bodyName&gt;base_footprint&lt;/bodyName&gt; &lt;topicName&gt;base_pose_ground_truth&lt;/topicName&gt; &lt;gaussianNoise&gt;0.0&lt;/gaussianNoise&gt; &lt;frameName&gt;map&lt;/frameName&gt; &lt;xyzOffsets&gt;0 0 0&lt;/xyzOffsets&gt; &lt;rpyOffsets&gt;0 0 0&lt;/rpyOffsets&gt; &lt;/plugin&gt;&lt;/gazebo&gt; ros生成tum文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;ros/ros.h&gt;#include &quot;geometry_msgs/PoseWithCovarianceStamped.h&quot;#include &quot;nav_msgs/Odometry.h&quot;#include &lt;fstream&gt;#include &lt;string.h&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;class EvoCreatTum&#123;public: EvoCreatTum(); ~EvoCreatTum(); void poseCallback(const nav_msgs::Odometry::ConstPtr&amp; msg);private: ros::NodeHandle nh_; ros::Subscriber sub_; std::string odom_topic_; nav_msgs::Odometry pose_; std::string outFilename_;&#125;;EvoCreatTum::EvoCreatTum()&#123; ros::Time::init(); nh_.param&lt;std::string&gt;(&quot;/odom_topic&quot;, odom_topic_, &quot;/odom&quot;); nh_.param&lt;std::string&gt;(&quot;outFilename&quot;, outFilename_, &quot;/root/catkin_ws/devel/lib/evo_creat_tum/outpose.txt&quot;); sub_ = nh_.subscribe(odom_topic_, 1, &amp;EvoCreatTum::poseCallback, this);&#125;EvoCreatTum::~EvoCreatTum()&#123;&#125;void EvoCreatTum::poseCallback(const nav_msgs::Odometry::ConstPtr &amp;msg)&#123; ros::Time currTime = ros::Time::now(); double t_s = currTime.toSec(); // std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; &quot;t_s: &quot; &lt;&lt; t_s &lt;&lt; std::endl; pose_ = *msg; double tx = pose_.pose.pose.position.x; double ty = pose_.pose.pose.position.y; double tz = pose_.pose.pose.position.z; double qx = pose_.pose.pose.orientation.x; double qy = pose_.pose.pose.orientation.y; double qz = pose_.pose.pose.orientation.z; double qw = pose_.pose.pose.orientation.w; std::fstream outTumpose; // 打开并向后添加 outTumpose.open(outFilename_, std::ios::out | std::ios::app); outTumpose &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; t_s &lt;&lt; &quot; &quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; tx &lt;&lt; &quot; &quot; &lt;&lt; ty &lt;&lt; &quot; &quot; &lt;&lt; tz &lt;&lt; &quot; &quot; &lt;&lt; qx &lt;&lt; &quot; &quot; &lt;&lt; qy &lt;&lt; &quot; &quot; &lt;&lt; qz &lt;&lt; &quot; &quot; &lt;&lt; qw &lt;&lt; std::endl;&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;evo_creat_tum_node&quot;); // 节点的名字 EvoCreatTum evo_creat_tum; ros::spin(); // 程序执行到此处时开始进行等待，每次订阅的消息到来都会执行一次ScanCallback() return 0;&#125; 123456&lt;launch&gt; &lt;!-- creat_tum --&gt; &lt;param name=&quot;/odom_topic&quot; value=&quot;/odom&quot;/&gt; &lt;param name=&quot;outFilename&quot; value=&quot;/root/catkin_ws/devel/lib/evo_creat_tum/outpose.txt&quot;/&gt; &lt;node name=&quot;evo_creat_tum&quot; pkg=&quot;evo_creat_tum&quot; type=&quot;evo_creat_tum&quot; /&gt;&lt;/launch&gt; evo使用123456# 配准前evo_traj tum CameraTrajectory.txt groundtruth.txt -p# 配准后evo_traj tum CameraTrajectory.txt --ref=groundtruth.txt -p -a# 输出结果evo_ape tum groundtruth.txt CameraTrajectory.txt -r full -va -p --save_results results/ORB.zip","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"fstream","slug":"fstream","date":"2022-04-26T04:30:12.000Z","updated":"2022-04-26T03:37:36.843Z","comments":true,"path":"2022/04/26/fstream/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/26/fstream/","excerpt":"","text":"参考网址:(128条消息) C++ 深究fstream打开方式ios::app,ios::ate,ios::in,ios::out_悟名堂的博客-CSDN博客_fstream ios::app 例程默认(覆盖原文件)1234567891011121314151617181920212223242526#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; char data[100]; //第一次打开文件 ofstream outfile; outfile.open(&quot;D:\\\\afile.dat&quot;); cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Enter your name:&quot;; cin.getline(data, 100); outfile &lt;&lt; data &lt;&lt; endl; outfile.close(); //第二次打开文件 ofstream outfile2; outfile2.open(&quot;D:\\\\afile.dat&quot;);//**待修改语句** cout &lt;&lt; &quot;Enter your age:&quot;; cin &gt;&gt; data; outfile2 &lt;&lt; data &lt;&lt; endl; outfile2.close();//第二次关闭文件 return 0;&#125; 使用iso::app(在文末尾添加)1outfile2.open(&quot;D:\\\\afile.dat&quot;, ios::app);","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"param","slug":"ros_param","date":"2022-04-26T04:30:12.000Z","updated":"2022-04-26T03:27:41.290Z","comments":true,"path":"2022/04/26/ros_param/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/26/ros_param/","excerpt":"","text":"参考网址:(128条消息) ROS-节点参数param_TYINY的博客-CSDN博客_node.param (128条消息) 【ROS学习】ROS param 的使用_wongHome的博客-CSDN博客_ros::param::get 例程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091include &quot;ros/ros.h&quot; #include &lt;cstdlib&gt; using namespace std; int main(int argc,char** argv) &#123; //initial and name node ros::init(argc,argv,&quot;node_param&quot;); if(argc!=2) &#123; cout&lt;&lt;&quot;Error command paramter! Please run command eg:\\n&quot;\\ &lt;&lt;&quot;rosrun book_param book_param 1\\n&quot;\\ &lt;&lt;&quot;help information:\\n&quot;\\ &lt;&lt;&quot; 1 ------ set param mode(ros::param::set())\\n&quot;\\ &lt;&lt;&quot; 2 ------ set param mode(ros::NodeHandle::setParam())\\n&quot;\\ &lt;&lt;&quot; 3 ------ get param mode(ros::param::get())\\n&quot;\\ &lt;&lt;&quot; 4 ------ get param mode(ros::NodeHandle::getParam())\\n&quot;\\ &lt;&lt;&quot; 5 ------ get param mode(ros::NodeHandle::param())\\n&quot;\\ &lt;&lt;endl; return 1; &#125; //create node handle ros::NodeHandle nh; //param variable int IntParam; string StrParam; bool isIntParam, isStrParam; //mode flag int flag = atoi(argv[1]); // set or get param with different ways switch(flag) &#123; case 1: ROS_INFO(&quot;set param mode(ros::param::set()):&quot;); ros::param::set(&quot;IntParam&quot;,1); ros::param::set(&quot;StrParam&quot;,&quot;stringdemo&quot;); break; case 2: ROS_INFO(&quot;set param mode(ros::NodeHandle::setParam()):&quot;); nh.setParam(&quot;IntParam&quot;,1); nh.setParam(&quot;StrParam&quot;,&quot;stringdemo&quot;); break; case 3: ROS_INFO(&quot;get param mode(ros::param::get()):&quot;); isIntParam = ros::param::get(&quot;IntParam&quot;,IntParam); isStrParam = ros::param::get(&quot;StrParam&quot;,StrParam); if(isIntParam)&#123; ROS_INFO(&quot;The IntParam is:%d&quot;,IntParam); &#125;else&#123; ROS_INFO(&quot;Get IntParam fail!&quot;); &#125; if(isIntParam)&#123; ROS_INFO(&quot;The StrParam is:%s&quot;,StrParam.c_str()); &#125;else&#123; ROS_INFO(&quot;Get StrParam fail!&quot;); &#125; break; case 4: ROS_INFO(&quot;get param mode(ros::NodeHandle::getParam()):&quot;); isIntParam = nh.getParam(&quot;IntParam&quot;,IntParam); isStrParam = nh.getParam(&quot;StrParam&quot;,StrParam); if(isIntParam)&#123; ROS_INFO(&quot;The IntParam is:%d&quot;,IntParam); &#125;else&#123; ROS_INFO(&quot;Get IntParam fail!&quot;); &#125; if(isIntParam)&#123; ROS_INFO(&quot;The StrParam is:%s&quot;,StrParam.c_str()); &#125;else&#123; ROS_INFO(&quot;Get StrParam fail!&quot;); &#125; break; case 5: ROS_INFO(&quot;get param mode(ros::NodeHandle::param()):&quot;); //warning: this way will set default value when get no param! nh.param(&quot;IntParam&quot;,IntParam,11); // be careful when use ros::NodeHandle::param get string param! nh.param&lt;std::string&gt;(&quot;StrParam&quot;,StrParam,&quot;stringdemo_default&quot;); ROS_INFO(&quot;\\nThe IntParam is:%d\\nThe StrParam is:%s&quot;,IntParam,StrParam.c_str()); break; default: ROS_INFO(&quot;flag value is not in range: [1,5]&quot;); &#125; return 0; &#125;&#125; launch文件配置12345678910111213141516&lt;launch&gt; &lt;!--param参数配置--&gt; &lt;param name=&quot;param1&quot; value=&quot;1&quot; /&gt; &lt;param name=&quot;param2&quot; value=&quot;2&quot; /&gt; &lt;!--param name=&quot;table_description&quot; command=&quot;$(find xacro)/xacro.py $(find gazebo_worlds)/objects/table.urdf.xacro&quot; /--&gt; &lt;!--rosparam参数配置--&gt; &lt;rosparam&gt; param3: 3 param4: 4 param5: 5 &lt;/rosparam&gt; &lt;!--以上写法将参数转成YAML文件加载，注意param前面必须为空格，不能用Tab，否则YAML解析错误--&gt; &lt;!--rosparam file=&quot;$(find robot_sim_demo)/config/xbot-u_control.yaml&quot; command=&quot;load&quot; /--&gt; &lt;node pkg=&quot;param_demo&quot; type=&quot;param_demo&quot; name=&quot;param_demo&quot; output=&quot;screen&quot; &gt; &lt;/node&gt;&lt;/launch&gt; yaml文件12param1:1param2:&quot;str&quot;","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"time","slug":"ros_time","date":"2022-04-26T04:30:12.000Z","updated":"2022-04-26T03:33:55.314Z","comments":true,"path":"2022/04/26/ros_time/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/26/ros_time/","excerpt":"","text":"参考网址:(128条消息) ROS学习八、ros中的时间Time,Duration,Timer和Rate（2）_RuiH.AI的博客-CSDN博客_ros时间 例程Time和Duration的数据类型相同： 12int32 secint32 nsec 获取当前时间: 12ros::Time::init();ros::Time start = ros::Time::now(); 转化为ms/s 1234// 转为msdouble t_ms = t.toNSec();// 转为sdouble t_s = t.toSec(); 时间间隔: 1234ros::Duration + ros::Duration = ros::Durationros::Duration - ros::Duration = ros::Durationros::Time + ros::Duration = ros::Timeros::Time - ros::Time = ros::Duration sleep: 12// 使用方法：ros::Duration(2.5).sleep(); ros::rate循环 1234567// 10Hzros::Rate r(10)；while(ros::ok())&#123; ... r.sleep();&#125;","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"文件同步工具","slug":"文件同步工具","date":"2022-04-25T04:30:12.000Z","updated":"2022-04-25T14:10:03.221Z","comments":true,"path":"2022/04/25/文件同步工具/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/25/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/","excerpt":"","text":"参考网址:敢和 Edge 争高下？99%的人没听说过的宝藏浏览器！_哔哩哔哩_bilibili 功能不同设备之间同步,比如 使用","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"icp","slug":"icp","date":"2022-04-23T04:30:12.000Z","updated":"2022-04-27T03:32:12.236Z","comments":true,"path":"2022/04/23/icp/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/23/icp/","excerpt":"","text":"参考网址:(128条消息) 迭代最近点 ICP 详细推导（C++实现）_Alan Lan的博客-CSDN博客_迭代最近点算法 (128条消息) ICP算法的原理与实现_酷小川的博客-CSDN博客_icp算法 (128条消息) 基于kdtree与svd的迭代最近点ICP算法的matlab实现_头顶日渐发凉的博客-CSDN博客 zjudmd1015/icp (github.com) ClayFlannigan/icp: iterative closest point (github.com) Gregjksmith/Iterative-Closest-Point 步骤1234求质心,求t去中心化计算SVD,求R迭代 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;Eigen/Eigen&gt; void ICP(const std::vector&lt;Eigen::Vector3f&gt;&amp; p1, const std::vector&lt;Eigen::Vector3f&gt;&amp; p2, Eigen::Matrix3f&amp; R_12, Eigen::Vector3f&amp; t_12) &#123; assert(p1.size() == p2.size()); // center of mass size_t N = p1.size(); Eigen::Vector3f p1_center, p2_center; for (int i = 0; i &lt; N; ++i) &#123; p1_center += p1.at(i); p2_center += p2.at(i); &#125; p1_center /= N; p2_center /= N; // remove the center std::vector&lt;Eigen::Vector3f&gt; q1(N), q2(N); for (int i = 0; i &lt; N; ++i) &#123; q1[i] = p1.at(i) - p1_center; q2[i] = p2.at(i) - p2_center; &#125; // compute q2*q1^T Eigen::Matrix3f H = Eigen::Matrix3f::Zero(); for (int i = 0; i &lt; N; ++i) &#123; H += q2.at(i) * q1.at(i).transpose(); &#125; // SVD on H Eigen::JacobiSVD&lt;Eigen::Matrix3f&gt; svd(H, Eigen::ComputeFullU | Eigen::ComputeFullV); Eigen::Matrix3f U = svd.matrixU(); Eigen::Matrix3f V = svd.matrixV(); R_12 = V * U.transpose(); t_12 = p1_center - R_12 * p2_center;&#125; int main(int argc, char** argv) &#123; Eigen::AngleAxisf angle_axis(M_PI / 3, Eigen::Vector3f(0, 0, 1)); Eigen::Matrix3f R_12_ = angle_axis.matrix(); Eigen::Vector3f t_12_(1, 2, 3); std::cout &lt;&lt; &quot;except R_12:\\n&quot; &lt;&lt; R_12_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;except t_12:\\n&quot; &lt;&lt; t_12_.transpose() &lt;&lt; std::endl; std::vector&lt;Eigen::Vector3f&gt; p1, p2; Eigen::Vector3f point; std::ifstream fin(&quot;/tmp/bunny.txt&quot;); std::string line; while (getline(fin, line)) &#123; std::stringstream ss(line); ss &gt;&gt; point.x(); ss &gt;&gt; point.y(); ss &gt;&gt; point.z(); p2.push_back(point); p1.push_back(R_12_ * point + t_12_); &#125; fin.close(); Eigen::Matrix3f R_12; Eigen::Vector3f t_12; ICP(p1, p2, R_12, t_12); std::cout &lt;&lt; &quot;result R_12:\\n&quot; &lt;&lt; R_12_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;result t_12:\\n&quot; &lt;&lt; t_12.transpose() &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"pca降维","slug":"pca降维","date":"2022-04-21T04:30:12.000Z","updated":"2022-04-25T09:14:09.653Z","comments":true,"path":"2022/04/21/pca降维/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/21/pca%E9%99%8D%E7%BB%B4/","excerpt":"","text":"参考网址:[PCA算法的原理以及c++实现_chengwei0019的博客-CSDN博客_c++ pca算法](https://blog.csdn.net/u012700322/article/details/104822390?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pca c++&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-4-104822390.142^v9^control,157^v4^control&amp;spm=1018.2226.3001.4187) ihar/EigenPCA: A class for performing principal component analysis using Eigen library (github.com) (PCA降维原理及其代码实现 步骤123456PCA主成分分析，是模式识别中常见的特征降维的算法，其大体步骤可以分为以下几个部分：（1）原始特征矩阵归一化处理（假设M和样本，每个样本n个特征，则对M*N的X数据，进行零均值化，即减去这一列的均值）（2）求取归一化处理后特征矩阵的协方差矩阵（3）计算协方差矩阵的特征值及其对应的特征向量（4）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P；（5）Y=PX即为降维到k维后的数据; test_data.txt 123456789101110 22.5 2.40.5 0.72.2 2.91.9 2.23.1 3.02.3 2.72.0 1.61.0 1.11.5 1.61.1 0.9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;fstream&gt;#include &quot;Eigen/Dense&quot;using namespace std;using namespace Eigen;void featurenormalize(MatrixXd &amp;X)&#123; //计算每一维度均值 MatrixXd meanval = X.colwise().mean(); RowVectorXd meanvecRow = meanval; //样本均值化为0 X.rowwise() -= meanvecRow;&#125;void computeCov(MatrixXd &amp;X, MatrixXd &amp;C)&#123; //计算协方差矩阵C = XTX / n-1; C = X.adjoint() * X; C = C.array() / (X.rows() - 1);&#125;void computeEig(MatrixXd &amp;C, MatrixXd &amp;vec, MatrixXd &amp;val)&#123; //计算特征值和特征向量，使用selfadjont按照对阵矩阵的算法去计算，可以让产生的vec和val按照有序排列 SelfAdjointEigenSolver&lt;MatrixXd&gt; eig(C); vec = eig.eigenvectors(); val = eig.eigenvalues();&#125;int computeDim(MatrixXd &amp;val)&#123; int dim; double sum = 0; for (int i = val.rows() - 1; i &gt;= 0; --i) &#123; sum += val(i, 0); dim = i; if (sum / val.sum() &gt;= 0.95) break; &#125; return val.rows() - dim;&#125;int main()&#123; ifstream fin(&quot;test_data&quot;); ofstream fout(&quot;output.txt&quot;); //读取数据 double a, b; fin &gt;&gt; a; fin &gt;&gt; b; std::cout &lt;&lt; &quot;pass &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; const int m = a, n = b; MatrixXd X(m, n), C(n, n); MatrixXd vec, val; double in[200]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) fin &gt;&gt; in[j]; for (int j = 1; j &lt;= n; ++j) X(i, j - 1) = in[j-1]; &#125; //pca //零均值化 featurenormalize(X); //计算协方差 computeCov(X, C); std::cout &lt;&lt; &quot;cov: \\n&quot; &lt;&lt; C &lt;&lt; std::endl; //计算特征值和特征向量 computeEig(C, vec, val); //计算损失率，确定降低维数 int dim = computeDim(val); std::cout &lt;&lt; val &lt;&lt; std::endl; std::cout &lt;&lt; vec &lt;&lt; std::endl; //计算结果 MatrixXd res = X * vec.rightCols(n); //输出结果 fout &lt;&lt; &quot;the result is &quot; &lt;&lt; res.rows() &lt;&lt; &quot;x&quot; &lt;&lt; res.cols() &lt;&lt; &quot; after pca algorithm.&quot; &lt;&lt; endl; fout &lt;&lt; res; fout.close(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"g2o与ceres-solver安装","slug":"g2o与ceres-solver安装","date":"2022-04-19T04:30:12.000Z","updated":"2022-04-19T09:07:34.802Z","comments":true,"path":"2022/04/19/g2o与ceres-solver安装/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/19/g2o%E4%B8%8Eceres-solver%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考网址:(127条消息) ubuntu18.04安装g2o_弓满路长的博客-CSDN博客_ubuntu18.04安装g2o g2o安装12345678# 安装依赖sudo apt-get install libeigen3-dev libsuitesparse-dev qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5# 下载g2ogit clone https://ghproxy.com/https://github.com/RainerKuemmerle/g2o.gitcd g2o &amp;&amp; mkdir build &amp;&amp; cd buildcmake ..make -j8make install ceres-solver安装1234567891011# 安装依赖sudo nano /etc/apt/sources.listdeb https://cz.archive.ubuntu.com/ubuntu trusty main universesudo apt-get updatesudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev libgoogle-glog-dev libgtest-dev# 获取ceres-solvergit clone https://ceres-solver.googlesource.com/ceres-solvercd ceres-solver &amp;&amp; mkdir build &amp;&amp; cd buildcmake ..make -j8make install","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"carto建图与定位","slug":"carto建图与定位","date":"2022-04-18T04:30:12.000Z","updated":"2022-04-18T12:36:25.618Z","comments":true,"path":"2022/04/18/carto建图与定位/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/18/carto%E5%BB%BA%E5%9B%BE%E4%B8%8E%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"参考网址: (124条消息) Cartographer用于机器人纯定位_梦凝小筑的博客-CSDN博客_cartographer纯定位 (124条消息) 使用Cartographer2D建图_熊铁树的博客-CSDN博客_cartographer建图流程 (124条消息) 用自己的机器人实现cartographer建图测试与地图保存应该这样做_白茶-清欢的博客-CSDN博客_cartographer建图 (125条消息) 【移动机器人技术】Cartographer使用流程-建图-纯定位-导航_A MAN NAMED MAGIC的博客-CSDN博客_cartographer 定位 (127条消息) ROS SLAM功能包应用方法–cartographer_鸢雨如歌的博客-CSDN博客_cartographer 导航 (127条消息) cartographer建图参数配置详细说明_非晚非晚的博客-CSDN博客_cartographer参数配置 建图demo_revo_lds.launch 1234567891011121314151617181920212223&lt;launch&gt; &lt;!-- 启动仿真程序 --&gt; &lt;!-- &lt;include file=&quot;$(find robot_sim_demo)/launch/robot_spawn.launch&quot;/&gt; --&gt; &lt;!-- 启动关键的建图节点，这是我们主要要更改的地方，更改下面的configuration_directory和configuration_basename的路径 --&gt; &lt;node name=&quot;cartographer_node&quot; pkg=&quot;cartographer_ros&quot; type=&quot;cartographer_node&quot; args=&quot; -configuration_directory $(find carto)/configuration_files -configuration_basename revo_lds.lua&quot; output=&quot;screen&quot;&gt; &lt;!-- 更改horizontal_laser_2d为我们的雷达话题 --&gt; &lt;!-- &lt;remap from=&quot;scan&quot; to=&quot;scan&quot; /&gt; --&gt; &lt;!-- 更改odom为里程计话题 --&gt; &lt;!-- &lt;remap from=&quot;odom&quot; to=&quot;odom&quot; /&gt; --&gt; &lt;/node&gt; &lt;!-- 一般不更改，有个建图分辨率参数 --&gt; &lt;node name=&quot;cartographer_occupancy_grid_node&quot; pkg=&quot;cartographer_ros&quot; type=&quot;cartographer_occupancy_grid_node&quot; args=&quot;-resolution 0.05&quot; /&gt; &lt;!-- 下面这两个一般直接注释掉，我们自己需要再启动就可以了 --&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; required=&quot;true&quot; args=&quot;-d $(find carto)/rviz/cartographer.rviz&quot; /&gt;&lt;/launch&gt; 配置文件 revo_lds.lua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354include &quot;map_builder.lua&quot;include &quot;trajectory_builder.lua&quot;options = &#123; map_builder = MAP_BUILDER, trajectory_builder = TRAJECTORY_BUILDER, map_frame = &quot;map&quot;, -- tracking_frame更改为我们机器人的基坐标tf，一般是base_link， tracking_frame = &quot;base_link&quot;, -- 以下四个参数与里程计有关，在下面进行单独说明 odom_frame = &quot;odom&quot;, published_frame = &quot;base_link&quot;, provide_odom_frame = false, use_odometry = true, publish_frame_projected_to_2d = false, use_pose_extrapolator = true, use_nav_sat = false, use_landmarks = false, num_laser_scans = 1, num_multi_echo_laser_scans = 0, num_subdivisions_per_laser_scan = 1, num_point_clouds = 0, lookup_transform_timeout_sec = 0.2, submap_publish_period_sec = 0.3, pose_publish_period_sec = 5e-3, trajectory_publish_period_sec = 30e-3, rangefinder_sampling_ratio = 1., odometry_sampling_ratio = 0.3, fixed_frame_pose_sampling_ratio = 1., imu_sampling_ratio = 1., landmarks_sampling_ratio = 1.,&#125;MAP_BUILDER.use_trajectory_builder_2d = trueTRAJECTORY_BUILDER_2D.submaps.num_range_data = 35TRAJECTORY_BUILDER_2D.min_range = 0.3TRAJECTORY_BUILDER_2D.max_range = 8.TRAJECTORY_BUILDER_2D.missing_data_ray_length = 1.-- 决定是否使用imu数据TRAJECTORY_BUILDER_2D.use_imu_data = falseTRAJECTORY_BUILDER_2D.use_online_correlative_scan_matching = trueTRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.linear_search_window = 0.1TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.translation_delta_cost_weight = 10.TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.rotation_delta_cost_weight = 1e-1POSE_GRAPH.optimization_problem.huber_scale = 1e2POSE_GRAPH.optimize_every_n_nodes = 35POSE_GRAPH.constraint_builder.min_score = 0.65return options 纯定位demo_backpack_2d_localization.launch 1234567891011121314151617181920212223242526272829&lt;launch&gt; &lt;include file=&quot;$(find robot_sim_demo)/launch/robot_spawn.launch&quot;/&gt; &lt;node name=&quot;cartographer_node&quot; pkg=&quot;cartographer_ros&quot; type=&quot;cartographer_node&quot; args=&quot; -configuration_directory $(find carto)/configuration_files -configuration_basename backpack_2d_localization.lua -load_state_filename /root/catkin_ws/src/ROS-Academy-for-Beginners/carto/map/carto_2022_04_18_1.pbstream&quot; output=&quot;screen&quot;&gt; &lt;remap from=&quot;points2&quot; to=&quot;/camera/depth/points&quot;/&gt; &lt;/node&gt; &lt;!-- &lt;node name=&quot;cartographer_occupancy_grid_node&quot; pkg=&quot;cartographer_ros&quot; type=&quot;cartographer_occupancy_grid_node&quot; args=&quot;-resolution 0.05 -pure_localization 1&quot; /&gt; --&gt; &lt;!-- Map server --&gt; &lt;arg name=&quot;map_file&quot; default=&quot;$(find carto)/map/carto.yaml&quot;/&gt; &lt;node name=&quot;map_server&quot; pkg=&quot;map_server&quot; type=&quot;map_server&quot; args=&quot;$(arg map_file)&quot; /&gt; &lt;include file=&quot;$(find navigation_sim_demo)/launch/include/move_base.launch.xml&quot;/&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; required=&quot;true&quot; args=&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot; /&gt;&lt;/launch&gt; backpack_2d_localization.lua 12345678include &quot;backpack_2d.lua&quot;TRAJECTORY_BUILDER.pure_localization_trimmer = &#123; max_submaps_to_keep = 3,&#125;POSE_GRAPH.optimize_every_n_nodes = 20return options backpack_2d.lua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354include &quot;map_builder.lua&quot;include &quot;trajectory_builder.lua&quot;options = &#123; map_builder = MAP_BUILDER, trajectory_builder = TRAJECTORY_BUILDER, map_frame = &quot;map&quot;, -- tracking_frame更改为我们机器人的基坐标tf，一般是base_link， tracking_frame = &quot;base_footprint&quot;, -- 以下四个参数与里程计有关，在下面进行单独说明 odom_frame = &quot;odom&quot;, published_frame = &quot;base_footprint&quot;, provide_odom_frame = false, use_odometry = true, publish_frame_projected_to_2d = false, use_pose_extrapolator = true, use_nav_sat = false, use_landmarks = false, num_laser_scans = 1, num_multi_echo_laser_scans = 0, num_subdivisions_per_laser_scan = 1, num_point_clouds = 0, lookup_transform_timeout_sec = 0.2, submap_publish_period_sec = 0.3, pose_publish_period_sec = 5e-3, trajectory_publish_period_sec = 30e-3, rangefinder_sampling_ratio = 1., odometry_sampling_ratio = 0.3, fixed_frame_pose_sampling_ratio = 1., imu_sampling_ratio = 1., landmarks_sampling_ratio = 1.,&#125;MAP_BUILDER.use_trajectory_builder_2d = trueTRAJECTORY_BUILDER_2D.submaps.num_range_data = 35TRAJECTORY_BUILDER_2D.min_range = 0.3TRAJECTORY_BUILDER_2D.max_range = 8.TRAJECTORY_BUILDER_2D.missing_data_ray_length = 1.-- 决定是否使用imu数据TRAJECTORY_BUILDER_2D.use_imu_data = falseTRAJECTORY_BUILDER_2D.use_online_correlative_scan_matching = trueTRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.linear_search_window = 0.1TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.translation_delta_cost_weight = 10.TRAJECTORY_BUILDER_2D.real_time_correlative_scan_matcher.rotation_delta_cost_weight = 1e-1POSE_GRAPH.optimization_problem.huber_scale = 1e2POSE_GRAPH.optimize_every_n_nodes = 35POSE_GRAPH.constraint_builder.min_score = 0.65return options 参数意义","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"melodic+carto","slug":"melodic+carto","date":"2022-04-16T04:30:12.000Z","updated":"2022-04-18T02:49:01.933Z","comments":true,"path":"2022/04/16/melodic+carto/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/16/melodic+carto/","excerpt":"","text":"参考网址: (124条消息) （实测成功安装）ubuntu18.04+ros(melodic)安装 cartographer安装_我想lu内只狗的博客-CSDN博客 安装carto12345678910111213141516171819# 安装工具sudo apt-get updatesudo apt-get install -y python-wstool python-rosdep ninja-build stow# 创建初始空间mkdir -p cart_ws/srccd cart_wswstool init src # 下载包cd srcgit clone https://ghproxy.com/https://github.com/cartographer-project/cartographergit clone https://ghproxy.com/https://github.com/cartographer-project/cartographer_rosgit clone -b 1.14.x https://ghproxy.com/https://github.com/ceres-solver/ceres-solver# 添加依赖cd .. &amp;&amp;src/cartographer/scripts/install_abseil.shsudo rosdep initrosdep update rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y# 编译安装catkin_make_isolated --install --use-ninja 安装ceres-solver12345git clone https://ceres-solver.googlesource.com/ceres-solvercd ceres-solvermkdir build&amp;&amp;cd buildcmake .. make -j8&amp;&amp;sudo make install 测试测试包 12roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=/home/fairy/Downloads/b0-2014-07-11-11-00-49.bagroslaunch cartographer_ros demo_backpack_3d.launch bag_filename:=/home/fairy/Downloads/b3-2016-03-01-13-39-41.bag 修改~/.bashrc123sudo echo &quot;source ~/cart_ws/devel_isolated/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcecho $ROS_PACKAGE_PATH","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"wsl+docker+ssh+mobaxterm","slug":"wsl+docker+ssh+mobaxterm","date":"2022-04-16T04:30:12.000Z","updated":"2022-04-16T07:00:29.145Z","comments":true,"path":"2022/04/16/wsl+docker+ssh+mobaxterm/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/16/wsl+docker+ssh+mobaxterm/","excerpt":"","text":"参考网址: (124条消息) Docker容器使用MobaXterm连接_wooyang2018的博客-CSDN博客_mobaxterm 连接docker","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"wsl2+docker+carto","slug":"wsl2+docker+carto","date":"2022-04-16T04:30:12.000Z","updated":"2022-04-16T06:03:04.600Z","comments":true,"path":"2022/04/16/wsl2+docker+carto/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/16/wsl2+docker+carto/","excerpt":"","text":"参考网址: (124条消息) 【亲测有效】离线安装WSL windows 10子系统Ubuntu 20.04方法_青柚创客的博客-CSDN博客_wsl 离线安装 Ubuntu - Docker — 从入门到实践 (gitbook.io) Docker快速搭建cartographer/cartographer_ros编译开发环境 - AustinZ的个人空间 - OSCHINA - 中文开源技术交流社区 安装wsl2 配置好wsl2环境( wsl安装 ),离线下载ubuntu18 下载完成后,双击安装 安装docker1234567891011121314151617# 配置httpsudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release# 配置docker下载安装环境 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgecho \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 安装sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io# 启动sudo service docker start 安装docker_carto12345678910111213141516171819202122# 拉取镜像 # ubuntu18.04 docker pull fdko11/ros:bionic-melodic-cartographer # ubuntu20.04 docker pull fdko11/ros:focal-noetic-cartographer# 运行并创建docker docker run -it --name=&quot;carto&quot; --net=host -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix fdko11/ros:bionic-melodic-cartographer# 用户名:carto 密码:123456 有sudo权限# 需要在容器中手动进行一次abseil库编译安装su cartocd /home/carto/carto_ws/abseil-cpp/mkdir buildcd buildcmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DCMAKE_INSTALL_PREFIX=/usr/local/stow/absl ..sudo ninja installcd /usr/local/stowsudo stow absl# 编译cartosu cartocd /home/carto/carto_wssource /opt/ros/melodic/setup.bashcatkin_make_isolated --install --use-ninja","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"gtest安装与使用","slug":"gtest安装与使用","date":"2022-04-15T04:30:12.000Z","updated":"2022-04-25T08:29:06.929Z","comments":true,"path":"2022/04/15/gtest安装与使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/15/gtest%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:(128条消息) cmake + googletest 之一 入门_Joel的小喵咪的博客-CSDN博客 (128条消息) GTest的安装与使用_蕾蕾的好包包的博客-CSDN博客_gtest安装 安装123456git clone https://ghproxy.com/https://github.com/google/googletest.gitcd googletest &amp;&amp; mkdir buildcd build &amp;&amp; cmake ..sudo make -j4 cd lib &amp;&amp; sudo cp *.a /usr/lib 简单使用目录12345678├── CMakeLists.txt├── main.cpp├── src│ └── myproject│ └── myclass.hpp└── test ├── CMakeLists.txt └── test_my_class.cpp 文件(从上到下)1234567891011121314151617181920# CMakeLists.txtcmake_minimum_required(VERSION 3.10)project(MyProject)set(CMAKE_CXX_STANDARD 14)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/src)# 开启测试enable_testing()set(MY_PROJECT_SRC src/myproject/myclass.hpp)add_executable(MyProject $&#123;MY_PROJECT_SRC&#125; main.cpp )# 添加测试目录add_subdirectory(test) 12345678// main.cpp#include&lt;iostream&gt;int main(int argc, char **argv)&#123; std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl; return 0;&#125; 12345678910111213141516171819202122// myclass.hpp#pragma once#include &lt;string&gt;class my_class&#123;public: my_class(const std::string &amp;name, int age) &#123; m_age = age; m_name = name; &#125;public: int get_age() &#123; return m_age; &#125; std::string get_name() &#123; return m_name; &#125;private: int m_age; std::string m_name;&#125;; 123456789101112131415# CMakeLists.txt# 查找 GTest 库find_package(GTest REQUIRED)# GTest 的头文件include_directories($&#123;GTEST_INCLUDE_DIRS&#125;)add_executable(test_my_class test_my_class.cpp)# 链接测试库target_link_libraries( test_my_class $&#123;GTEST_BOTH_LIBRARIES&#125; pthread )# 添加到测试gtest_discover_tests(test_my_class) 12345678910111213141516// test_my_class.cpp#include &lt;gtest/gtest.h&gt;#include &lt;myproject/myclass.hpp&gt;TEST(test_my_class, get_age)&#123; my_class myClass(&quot;Joel&quot;, 21); ASSERT_TRUE(myClass.get_age() == 16) &lt;&lt; &quot;age is not 16&quot;;&#125;TEST(test_my_class, get_name)&#123; my_class myClass(&quot;Joel&quot;, 21); ASSERT_EQ(myClass.get_name(), &quot;Joel&quot;) &lt;&lt; &quot;name is not Joel&quot;;&#125; 具体工具类布尔值检查 Fatal assertion Nonfatal assertion Verifies ASSERT_TRUE(condition); EXPECT_TRUE(condition); condition is true ASSERT_FALSE(condition); EXPECT_FALSE(condition); condition is false 数值型数据检查 Fatal assertion Nonfatal assertion Verifies ASSERT_EQ(expected, actual); EXPECT_EQ(expected, actual); expected == actual ASSERT_NE(val1, val2); EXPECT_NE(val1, val2); val1 != val2 ASSERT_LT(val1, val2); EXPECT_LT(val1, val2); val1 &lt; val2 ASSERT_LE(val1, val2); EXPECT_LE(val1, val2); val1 &lt;= val2 ASSERT_GT(val1, val2); EXPECT_GT(val1, val2); val1 &gt; val2 ASSERT_GE(val1, val2); EXPECT_GE(val1, val2); val1 &gt;= val2 字符串比较 Fatal assertion Nonfatal assertion Verifies ASSERT_STREQ(expected_str, actual_str); EXPECT_STREQ(expected_str, actual_str); 两个C字符串有相同的内容 ASSERT_STRNE(str1, str2); EXPECT_STRNE(str1, str2); 两个C字符串有不同的内容 ASSERT_STRCASEEQ(expected_str, actual_str); EXPECT_STRCASEEQ(expected_str, actual_str); 两个C字符串有相同的内容，忽略大小写 ASSERT_STRCASENE(str1, str2); EXPECT_STRCASENE(str1, str2); 两个C字符串有不同的内容，忽略大小写 异常检查 Fatal assertion Nonfatal assertion Verifies ASSERT_THROW(statement, exception_type); EXPECT_THROW(statement, exception_type); statement throws an exception of the given type ASSERT_ANY_THROW(statement); EXPECT_ANY_THROW(statement); statement throws an exception of any type ASSERT_NO_THROW(statement); EXPECT_NO_THROW(statement); statement doesn’t throw any exception 浮点型检查 Fatal assertion Nonfatal assertion Verifies ASSERT_FLOAT_EQ(expected, actual); EXPECT_FLOAT_EQ(expected, actual); the two float values are almost equal ASSERT_DOUBLE_EQ(expected, actual); EXPECT_DOUBLE_EQ(expected, actual); the two double values are almost equal 邻近值比较 Fatal assertion Nonfatal assertion Verifies ASSERT_NEAR(val1, val2, abs_error); EXPECT_NEAR*(val1, val2, abs_error*); the difference between val1 and val2 doesn’t exceed the given absolute error 事件机制(全局-&gt;TestSuite-&gt;TestCase)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;gtest/gtest.h&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;class Student&#123;public: Student()&#123; age=0; &#125; Student(int a)&#123; age=a; &#125; void print()&#123; cout&lt;&lt;&quot;*********** &quot;&lt;&lt;age&lt;&lt;&quot; **********&quot;&lt;&lt;endl;; &#125; private: int age;&#125;;class FooEnvironment : public testing::Environment&#123;public: virtual void SetUp() &#123; std::cout &lt;&lt; &quot;Foo FooEnvironment SetUP&quot; &lt;&lt; std::endl; &#125; virtual void TearDown() &#123; std::cout &lt;&lt; &quot;Foo FooEnvironment TearDown&quot; &lt;&lt; std::endl; &#125;&#125;;static Student *s;//在第一个test之前，最后一个test之后调用SetUpTestCase()和TearDownTestCase()class TestMap:public testing::Test&#123;public: static void SetUpTestCase() &#123; cout&lt;&lt;&quot;SetUpTestCase()&quot;&lt;&lt;endl; s=new Student(23); &#125; static void TearDownTestCase() &#123; delete s; cout&lt;&lt;&quot;TearDownTestCase()&quot;&lt;&lt;endl; &#125; void SetUp() &#123; cout&lt;&lt;&quot;SetUp() is running&quot;&lt;&lt;endl; &#125; void TearDown() &#123; cout&lt;&lt;&quot;TearDown()&quot;&lt;&lt;endl; &#125; &#125;; TEST_F(TestMap, Test1) &#123; // you can refer to s here s-&gt;print();&#125;int main(int argc, char** argv)&#123; testing::AddGlobalTestEnvironment(new FooEnvironment); testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125;","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"内存泄漏","slug":"检查内存泄漏","date":"2022-04-15T04:30:12.000Z","updated":"2022-04-25T08:47:05.759Z","comments":true,"path":"2022/04/15/检查内存泄漏/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/15/%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"参考网址:(128条消息) 内存泄漏检查工具_comochris的博客-CSDN博客_内存泄露检测工具 (128条消息) valgrind简介与使用_WuYuJun’s blog的博客-CSDN博客_valgrind (128条消息) 几种内存泄露检测工具的比较_cym64039的博客-CSDN博客 安装12345678# 下载(https://valgrind.org/downloads/current.html#current)# https://sourceware.org/pub/valgrind/valkyrie-2.0.0.tar.bz2# https://sourceware.org/pub/valgrind/valgrind-3.19.0.tar.bz2wget https://sourceware.org/pub/valgrind/valgrind-3.19.0.tar.bz2cd valgrind-3.19.0./configuresudo makemake install 简单使用:注意(gcc/g++都需要加上-g选项)123456789101112131415// valgrind_test.c#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void fun(void)&#123; int *x = malloc(10*sizeof(int)); x [10] = 0; //问题1：堆块溢出&#125; //问题2：内存泄漏 - x未释放 int main(int argc, char **argv) &#123; fun() ; return 0 ;&#125; 12gcc -g valgrind_test.c -o valgrind_testvalgrind --leak-check=yes ./valgrind_test 常见内存问题具体参考 12345671. 动态内存泄露；2. 资源泄露，比如文件指针不关闭；3. 动态内存越界；4.数组内存越界；5.动态内存double free；6.使用野指针，即未初始化的指针；7.释放野指针，即未初始化的指针。","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"map_tp_map方法实现的回环检测","slug":"map_tp_map方法实现的回环检测","date":"2022-04-01T04:30:12.000Z","updated":"2022-04-02T07:52:29.100Z","comments":true,"path":"2022/04/01/map_tp_map方法实现的回环检测/","link":"","permalink":"https://peitianyu.github.io/blog/2022/04/01/map_tp_map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B/","excerpt":"","text":"参考网址: A Triangle Feature Based Map-to-map Matching and Loop Closure for 2D Graph SLAM 步骤 建图步:通过csm于pl-icp建图 通过SIFT,SURF,ORB等方式对全局地图与子图选择特征角点 通过L1≥L2≥L3的方式设置三角形(L1=|x1-x2|,L2=|x2-x3|,L3=|x1-x3|) ,分别将全局地图与子图x1,x2,x3分别放入三个数组中备用,记为Tk(3)与Tl(3) 根据以下公式,筛选出合适的对应点,但实际上两个距离只能达到大致相等,因此需要加一个阈值,阈值函数如下,找出全等三角形$$dist^{k}\\left ( t_{k}^{i}\\left ( 1 \\right ),t_{k}^{i}\\left ( 2 \\right ) \\right )\\approx dist^{l}\\left ( t_{l}^{i}\\left ( 1 \\right ),t_{l}^{i}\\left ( 2 \\right ) \\right );\\ dist^{k}\\left ( t_{k}^{i}\\left ( 2 \\right ),t_{k}^{i}\\left ( 3 \\right ) \\right )\\approx dist^{l}\\left ( t_{l}^{i}\\left ( 2 \\right ),t_{l}^{i}\\left ( 3 \\right ) \\right );\\ dist^{k}\\left ( t_{k}^{i}\\left ( 1 \\right ),t_{k}^{i}\\left ( 3 \\right ) \\right )\\approx dist^{l}\\left ( t_{l}^{i}\\left ( 1 \\right ),t_{l}^{i}\\left ( 3 \\right ) \\right );\\ \\frac{\\left| x1 -x2 \\right|}{min\\left ( x1,x2 \\right )} &lt; 0.03$$4. 根据找出的全等三角形可以得到数组(dX,dY,dTheta),对dTheta在(-pi~pi)上的投票,选出合适的数组(dX,dY,dTheta),通过阈值将不太可能的数组过滤掉5. 通过二部图匹配,km算法最终得到(dX,dY,dTheta),也即得到了初步定位坐标6. 使用icp算法做最后的精细定位 加速算法 在生成三角形时注意可以设置长边阈值,大于最大长边的三角形不生成 在进行第3步的时候可以先进行排序,后进行筛选 在第四步投票时可以通过部分采样的方式,选取一定量样本,加快投票速度","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"ubuntu18查看磁盘占用","slug":"ubuntu18查看磁盘占用","date":"2022-03-30T04:30:12.000Z","updated":"2022-03-30T05:43:06.666Z","comments":true,"path":"2022/03/30/ubuntu18查看磁盘占用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/30/ubuntu18%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8/","excerpt":"","text":"参考网址: (121条消息) ubuntu查看磁盘占用和分配情况_forAllforMe的博客-CSDN博客_ubuntu 查看磁盘占用 df -hl12345678Filesystem Size Used Avail Use% Mounted onudev 978M 0 978M 0% /devtmpfs 200M 3.6M 197M 2% /run/dev/sda5 28G 12G 15G 45% /tmpfs 1000M 216K 999M 1% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 1000M 0 1000M 0% /sys/fs/cgrouptmpfs 200M 52K 200M 1% /run/user/1000 sudo fdisk -l1234567891011Disk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x0b032873Device Boot Start End Sectors Size Id Type/dev/sda1 * 2046 60547071 60545026 28.9G 5 Extended/dev/sda5 2048 58593279 58591232 28G 83 Linux/dev/sda6 58595328 60547071 1951744 953M 82 Linux swap / Solaris free -m 查看内存12345lostman@lostman-MS-6702E:~/桌面$ free -m total used free shared buffers cachedMem: 496 457 38 0 8 104-/+ buffers/cache: 344 151Swap: 510 156 354 top 查看内存与cpu","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"微雪树莓派安装ubuntu18_server","slug":"微雪树莓派安装ubuntu18_server","date":"2022-03-30T04:30:12.000Z","updated":"2022-03-30T05:19:06.275Z","comments":true,"path":"2022/03/30/微雪树莓派安装ubuntu18_server/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/30/%E5%BE%AE%E9%9B%AA%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/","excerpt":"","text":"参考网址: CM4 Burn EMMC - Waveshare Wiki 步骤 安装 rpiboot 软件 将 BOOT开关拨至ON 打开 rpiboot软件,会出现如下,说明已经连接上树莓派 安装树莓派镜像烧录器 下载[ubuntu8_server]( Index of /ubuntu-cdimage/ubuntu/releases/18.04.5/release/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror ) 使用树莓派烧录器安装ubuntu18_server 完成后重启树莓派,修改boot下network-config与user-data 1234567891011121314version: 2ethernets: eth0: dhcp4: false addresses: [192.168.8.110/24] eth1: dhcp4: false addresses: [192.168.8.111/24]wifis: wlan0: access-points: HUAWEI_PTY: password: pty123456787 dhcp4: true 12345ssh_pwauth: truechpasswd: expire: false list: - ubuntu:ubuntu USB2.0 默认是关闭的，如需打开需要在config.txt中添加 dtoverlay=dwc2,dr_mode=host 将 BOOT开关拨至OFF,连接显示屏查看ip 使用sudo systemctl enable ssh与sudo systemctl start ssh启动ssh 通过ssh &#x75;&#x62;&#117;&#x6e;&#x74;&#117;&#64;&#49;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#x38;&#46;&#x31;&#x31;&#x30;连接树莓派","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"path_plan","slug":"path_plan","date":"2022-03-21T04:30:12.000Z","updated":"2022-03-21T05:25:06.750Z","comments":true,"path":"2022/03/21/path_plan/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/21/path_plan/","excerpt":"","text":"参考网址: 运动规划_哔哩哔哩_bilibili teamo1996/Motion-plan: 深蓝运动规划课程 (github.com) 机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) 简介基于搜索 bfs/dfs Djikstra A* jps 基于采样 dwa RRT / RRT* / nformed RRT* 基于动力学约束 状态栅格搜索算法(State Lattice Search) OBVP 虚拟力场 VFF VFH / VFH+ / VFH*","categories":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"}],"tags":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"}]},{"title":"图优化","slug":"图优化","date":"2022-03-21T04:30:12.000Z","updated":"2022-03-22T00:07:40.041Z","comments":true,"path":"2022/03/21/图优化/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/21/%E5%9B%BE%E4%BC%98%E5%8C%96/","excerpt":"","text":"参考网址: (116条消息) 图优化一_a4zhangfei的博客-CSDN博客_图优化 AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) 图优化理解通过顶点与边构成相互约束,从而构建残差方程,然后通过最小二乘求解坐标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307import copyimport itertoolsimport mathimport matplotlib.pyplot as pltimport numpy as npfrom scipy.spatial.transform import Rotation as Rot# Simulation parameterQ_sim = np.diag([0.2, np.deg2rad(1.0)]) ** 2R_sim = np.diag([0.1, np.deg2rad(10.0)]) ** 2DT = 2.0 # time tick [s]SIM_TIME = 100.0 # simulation time [s]MAX_RANGE = 30.0 # maximum observation rangeSTATE_SIZE = 3 # State size [x,y,yaw]# Covariance parameter of Graph Based SLAMC_SIGMA1 = 0.1C_SIGMA2 = 0.1C_SIGMA3 = np.deg2rad(1.0)MAX_ITR = 20 # Maximum iterationshow_graph_d_time = 20.0 # [s]show_animation = Trueclass Edge: def __init__(self): self.e = np.zeros((3, 1)) self.omega = np.zeros((3, 3)) # information matrix self.d1 = 0.0 self.d2 = 0.0 self.yaw1 = 0.0 self.yaw2 = 0.0 self.angle1 = 0.0 self.angle2 = 0.0 self.id1 = 0 self.id2 = 0def cal_observation_sigma(): sigma = np.zeros((3, 3)) sigma[0, 0] = C_SIGMA1 ** 2 sigma[1, 1] = C_SIGMA2 ** 2 sigma[2, 2] = C_SIGMA3 ** 2 return sigmadef calc_rotational_matrix(angle): return Rot.from_euler(&#x27;z&#x27;, angle).as_matrix()def calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1, angle1, d2, angle2, t1, t2): edge = Edge() tangle1 = pi_2_pi(yaw1 + angle1) tangle2 = pi_2_pi(yaw2 + angle2) tmp1 = d1 * math.cos(tangle1) tmp2 = d2 * math.cos(tangle2) tmp3 = d1 * math.sin(tangle1) tmp4 = d2 * math.sin(tangle2) edge.e[0, 0] = x2 - x1 - tmp1 + tmp2 edge.e[1, 0] = y2 - y1 - tmp3 + tmp4 edge.e[2, 0] = 0 Rt1 = calc_rotational_matrix(tangle1) Rt2 = calc_rotational_matrix(tangle2) sig1 = cal_observation_sigma() sig2 = cal_observation_sigma() edge.omega = np.linalg.inv(Rt1 @ sig1 @ Rt1.T + Rt2 @ sig2 @ Rt2.T) edge.d1, edge.d2 = d1, d2 edge.yaw1, edge.yaw2 = yaw1, yaw2 edge.angle1, edge.angle2 = angle1, angle2 edge.id1, edge.id2 = t1, t2 return edgedef calc_edges(x_list, z_list): # 计算边,并构建残差方程 edges = [] cost = 0.0 z_ids = list(itertools.combinations(range(len(z_list)), 2)) for (t1, t2) in z_ids: x1, y1, yaw1 = x_list[0, t1], x_list[1, t1], x_list[2, t1] x2, y2, yaw2 = x_list[0, t2], x_list[1, t2], x_list[2, t2] if z_list[t1] is None or z_list[t2] is None: continue # No observation for iz1 in range(len(z_list[t1][:, 0])): for iz2 in range(len(z_list[t2][:, 0])): if z_list[t1][iz1, 3] == z_list[t2][iz2, 3]: d1 = z_list[t1][iz1, 0] angle1, phi1 = z_list[t1][iz1, 1], z_list[t1][iz1, 2] d2 = z_list[t2][iz2, 0] angle2, phi2 = z_list[t2][iz2, 1], z_list[t2][iz2, 2] edge = calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1, angle1, d2, angle2, t1, t2) edges.append(edge) cost += (edge.e.T @ edge.omega @ edge.e)[0, 0] print(&quot;cost:&quot;, cost, &quot;,n_edge:&quot;, len(edges)) return edgesdef calc_jacobian(edge): t1 = edge.yaw1 + edge.angle1 A = np.array([[-1.0, 0, edge.d1 * math.sin(t1)], [0, -1.0, -edge.d1 * math.cos(t1)], [0, 0, 0]]) t2 = edge.yaw2 + edge.angle2 B = np.array([[1.0, 0, -edge.d2 * math.sin(t2)], [0, 1.0, edge.d2 * math.cos(t2)], [0, 0, 0]]) return A, Bdef fill_H_and_b(H, b, edge): A, B = calc_jacobian(edge) # 计算jacobian矩阵 id1 = edge.id1 * STATE_SIZE id2 = edge.id2 * STATE_SIZE H[id1:id1 + STATE_SIZE, id1:id1 + STATE_SIZE] += A.T @ edge.omega @ A H[id1:id1 + STATE_SIZE, id2:id2 + STATE_SIZE] += A.T @ edge.omega @ B H[id2:id2 + STATE_SIZE, id1:id1 + STATE_SIZE] += B.T @ edge.omega @ A H[id2:id2 + STATE_SIZE, id2:id2 + STATE_SIZE] += B.T @ edge.omega @ B b[id1:id1 + STATE_SIZE] += (A.T @ edge.omega @ edge.e) b[id2:id2 + STATE_SIZE] += (B.T @ edge.omega @ edge.e) return H, bdef graph_based_slam(x_init, hz): print(&quot;start graph based slam&quot;) z_list = copy.deepcopy(hz) x_opt = copy.deepcopy(x_init) nt = x_opt.shape[1] n = nt * STATE_SIZE # 高斯牛顿法迭代结果 for itr in range(MAX_ITR): edges = calc_edges(x_opt, z_list) H = np.zeros((n, n)) b = np.zeros((n, 1)) for edge in edges: H, b = fill_H_and_b(H, b, edge) # 计算H矩阵和b矩阵 # to fix origin H[0:STATE_SIZE, 0:STATE_SIZE] += np.identity(STATE_SIZE) dx = - np.linalg.inv(H) @ b # 计算残差方程的解 for i in range(nt): x_opt[0:3, i] += dx[i * 3:i * 3 + 3, 0] # 更新状态 diff = dx.T @ dx print(&quot;iteration: %d, diff: %f&quot; % (itr + 1, diff)) if diff &lt; 1.0e-5: break return x_optdef calc_input(): v = 1.0 # [m/s] yaw_rate = 0.1 # [rad/s] u = np.array([[v, yaw_rate]]).T return udef observation(xTrue, xd, u, RFID): xTrue = motion_model(xTrue, u)# 获得预测状态 # add noise to gps x-y z = np.zeros((0, 4)) for i in range(len(RFID[:, 0])): dx = RFID[i, 0] - xTrue[0, 0] dy = RFID[i, 1] - xTrue[1, 0] d = math.hypot(dx, dy) # 计算距离 angle = pi_2_pi(math.atan2(dy, dx)) - xTrue[2, 0] phi = pi_2_pi(math.atan2(dy, dx)) if d &lt;= MAX_RANGE: dn = d + np.random.randn() * Q_sim[0, 0] # add noise 添加状态噪声 angle_noise = np.random.randn() * Q_sim[1, 1] # add noise angle += angle_noise phi += angle_noise zi = np.array([dn, angle, phi, i])# 观测值 z = np.vstack((z, zi)) # 将观测值添加到z中 # add noise to input 添加控制噪声 ud1 = u[0, 0] + np.random.randn() * R_sim[0, 0] ud2 = u[1, 0] + np.random.randn() * R_sim[1, 1] ud = np.array([[ud1, ud2]]).T xd = motion_model(xd, ud) # 预测RFID状态 return xTrue, z, xd, ud # 车体真实值，观测RFID状态,预测车体状态，控制噪声def motion_model(x, u): # 状态方程,运动模型 F = np.array([[1.0, 0, 0], [0, 1.0, 0], [0, 0, 1.0]]) B = np.array([[DT * math.cos(x[2, 0]), 0], [DT * math.sin(x[2, 0]), 0], [0.0, DT]]) x = F @ x + B @ u return xdef pi_2_pi(angle): return (angle + math.pi) % (2 * math.pi) - math.pidef main(): print(__file__ + &quot; start!!&quot;) time = 0.0 # RFID positions [x, y, yaw] RFID = np.array([[10.0, -2.0, 0.0], [15.0, 10.0, 0.0], [3.0, 15.0, 0.0], [-5.0, 20.0, 0.0], [-5.0, 5.0, 0.0] ]) # State Vector [x y yaw v]&#x27; xTrue = np.zeros((STATE_SIZE, 1)) xDR = np.zeros((STATE_SIZE, 1)) # Dead reckoning 航位推测法 # history hxTrue = [] hxDR = [] hz = [] d_time = 0.0 init = False while SIM_TIME &gt;= time: if not init: hxTrue = xTrue hxDR = xTrue init = True else: hxDR = np.hstack((hxDR, xDR)) hxTrue = np.hstack((hxTrue, xTrue)) time += DT d_time += DT u = calc_input()# 输入控制量(v, w) xTrue, z, xDR, ud = observation(xTrue, xDR, u, RFID)# 车体真实值，观测RFID状态,预测车体状态，控制噪声 hz.append(z) if d_time &gt;= show_graph_d_time: x_opt = graph_based_slam(hxDR, hz)# 输入,航测推测位姿值与观测RFID值 d_time = 0.0 if show_animation: # pragma: no cover plt.cla() # for stopping simulation with the esc key. plt.gcf().canvas.mpl_connect( &#x27;key_release_event&#x27;, lambda event: [exit(0) if event.key == &#x27;escape&#x27; else None]) plt.plot(RFID[:, 0], RFID[:, 1], &quot;*k&quot;) plt.plot(hxTrue[0, :].flatten(), hxTrue[1, :].flatten(), &quot;-b&quot;) plt.plot(hxDR[0, :].flatten(), hxDR[1, :].flatten(), &quot;-k&quot;) plt.plot(x_opt[0, :].flatten(), x_opt[1, :].flatten(), &quot;-r&quot;) plt.axis(&quot;equal&quot;) plt.grid(True) plt.title(&quot;Time&quot; + str(time)[0:5]) plt.pause(1.0)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"matlab中文乱码","slug":"matlab中文乱码","date":"2022-03-20T04:30:12.000Z","updated":"2022-03-20T09:08:52.199Z","comments":true,"path":"2022/03/20/matlab中文乱码/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/20/matlab%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"参考网址 (116条消息) 解决matlab打开.m文件中文注释乱码问题_童童同学的博客-CSDN博客_.m文件中文乱码 步骤 查看当前matlab编码格式 123slCharacterEncoding()% 乱码一般显示为:ans = &#x27;GBK&#x27; 打开matlab/bin文件夹,将 lcdata_utf8.xml 文件复制并重命名为 lcdata.xml ,若存在该文件,将其改名,保存,文件结构与如下 打开 新复制的lcdata.xml,并删除 123&lt;encoding name=”GBK”&gt; &lt; encoding_alias name=”936”&gt; &lt;/encoding&gt; 修改并加入 123456789修改前&lt;encoding name=”UTF-8”&gt; &lt;encoding_alias name=”utf8”/&gt; &lt;/encoding&gt; 修改后&lt;encoding name=”UTF-8”&gt; &lt;encoding_alias name=”utf8”/&gt; &lt;encoding_alias name=”GBK”/&gt; &lt;/encoding&gt; 保存并重启matlab","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"jps","slug":"jps","date":"2022-03-18T04:30:12.000Z","updated":"2022-03-21T02:30:11.516Z","comments":true,"path":"2022/03/18/jps/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/18/jps/","excerpt":"","text":"参考网址: (116条消息) JPS算法_Jason.Li_0012的博客-CSDN博客_jps 算法 运动规划_哔哩哔哩_bilibili YYRise/jps: python实现跳点寻路算法（JPS：Jump Point Search） (github.com) 最快速的寻路算法 Jump Point Search - 知乎 (zhihu.com) 算法流程 与A*算法流程完全一样,只是对于邻接节点的定义不同, A∗算法的邻居节点为几何意义上的邻居，而Jps算法的邻居节点为跳跃所得的邻居。 1234567891011开始 将起点放入open list中 while true if open list 为空 搜索失败,结束 取open list中最小节点 if 节点为终点 找到路径,结束 拓展该节点子节点 将节点放入closed list中结束 修剪邻居节点与跳转规则 jps代码123456789101112131415161718192021222324# 查找路径的入口函数def find_path(self, s_pos, e_pos): self.s_pos, self.e_pos = s_pos, e_pos # 构建开始节点 p = Node(None, self.s_pos, 0, abs(self.s_pos[0]-self.e_pos[0]) + abs(self.s_pos[1]-self.e_pos[1])) self.open.append(p) while True: # 扩展F值最小的节点 # 如果开放列表为空，则不存在路径，返回 if not self.open: return &quot;not find&quot; # 获取F值最小的节点 idx, p = self.get_min_f_node() print(&quot;find path with extend_round(%d, %d), open_list = %s&quot; % (p.pos[0], p.pos[1], [[n.pos[0], n.pos[1]] for n in self.open])) # 找到路径，生成路径，返回 if self.is_target(p): self.make_path(p) return # 扩展该节点的子节点 self.extend_round(p) # 把此节点压入关闭列表，并从开放列表里删除 self.close.append(p) del self.open[idx] 12345678910111213141516171819202122232425# 扩展该节点的子节点def extend_round(self, c): # 修剪邻近节点 nbs = self.prune_neighbours(c) print &quot;************[%d, %d] --- %s, parent = [%d, %d]&quot; % (c.pos[0], c.pos[1], nbs, c.pos[0], c.pos[1]) for n in nbs: jp = self.jump_node(n,[c.pos[0], c.pos[1]])# 跳跃节点 print &quot;expandSuccessors:parent = %s, nb = %s, jp = %s&quot; % ([c.pos[0], c.pos[1]], n, jp) if jp: if self.node_in_close(jp): continue g = self.get_g(jp, c.pos) h = self.get_h(jp, self.e_pos) node = Node(c, jp, c.g + g, h) i = self.node_in_open(node) if i != -1: # 新节点在开放列表 if self.open[i].g &gt; node.g: # 现在的路径到比以前到这个节点的路径更好~ # 则使用现在的路径 self.open[i].parent = c self.open[i].g = node.g self.open[i].f = node.g + self.open[i].h continue self.open.append(node) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 修剪邻居节点def prune_neighbours(self, c): nbs = [] # 不是起始点 if c.parent: # 进入的方向 dir = c.get_direction() if self.is_pass(c.pos[0] + dir[0], c.pos[1] + dir[1]): nbs.append([c.pos[0] + dir[0], c.pos[1] + dir[1]]) print &quot;dir = &quot;, dir # 对角线行走; eg:右下(1, 1) if dir[0] != 0 and dir[1] != 0: # 下（0， 1） if self.is_pass(c.pos[0], c.pos[1] + dir[1]): nbs.append([c.pos[0], c.pos[1] + dir[1]]) # 右（1， 0） if self.is_pass(c.pos[0]+dir[0], c.pos[1]): nbs.append([c.pos[0]+dir[0], c.pos[1]]) # 左不能走且下可走 if not self.is_pass(c.pos[0] - dir[0], c.pos[1]) and self.is_pass(c.pos[0], c.pos[1] + dir[1]): # 左下（-1， 1） nbs.append([c.pos[0] - dir[0], c.pos[1] + dir[1]]) # 上不能走且右可走 if not self.is_pass(c.pos[0], c.pos[1]-dir[1]) and self.is_pass(c.pos[0]+dir[0], c.pos[1]): # 右上（1， -1） nbs.append([c.pos[0]+dir[0], c.pos[1]-dir[1]]) else: # 直行 # 垂直走 if dir[0] == 0: # 右不能走 if not self.is_pass(c.pos[0]+1, c.pos[1]): # 右下 nbs.append([c.pos[0]+1, c.pos[1]+dir[1]]) # 左不能走 if not self.is_pass(c.pos[0]-1, c.pos[1]): # 左下 nbs.append([c.pos[0]-1, c.pos[1]+dir[1]]) else: # 水平走，向右走为例 # 下不能走 if not self.is_pass(c.pos[0], c.pos[1]+1): # 右下 nbs.append([c.pos[0]+dir[0], c.pos[1]+1]) # 上不能走 if not self.is_pass(c.pos[0], c.pos[1]-1): # 右上 nbs.append([c.pos[0]+dir[0], c.pos[1]-1]) else: for d in g_dir: if self.is_pass(c.pos[0] + d[0], c.pos[1] + d[1]): nbs.append([c.pos[0] + d[0], c.pos[1] + d[1]]) print &quot;prune_neighbours c= %s, nbs = %s&quot; % ([c.pos[0], c.pos[1]], nbs) return nbs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# ↑ ↓ ← → ↖ ↙ ↗ ↘ def jump_node(self, now, pre): dir = [a != b and (a - b)/abs(a-b) or 0 for a, b in zip(now, pre)] print &quot;now = %s, pre = %s, dir = %s&quot; %(now, pre, dir) if now == self.e_pos: return now if self.is_pass(now[0], now[1]) is False: return None if dir[0] != 0 and dir[1] != 0: # 左下能走且左不能走，或右上能走且上不能走 if (self.is_pass(now[0] - dir[0], now[1] + dir[1]) and not self.is_pass(now[0]-dir[0], now[1])) or (self.is_pass(now[0] + dir[0], now[1] - dir[1]) and not self.is_pass(now[0], now[1]-dir[1])): return now else: # 水平方向 if dir[0] != 0: # 右下能走且下不能走， 或右上能走且上不能走 &#x27;&#x27;&#x27; * 1 0 0 0 0 0 → 0 0 0 0 * 1 0 0 0 0 &#x27;&#x27;&#x27; print &#x27;水平方向:&#x27;, self.is_pass(now[0] + dir[0], now[1] + 1), self.is_pass(now[0], now[1]+1), self.is_pass(now[0] + dir[0], now[1] - 1), self.is_pass(now[0], now[1]-1) if (self.is_pass(now[0] + dir[0], now[1] + 1) and not self.is_pass(now[0], now[1]+1)) or (self.is_pass(now[0] + dir[0], now[1] - 1) and not self.is_pass(now[0], now[1]-1)): return now else: # 垂直方向 # 右下能走且右不能走，或坐下能走且左不能走 &#x27;&#x27;&#x27; 0 0 0 1 ↓ 1 0 0 0 &#x27;&#x27;&#x27; print &#x27;垂直方向:&#x27;, self.is_pass(now[0] + 1, now[1] + dir[1]), self.is_pass(now[0] + 1, now[1]), self.is_pass(now[0]-1 , now[1] + dir[1]), self.is_pass(now[0] - 1, now[1]) if (self.is_pass(now[0] + 1, now[1] + dir[1]) and not self.is_pass(now[0]+1, now[1])) or (self.is_pass(now[0] - 1, now[1] + dir[1]) and not self.is_pass(now[0]-1, now[1])): return now if dir[0] != 0 and dir[1] != 0: t1 = self.jump_node([now[0]+dir[0], now[1]], now) t2 = self.jump_node([now[0], now[1] + dir[1]], now) if t1 or t2: return now if self.is_pass(now[0] + dir[0], now[1]) or self.is_pass(now[0], now[1] + dir[1]): t = self.jump_node([now[0] + dir[0], now[1] + dir[1]], now) if t: return t return None","categories":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"}],"tags":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"}]},{"title":"线性二次型调节器(lqr)","slug":"lqr","date":"2022-03-18T04:30:12.000Z","updated":"2022-03-20T05:33:58.919Z","comments":true,"path":"2022/03/18/lqr/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/18/lqr/","excerpt":"","text":"参考网址 (116条消息) LQR 的直观推导及简单应用_白巧克力亦唯心的博客-CSDN博客_lqr算法 路径规划与轨迹跟踪系列算法学习_第12讲_线性二次型调节器(LQR)法_哔哩哔哩_bilibili https://github.com/AtsushiSakai/PythonRobotics 解释 对于一个线性系统可以用x_dot = Ax +Bu表示,参考全反馈控制模型,我们需要设计一个状态反馈控制器,表示为 u = -Kx,使得闭环系统满足我们的期望性能.因此可以可得到状态方程为x_dot = (A-BK)x=Acx 通过设计一款能量函数,如下,希望最优的控制轨迹应该使得该能量函数最小 ​ 由于u = -Kx,我们可以得到, 为便于求解K,引入常矩阵P,最终化简可以得到 lqr求解流程 选择参数矩阵Q,R 求解Riccati 方程得到矩阵P 计算 : K = R*-1* BT P lqr结构图 程序 倒立摆的状态变量为x=[p,p_dot,the,the_dot]T,其中p(t)是小车位置，θ是倒立摆的角度,这里直接调用matlab中lqr 1234567891011121314151617181920212223A = [0 1 0 0 0 0 -1 0 0 0 0 1 0 0 9 0];B = [0;0.1;0;-0.1];C = [0 0 1 0]; %观测角度D = 0;Q = [1 0 0 0 0 1 0 0 0 0 10 0 0 0 0 10 ];R = 0.1;%由上面这个系统，可以计算出KK = lqr(A,B,Q,R);Ac = A - B*K;%对系统进行模拟x0 = [0.1;0;0.1;0]; %初始状态t = 0:0.05:20;u = zeros(size(t));[y,x]=lsim(Ac,B,C,D,u,t,x0); plot(t,y); python实现dlqr1234567891011121314151617181920212223242526272829303132def solve_DARE(A, B, Q, R): &quot;&quot;&quot; solve a discrete time_Algebraic Riccati equation (DARE) &quot;&quot;&quot; X = Q maxiter = 150 eps = 0.01 for i in range(maxiter): Xn = A.T @ X @ A - A.T @ X @ B @ \\ la.inv(R + B.T @ X @ B) @ B.T @ X @ A + Q if (abs(Xn - X)).max() &lt; eps: break X = Xn return Xndef dlqr(A, B, Q, R): &quot;&quot;&quot;Solve the discrete time lqr controller. x[k+1] = A x[k] + B u[k] cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k] # ref Bertsekas, p.151 &quot;&quot;&quot; # first, try to solve the ricatti equation X = solve_DARE(A, B, Q, R) # compute the LQR gain K = la.inv(B.T @ X @ B + R) @ (B.T @ X @ A) eigVals, eigVecs = la.eig(A - B @ K) return K, X, eigVals 注意这里的A,B使用的是frenet坐标系 主要是[e,e_dot,the_e,the_e_dot] 关于加入纵向控制lqr算法注意: x = [e, dot_e, th_e, dot_th_e, delta_v],当然相关的A,B,Q,R同样修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def lqr_speed_steering_control(state, cx, cy, cyaw, ck, pe, pth_e, sp, Q, R): ind, e = calc_nearest_index(state, cx, cy, cyaw) tv = sp[ind] k = ck[ind] v = state.v th_e = pi_2_pi(state.yaw - cyaw[ind]) # A = [1.0, dt, 0.0, 0.0, 0.0 # 0.0, 0.0, v, 0.0, 0.0] # 0.0, 0.0, 1.0, dt, 0.0] # 0.0, 0.0, 0.0, 0.0, 0.0] # 0.0, 0.0, 0.0, 0.0, 1.0] A = np.zeros((5, 5)) A[0, 0] = 1.0 A[0, 1] = dt A[1, 2] = v A[2, 2] = 1.0 A[2, 3] = dt A[4, 4] = 1.0 # B = [0.0, 0.0 # 0.0, 0.0 # 0.0, 0.0 # v/L, 0.0 # 0.0, dt] B = np.zeros((5, 2)) B[3, 0] = v / L B[4, 1] = dt K, _, _ = dlqr(A, B, Q, R) # state vector # x = [e, dot_e, th_e, dot_th_e, delta_v] # e: lateral distance to the path # dot_e: derivative of e # th_e: angle difference to the path # dot_th_e: derivative of th_e # delta_v: difference between current speed and target speed x = np.zeros((5, 1)) x[0, 0] = e x[1, 0] = (e - pe) / dt x[2, 0] = th_e x[3, 0] = (th_e - pth_e) / dt x[4, 0] = v - tv # input vector # u = [delta, accel] # delta: steering angle # accel: acceleration ustar = -K @ x # calc steering input ff = math.atan2(L * k, 1) # feedforward steering angle fb = pi_2_pi(ustar[0, 0]) # feedback steering angle delta = ff + fb # calc accel input accel = ustar[1, 0] return delta, ind, e, th_e, accel","categories":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/categories/path-tracking/"}],"tags":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/tags/path-tracking/"}]},{"title":"path_tracking","slug":"path_tracking","date":"2022-03-17T04:30:12.000Z","updated":"2022-03-20T04:09:40.125Z","comments":true,"path":"2022/03/17/path_tracking/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/17/path_tracking/","excerpt":"","text":"参考网址 (116条消息) 智能驾驶车辆横向控制算法_肥嘟嘟的左卫门的博客-CSDN博客_汽车横向控制和纵向控制 (116条消息) 基于车辆模型的横向控制方法_氢键H-H的博客-CSDN博客_车辆横向控制 走进自动驾驶横向控制，你需要这篇超长综述 - 知乎 (zhihu.com) 忠厚老实的老王的个人空间_哔哩哔哩_bilibili 小黎的Ally的个人空间_哔哩哔哩_bilibili 机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili","categories":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/categories/path-tracking/"}],"tags":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/tags/path-tracking/"}]},{"title":"pure_pursuit","slug":"pure_pursuit","date":"2022-03-17T04:30:12.000Z","updated":"2022-03-20T05:28:43.182Z","comments":true,"path":"2022/03/17/pure_pursuit/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/17/pure_pursuit/","excerpt":"","text":"参考网址 路径规划与轨迹跟踪系列算法学习_第10讲_纯跟踪法_哔哩哔哩_bilibili (116条消息) 无人车系统（五）：轨迹跟踪Pure Pursuit方法_windSeS的博客-CSDN博客 AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) 算法流程: 代码1234567891011121314151617181920212223242526272829303132def search_target_index(self, state): # To speed up nearest point search, doing it at only first time. if self.old_nearest_point_index is None: # search nearest point index dx = [state.rear_x - icx for icx in self.cx] dy = [state.rear_y - icy for icy in self.cy] d = np.hypot(dx, dy) ind = np.argmin(d) self.old_nearest_point_index = ind else: ind = self.old_nearest_point_index distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind]) while True: distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1]) if distance_this_index &lt; distance_next_index: break ind = ind + 1 if (ind + 1) &lt; len(self.cx) else ind distance_this_index = distance_next_index self.old_nearest_point_index = ind Lf = k * state.v + Lfc # update look ahead distance #更新前瞻距离,与速度有关 # search look ahead target point index # 搜索前瞻目标点索引 while Lf &gt; state.calc_distance(self.cx[ind], self.cy[ind]): if (ind + 1) &gt;= len(self.cx): break # not exceed goal ind += 1 return ind, Lf 12345678910111213141516171819def pure_pursuit_steer_control(state, trajectory, pind): ind, Lf = trajectory.search_target_index(state) if pind &gt;= ind: ind = pind if ind &lt; len(trajectory.cx): tx = trajectory.cx[ind] ty = trajectory.cy[ind] else: # toward goal tx = trajectory.cx[-1] ty = trajectory.cy[-1] ind = len(trajectory.cx) - 1 alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0) return delta, ind","categories":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/categories/path-tracking/"}],"tags":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/tags/path-tracking/"}]},{"title":"RRT","slug":"RRT","date":"2022-03-16T04:30:12.000Z","updated":"2022-03-19T08:53:45.877Z","comments":true,"path":"2022/03/16/RRT/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/16/RRT/","excerpt":"","text":"参考网址: IR艾若机器人的个人空间_哔哩哔哩_bilibili AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) (115条消息) 快速随机搜索树（RRT）的MATLAB代码实现_露摇芝麻粒的博客-CSDN博客_快速搜索随机树 算法流程 12340 初始化起点,终点坐标1 采样点,采样点与步长连线2 根据一定步长判断是否中间有障碍物,若没有生成新节点3 一直循环,直到新节点跟终点距离在一定范围内,我们判断为找到终点 代码实现有一个小技巧,可以在获得随机点ian加入以终点为随机点的可能性 123456789101112131415161718192021222324252627282930313233343536def planning(self, animation=True): &quot;&quot;&quot; rrt path planning animation: flag for animation on or off &quot;&quot;&quot; self.node_list = [self.start] for i in range(self.max_iter): # 生成随机节点 rnd_node = self.get_random_node() # 获得最近节点id nearest_ind = self.get_nearest_node_index(self.node_list, rnd_node) # 加入最近节点列表 nearest_node = self.node_list[nearest_ind] # 根据最近节点计算新节点 new_node = self.steer(nearest_node, rnd_node, self.expand_dis) # 判断新节点是否在障碍物内,如果不是则加入新节点列表 if self.check_if_outside_play_area(new_node, self.play_area) and \\ self.check_collision(new_node, self.obstacle_list): self.node_list.append(new_node) # 绘制动画 if animation and i % 5 == 0: self.draw_graph(rnd_node) # 计算与终点距离,如果不在障碍物内,则路径规划完成 if self.calc_dist_to_goal(self.node_list[-1].x, self.node_list[-1].y) &lt;= self.expand_dis: final_node = self.steer(self.node_list[-1], self.end, self.expand_dis) if self.check_collision(final_node, self.obstacle_list): return self.generate_final_course(len(self.node_list) - 1) if animation and i % 5: self.draw_graph(rnd_node) return None # cannot find path 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172figure(1);ImpRgb=imread(&#x27;newmap.png&#x27;);Imp=rgb2gray(ImpRgb);imshow(Imp)xL=size(Imp,1);%地图x轴长度yL=size(Imp,2);%地图y轴长度hold onplot(x_I, y_I, &#x27;ro&#x27;, &#x27;MarkerSize&#x27;,5, &#x27;MarkerFaceColor&#x27;,&#x27;r&#x27;);plot(x_G, y_G, &#x27;go&#x27;, &#x27;MarkerSize&#x27;,5, &#x27;MarkerFaceColor&#x27;,&#x27;g&#x27;);% 绘制起点和目标点count=1;for iter = 1:3000 p_rand=[]; %Step 1: 在地图中随机采样一个点x_rand % 这里有个技巧,可以在这里加一个几率直接连接到终点 %提示：用（p_rand(1),p_rand(2)）表示环境中采样点的坐标 p_rand(1)=ceil(rand()*xL); % rand()生成的是0~1均匀分布的随机数，乘以800再向上取整，数便为[1,800]间的整数 p_rand(2)=ceil(rand()*yL); p_near=[]; %Step 2: 遍历树，从树中找到最近邻近点x_near %提示：x_near已经在树T里 min_distance = 1000; for i=1:count distance = sqrt( ( T.v(i).x - p_rand(1) )^2 + ( T.v(i).y - p_rand(2) )^2 ); if distance &lt; min_distance min_distance = distance; % 通过index确定树中使用分支 index = i; end end p_near(1) = T.v(index).x; p_near(2) = T.v(index).y; p_new=[]; %Step 3: 扩展得到x_new节点 %提示：注意使用扩展步长Delta p_new(1) = p_near(1) + round( ( p_rand(1)-p_near(1) ) * Delta/min_distance ); p_new(2) = p_near(2) + round( ( p_rand(2)-p_near(2) ) * Delta/min_distance ); %检查节点是否是collision-free if ~collisionChecking(p_near,p_new,Imp) continue; end count=count+1; %Step 4: 将x_new插入树T %提示：新节点x_new的父节点是x_near T.v(count).x = p_new(1); T.v(count).y = p_new(2); T.v(count).xPrev = p_near(1); T.v(count).yPrev = p_near(2); T.v(count).dist = min_distance; %Step 5:检查是否到达目标点附近 %提示：注意使用目标点阈值Thr，若当前节点和终点的欧式距离小于Thr，则跳出当前for循环 new_distance = sqrt( ( p_new(1) - x_G )^2 + ( p_new(2) - y_G )^2 ); if new_distance &lt;= Thr plot(p_new(1), p_new(2), &#x27;bo&#x27;, &#x27;MarkerSize&#x27;,2, &#x27;MarkerFaceColor&#x27;,&#x27;b&#x27;); % 绘制x_new line( [p_new(1) p_near(1)], [p_new(2) p_near(2)], &#x27;Marker&#x27;,&#x27;.&#x27;,&#x27;LineStyle&#x27;,&#x27;-&#x27;); %连接x_near和x_new line( [x_G p_new(1)], [y_G p_new(2)], &#x27;Marker&#x27;,&#x27;.&#x27;,&#x27;LineStyle&#x27;,&#x27;-&#x27;); %连接x_Target和x_new break; end %Step 6:将x_near和x_new之间的路径画出来 %提示 1：使用plot绘制，因为要多次在同一张图上绘制线段，所以每次使用plot后需要接上hold on命令 %提示 2：在判断终点条件弹出for循环前，记得把x_near和x_new之间的路径画出来 plot(p_new(1), p_new(2), &#x27;bo&#x27;, &#x27;MarkerSize&#x27;,2, &#x27;MarkerFaceColor&#x27;,&#x27;b&#x27;); % 绘制x_new line( [p_new(1) p_near(1)], [p_new(2) p_near(2)], &#x27;Marker&#x27;,&#x27;.&#x27;,&#x27;LineStyle&#x27;,&#x27;-&#x27;); %连接x_near和x_new hold on; pause(0.1); %暂停0.1s，使得RRT扩展过程容易观察end RRT*参考网址: (115条消息) 【规划】RRT*算法图解_笑扬轩逸的博客-CSDN博客_rrt算法 (115条消息) 运动规划RRT算法图解_何伯特的博客-CSDN博客_rrt算法 (115条消息) 基于matlab的RRT&amp;RRT算法实现以及可视化_肉bot的博客-CSDN博客_rrt算法 代码流程两个改进: 当前节点重新选择父节点 范围内的节点重新连接 渐进最优 代码在RRT算法基础上加入了 123456789101112if self.check_collision(new_node, self.obstacle_list): # 找出最近的节点 near_inds = self.find_near_nodes(new_node) # 重新选择父节点 node_with_updated_parent = self.choose_parent( new_node, near_inds) if node_with_updated_parent: # 范围内的点进行重新连接 self.rewire(node_with_updated_parent, near_inds) self.node_list.append(node_with_updated_parent) else: self.node_list.append(new_node) Inform RRT*目的是为了加快渐进最优速度,采用在椭圆中采样的方式,代码中实际上就是将smaple转换为informed_sample 算法主要体现在 123456789101112131415161718# 输入Cbest Cmin xCenter C(旋转矩阵)def informed_sample(self, cMax, cMin, xCenter, C): if cMax &lt; float(&#x27;inf&#x27;): # 椭圆长短边 r = [cMax / 2.0, math.sqrt(cMax ** 2 - cMin ** 2) / 2.0, math.sqrt(cMax ** 2 - cMin ** 2) / 2.0] # 构建对焦矩阵 L = np.diag(r) # 圆形采样 xBall = self.sample_unit_ball() # 构建椭圆采样,并平移旋转矩阵 rnd = np.dot(np.dot(C, L), xBall) + xCenter rnd = [rnd[(0, 0)], rnd[(1, 0)]] else: rnd = self.sample_free_space() return rnd","categories":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"}],"tags":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"}]},{"title":"前轮反馈控制(stanley)","slug":"前轮反馈控制(stanley)","date":"2022-03-16T04:30:12.000Z","updated":"2022-03-20T05:08:05.476Z","comments":true,"path":"2022/03/16/前轮反馈控制(stanley)/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/16/%E5%89%8D%E8%BD%AE%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6(stanley)/","excerpt":"","text":"参考网址 路径规划与轨迹跟踪系列算法学习_第11讲_Stanley法_哔哩哔哩_bilibili AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) [(116条消息) Stanley轨迹跟踪算法Python/Matlab算法实现_gophae的博客-CSDN博客_stanley算法](https://blog.csdn.net/gophae/article/details/102765091?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stanley算法 c实现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-3-102765091.142^v2^article_score_rank,143^v4^control&amp;spm=1018.2226.3001.4187) 算法简介通过前轮反馈控制,采用航向偏差与横向偏差(err = err_phi + err_y) 代码实现获得最近点index12345678910111213141516function [error, ind] = calc_target_index(x,y,yaw, cx,cy,L)x = x + L * cos(yaw);y = y + L * sin(yaw);N = length(cx);Distance = zeros(N,1);for i = 1:NDistance(i) = sqrt((cx(i)-x)^2 + (cy(i)-y)^2);end[value, location]= min(Distance);ind = location; if y&lt;cy(ind) error = -value; else error = value; endend stanley12345678910function [delta] = stanley_control(x,y,yaw,v,cx,cy,cyaw, ind,ck,L, error) tx = cx(ind + 5); ty = cy(ind + 5); delta_yaw = v * 0.1 * sin(yaw) / L;% th_e = pipi(yaw + delta_yaw - cyaw(ind)); alpha = pipi(atan((ty-y)/(tx-x)) -yaw); gain_k = 1; theta = atan(gain_k* error/v); delta = alpha + theta;end 纵向控制123function [a] = PIDcontrol(target_v, current_v, Kp) a = Kp * (target_v - current_v);end","categories":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/categories/path-tracking/"}],"tags":[{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/tags/path-tracking/"}]},{"title":"DWA","slug":"DWA","date":"2022-03-08T04:30:12.000Z","updated":"2022-03-11T08:50:26.724Z","comments":true,"path":"2022/03/08/DWA/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/08/DWA/","excerpt":"","text":"参考网址: (114条消息) DWA动态窗口法的原理及应用_gophae的博客-CSDN博客_动态窗口法 ROS 2D导航原理系列教程合集（WHEELTEC）_哔哩哔哩_bilibili ShisatoYano/dynamic_window_approach (github.com) (114条消息) SLAM学习：DWA算法原理和Python编程实现_YuriFan的博客-CSDN博客_dwa算法实现 流程 代码流程1234567891011for 1:1000 % 迭代1000次 dwa_control(); motion(); if 接近目标点: breakdwa_control(): calc_dynamic_window(); -&gt; calc_final_input();calc_final_input(): calc_trajectory()-&gt;to_goal_cost-&gt;speed_cost-&gt;obst_cost-&gt;u_traj(v,w) 参考代码123456789101112131415161718192021// 初始化状态信息DynamicWindow calc_dynamic_window(State *st)&#123; DynamicWindow dw = &#123;0.0, 0.0, 0.0, 0.0&#125;; // from robot specification float vs[4] = &#123;MIN_SPD_MS, MAX_SPD_MS, -MAX_YAWRATE_RS, MAX_YAWRATE_RS&#125;; // from motion model float vd[4] = &#123;st-&gt;v_ms - MAX_ACCEL_MS2 * DT_S, st-&gt;v_ms + MAX_ACCEL_MS2 * DT_S, st-&gt;omega_rads - MAX_DYAWRATE_RS2 * DT_S, st-&gt;omega_rads + MAX_DYAWRATE_RS2 * DT_S&#125;; dw.min_v = max(vs[0], vd[0]); dw.max_v = min(vs[1], vd[1]); dw.min_yr = max(vs[2], vd[2]); dw.max_yr = min(vs[3], vs[3]); return dw;&#125; 12345678910111213141516171819202122// 生成一系列轨迹for (float v = dw-&gt;min_v; v &lt; dw-&gt;max_v; v+=V_RESO) &#123; for (float y = dw-&gt;min_yr; y &lt; dw-&gt;max_yr; y+=YAWRATE_RESO) &#123; traj = calc_trajectory(&amp;st_init, v, y); // calculate cost to_goal_cost = GOAL_COST_GAIN * calc_to_goal_cost(&amp;traj, goal); speed_cost = SPD_COST_GAIN * (MAX_SPD_MS - traj.back().v_ms); obst_cost = OBST_COST_GAIN*calc_obstacle_cost(&amp;traj, obst, obst_num); final_cost = to_goal_cost + speed_cost + obst_cost; // search minimum trajectory if (min_cost &gt;= final_cost) &#123; min_cost = final_cost; min_u.v_ms = v; min_u.omega_rads = y; best_traj = traj; &#125; &#125;&#125;// 最后输出","categories":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"}],"tags":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"}]},{"title":"Dijkstra与Astar","slug":"Dijkstra_Astar","date":"2022-03-08T04:30:12.000Z","updated":"2022-03-10T07:05:08.585Z","comments":true,"path":"2022/03/08/Dijkstra_Astar/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/08/Dijkstra_Astar/","excerpt":"","text":"参考网址: AtsushiSakai/PythonRobotics: Python sample codes for robotics algorithms. (github.com) 基于dijkstra算法，实现路径规划 机器人路径规划、轨迹优化系列课程_哔哩哔哩_bilibili AStarSearch 算法基本思想 代码流程 使用优先级队列实现123456789101112131415161718192021222324252627282930// 原型:fill (ForwardIterator first, ForwardIterator last, const T&amp; val);fill(dist, dist + nV + 1, INF);// 原型:priority_queue&lt;Type, Container, Functional&gt;// P表示最短距离与定点编号,greater:升序队列,less:降序队列priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;dist[s] = 0;// 将起点加入优先队列q.push(P(0, s));while (!q.empty())&#123; P p = q.top(); //从尚未使用的顶点中找到一个距离最小的顶点,由于是升序队列,所以取出的是最小的 q.pop(); // 将顶点从优先队列中删除 int v = p.second; // 取出顶点编号 if (dist[v] &lt; p.first) // 如果该顶点的距离已经被更新,则跳过 continue; if (v == end) // 如果该顶点是终点,则跳出循环 break; for (int unsigned i = 0; i &lt; G[v].size(); i++)&#123; // 遍历该顶点的所有邻接点 Edge &amp;e = G[v][i]; // 取出与该顶点相连的边 int dis = dist[v] + e.cost; // 更新该顶点的距离 if (dist[e.to] &gt; dis)&#123; // 如果新距离比原来的距离小,则更新 dist[e.to] = dist[v] + e.cost; q.push(P(dist[e.to], e.to)); G4[v].push_back(e); &#125; else if (dist[e.to] == dis)&#123; G4[v].push_back(e); &#125; &#125;&#125; Astar算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576APoint* CAstar::findWay(APoint *beginPoint, APoint *endPoint,vector&lt; vector&lt;APoint*&gt; &gt;&amp; allPoints)&#123; //传递地图 _allPoints = allPoints; _endPoint = endPoint; if (_endPoint-&gt;type == AType::ATYPE_BARRIER) &#123; cout&lt;&lt;&quot;终点是障碍&quot;&lt;&lt;endl; return nullptr; &#125; if (*_endPoint == *beginPoint) &#123; cout&lt;&lt;&quot;起始点相同&quot;&lt;&lt;endl; return nullptr; &#125; _openList.push_back(beginPoint); beginPoint-&gt;type = AType::ATYPE_OPENED; // F = G + H beginPoint-&gt;f = getF(beginPoint); //--------- do &#123; //获取最小值的节点 _curPoint = _openList[0]; _openList.erase(_openList.begin()); _curPoint-&gt;type = AType::ATYPE_CLOSED; _closeList.push_back(_curPoint); if (*_curPoint == *_endPoint) &#123; cout&lt;&lt;&quot;have find way&quot;&lt;&lt;endl; return _curPoint; &#125; //获取相邻的节点 vector&lt;APoint*&gt; neVec = getNeighboringPoint(_curPoint); for (int i = 0; i&lt;neVec.size(); i++) &#123; auto tmpoint = neVec[i]; if (tmpoint-&gt;type == AType::ATYPE_CLOSED) &#123; continue; &#125; //是否在开放列表里 if (tmpoint-&gt;type != AType::ATYPE_OPENED) &#123; tmpoint-&gt;parent = _curPoint; tmpoint-&gt;g = _curPoint-&gt;g + 10; //计算H值 tmpoint-&gt;h = getH(tmpoint); //添加到开放列表里 _openList.push_back(tmpoint); tmpoint-&gt;type = AType::ATYPE_OPENED; &#125; else &#123; //已经在开放列表里 if (tmpoint-&gt;h &lt; _curPoint-&gt;h) &#123; tmpoint-&gt;parent = _curPoint; tmpoint-&gt;g = _curPoint-&gt;g + 10; &#125; &#125; &#125; //排序 F值最小的排在前面 sort(_openList.begin(), _openList.end(), mySort); &#125; while (_openList.size()&gt;0); cout&lt;&lt;&quot;---can not find way---&quot;&lt;&lt;endl; return nullptr;&#125;","categories":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"}],"tags":[{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"}]},{"title":"ROS时间戳函数和输出显示","slug":"ROS时间戳函数和输出显示","date":"2022-03-07T04:30:12.000Z","updated":"2022-03-07T06:23:23.432Z","comments":true,"path":"2022/03/07/ROS时间戳函数和输出显示/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/07/ROS%E6%97%B6%E9%97%B4%E6%88%B3%E5%87%BD%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E6%98%BE%E7%A4%BA/","excerpt":"","text":"参考网址: (112条消息) ROS时间戳函数和输出显示_Kevin_Xie86的博客-CSDN博客_ros 时间戳 代码12double t = msg-&gt;header.stamp.toSec()//把时间戳转化成浮点型格式pringf(&quot;time:%f\\n&quot;,t);//输出显示","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"make_pair(),mean(),assign()使用","slug":"make_pair(),mean(),assign()使用","date":"2022-03-07T04:30:12.000Z","updated":"2022-03-07T06:26:37.551Z","comments":true,"path":"2022/03/07/make_pair(),mean(),assign()使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/07/make_pair(),mean(),assign()%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址: (112条消息) make_pair函数_半尺杆头的博客-CSDN博客_make_pair (112条消息) C++STL中vector容器 assign()函数的用法_xlm289348的专栏-CSDN博客_vector的assign函数 代码演示make_pair()12345return std::make_pair(int, float);std::pair&lt;int, float&gt; result &#123;loop_id, yaw_diff_rad&#125;;std::pair&lt;float, int&gt; sc_dist_result = distanceBetweenScancontexts( curr_desc, context_candidate ); float candidate_dist = sc_dist_result.first;int candidate_align = sc_dist_result.second; mean()12345mean()求均值mean（A）若A为[矩阵](https://so.csdn.net/so/search?q=矩阵&amp;spm=1001.2101.3001.7020)，则输出每一列的均值（一个向量）若A为列向量，则输出均值（一个数）若A为行向量，则也是输出均值（一个数），和列向量一样 代码 1234567Eigen::MatrixXf invariant_key(desc.rows(), 1);for ( int row_idx = 0; row_idx &lt; desc.rows(); row_idx++ )&#123; // 对一行求均值 Eigen::MatrixXf curr_row = desc.row(row_idx); // mean()求均值 invariant_key(row_idx, 0) = curr_row.mean();&#125; assign()12void assign(const_iterator first,const_iterator last);//将区间[first,last)的元素赋值到当前的vector容器中，或者赋n个值为x的元素到vector容器中，这个容器会清除掉vector容器中以前的内容。 12v2.assign(v1.begin(), v1.end()-6);// 将v1从开头到最后第六位赋值给assign","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"ros_mobile","slug":"ros_mobile","date":"2022-03-07T04:30:12.000Z","updated":"2022-03-07T06:38:44.389Z","comments":true,"path":"2022/03/07/ros_mobile/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/07/ros_mobile/","excerpt":"","text":"参考网址: (112条消息) 一款超好用的ROS APP推荐——ROS-Mobile（亲测好用！！！）_尾巴l的博客-CSDN博客_rosapp ROS-Mobile/ROS-Mobile-Android: Visualization and controlling application for Android (github.com) github上有教程 注意填写master!其他使用都比较简单,随意","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"对于slam整体流程的思考","slug":"对于slam整体流程的思考","date":"2022-03-07T04:30:12.000Z","updated":"2022-03-08T01:18:28.298Z","comments":true,"path":"2022/03/07/对于slam整体流程的思考/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/07/%E5%AF%B9%E4%BA%8Eslam%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"参考网址: (112条消息) SLAM基本流程和算法框架_lzj50002801的博客-CSDN博客_slam基本框架 流程图 123456789传感器信息读取:在视觉 SLAM 中主要为相机图像信息的读取和预处理。如果在机器人中，还可能有码盘、惯性传感器等信息的读取和同步。视觉里程计 (Visual Odometry, VO):视觉里程计任务是估算相邻图像间相机的运动，以及局部地图的样子。VO 又称为前端（Front End）。后端优化（Optimization）:后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。由于接在 VO 之后，又称为后端（Back End）。回环检测（Loop Closing）:回环检测判断机器人是否曾经到达过先前的位置。如果检测到回环，它会把信息提供给后端进行处理。建图（Mapping）:它根据估计的轨迹，建立与任务要求对应的地图。 在图中很清晰的表现出了slam流程: 根据传感器信息获得初步的前端里程计,这时候同时进行回环检测,然后将两个数据都传给后端进行后端的非线性优化,最后通过非线性优化得到的坐标数据,进行最终建图. 传感器 odom:一般用于辅助前端定位作用 imu:由于其角度相较于odom更准,所以也会将其放做里程计角度数值,当然也会有用于ekf做传感器融合 scan:激光数据包括:ranges, intensities,数据 前端里程计滤波大法主要是ekf与pf两种,具体可参考:gmapping,amcl,refletor_ekf_slam 非线性优化 icp scan_to_map scan_to_submap: Scan To SubMap方法只将当前帧激光雷达数据与历史前几帧数据进行匹配 回环检测 通过特征点进行匹配(原特征,叫角特征,线特征) 通过icp进行的暴力匹配 scan_context 后端优化(图优化) 图优化的目的是从整体上对所有已估计到的并且在回环上的位姿进行优化，减小误差。普遍有两种: 图优化的思路是将位姿作为图(Graph)的顶点(Vertex),位姿间的坐标变换关系作为边(Edge), 顶点为优化变量，边为优化约束，构建出一个位姿图(Pose Graph)。 将雷达观测点也作为图的顶点，观测点与机器人的位姿之间的关系也作为边构建出一个图，这种情况下称之为Bundle Adjustment(BA)问题 具体非线性优化可以参考g2o与之前的手撸高斯牛顿,以此得到较为不错的估计坐标 建图这方面,其实可以参考的有很多,比如hector的建图,以及深蓝学院的建图都比较简单容易移植. 全局定位 最常用且传统的方式是amcl,采用贝叶斯滤波的方式实现,包括比较固定的里程计模型,还有就是根据不同传感器写的不同观测模型,对于2d激光slam来讲,scan是最常见的观测方式,当然再此基础上结合gps结合反光板,结合多激光头进行多传感器融合也同样常见,原理类似 scan_to_map是比较常用的纯定位方式,缺点是由于重定位比较麻烦,一般对于车体初始位姿要求比较高 采用carto的scan_to_submap,首先在各个子图中搜索,然后再查找,不过同样的面临着一开始需要很长时间进行搜索定位的过程,所以一般做法依旧是选择较好的初始位姿. 基于特征匹配进行的全局定位,如scan_context或者是角特征,线特征,原特征等 最粗暴的方法,使用icp进行暴力穷举,我相信那一定是很让人难忘的方式","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"scan_context","slug":"scan_context","date":"2022-03-06T04:30:12.000Z","updated":"2022-03-07T09:11:23.996Z","comments":true,"path":"2022/03/06/scan_context/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/06/scan_context/","excerpt":"","text":"参考网址: (112条消息) Scan Context 学习记录_春至冬去-CSDN博客_scancontext Lidar定位：Scan Context - 知乎 (zhihu.com) irapkaist/scancontext: Global LiDAR descriptor for place recognition and long-term localization 原创投稿 | ScanContext 论文详解 - 用途：Lidar SLAM 回环检测、空间描述符 - 哔哩哔哩 (bilibili.com) (112条消息) 激光闭环检测Scancontext_weixin_35536487的博客-CSDN博客_scancontext Slam-Project-Of-MyOwn/src at master · softdream/Slam-Project-Of-MyOwn (github.com) 流程 给定一帧点云，划分成20个环，每个环分成60等份，一共1200个格子 每个格子存里面点的最大高度值（z值），这样一帧点云就用一个二维图像表示了，想象成一个带高度的俯视图，或者地形图，记为scan context scan context进一步计算列的均值，得到一个1x60的向量，记为ring key；计算行的均值，得到一个20x1的向量，记为sector key 用ring key构造kd-tree，并且执行knn搜索 对于候选匹配scan context，首先要左右循环偏移一下，对齐，实际会用sector key去对齐，得到一个偏移量 对候选匹配scan context，施加偏移量，然后作比较 代码make scanContext1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 一帧点云生成scan contextMatrixXd SCManager::makeScancontext( pcl::PointCloud&lt;SCPointType&gt; &amp; _scan_down )&#123; // 激光点数量 int num_pts_scan_down = _scan_down.points.size(); const int NO_POINT = -1000; // 这里矩阵的记法跟paper的示意图是一致的 MatrixXd desc = NO_POINT * MatrixXd::Ones(PC_NUM_RING, PC_NUM_SECTOR); SCPointType pt; float azim_angle, azim_range; // wihtin 2d plane int ring_idx, sctor_idx; // 遍历激光点 for (int pt_idx = 0; pt_idx &lt; num_pts_scan_down; pt_idx++) &#123; pt.x = _scan_down.points[pt_idx].x; pt.y = _scan_down.points[pt_idx].y; // 让高度大于0，所有点的高度都加2，不影响匹配结果 pt.z = _scan_down.points[pt_idx].z + LIDAR_HEIGHT; // naive adding is ok (all points should be &gt; 0). // 距离 azim_range = sqrt(pt.x * pt.x + pt.y * pt.y); // 角度，0~360° azim_angle = xy2theta(pt.x, pt.y); // 距离超过80米的点不考虑了 if( azim_range &gt; PC_MAX_RADIUS ) continue; // 计算这个点落在哪个bin里面，下标从1开始数 ring_idx = std::max( std::min( PC_NUM_RING, int(ceil( (azim_range / PC_MAX_RADIUS) * PC_NUM_RING )) ), 1 ); sctor_idx = std::max( std::min( PC_NUM_SECTOR, int(ceil( (azim_angle / 360.0) * PC_NUM_SECTOR )) ), 1 ); // 用z值，也就是高度来更新这个格子，存最大的高度； if ( desc(ring_idx-1, sctor_idx-1) &lt; pt.z ) // -1 means cpp starts from 0 desc(ring_idx-1, sctor_idx-1) = pt.z; // update for taking maximum value at that bin &#125; // reset no points to zero (for cosine dist later) for ( int row_idx = 0; row_idx &lt; desc.rows(); row_idx++ ) for ( int col_idx = 0; col_idx &lt; desc.cols(); col_idx++ ) if( desc(row_idx, col_idx) == NO_POINT ) desc(row_idx, col_idx) = 0; return desc;&#125; make Ringkey12345678910111213// 由scan context计算ring key，Nx1MatrixXd SCManager::makeRingkeyFromScancontext( Eigen::MatrixXd &amp;_desc )&#123; // 每行计算一个均值 Eigen::MatrixXd invariant_key(_desc.rows(), 1); for ( int row_idx = 0; row_idx &lt; _desc.rows(); row_idx++ ) &#123; Eigen::MatrixXd curr_row = _desc.row(row_idx); invariant_key(row_idx, 0) = curr_row.mean(); &#125; return invariant_key;&#125; make Sectorkey12345678910111213// 由scan context计算sector key，1xMMatrixXd SCManager::makeSectorkeyFromScancontext( Eigen::MatrixXd &amp;_desc )&#123; // 每列计算一个均值 Eigen::MatrixXd variant_key(1, _desc.cols()); for ( int col_idx = 0; col_idx &lt; _desc.cols(); col_idx++ ) &#123; Eigen::MatrixXd curr_col = _desc.col(col_idx); variant_key(0, col_idx) = curr_col.mean(); &#125; return variant_key;&#125; 调整偏移,获得偏移量按列均值,目的是,便于通过调整偏移量来实现对scanContext进行比较 12345678910111213141516171819202122232425// _vkey1、_vkey2是两个sector key// 对_vkey2做循环偏移，计算与_vkey1最佳匹配时的偏移量int SCManager::fastAlignUsingVkey( MatrixXd &amp; _vkey1, MatrixXd &amp; _vkey2)&#123; int argmin_vkey_shift = 0; double min_veky_diff_norm = 10000000; for ( int shift_idx = 0; shift_idx &lt; _vkey1.cols(); shift_idx++ ) &#123; // 矩阵的列，循环右移shift个单位 MatrixXd vkey2_shifted = circshift(_vkey2, shift_idx); // 直接相减，sector key是1xN的矩阵 MatrixXd vkey_diff = _vkey1 - vkey2_shifted; // 范数 double cur_diff_norm = vkey_diff.norm(); // 记录距离最小时对应的循环偏移量 if( cur_diff_norm &lt; min_veky_diff_norm ) &#123; argmin_vkey_shift = shift_idx; min_veky_diff_norm = cur_diff_norm; &#125; &#125; return argmin_vkey_shift;&#125; 闭环检测12345678910111213141516171819202122232425262728293031323334353637383940414243// 接口二，执行闭环检测std::pair&lt;int, float&gt; SCManager::detectLoopClosureID ( void )；/** * 计算两个scan context之间的距离*/std::pair&lt;double, int&gt; SCManager::distanceBtnScanContext( MatrixXd &amp;_sc1, MatrixXd &amp;_sc2 )&#123; // 1. fast align using variant key (not in original IROS18) // 计算sector Key,也就是sector最大高度均值组成的数组，1xN MatrixXd vkey_sc1 = makeSectorkeyFromScancontext( _sc1 ); MatrixXd vkey_sc2 = makeSectorkeyFromScancontext( _sc2 ); // 这里将_vkey2循环右移，然后跟_vkey1作比较，找到一个最相似（二者做差最小）的时候，记下循环右移的量 int argmin_vkey_shift = fastAlignUsingVkey( vkey_sc1, vkey_sc2 ); // 上面用sector key匹配，找到一个初始的偏移量，但肯定不是准确的，再在这个偏移量左右扩展一下搜索空间 const int SEARCH_RADIUS = round( 0.5 * SEARCH_RATIO * _sc1.cols() ); // a half of search range std::vector&lt;int&gt; shift_idx_search_space &#123; argmin_vkey_shift &#125;; for ( int ii = 1; ii &lt; SEARCH_RADIUS + 1; ii++ ) &#123; shift_idx_search_space.push_back( (argmin_vkey_shift + ii + _sc1.cols()) % _sc1.cols() ); shift_idx_search_space.push_back( (argmin_vkey_shift - ii + _sc1.cols()) % _sc1.cols() ); &#125; std::sort(shift_idx_search_space.begin(), shift_idx_search_space.end()); // 2. fast columnwise diff int argmin_shift = 0; double min_sc_dist = 10000000; for ( int num_shift: shift_idx_search_space ) &#123; // 把scan context循环右移一下 MatrixXd sc2_shifted = circshift(_sc2, num_shift); // 计算两个scan context之间的距离 double cur_sc_dist = distDirectSC( _sc1, sc2_shifted ); if( cur_sc_dist &lt; min_sc_dist ) &#123; argmin_shift = num_shift; min_sc_dist = cur_sc_dist; &#125; &#125; // 最小scan context距离，偏移量 return make_pair(min_sc_dist, argmin_shift);&#125; 注意scanContext方法只是用于简单的位姿对比,对于精确位姿还需要最后使用更加精确的手段进行定位,比如icp,scantomap,图优化都可以. 简单介绍回环检测与图优化结合方式 首先通过sccan_to_map检测是否超过一定距离与角度,若是,设为关键帧 将关键帧保存数组 生成scanContext并加入图优化顶点 检测是否有回环,若有,则根据记录下来的顶点,scan,运动坐标进行图优化,更新坐标 重新建图:先删除之前所有建图信息, 根据估计的关键姿态重建地图","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"坐标变换","slug":"坐标系变换","date":"2022-03-06T04:30:12.000Z","updated":"2022-05-07T07:24:19.253Z","comments":true,"path":"2022/03/06/坐标系变换/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/06/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2/","excerpt":"","text":"参考网址:坐标变换 由一道周作业题想到的坐标系变换_哔哩哔哩_bilibili 不同坐标系变换1234567Pose2D TransformFrom(const Pose2D&amp; pose_new) const&#123; float dx = pose_new.x - x; float dy = pose_new.y - y; return Pose2d(dx*std::cos(theta)+dy*std::sin(theta), -dx*std::sin(theta)+dy*std::cos(theta), pose_new.theta - theta);&#125; 12345Pose2D TransformAdd(const Pose2D&amp; pose_delta) const&#123; float dx = pose_delta.x*std::cos(theta)-pose_delta.y*std::sin(theta); float dy = pose_delta.x*std::sin(theta)+pose_delta.y*std::cos(theta); return Pose2d(x+dx, y+dy, theta+pose_delta.theta);&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"分支定界法","slug":"分支定界法","date":"2022-03-04T04:30:12.000Z","updated":"2022-03-07T07:10:54.305Z","comments":true,"path":"2022/03/04/分支定界法/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/04/%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/","excerpt":"","text":"参考网址: 【运筹学】-整数线性规划(一)(分支定界法)_哔哩哔哩_bilibili (111条消息) 基于C语言的分支限界法_Mr.zhou_Zxy-CSDN博客_c语言分支限界法 [(111条消息) 学习C/C++的第三十二天 五大常规算法——5.分支定界法_w707577314的博客-CSDN博客](https://blog.csdn.net/w707577314/article/details/103827880?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=分支定界法 c语言&amp;utm_medium=distribute.pc_search_result.none-task-blog-2blogsobaiduweb~default-3-103827880.nonecase&amp;spm=1018.2226.3001.4450)","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"由g2o引出的变换矩阵的思考","slug":"由g2o引出的变换矩阵的思考","date":"2022-03-04T04:30:12.000Z","updated":"2022-03-04T07:51:24.900Z","comments":true,"path":"2022/03/04/由g2o引出的变换矩阵的思考/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/04/%E7%94%B1g2o%E5%BC%95%E5%87%BA%E7%9A%84%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"参考网址:Slam-Project-Of-MyOwn gaoxiang12/slambook2: edition 2 of the slambook (github.com) 简介由于最近在看道锋大佬的slam代码,其中有这样一段关于g2o后端优化的程序,不太理解,于是找道锋大佬咨询 代码: 123456Eigen::Matrix3d information = 1 * Eigen::Matrix3d::Identity(); //information matrixEigen::Matrix&lt;float, 3, 3&gt; T1 = slam.v2t( robotPoseCurr );Eigen::Matrix&lt;float, 3, 3&gt; T2 = slam.v2t( keyPoses[loopId] );Eigen::Matrix&lt;float, 3, 3&gt; T = T1.inverse() * T2;//这里T值得是转移矩阵Eigen::Vector3f V = slam.t2v( T );// 矩阵转向量optimizer.addEdge( V, keyFrameCount, loopId, information ); // add a loop constraint v2t与t2v代码如下: 123456789101112131415161718192021222324252627// 这里v是当前机器人位姿到回环点的位姿的位姿增量[dx,dy,dtheta],// T是当前机器人位姿到回环点的位姿坐标变换矩阵（齐次坐标变换，就是由旋转矩阵加平移组成的）// T = [R,t// 0,1] R为旋转矩阵,t为移动矩阵const Eigen::Matrix&lt;float, 3, 3&gt; SlamProcessor::v2t(const Eigen::Vector3f &amp;v)&#123; float c = ::cos( v(2) ); float s = ::sin( v(2) ); Eigen::Matrix&lt;float, 3, 3&gt; A; A &lt;&lt; c, -s, v(0), s, c, v(1), 0, 0, 1; return A;&#125;const Eigen::Vector3f SlamProcessor::t2v(const Eigen::Matrix&lt;float, 3, 3&gt; &amp;A)&#123; Eigen::Vector3f v; v(0) = A(0, 2); v(1) = A(1, 2); v(2) = ::atan2( A( 1, 0 ), A(0, 0) ); return v;&#125; 于是翻出珍藏多年的slam14讲 首先:变换矩阵T表现为旋转矩阵R与平移矩阵t 12// T = [R,t// 0,1] R为旋转矩阵,t为移动矩阵 而这里的T1与T2分别为当前车体坐标与回环点坐标,将他们先转换为其次坐标之后做变换可得变换矩阵 1T2 = T1*T ==&gt; inv(T1)*T1*T = inv(T1)*T2 ==&gt; T = inv(T1)*T2 这也是齐次坐标的好处,便于做坐标转换","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"scan_to_map","slug":"scan_to_map","date":"2022-03-03T04:30:12.000Z","updated":"2022-03-03T00:45:39.941Z","comments":true,"path":"2022/03/03/scan_to_map/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/03/scan_to_map/","excerpt":"","text":"参考网址: hector_slam Forrest-Z/Slam-Project-Of-MyOwn 简介 和ICP方法不同，当前帧的激光雷达扫描数据与已建好的历史占据栅格地图进行匹配，根据激光雷达观测点在地图上占据栅格的概率值的和来建立误差方程，使用高斯牛顿法求解方程使得占据概率值的和最大，得到最佳的机器人位姿坐标变换。此外还使用了双线性插值方法(Bilinear Interpolation)来计算当前帧激光雷达数据在地图上对应点的占据概率，提高匹配精准度。 最常见的就是hector的前端里程计了. 实现 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329#include &quot;scanMatch.h&quot;#include &quot;utils.h&quot;//#define TERMINAL_LOGnamespace slam &#123;ScanMatchMethod::ScanMatchMethod() : mP00( 0 ), mP11( 0 ), mP01( 0 ), mP10(0)&#123;&#125;ScanMatchMethod::~ScanMatchMethod()&#123;&#125;float ScanMatchMethod::bilinearInterpolation( const OccupiedMap &amp;occuMap, const Eigen::Vector2f &amp;coords )&#123; // 1. judge weather out of range if( occuMap.isPointOutOfRange( coords ) )&#123; return 0.0f; &#125; // 2. map coords are always positive, floor them by casting to int Eigen::Vector2i indMin( coords.cast&lt;int&gt;() ); // 3. factor0 = ( x - x0 ) // factor1 = ( y - y0 ) float factor0 = coords[0] - static_cast&lt;float&gt;( indMin[0] ); float factor1 = coords[1] - static_cast&lt;float&gt;( indMin[1] ); // 4. find p(m) point in map coordinate int sizeX = occuMap.getSizeX(); int index = indMin[1] * sizeX + indMin[0]; // 5. get the probability of the four points mP00 = occuMap.getCellOccupiedProbability( index ); index ++; mP10 = occuMap.getCellOccupiedProbability( index ); index += sizeX - 1; mP01 = occuMap.getCellOccupiedProbability( index ); index ++; mP11 = occuMap.getCellOccupiedProbability( index ); // 6. factorInv0 = 1 - ( x - x0 ) // factorInv1 = 1 - ( y - y0 ) float factorInv0 = 1.0f - factor0; float factorInv1 = 1.0f - factor1; // 7. M(Pm) = (y - y0) * &#123; (x - x0) * M(P11) + [1 - (x - x0)] * M(P01) &#125; + [1 - (y - y0)] * &#123; (x - x0) * M(P10) + [1 - (x - x0)] * M(P00) &#125; return ( factor1 * ( factor0 * mP11 + factorInv0 * mP01 ) ) + ( factorInv1 * ( factor0 * mP10 + factorInv0 * mP00 ) );&#125;Eigen::Vector3f ScanMatchMethod::bilinearInterpolationWithDerivative( const OccupiedMap &amp;occuMap, const Eigen::Vector2f &amp;coords )&#123; // M(Pm) = (y-y0)/(y1-y0) * &#123; [(x-x0)/(x1-x0)] * M(P11) + [(x1-x)/(x1-x0)] * M(P01) &#125; // +(y1-y)/(y1-y0) * &#123; [(x-x0)/(x1-x0)] * M(P10) + [(x1-x)/(x1-x0)] * M(P00) &#125; // among them: // y1 - y0 = 1 // x1 - x0 = 1 // x1 - x = 1 - ( x - x0 ) // y1 - y = 1 - ( y - y0 ) // // M(Pm) = (y-y0) * &#123; (x-x0) * M(P11) + (1-(x-x0)) * M(P01) &#125; // +(1-(y-y0)) * &#123; (x-x0) * M(P10) + (1-(x-x0)) * M(P00) &#125; // // dM(Pm)/dx = (y-y0)/(y1-y0) * &#123; M(P11) - M(P01) &#125; // +(y1-y)/(y1-y0) * &#123; M(P10) - M(P00) &#125; // = (y-y0) * &#123; M(P11) - M(P01) &#125; + (1-(y-y0)) * &#123; M(P10) - M(P00) &#125; // // dM(Pm)/dy = (x-x0)/(x1-x0) * &#123; M(P11) - M(P10) &#125; // +(x1-x)/(x1-x0) * &#123; M(P01) - M(P00) &#125; // = (x-x0) * &#123; M(P11) - M(P10) &#125; + (1-(x-x0)) * &#123; M(P01) - M(P00) &#125; // // dM(Pm)/dPm = &#123; dM(Pm)/dx, dM(Pm)/dy &#125; // 1. judge weather out of range if( occuMap.isPointOutOfRange( coords ) )&#123; return Eigen::Vector3f( 0.0f, 0.0f, 0.0f ); &#125; // 2. map coords are always positive, floor them by casting to int Eigen::Vector2i indMin( coords.cast&lt;int&gt;() );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;intergerMin = &quot;&lt;&lt;std::endl&lt;&lt;indMin&lt;&lt;std::endl;#endif // 3. factor0 = ( x - x0 ) // factor1 = ( y - y0 ) float factor0 = coords[0] - static_cast&lt;float&gt;( indMin[0] ); float factor1 = coords[1] - static_cast&lt;float&gt;( indMin[1] ); // 4. find p(m) point in map coordinate int sizeX = occuMap.getSizeX(); int index = indMin[1] * sizeX + indMin[0]; // 5. get the probability of the four points mP00 = occuMap.getCellOccupiedProbability( index );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;Mp(00) = &quot;&lt;&lt;mP00&lt;&lt;std::endl; #endif index ++; mP10 = occuMap.getCellOccupiedProbability( index );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;Mp(10) = &quot;&lt;&lt;mP10&lt;&lt;std::endl;#endif index += sizeX - 1; mP01 = occuMap.getCellOccupiedProbability( index );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;Mp(01) = &quot;&lt;&lt;mP01&lt;&lt;std::endl;#endif index ++; mP11 = occuMap.getCellOccupiedProbability( index );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;Mp(11) = &quot;&lt;&lt;mP11&lt;&lt;std::endl;#endif // 6. factorInv0 = 1 - ( x - x0 ) // factorInv1 = 1 - ( y - y0 ) float factorInv0 = 1.0f - factor0; float factorInv1 = 1.0f - factor1; // 7. M(Pm) = (y - y0) * &#123; (x - x0) * M(P11) + [1 - (x - x0)] * M(P01) &#125; + [1 - (y - y0)] * &#123; (x - x0) * M(P10) + [1 - (x - x0)] * M(P00) &#125; // --------------------------------------------------------------------------------------------------------------------------------------- // d(M(Pm)) / dx = (y - y0) * [M(P11) - M(P01)] + (1 - (y - y0)) * [M(P10) - M(P00)] // --------------------------------------------------------------------------------- // d(M(Pm)) / dy = (x - x0) * [M(P11) - M(P10)] + (1 - (x - x0)) * [M(P01) - M(P00)] return Eigen::Vector3f( ( ( factor1 * ( factor0 * mP11 + factorInv0 * mP01 ) ) + ( factorInv1 * ( factor0 * mP10 + factorInv0 * mP00 ) ) ), ( factor1 * ( mP11 - mP01 ) + factorInv1 * ( mP10 - mP00 ) ), ( factor0 * ( mP11 - mP10 ) + factorInv0 * ( mP01 - mP00 ) ) );&#125;void ScanMatchMethod::getHessianDerivative( const OccupiedMap &amp;occuMap, Eigen::Vector3f &amp;robotPoseInWorld, const ScanContainer &amp;scanPoints, Eigen::Matrix3f &amp;H, Eigen::Vector3f &amp;dTr )&#123; // H = Sigma(i = 1 to n)&#123; Nabla( Si(cauchy) ) * [( d(Si(cauchy)) )/( d(cauchy) )] &#125;^2 // n is the number of the scan points // // Si(cauchy) = | cosRot -sinRot | * | x_i | + | Px | // | sinRot cosRot | | y_i | | Py | // // among them: // ( x_i, y_i ) is the point that lidar has observed in map coordinate, i = 0, 1, 2, ..., n; // ( Px, Py ) is the Translation vector // | cosRot -sinRot | // | sinRot cosRot | is the Rotation Matrix // // d(Si(cauchy)) / d(cauchy) = | 1 0 -sinRot * x_i - cosRot * y_i | // | 0 1 cosRot * x_i - sinRot * y_i | // // Nabla( Si(cauchy) = dM(Pm)/dPm = &#123; dM(Pm)/dx, dM(Pm)/dy &#125; // // dTr = Sigma(i = 1 to n)&#123; Nabla( Si(cauchy) ) * [( d(Si(cauchy)) )/( d(cauchy) )] &#125; * &#123; 1 - M( Si(cauchy) ) &#125; int size = scanPoints.getSize(); float sinRot = ::sin( robotPoseInWorld[2] ); float cosRot = ::cos( robotPoseInWorld[2] );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;sinRot = &quot;&lt;&lt;sinRot&lt;&lt;std::endl; std::cout&lt;&lt;&quot;cosRot = &quot;&lt;&lt;cosRot&lt;&lt;std::endl;#endif H = Eigen::Matrix3f::Zero(); dTr = Eigen::Vector3f::Zero(); #ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;size = &quot;&lt;&lt;size&lt;&lt;std::endl;#endif for( int i = 0; i &lt; size; i ++ )&#123; // 1. get the current point in laser coordinate Eigen::Vector2f currPointInLaser( scanPoints.getIndexData( i ) ); Eigen::Vector2f currPointInScaleLaser( scanPoints.getIndexData( i ) * occuMap.getScale() ); // 2. Transform the End Point from Laser Coordinate to World Coordinate Eigen::Vector2f currPointInWorld( occuMap.observedPointPoseLaser2World( currPointInLaser, robotPoseInWorld ) );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;currPointInWorld: &quot;&lt;&lt;std::endl&lt;&lt;currPointInWorld&lt;&lt;std::endl; #endif // 3. Transform the End Point from World Coordinate to Map Coordinate Eigen::Vector2f currPointInMap( occuMap.observedPointPoseWorld2Map( currPointInWorld ) );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;currPointInMap: &quot;&lt;&lt;std::endl&lt;&lt;currPointInMap&lt;&lt;std::endl; #endif // 4. get the M(Pm), d(M(Pm))/dx, d(M(Pm))/dy Eigen::Vector3f interpolatedValue( bilinearInterpolationWithDerivative( occuMap, currPointInMap ) );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;interpolatedValue: &quot;&lt;&lt;std::endl&lt;&lt;interpolatedValue&lt;&lt;std::endl;#endif // 5. the Objective Function: f(x) = 1 - M(Pm) float funcValue = 1.0f - interpolatedValue[0]; // 6. dTr[0] += interpolatedValue[1] * funcValue; dTr[1] += interpolatedValue[2] * funcValue; // 7. float rotDeriv = ( interpolatedValue[1] * ( -sinRot * currPointInScaleLaser[0] - cosRot * currPointInScaleLaser[1] ) ) + ( interpolatedValue[2] * ( cosRot * currPointInScaleLaser[0] - sinRot * currPointInScaleLaser[1] ) ); // 8. dTr[2] += rotDeriv * funcValue; // 9. H( 0, 0 ) += sqr( interpolatedValue[1] ); H( 1, 1 ) += sqr( interpolatedValue[2] ); H( 2, 2 ) += sqr( rotDeriv ); H( 0, 1 ) += interpolatedValue[1] * interpolatedValue[2]; H( 0, 2 ) += interpolatedValue[1] * rotDeriv; H( 1, 2 ) += interpolatedValue[2] * rotDeriv; &#125; // 10. H( 1, 0 ) = H( 0, 1 ); H( 2, 0 ) = H( 0, 2 ); H( 2, 1 ) = H( 1, 2 );&#125;bool ScanMatchMethod::estimateTransformationOnce( const OccupiedMap &amp;occuMap, Eigen::Vector3f &amp;estimateInWorld, const ScanContainer &amp;scanPoints )&#123; getHessianDerivative( occuMap, estimateInWorld, scanPoints, H, dTr );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;Hessian : &quot;&lt;&lt;std::endl; std::cout&lt;&lt;H&lt;&lt;std::endl; std::cout&lt;&lt;&quot;dTr: &quot;&lt;&lt;std::endl; std::cout&lt;&lt;dTr&lt;&lt;std::endl;;#endif if ( ( H(0, 0) != 0.0f ) &amp;&amp; ( H(1, 1) != 0.0f ) )&#123; // delta(cauchy) = H.inverse() * dTr; Eigen::Vector3f deltaCauchy( H.inverse() * dTr );#ifdef TERMINAL_LOG std::cout&lt;&lt;&quot;delata Cauchy: &quot;&lt;&lt;std::endl&lt;&lt;deltaCauchy&lt;&lt;std::endl;#endif if( deltaCauchy[2] &gt; 0.2f )&#123; deltaCauchy[2] = 0.2f; std::cout&lt;&lt;&quot;delta Cauchy angle change too large&quot;&lt;&lt;std::endl; &#125; else if( deltaCauchy[2] &lt; -0.2f )&#123; deltaCauchy[2] = -0.2f; std::cout&lt;&lt;&quot;delta Cauchy angle change too small&quot;&lt;&lt;std::endl; &#125; updateEstimatedPose( occuMap, estimateInWorld, deltaCauchy ); return true; &#125; return false; &#125;void ScanMatchMethod::updateEstimatedPose( const OccupiedMap &amp;occuMap, Eigen::Vector3f &amp;estimateInWorld, Eigen::Vector3f &amp;delta )&#123; Eigen::Vector3f estimateInMap( occuMap.robotPoseWorld2Map( estimateInWorld ) ); // pose[t_time] = pose[(t - 1)_time] + delta( cauchy ); estimateInMap += delta; estimateInWorld = occuMap.robotPoseMap2World( estimateInMap );&#125;Eigen::Vector3f ScanMatchMethod::scanToMap( const OccupiedMap &amp;occuMap, Eigen::Vector3f &amp;beginEstimatedPoseInWorld, const ScanContainer &amp;scanPoints, Eigen::Matrix3f &amp;covarinceMatrix, int maxInterations )&#123; //std::cout&lt;&lt;&quot;-----------------------------------LOGGGGG ---- OccupiedMap.getSizeX(): &quot;&lt;&lt;occuMap.getSizeX()&lt;&lt;std::endl; Eigen::Vector3f estimatePose( beginEstimatedPoseInWorld ); if( scanPoints.getSize() == 0 )&#123; return beginEstimatedPoseInWorld; &#125; // 1. first iteration estimateTransformationOnce( occuMap, estimatePose, scanPoints ); // 2. multiple iterations for( int i = 0; i &lt; maxInterations - 1; i ++ )&#123; estimateTransformationOnce( occuMap, estimatePose, scanPoints ); &#125; // 3. normalize the angle [-PI ~ PI] estimatePose[2] = normalize_angle( estimatePose[2] ); // 4. get the covariance matrix covarinceMatrix = Eigen::Matrix3f::Zero(); covarinceMatrix = H; // 5. return the estimated pose in world coordinate return estimatePose;&#125;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"Eigen","slug":"Eigen","date":"2022-03-02T04:30:12.000Z","updated":"2022-03-02T05:45:40.321Z","comments":true,"path":"2022/03/02/Eigen/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/02/Eigen/","excerpt":"","text":"参考网址: (110条消息) EIGEN:学习笔记_hpu_lx-CSDN博客 (110条消息) eigen与matlab对应函数列表_Hurmean的博客-CSDN博客 eigen与matlab对应函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// A simple quickref for Eigen. Add anything that&#x27;s missing.// Main author: Keir Mierle#include &lt;Eigen/Dense&gt;Matrix&lt;double, 3, 3&gt; A; // Fixed rows and cols. Same as Matrix3d.Matrix&lt;double, 3, Dynamic&gt; B; // Fixed rows, dynamic cols.Matrix&lt;double, Dynamic, Dynamic&gt; C; // Full dynamic. Same as MatrixXd.Matrix&lt;double, 3, 3, RowMajor&gt; E; // Row major; default is column-major.Matrix3f P, Q, R; // 3x3 float matrix.Vector3f x, y, z; // 3x1 float matrix.RowVector3f a, b, c; // 1x3 float matrix.VectorXd v; // Dynamic column vector of doublesdouble s; // Basic usage// Eigen // Matlab // commentsx.size() // length(x) // vector sizeC.rows() // size(C,1) // number of rowsC.cols() // size(C,2) // number of columnsx(i) // x(i+1) // Matlab is 1-basedC(i,j) // C(i+1,j+1) //A.resize(4, 4); // Runtime error if assertions are on.B.resize(4, 9); // Runtime error if assertions are on.A.resize(3, 3); // Ok; size didn&#x27;t change.B.resize(3, 9); // Ok; only dynamic cols changed. A &lt;&lt; 1, 2, 3, // Initialize A. The elements can also be 4, 5, 6, // matrices, which are stacked along cols 7, 8, 9; // and then the rows are stacked.B &lt;&lt; A, A, A; // B is three horizontally stacked A&#x27;s.A.fill(10); // Fill A with all 10&#x27;s.// Eigen // MatlabMatrixXd::Identity(rows,cols) // eye(rows,cols)C.setIdentity(rows,cols) // C = eye(rows,cols)MatrixXd::Zero(rows,cols) // zeros(rows,cols)C.setZero(rows,cols) // C = ones(rows,cols)MatrixXd::Ones(rows,cols) // ones(rows,cols)C.setOnes(rows,cols) // C = ones(rows,cols)MatrixXd::Random(rows,cols) // rand(rows,cols)*2-1 // MatrixXd::Random returns uniform random numbers in (-1, 1).C.setRandom(rows,cols) // C = rand(rows,cols)*2-1VectorXd::LinSpaced(size,low,high) // linspace(low,high,size)&#x27; v.setLinSpaced(size,low,high) // v = linspace(low,high,size)&#x27;// Matrix slicing and blocks. All expressions listed here are read/write.// Templated size versions are faster. Note that Matlab is 1-based (a size N// vector is x(1)...x(N)).// Eigen // Matlabx.head(n) // x(1:n)x.head&lt;n&gt;() // x(1:n)x.tail(n) // x(end - n + 1: end)x.tail&lt;n&gt;() // x(end - n + 1: end)x.segment(i, n) // x(i+1 : i+n)x.segment&lt;n&gt;(i) // x(i+1 : i+n)P.block(i, j, rows, cols) // P(i+1 : i+rows, j+1 : j+cols)P.block&lt;rows, cols&gt;(i, j) // P(i+1 : i+rows, j+1 : j+cols)P.row(i) // P(i+1, :)P.col(j) // P(:, j+1)P.leftCols&lt;cols&gt;() // P(:, 1:cols)P.leftCols(cols) // P(:, 1:cols)P.middleCols&lt;cols&gt;(j) // P(:, j+1:j+cols)P.middleCols(j, cols) // P(:, j+1:j+cols)P.rightCols&lt;cols&gt;() // P(:, end-cols+1:end)P.rightCols(cols) // P(:, end-cols+1:end)P.topRows&lt;rows&gt;() // P(1:rows, :)P.topRows(rows) // P(1:rows, :)P.middleRows&lt;rows&gt;(i) // P(:, i+1:i+rows)P.middleRows(i, rows) // P(:, i+1:i+rows)P.bottomRows&lt;rows&gt;() // P(:, end-rows+1:end)P.bottomRows(rows) // P(:, end-rows+1:end)P.topLeftCorner(rows, cols) // P(1:rows, 1:cols)P.topRightCorner(rows, cols) // P(1:rows, end-cols+1:end)P.bottomLeftCorner(rows, cols) // P(end-rows+1:end, 1:cols)P.bottomRightCorner(rows, cols) // P(end-rows+1:end, end-cols+1:end)P.topLeftCorner&lt;rows,cols&gt;() // P(1:rows, 1:cols)P.topRightCorner&lt;rows,cols&gt;() // P(1:rows, end-cols+1:end)P.bottomLeftCorner&lt;rows,cols&gt;() // P(end-rows+1:end, 1:cols)P.bottomRightCorner&lt;rows,cols&gt;() // P(end-rows+1:end, end-cols+1:end)// Of particular note is Eigen&#x27;s swap function which is highly optimized.// Eigen // MatlabR.row(i) = P.col(j); // R(i, :) = P(:, i)R.col(j1).swap(mat1.col(j2)); // R(:, [j1 j2]) = R(:, [j2, j1])// Views, transpose, etc; all read-write except for .adjoint().// Eigen // MatlabR.adjoint() // R&#x27;R.transpose() // R.&#x27; or conj(R&#x27;)R.diagonal() // diag(R)x.asDiagonal() // diag(x)R.transpose().colwise().reverse(); // rot90(R)R.conjugate() // conj(R)// All the same as Matlab, but matlab doesn&#x27;t have *= style operators.// Matrix-vector. Matrix-matrix. Matrix-scalar.y = M*x; R = P*Q; R = P*s;a = b*M; R = P - Q; R = s*P;a *= M; R = P + Q; R = P/s; R *= Q; R = s*P; R += Q; R *= s; R -= Q; R /= s;// Vectorized operations on each element independently// Eigen // MatlabR = P.cwiseProduct(Q); // R = P .* QR = P.array() * s.array();// R = P .* sR = P.cwiseQuotient(Q); // R = P ./ QR = P.array() / Q.array();// R = P ./ QR = P.array() + s.array();// R = P + sR = P.array() - s.array();// R = P - sR.array() += s; // R = R + sR.array() -= s; // R = R - sR.array() &lt; Q.array(); // R &lt; QR.array() &lt;= Q.array(); // R &lt;= QR.cwiseInverse(); // 1 ./ PR.array().inverse(); // 1 ./ PR.array().sin() // sin(P)R.array().cos() // cos(P)R.array().pow(s) // P .^ sR.array().square() // P .^ 2R.array().cube() // P .^ 3R.cwiseSqrt() // sqrt(P)R.array().sqrt() // sqrt(P)R.array().exp() // exp(P)R.array().log() // log(P)R.cwiseMax(P) // max(R, P)R.array().max(P.array()) // max(R, P)R.cwiseMin(P) // min(R, P)R.array().min(P.array()) // min(R, P)R.cwiseAbs() // abs(P)R.array().abs() // abs(P)R.cwiseAbs2() // abs(P.^2)R.array().abs2() // abs(P.^2)(R.array() &lt; s).select(P,Q); // (R &lt; s ? P : Q)// Reductions.int r, c;// Eigen // MatlabR.minCoeff() // min(R(:))R.maxCoeff() // max(R(:))s = R.minCoeff(&amp;r, &amp;c) // [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);s = R.maxCoeff(&amp;r, &amp;c) // [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);R.sum() // sum(R(:))R.colwise().sum() // sum(R)R.rowwise().sum() // sum(R, 2) or sum(R&#x27;)&#x27;R.prod() // prod(R(:))R.colwise().prod() // prod(R)R.rowwise().prod() // prod(R, 2) or prod(R&#x27;)&#x27;R.trace() // trace(R)R.all() // all(R(:))//检测矩阵中是否全为非零元素R.colwise().all() // all(R)R.rowwise().all() // all(R, 2)R.any() // any(R(:))//检测矩阵中是否有非零元素，如果有，则返回1，否则，返回0。用法和all一样R.colwise().any() // any(R)R.rowwise().any() // any(R, 2)// Dot products, norms, etc.// Eigen // Matlabx.norm() // norm(x). Note that norm(R) doesn&#x27;t work in Eigen.x.squaredNorm() // dot(x, x) Note the equivalence is not true for complexx.dot(y) // dot(x, y)x.cross(y) // cross(x, y) Requires #include &lt;Eigen/Geometry&gt; Type conversion// Eigen // MatlabA.cast&lt;double&gt;(); // double(A)A.cast&lt;float&gt;(); // single(A)A.cast&lt;int&gt;(); // int32(A)A.real(); // real(A)A.imag(); // imag(A)// if the original type equals destination type, no work is done// Note that for most operations Eigen requires all operands to have the same type:MatrixXf F = MatrixXf::Zero(3,3);A += F; // illegal in Eigen. In Matlab A = A+F is allowedA += F.cast&lt;double&gt;(); // F converted to double and then added (generally, conversion happens on-the-fly)// Eigen can map existing memory into Eigen matrices.float array[3];Vector3f::Map(array).fill(10); // create a temporary Map over array and sets entries to 10int data[4] = &#123;1, 2, 3, 4&#125;;Matrix2i mat2x2(data); // copies data into mat2x2Matrix2i::Map(data) = 2*mat2x2; // overwrite elements of data with 2*mat2x2MatrixXi::Map(data, 2, 2) += mat2x2; // adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)// Solve Ax = b. Result stored in x. Matlab: x = A \\ b.x = A.ldlt().solve(b)); // A sym. p.s.d. #include &lt;Eigen/Cholesky&gt;x = A.llt() .solve(b)); // A sym. p.d. #include &lt;Eigen/Cholesky&gt;x = A.lu() .solve(b)); // Stable and fast. #include &lt;Eigen/LU&gt;x = A.qr() .solve(b)); // No pivoting. #include &lt;Eigen/QR&gt;x = A.svd() .solve(b)); // Stable, slowest. #include &lt;Eigen/SVD&gt;// .ldlt() -&gt; .matrixL() and .matrixD()// .llt() -&gt; .matrixL()// .lu() -&gt; .matrixL() and .matrixU()// .qr() -&gt; .matrixQ() and .matrixR()// .svd() -&gt; .matrixU(), .singularValues(), and .matrixV()// Eigenvalue problems// Eigen // MatlabA.eigenvalues(); // eig(A);EigenSolver&lt;Matrix3d&gt; eig(A); // [vec val] = eig(A)eig.eigenvalues(); // diag(val)eig.eigenvectors(); // vec// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"g2o","slug":"g2o","date":"2022-03-02T04:30:12.000Z","updated":"2022-03-22T00:13:17.105Z","comments":true,"path":"2022/03/02/g2o/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/02/g2o/","excerpt":"","text":"参考网址: slambook2/ch6 at master · gaoxiang12/slambook2 (github.com) (111条消息) 从零开始搭二维激光SLAM — 基于g2o的后端优化的代码实现 (111条消息) 从零开始一起学习SLAM | 掌握g2o顶点编程套路_计算机视觉life-CSDN博客 Slam-Project-Of-MyOwn/slamSimulationTest.cpp at master (111条消息) SLAM从0到1之图优化g2o：从看懂代码到动手编写（长文）_3D视觉工坊-CSDN博客 简介在图优化里,g2o使用非常普遍,需要注意一下关于( vertex)与(edge)概念与选择.实现步骤如下: 创建一个线性求解器LinearSolver 创建BlockSolver。并用上面定义的线性求解器初始化 创建总求解器solver 稀疏优化器（SparseOptimizer） 定义图的顶点和边。并添加到SparseOptimizer中 设置优化参数，开始执行优化 高翔博士123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;g2o/core/g2o_core_api.h&gt;#include &lt;g2o/core/base_vertex.h&gt;#include &lt;g2o/core/base_unary_edge.h&gt;#include &lt;g2o/core/block_solver.h&gt;#include &lt;g2o/core/optimization_algorithm_levenberg.h&gt;#include &lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;#include &lt;g2o/core/optimization_algorithm_dogleg.h&gt;#include &lt;g2o/solvers/dense/linear_solver_dense.h&gt;#include &lt;Eigen/Core&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;cmath&gt;#include &lt;chrono&gt;using namespace std;// 曲线模型的顶点，模板参数：优化变量维度和数据类型class CurveFittingVertex : public g2o::BaseVertex&lt;3, Eigen::Vector3d&gt; &#123;public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW // 重置 virtual void setToOriginImpl() override &#123; _estimate &lt;&lt; 0, 0, 0; &#125; // 更新 virtual void oplusImpl(const double *update) override &#123; _estimate += Eigen::Vector3d(update); &#125; // 存盘和读盘：留空 virtual bool read(istream &amp;in) &#123;&#125; virtual bool write(ostream &amp;out) const &#123;&#125;&#125;;// 误差模型 模板参数：观测值维度，类型，连接顶点类型class CurveFittingEdge : public g2o::BaseUnaryEdge&lt;1, double, CurveFittingVertex&gt; &#123;public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW CurveFittingEdge(double x) : BaseUnaryEdge(), _x(x) &#123;&#125; // 计算曲线模型误差 virtual void computeError() override &#123; const CurveFittingVertex *v = static_cast&lt;const CurveFittingVertex *&gt; (_vertices[0]); const Eigen::Vector3d abc = v-&gt;estimate(); _error(0, 0) = _measurement - std::exp(abc(0, 0) * _x * _x + abc(1, 0) * _x + abc(2, 0)); &#125; // 计算雅可比矩阵 virtual void linearizeOplus() override &#123; const CurveFittingVertex *v = static_cast&lt;const CurveFittingVertex *&gt; (_vertices[0]); const Eigen::Vector3d abc = v-&gt;estimate(); double y = exp(abc[0] * _x * _x + abc[1] * _x + abc[2]); _jacobianOplusXi[0] = -_x * _x * y; _jacobianOplusXi[1] = -_x * y; _jacobianOplusXi[2] = -y; &#125; virtual bool read(istream &amp;in) &#123;&#125; virtual bool write(ostream &amp;out) const &#123;&#125;public: double _x; // x 值， y 值为 _measurement&#125;;int main(int argc, char **argv) &#123; double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点 double w_sigma = 1.0; // 噪声Sigma值 double inv_sigma = 1.0 / w_sigma; cv::RNG rng; // OpenCV随机数产生器 vector&lt;double&gt; x_data, y_data; // 数据 for (int i = 0; i &lt; N; i++) &#123; double x = i / 100.0; x_data.push_back(x); y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); &#125; // 构建图优化，先设定g2o // 第1步：创建一个线性求解器LinearSolver typedef g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;3, 1&gt;&gt; BlockSolverType; // 每个误差项优化变量维度为3，误差值维度为1 // 第2步：创建BlockSolver。并用上面定义的线性求解器初始化 typedef g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType; // 线性求解器类型 // 梯度下降方法，可以从GN, LM, DogLeg 中选 // 第3步：创建总求解器solver。并从GN, LM, DogLeg 中选一个，再用上述块求解器BlockSolver初始化 auto solver = new g2o::OptimizationAlgorithmGaussNewton( g2o::make_unique&lt;BlockSolverType&gt;(g2o::make_unique&lt;LinearSolverType&gt;())); // 第4步：创建终极大boss 稀疏优化器（SparseOptimizer） g2o::SparseOptimizer optimizer; // 图模型 optimizer.setAlgorithm(solver); // 设置求解器 optimizer.setVerbose(true); // 打开调试输出 // 第5步：定义图的顶点和边。并添加到SparseOptimizer中 // 往图中增加顶点 CurveFittingVertex *v = new CurveFittingVertex(); v-&gt;setEstimate(Eigen::Vector3d(ae, be, ce)); v-&gt;setId(0); optimizer.addVertex(v); // 往图中增加边 for (int i = 0; i &lt; N; i++) &#123; CurveFittingEdge *edge = new CurveFittingEdge(x_data[i]); edge-&gt;setId(i); edge-&gt;setVertex(0, v); // 设置连接的顶点 edge-&gt;setMeasurement(y_data[i]); // 观测数值 edge-&gt;setInformation(Eigen::Matrix&lt;double, 1, 1&gt;::Identity() * 1 / (w_sigma * w_sigma)); // 信息矩阵：协方差矩阵之逆 optimizer.addEdge(edge); &#125; // 执行优化 cout &lt;&lt; &quot;start optimization&quot; &lt;&lt; endl; chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); // 第6步：设置优化参数，开始执行优化 optimizer.initializeOptimization(); optimizer.optimize(10); chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;(t2 - t1); cout &lt;&lt; &quot;solve time cost = &quot; &lt;&lt; time_used.count() &lt;&lt; &quot; seconds. &quot; &lt;&lt; endl; // 输出优化值 Eigen::Vector3d abc_estimate = v-&gt;estimate(); cout &lt;&lt; &quot;estimated model: &quot; &lt;&lt; abc_estimate.transpose() &lt;&lt; endl; return 0;&#125; 李想大佬12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 添加Vertexvoid G2oSolver::AddNode(karto::Vertex&lt;karto::LocalizedRangeScan&gt; *pVertex)&#123; karto::Pose2 odom = pVertex-&gt;GetObject()-&gt;GetCorrectedPose(); g2o::VertexSE2 *poseVertex = new g2o::VertexSE2; poseVertex-&gt;setEstimate(g2o::SE2(odom.GetX(), odom.GetY(), odom.GetHeading())); poseVertex-&gt;setId(pVertex-&gt;GetObject()-&gt;GetUniqueId()); mOptimizer.addVertex(poseVertex); ROS_DEBUG(&quot;[g2o] Adding node %d.&quot;, pVertex-&gt;GetObject()-&gt;GetUniqueId());&#125;// 添加edgevoid G2oSolver::AddConstraint(karto::Edge&lt;karto::LocalizedRangeScan&gt; *pEdge)&#123; // Create a new edge g2o::EdgeSE2 *odometry = new g2o::EdgeSE2; // Set source and target int sourceID = pEdge-&gt;GetSource()-&gt;GetObject()-&gt;GetUniqueId(); int targetID = pEdge-&gt;GetTarget()-&gt;GetObject()-&gt;GetUniqueId(); odometry-&gt;vertices()[0] = mOptimizer.vertex(sourceID); odometry-&gt;vertices()[1] = mOptimizer.vertex(targetID); if (odometry-&gt;vertices()[0] == NULL) &#123; ROS_ERROR(&quot;[g2o] Source vertex with id %d does not exist!&quot;, sourceID); delete odometry; return; &#125; if (odometry-&gt;vertices()[1] == NULL) &#123; ROS_ERROR(&quot;[g2o] Target vertex with id %d does not exist!&quot;, targetID); delete odometry; return; &#125; // Set the measurement (odometry distance between vertices) karto::LinkInfo *pLinkInfo = (karto::LinkInfo *)(pEdge-&gt;GetLabel()); karto::Pose2 diff = pLinkInfo-&gt;GetPoseDifference(); g2o::SE2 measurement(diff.GetX(), diff.GetY(), diff.GetHeading()); odometry-&gt;setMeasurement(measurement); // Set the covariance of the measurement karto::Matrix3 precisionMatrix = pLinkInfo-&gt;GetCovariance().Inverse(); Eigen::Matrix&lt;double, 3, 3&gt; info; info(0, 0) = precisionMatrix(0, 0); info(0, 1) = info(1, 0) = precisionMatrix(0, 1); info(0, 2) = info(2, 0) = precisionMatrix(0, 2); info(1, 1) = precisionMatrix(1, 1); info(1, 2) = info(2, 1) = precisionMatrix(1, 2); info(2, 2) = precisionMatrix(2, 2); odometry-&gt;setInformation(info); // Add the constraint to the optimizer ROS_DEBUG(&quot;[g2o] Adding Edge from node %d to node %d.&quot;, sourceID, targetID); mOptimizer.addEdge(odometry);&#125; 道峰大佬 - 直接将V计算给edge12345678910111213141516171819202122232425262728// 初始化slam::optimizer::GraphOptimize optimizer;optimizer.createOptimizer();optimizer.setMaxIeration(10);// 加顶点,加边Eigen::Vector3f robotPoseCurr( 0.0f, 0.0f, 0.0f );int keyFrameCount = 0;optimizer.addVertex( robotPoseCurr, keyFrameCount ); // add a vertexEigen::Matrix3d information = Eigen::Matrix3d::Identity(); //information matrixEigen::Matrix&lt;float, 3, 3&gt; T1 = slam.v2t( robotPosePrev );Eigen::Matrix&lt;float, 3, 3&gt; T2 = slam.v2t( robotPoseCurr );Eigen::Matrix&lt;float, 3, 3&gt; T = T1.inverse() * T2;Eigen::Vector3f V = slam.t2v( T );optimizer.addEdge( V, keyFrameCount - 1, keyFrameCount, information ); // add a edgeEigen::Matrix3d information = 1 * Eigen::Matrix3d::Identity(); //information matrixEigen::Matrix&lt;float, 3, 3&gt; T1 = slam.v2t( robotPoseCurr );Eigen::Matrix&lt;float, 3, 3&gt; T2 = slam.v2t( keyPoses[loopId] );Eigen::Matrix&lt;float, 3, 3&gt; T = T1.inverse() * T2;Eigen::Vector3f V = slam.t2v( T );optimizer.addEdge( V, keyFrameCount, loopId, information ); // add a loop constraint// 执行optimizer.execuateGraphOptimization(); // execuate the graph optimizationoptimizer.getOptimizedResults(); // get the optimized resultsstd::vector&lt;Eigen::Vector3f&gt; estimatedPoses = optimizer.getEstimatedPoses(); 设置一元边 - 使用现成的edge12345678// 往图中增加边 for ( int i=0; i&lt;N; i++ )&#123; CurveFittingEdge* edge = new CurveFittingEdge( x_data[i] ); edge-&gt;setId(i); edge-&gt;setVertex( 0, v ); optimizer.addEdge( edge );&#125; 设置二元边( 前后两个位姿 )12345678910index = 1;for ( const Point2f p:points_2d )&#123; g2o::EdgeProjectXYZ2UV* edge = new g2o::EdgeProjectXYZ2UV(); edge-&gt;setId ( index ); // 边的b编号 edge-&gt;setVertex ( 1, pose ); edge-&gt;setMeasurement ( Eigen::Vector2d ( p.x, p.y ) ); // 设置观测的特征点图像坐标 edge-&gt;setInformation( Eigen::Matrix&lt;double,1,1&gt;::Identity()*1/(w_sigma*w_sigma) ); // 信息矩阵：协方差矩阵之逆 optimizer.addEdge ( edge ); index++;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"matlab实现雅可比,海塞矩阵","slug":"matlab实现雅可比,海塞矩阵","date":"2022-03-01T04:30:12.000Z","updated":"2022-03-01T11:42:00.396Z","comments":true,"path":"2022/03/01/matlab实现雅可比,海塞矩阵/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/matlab%E5%AE%9E%E7%8E%B0%E9%9B%85%E5%8F%AF%E6%AF%94,%E6%B5%B7%E5%A1%9E%E7%9F%A9%E9%98%B5/","excerpt":"","text":"参考网址: (110条消息) matlab 构建雅可比矩阵,matlab jacobian函数_weixin_39726697的博客-CSDN博客 (110条消息) matlab不能使用syms,matlab syms什么意思_不告诉你不告诉你的博客-CSDN博客 (110条消息) matlab计算hessian矩阵_微电子学与固体电子学-CSDN博客_matlab计算海塞矩阵 (110条消息) Matlab中gradient函数的使用方法_Simy Hsu’s Blog-CSDN博客_gradient matlab 实例123456789101112131415161718clc;clear all;close;% syms x y z% jacobian([x*y*z, y^2, x + z], [x, y, z])%syms a b c x% 设变量为a,b,cf = exp(a*x^2+b*x+c);d = jacobian(f,[a,b,c]);% 进行有雅可比变换disp(d)% pretty(d)% hessian矩阵 = 梯度矩阵的雅可比矩阵% syms x y z;% f1=(x^2-2*x)*exp(-x^2-y^2-x*y);% f = x*y + 2*z*x;% hessian(f,[x,y,z])% gradient(f1):求f1梯度S=jacobian(gradient(f,[a,b,c]),[a,b,c]);disp(S)% pretty(S)","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"matlab正态分布常用函数","slug":"matlab正态分布常用函数","date":"2022-03-01T04:30:12.000Z","updated":"2022-03-01T02:34:25.542Z","comments":true,"path":"2022/03/01/matlab正态分布常用函数/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/matlab%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"参考网址: (110条消息) 【Matlab】正态分布常用函数normpdf_normcdf_norminv_normrnd_normfit_Find your love-CSDN博客_matlab正态分布函数 normrnd用法 12R = normrnd(mu,sigma) % 生成一个数R = normrnd(mu,sigma,m,n,...) % 生成m*n列向量 例子 12345678910&gt;&gt; normrnd(0,1)ans = 1.4122&gt;&gt; normrnd(0,1,5,3)ans = 0.0226 0.9199 -0.7777 -0.0479 0.1498 0.5667 1.7013 1.4049 -1.3826 -0.5097 1.0341 0.2445 -0.0029 0.2916 0.8084","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"pf","slug":"pf","date":"2022-03-01T04:30:12.000Z","updated":"2022-03-01T02:48:50.913Z","comments":true,"path":"2022/03/01/pf/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/pf/","excerpt":"","text":"参考网址: 忠厚老实的老王的个人空间_哔哩哔哩_bilibili 笔记123456789101112131415pf简单步骤 - 预测:xk(i)=f(xk-1(i))+vk vk~N(0,Q) - 更新:wk(i)=fk(yk-h(xk(i)))*wk-1(i) - 归一化:wk(i)=wk(i)/(求和)wk(i) - 重采样:具体看下边重采样部分pf步骤 - 给初值x0~N(u,sigma^2) - 生成x0(i),w0(i)=1/n - 预测步,生成x1(i)=f(x0(i))+v,v为~N(0,Q)随机数,共n个 - 更新步,设观测值y1,生成w1(i)=fR(y-h(x1(i)))*w0(i) - 将w1(i)归一化,w1(i)=w1(i)/(求和(w1(i))) - 此时得到新的例子x1(i),新的权重w1(i) - 再由预测步生成x2(i)=f(x1(i))+v - 在由更新步生成w2(i)=fR(y-h(x1(i)))*w1(i),归一化 - 如此递归 具体重采样算法 求期望与方差12Ex = (积分)[(求和)wi*(狄拉克)(x-xi)]dx =(求和)(wi*xi)Dx = E(x^2)+(Ex)^2 = (求和)(wi*xi^2)+(Ex)^2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102%粒子滤波演示代码%纸上得来终觉浅，绝知此事要躬行%演示代码，让机器适应人，代码讲究逻辑性可读性%工程代码，让人适应机器，强调代码运行速度和性能%x(i)=sin(x(i-1))+5*x(i-1)/(x(i-1)^2+1)+Q%y(i)=x(i)^2+R%注意，滤波之前一定要写成状态方程观测方程形式%xk=f(xk-1)%大多数情况下，是不能直接得到xk与xk-1的关系的%x=f(t)%要将x=f(t)转化为xk=F(xk-1),具体可以看第八讲，还有更精细的模型，先看完第八讲，再看《数值分析》%第九章《常微分方程的数值解法》，第八讲实际上就是欧拉法，你们可以用改进欧拉法，或者龙格库塔法得到更精细的%xk=F(xk-1)%生成100个信号t=0.01:0.01:1;x=zeros(1,100);y=zeros(1,100);%t纯粹用来画图，注意和第八讲的区别，第八讲有dt这里没有，因为我直接给出了xk与xk-1的关系，所以不需要dt%给初值x(1)=0.1;y(1)=0.01^2;%生成真实数据与观测数据for i=2:100 x(i)=sin(x(i-1))+5*x(i-1)/(x(i-1)^2+1); y(i)=x(i)^2+normrnd(0,1);end%PF start%设粒子集合n=100;xold=zeros(1,n);xnew=zeros(1,n);xplus=zeros(1,100);%xplus用于存放滤波值，就是每一次后验概率的期望w=zeros(1,n);%设置x0(i),可以直接在正态分布采样，如果对初值有自信，也可以让所有粒子都相同for i=1:n xold(i)=0.1; w(i)=1/n;end%PF核心代码for i=2:100 %预测步 由x0推出x1 for j=1:n xold(j)=sin(xold(j))+5*xold(j)/(xold(j)^2+1)+normrnd(0,0.1);%Q end %预测步完毕 %更新步 for j=1:n % 因为这里是设置的常数 %w(j)=w(j)*fR(.....) %fR=(2*pi*R)^(-0.5)*exp(-((y(i)-xold(j)^2)^2/(2*R))) w(j)=exp(-((y(i)-xold(j)^2)^2/(2*0.1))); end %归一化 w=w/sum(w); %w/sum(w)与k*w/sum(k*w)结果一模一样 %(2*pi*R)^(-0.5)是常数 %w(j)，如果每次都重采样，每次w(j)都会被设为1/n，也是常数 %所以可以将他们去掉 %重采样 %N&lt;1/sum(wi^2),若不是每次都重采样，那么代码第54行就要做相应修改，把w(j)加上去 %生成c,范围为(0~1) c=zeros(1,n); c(1)=w(1); for j=2:n c(j)=c(j-1)+w(j); end %转盘子，生成随机数，看落在哪个区间 %首先我们要重采样n个粒子，粒子数要与之前相同 for j=1:n a=unifrnd(0,1);%均匀分布随机数 for k=1:n if (a&lt;c(k)) xnew(j)=xold(k); break;%%%%一定要break，否则重采样粒子会被最后一个粒子覆盖，具体见新的第十讲 end end end %重采样完毕 %把新的粒子赋值给xold，为下一步递推做准备 xold=xnew; %所有粒子权重都设为1/n for j=1:n w(j)=1/n; end %把每一步的后验概率期望赋值给xplus xplus(i)=sum(xnew)/n; endplot(t,x,&#x27;r&#x27;,t,xplus,&#x27;b&#x27;,&#x27;LineWidth&#x27;,1)%y=x^2+R 似然概率是一个多峰分布，y=4，x=2或-2%非线性问题一步一个坑，处处是雷%如果问题本身的性质就是强烈的非线性，比如多峰分布这种，粒子滤波并不能化腐朽为神奇%尽量不要有多峰分布%粒子滤波的计算速度是大硬伤%可以尝试没有重采样的粒子滤波代码会是什么样的，自己尝试写写，自己调调参数 %主要需要调Q,R,重采样,粒子数目","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"在线好用软件","slug":"在线好用软件","date":"2022-03-01T04:30:12.000Z","updated":"2022-03-01T05:39:14.419Z","comments":true,"path":"2022/03/01/在线好用软件/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/%E5%9C%A8%E7%BA%BF%E5%A5%BD%E7%94%A8%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"在线代码对比工具: 在线代码对比/合并工具|代码对比 - JSON.cn 这里包含了关于编译器,json解析工具,ip工具,电子计算器,图片压缩,代码对比等丰富资源 crc校验工具 On-line CRC calculation and free library - Lammert Bies 在线公式生成工具 Online LaTeX Equation Editor - create, integrate and download online. (codecogs.com) 流程图 diagrams.net 跨平台文件传输 AirPortal 空投快传 vpn 用户中心 - JiaSu8 Pink pdf转cad PDF转换成CAD – 在线PDF转CAD – 迅捷PDF转换器在线免费版 (xunjiepdf.com) 格式转换 在线将PGM 转换成 PNG 。 免费将.PGM 转换成.PNG 。 (onlineconvertfree.com) 在线计算器 GeoGebra","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"手撸高斯牛顿","slug":"手撸高斯牛顿","date":"2022-03-01T04:30:12.000Z","updated":"2022-03-02T05:33:41.741Z","comments":true,"path":"2022/03/01/手撸高斯牛顿/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/%E6%89%8B%E6%92%B8%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF/","excerpt":"","text":"参考网址: slambook2/ch6 at master · gaoxiang12/slambook2 (github.com) 步骤 给定初值x0. 对于k次迭代,求出当前雅可比矩阵J(xk)和误差发(xk). 求解增量方程:Hdxk=g. 若dxk足够小则停止.否则,令xk+1 = xk +dx,返回第2步. 高翔博士的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;using namespace std;using namespace Eigen;int main(int argc, char **argv) &#123; double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 // 给定初值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点 double w_sigma = 1.0; // 噪声Sigma值 double inv_sigma = 1.0 / w_sigma; // 噪声的逆 cv::RNG rng; // OpenCV随机数产生器 vector&lt;double&gt; x_data, y_data; // 数据 // 产生真实值 for (int i = 0; i &lt; N; i++) &#123; double x = i / 100.0; x_data.push_back(x); // 在x_data最后边存放x值 y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); //产生一个高斯噪声 &#125; // 开始Gauss-Newton迭代 int iterations = 100; // 迭代次数 double cost = 0, lastCost = 0; // 本次迭代的cost和上一次迭代的cost chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); for (int iter = 0; iter &lt; iterations; iter++) &#123; Matrix3d H = Matrix3d::Zero(); // Hessian = J^T W^&#123;-1&#125; J in Gauss-Newton Vector3d b = Vector3d::Zero(); // bias cost = 0; for (int i = 0; i &lt; N; i++) &#123; double xi = x_data[i], yi = y_data[i]; // 第i个数据点 // 对误差项error做最小二乘 double error = yi - exp(ae * xi * xi + be * xi + ce); Vector3d J; // 雅可比矩阵(Jacobian可以通过matlab求解) J[0] = -xi * xi * exp(ae * xi * xi + be * xi + ce); // de/da J[1] = -xi * exp(ae * xi * xi + be * xi + ce); // de/db J[2] = -exp(ae * xi * xi + be * xi + ce); // de/dc H += inv_sigma * inv_sigma * J * J.transpose(); b += -inv_sigma * inv_sigma * error * J; cost += error * error; &#125; // 求解线性方程 Hx=b Vector3d dx = H.ldlt().solve(b); if (isnan(dx[0])) &#123; cout &lt;&lt; &quot;result is nan!&quot; &lt;&lt; endl; break; &#125; if (iter &gt; 0 &amp;&amp; cost &gt;= lastCost) &#123; cout &lt;&lt; &quot;cost: &quot; &lt;&lt; cost &lt;&lt; &quot;&gt;= last cost: &quot; &lt;&lt; lastCost &lt;&lt; &quot;, break.&quot; &lt;&lt; endl; break; &#125; ae += dx[0]; be += dx[1]; ce += dx[2]; lastCost = cost; cout &lt;&lt; &quot;total cost: &quot; &lt;&lt; cost &lt;&lt; &quot;, \\t\\tupdate: &quot; &lt;&lt; dx.transpose() &lt;&lt; &quot;\\t\\testimated params: &quot; &lt;&lt; ae &lt;&lt; &quot;,&quot; &lt;&lt; be &lt;&lt; &quot;,&quot; &lt;&lt; ce &lt;&lt; endl; &#125; chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;(t2 - t1); cout &lt;&lt; &quot;solve time cost = &quot; &lt;&lt; time_used.count() &lt;&lt; &quot; seconds. &quot; &lt;&lt; endl; cout &lt;&lt; &quot;estimated abc = &quot; &lt;&lt; ae &lt;&lt; &quot;, &quot; &lt;&lt; be &lt;&lt; &quot;, &quot; &lt;&lt; ce &lt;&lt; endl; return 0;&#125; 用matlab实现一次12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455clear all; close all; clc;% 生成一组符合高斯噪声的,exp(1*X^2+2*x+1)的随机数ar=1;br=2;cr=1;n = 100; % 样本数w_sigma = 1;% 噪声值inv_sigma = 1/w_sigma;for i = 1:n x(i) = i/n; y(i) = exp(ar*x(i)^2+br*x(i)+cr)+normrnd(0,w_sigma);end% 设置x0初值ae = 2.0;be=-1.0;ce=5.0;cost = 0;lastcost=0;iterations = 100;% 迭代次数for iter = 1:iterations H = zeros(3,3); g = zeros(3,1); J = zeros(3,1); cost = 0; for j = 1:n error = y(j) - exp(ae*x(j)^2+be*x(j)+ce); J(1) = -x(j) * x(j) * exp(ae * x(j) * x(j) + be * x(j) + ce); % ae J(2) = -x(j) * exp(ae * x(j) * x(j) + be * x(j) + ce); % be J(3) = -exp(ae * x(j) * x(j) + be * x(j) + ce); % ce H = H+inv_sigma^2*J*J&#x27;; g = g-inv_sigma^2*J*error; cost = cost + error^2; end % 求解Hx=g deltax = inv(H)*g; if iter&gt;1&amp;&amp;abs(cost-lastcost)&lt;0.001 disp(&#x27;cost:&#x27;+cost); break; end ae = ae+deltax(1); be = be+deltax(2); ce = ce+deltax(3); lastcost = cost; disp([&#x27;iter: &#x27;,num2str(iter),&#x27; &#x27;, num2str(ae),&#x27; &#x27;,num2str(be),&#x27; &#x27;,num2str(ce)]); endf = exp(ae*x.^2+be*x+ce);plot(x,y,&#x27;bo&#x27;,x,f,&#x27;r&#x27;);","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"搜索网站","slug":"搜索网站","date":"2022-03-01T04:30:12.000Z","updated":"2022-05-12T02:19:58.914Z","comments":true,"path":"2022/03/01/搜索网站/","link":"","permalink":"https://peitianyu.github.io/blog/2022/03/01/%E6%90%9C%E7%B4%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"参考网址: 15个好用的百度网盘搜索引擎 - 知乎 (zhihu.com) 详细1、云铺子 - 百度网盘搜索引擎 地址：http://www.yunpz.net/ 查看方式：直接打开 推荐指数：★★★★★ 备注：聚合类，体验好，推荐！ 2、橘子盘搜-好用的影视资源搜索引擎 地址：https://www.nmme.cc/ 查看方式：直接打开 推荐指数：★★★★★ 备注：专攻影视搜索，度盘、迅雷、阿里，体验好，推荐！ 3、优聚搜 地址：https://ujuso.com/ 查看方式：直接打开 推荐指数：★★★★★ 备注：支持度盘、蓝奏、阿里，体验好，推荐！ 4、蓝瘦网盘在线搜索网页版 地址：http://www.sixyin.com/disk-search 查看方式：直接打开 推荐指数：★★★★☆ 备注：蓝奏云搜索，推荐！ 5、阿里盘搜 - 阿里云盘资源搜索神器 地址：https://www.alipanso.com/ 查看方式：直接打开 推荐指数：★★★★☆ 备注：阿里盘搜索，推荐！ 6、懒盘搜索聚合官网 地址：https://lzpan.com/ 查看方式：各种都有 推荐指数：★★★★☆ 备注：聚合类，含16个搜索引擎 7、超能搜 - 百度网盘搜索神器 地址：http://www.chaonengso.com/ 查看方式：各种都有 推荐指数：★★★★☆ 备注：聚合类，含18个搜索引擎 8、万网搜 - 资源搜索聚合神器 地址：http://www.wanwangsou.com/ 查看方式：各种都有 推荐指数：★★★★☆ 备注：聚合类，含15个搜索引擎 9、云盘狗-百度云网盘搜索 地址：http://www.yunpangou.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 10、学搜搜 地址：http://www.xuesousou.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 备注：学习资源搜索 11、盘131 - 云盘资源搜索引擎 地址：https://www.pan131.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 12、58网盘搜索 地址：https://www.58wangpan.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 13、56网盘搜索 地址：https://www.56wangpan.net/ 查看方式：直接打开 推荐指数：★★★☆☆ 14、一个好用的网盘搜索引擎 - 乌鸦搜 地址：https://www.wuyasou.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 15、bdy搜 地址：http://www.bdyso.com/ 查看方式：直接打开 推荐指数：★★★☆☆ 搜索相似网站 SimilarSites - Welcome","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"follow大佬","slug":"follow大佬","date":"2022-02-28T04:30:12.000Z","updated":"2022-03-19T14:53:15.653Z","comments":true,"path":"2022/02/28/follow大佬/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/28/follow%E5%A4%A7%E4%BD%AC/","excerpt":"","text":"slam方向 categories | 沉默杀手 (charon-cheung.github.io) (110条消息) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主 (110条消息) 「小白学移动机器人」一个专注分享移动机器人相关知识的公众号！_白茶-清欢_CSDN博客-从零搭建ROS机器人平台,slam相关,ros领域博主 Forrest-Z (zhouzuhong) (github.com) softdream (道锋) (github.com) (116条消息) 白巧克力亦唯心的博客_CSDN博客-算法推导系列 规划-控制 忠厚老实的老王的个人空间_哔哩哔哩_bilibili IR艾若机器人的个人空间_哔哩哔哩_bilibili 小黎的Ally的个人空间_哔哩哔哩_bilibili","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"kf","slug":"kf","date":"2022-02-28T04:30:12.000Z","updated":"2022-02-28T12:20:23.004Z","comments":true,"path":"2022/02/28/kf/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/28/kf/","excerpt":"","text":"参考网址: 忠厚老实的老王的个人空间_哔哩哔哩_bilibili 笔记12345678910111213----卡尔曼滤波算法----预测步 - 状态方程 X(K)minus=F*X(K-1)plus - 先验估计 P(K)minus=F*P(K-1)plus*F&#x27;+Q更新步 - 卡尔曼增益:若R足够大,则更偏向于观测值,若R趋近于0,则更相信预测值 K=P(K)minus*H&#x27;*inv(H*P(K)minus*H&#x27;+R) - 更新状态量 X(K)plus=X(K)minus+K*(y(k)-H*X(K)minus) - 更新后验概率 P(K)plus=(I-K*H)*(K)minus 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143clc ;close ;clear all;%%%%贝叶斯滤波与卡尔曼滤波第八讲matlab代码%%%%%%%%%%kalman filter%X(K)=F*X(K-1)+Q%Y(K)=H*X(K)+R%%%第一个问题，生成一段随机信号，并滤波%生成一段时间t,每隔0.01s采样一次t=0.1:0.01:1;L=length(t);%生成真实信号x，以及观测y%首先初始化x=zeros(1,L);y=x;y2=x;%生成信号，设x=t^2for i=1:L x(i)=t(i)^2; y(i)=x(i)+normrnd(0,0.1); %正态分布随机数，参数为期望和标准差 y2(i)=x(i)+normrnd(0,0.1);end%%%%%%%%%%%信号生成完毕%%%%%%%%%%%滤波算法%%%%%%%%%预测方程观测方程怎么写%%%%观测方程好写Y(K)=X(K)+R R~N(0,1)%预测方程不好写%%%%，在这里，可以猜一猜是线性增长，但是大多数问题，信号是杂乱无章的，怎么办%模型一，最粗糙的建模%X(K)=X(K-1)+Q%Y(K)=X(K)+R%猜Q~N(0,1);F1=1;H1=1;Q1=1;R1=1;%初始化x(k)+Xplus1=zeros(1,L);%plus + 的英语 minus -的英语%我们会经常用到Xplus,Xminus,Pplus,Pminus%设置一个初值，假设Xplus1(1)~N(0.01,0.01^2)Xplus1(1)=0.01;Pplus1=0.01^2;%%%卡尔曼滤波算法% 预测步%X(K)minus=F*X(K-1)plus%P(K)minus=F*P(K-1)plus*F&#x27;+Q(先验概率)% 更新步%K=P(K)minus*H&#x27;*inv(H*P(K)minus*H&#x27;+R)% 若R足够大,则更偏向于观测值,若R趋近于0,则更相信预测值%X(K)plus=X(K)minus+K*(y(k)-H*X(K)minus)% 更新后验概率%P(K)plus=(I-K*H)*P(K)minusfor i=2:L %%%%预测步%%%%%% Xminus1=F1*Xplus1(i-1); Pminus1=F1*Pplus1*F1&#x27;+Q1; %%%%%更新步%%%%% K1=(Pminus1*H1&#x27;)*inv(H1*Pminus1*H1&#x27;+R1); Xplus1(i)=Xminus1+K1*(y(i)-H1*Xminus1); Pplus1=(1-K1*H1)*Pminus1;end%模型2%X(K)=X(K-1)+X&#x27;(K-1)*dt+X&#x27;&#x27;(K-1)*dt^2*(1/2!)+Q2%Y(K)=X(K)+R R~N(0,1)%此时状态变量X=[X(K) X&#x27;(K) X&#x27;&#x27;(K) ]T(列向量）%Y(K)=H*X+R H=[1 0 0](行向量）%预测方程%X(K)=X(K-1)+X&#x27;(K-1)*dt+X&#x27;&#x27;(K-1)*dt^2*(1/2!)+Q2%X&#x27;(K)=0*X(K-1)+X&#x27;(K-1)+X&#x27;&#x27;(K-1)*dt+Q3%X&#x27;&#x27;(K)=0*X(K-1)+0*X&#x27;(K-1)+X&#x27;&#x27;(K-1)+Q4 %%多项式信号多求几阶导数，总会比较平缓，而%X&#x27;&#x27;(K)=X&#x27;&#x27;(K-1)+Q3正是描述平缓的随机过程，这种建模相对精细一些，适用范围也较广%F=1 dt 0.5*dt^2% 0 1 dt% 0 0 1%H=[1 0 0]%Q= Q2 0 0% 0 Q3 0% 0 0 Q4 协方差矩阵dt=t(2)-t(1);F2=[1,dt,0.5*dt^2;0,1,dt;0,0,1];%%%此处要注意矩阵是否病态，若dt特别小，易导致矩阵病态或精度丢失H2=[1,0,0];Q2=[1,0,0;0,0.01,0;0,0,0.0001];R2=3;%%%设置初值%%%%Xplus2=zeros(3,L);Xplus2(1,1)=0.1^2;Xplus2(2,1)=0;Xplus2(3,1)=0;Pplus2=[0.01, 0,0;0,0.01,0;0,0,0.0001];for i=2:L %%%预测步%%% Xminus2=F2*Xplus2(:,i-1); Pminus2=F2*Pplus2*F2&#x27;+Q2; %%%更新步%%%% K2=(Pminus2*H2&#x27;)*inv(H2*Pminus2*H2&#x27;+R2); Xplus2(:,i)=Xminus2+K2*(y(i)-H2*Xminus2); Pplus2=(eye(3)-K2*H2)*Pminus2;end%%%可以进行在线滤波，实时滤波%%%%%问题2，两个传感器，进行滤波% Y1(K)=X(K)+R% Y2(K)=X(K)+R%H=[1 1]T (列向量) X=X(K)%H=1 0 0 X=X(K) X&#x27;(K) X&#x27;&#x27;(K)% 1 0 0F3=[1,dt,0.5*dt^2;0,1,dt;0,0,1];%%%此处要注意矩阵是否病态，若dt特别小，易导致矩阵病态或精度丢失H3=[1,0,0;1,0,0];Q3=[1,0,0;0,0.01,0;0,0,0.0001];R3=[3,0;0,3];%%%%%一定要注意是协方差矩阵%%%设置初值%%%%Xplus3=zeros(3,L);Xplus3(1,1)=0.1^2;Xplus3(2,1)=0;Xplus3(3,1)=0;Pplus3=[0.01, 0,0;0,0.01,0;0,0,0.0001];for i=2:L %%%预测步%%% Xminus3=F3*Xplus3(:,i-1); Pminus3=F3*Pplus3*F3&#x27;+Q3; %%%更新步%%%% K3=(Pminus3*H3&#x27;)*inv(H3*Pminus3*H3&#x27;+R3); Y=zeros(2,1); Y(1,1)= y(i); Y(2,1)=y2(i); Xplus3(:,i)=Xminus3+K3*(Y-H3*Xminus3); Pplus3=(eye(3)-K3*H3)*Pminus3;endplot(t,x,&#x27;r&#x27;,t,y,&#x27;g&#x27;,t,Xplus1(1,:),&#x27;b&#x27;,t,Xplus2(1,:),&#x27;k&#x27;,t,Xplus3(1,:),&#x27;m&#x27;,&#x27;LineWidth&#x27;,2); 拓展卡尔曼滤波123456789101112131415161718192021222324252627282930313233343536%EKF代码%x(k)=sin(3*x(k-1))%y(k)=x(k)^2%注意似然概率是多峰分布,具有强烈非线性,当y=4时,不知道x=2还是-2%%%生成真是信号与观测t=0.01:0.01:1;n=length(t);x=zeros(1,n);y=zeros(1,n);x(1)=0.1^2;for i=2:n x(i)=sin(3*x(i-1)); y(i)=x(i)^2+normrnd(0,0.7);end%EKFXplus=zeros(1,n);Pplus=0.1;Xplus(1)=0.1;Q=0.1;R=1;for i=2:n % 对x(k)微分,并赋值给A,代替f的线性化 A=3*cos(3*Xplus(i-1)); Xminus=sin(3*Xplus(i-1)); Pminus=A*Pplus*A&#x27;+Q; %更新步 % 用y(k)微分,复制给C,代替h的线性化 C=2*Xminus; K=Pminus*C*inv(C*Pminus*C&#x27;+R); Xplus(i)=Xminus+K*(y(i)-Xminus^2); Pplus=(eye(1)-K*C)*Pminus;end% 注意,实际上拓展卡尔曼滤波器,就是把x(k)微分,代替f的线性化,把y(k)微分,代替h的线性化plot(t,x,&#x27;r&#x27;,t,y,&#x27;b&#x27;,t,Xplus,&#x27;m&#x27;,&#x27;LineWidth&#x27;,1)","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"matlab命令行运行","slug":"matlab命令行运行","date":"2022-02-28T04:30:12.000Z","updated":"2022-03-01T00:01:02.831Z","comments":true,"path":"2022/02/28/matlab命令行运行/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/28/matlab%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C/","excerpt":"","text":"参考网址: (110条消息) matlab执行cmd命令是什么意思,cmd 命令行方式执行 matlab 脚本_翻译奥莉姐的博客-CSDN博客 VScode运行MATLAB（最正确版本） - 知乎 (zhihu.com) cmd窗口运行1matlab -nojvm -nodesktop -nodisplay -r test 远程执行 matlab 脚本(关闭终端)1matlab -nosplash -nodesktop -r test 插件使用matlab extension pack code runner","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"cc++中malloc和calloc以及relloc使用","slug":"c++中malloc和calloc以及relloc使用","date":"2022-02-24T04:30:12.000Z","updated":"2022-02-27T12:52:48.006Z","comments":true,"path":"2022/02/24/c++中malloc和calloc以及relloc使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/c++%E4%B8%ADmalloc%E5%92%8Ccalloc%E4%BB%A5%E5%8F%8Arelloc%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址 (110条消息) c语言中calloc是什么意思,C语言中malloc和calloc以及relloc函数的区别_棒棒鸡不棒的博客-CSDN博客 区别malloc char p = (char)maolloc(100); calloc calloc申请的动态内存空间是干净的内存，当你输出内存中的数据时它是NULL ,而malloc()申请的动态内存空间不一定是干净的，当你输出时有可能会打印出一些未知的数据 relloc rellc()函数是用于你的动态内存空间不足以存储你所要储存的信息时，需要再追加一段内存，函数的格式是：(类型说明符*)relloc(p,size);p是你原来申请的动态空间的首地址，是你要申请的动态内存的大小，而不是你要追加的动态内存空间大小，这一点要切记。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"c++中rand使用","slug":"c++中rand使用","date":"2022-02-24T04:30:12.000Z","updated":"2022-05-10T01:10:38.782Z","comments":true,"path":"2022/02/24/c++中rand使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/c++%E4%B8%ADrand%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址 (110条消息) rand 函数 与 srand 函数_myKernel-CSDN博客_srand48 (110条消息) drand48()函数_dwell548560的博客-CSDN博客_drand48 (132条消息) srand((unsigned)time(NULL))详解_清风lsq的博客-CSDN博客_srand(time(null)) 简介rand使用范围是( *0~RAND_MAX* ), srand(seed)函数用于给rand()函数设定种子。一般若是设置srand(time(NULL))**,一现在时间为时间种子, 一般目的是由于rand为伪随机,加上以当前时间为种子的话,便于产生真实随机数 测试代码12345678910 void test_rand(void) &#123; unsigned long n; srand((unsigned)time(NULL)); for(int i = 0; i &lt; 100; i++) &#123; n = rand(); printf(&quot;d\\n&quot;, n); &#125;&#125; drand48()函数 drand48 返回服从均匀分布的·[0.0, 1.0) 之间的 double 型随机数。 测试代码 1double r = drand48();","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"c++中sort,stack使用","slug":"c++中sort,stack使用","date":"2022-02-24T04:30:12.000Z","updated":"2022-02-27T12:53:10.296Z","comments":true,"path":"2022/02/24/c++中sort,stack使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/c++%E4%B8%ADsort,stack%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址 (110条消息) C++ sort()排序详解_ACfun-CSDN博客_c++sort排序 [(110条消息) STL源码剖析 容器]（五）[stl_stack.h]_深藏功与名-CSDN博客 sort使用12345bool cmp1(data a, data b)&#123; return a.x &lt; b.x; &#125;// 这里使用的是指针sort(exm_set,exm_set + size, cmp1); stack使用12345678stack&lt;Tnode*&gt; search_path; Tnode* pSearch = Kd; // stack容器 - 先进后出// 支持在这里进行push(), pop(), top()操作 // 比如:search_path.push(pSearch); search_path.top()search_path.pop()","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"kd树","slug":"kd树","date":"2022-02-24T04:30:12.000Z","updated":"2022-03-01T02:39:51.216Z","comments":true,"path":"2022/02/24/kd树/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/kd%E6%A0%91/","excerpt":"","text":"参考网址 学生视频-KD树_哔哩哔哩_bilibili (110条消息) 详解KDTree_爱冒险的技术宅-CSDN博客_kdtree (110条消息) 【PCL模块解析 05 之KDTree】01 KDTree原理及代码解析_水亦心的博客-CSDN博客 KD树 - Earendil - 博客园 (cnblogs.com) amcl内部也存在kdtree,可以i拿来看看 算法流程分为生成kdtree与搜索树两部分 结构体12345678910struct data&#123; double x = 0; double y = 0; &#125;; struct Tnode&#123; struct data dom_elt; int split; struct Tnode * left; struct Tnode * right; &#125;; 生成kdtree 多所有数据的各个维度做方差 选择方差大的方向进行,排序选择中位数作为分割点,并保存分割维度 然后在该维度判断大小,小的放在左侧,大的放在右侧 保存左右节点 然后递归 搜索树 如果Kd是空的，则设dist为无穷大返回 判断分割维度,判断进入左树还是右树,递归,最终找到最接近的叶子节点 判断目标点与叶子节点距离是否大于目标点到超平面距离,若不大于,则叶子节点为最终最接近点,否则回溯上一父节点 比较父节点空间另一叶子节点,若距离最短,则为最近点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;math.h&gt; using namespace std; /*function of this program: build a 2d tree using the input training data the input is exm_set which contains a list of tuples (x,y) the output is a 2d tree pointer*/ struct data &#123; double x = 0; double y = 0; &#125;; struct Tnode &#123; struct data dom_elt; int split; struct Tnode * left; struct Tnode * right; &#125;; bool cmp1(data a, data b)&#123; return a.x &lt; b.x; &#125; bool cmp2(data a, data b)&#123; return a.y &lt; b.y; &#125; bool equal(data a, data b)&#123; if (a.x == b.x &amp;&amp; a.y == b.y) &#123; return true; &#125; else&#123; return false; &#125; &#125; // 调用ChooseSplit函数选择分割维度和分割点void ChooseSplit(data exm_set[], int size, int &amp;split, data &amp;SplitChoice)&#123; /*compute the variance on every dimension. Set split as the dismension that have the biggest variance. Then choose the instance which is the median on this split dimension.*/ // 计算每个维度的方差。将split设置为方差最大的维度。然后选择实例，它是这个分割维度上的中值。 /*compute variance on the x,y dimension. DX=EX^2-(EX)^2*/ // 数据方差大表明沿该坐标轴方向上的数据分散得比较开，在这个方向上进行数据分割有较好的分辨率； double tmp1,tmp2; tmp1 = tmp2 = 0; for (int i = 0; i &lt; size; ++i) &#123; tmp1 += 1.0 / (double)size * exm_set[i].x * exm_set[i].x; tmp2 += 1.0 / (double)size * exm_set[i].x; &#125; double v1 = tmp1 - tmp2 * tmp2; //compute variance on the x dimension tmp1 = tmp2 = 0; for (int i = 0; i &lt; size; ++i) &#123; tmp1 += 1.0 / (double)size * exm_set[i].y * exm_set[i].y; tmp2 += 1.0 / (double)size * exm_set[i].y; &#125; double v2 = tmp1 - tmp2 * tmp2; //compute variance on the y dimension split = v1 &gt; v2 ? 0:1; //set the split dimension if (split == 0) &#123; // sort排序规则：按照x坐标排序 sort(exm_set,exm_set + size, cmp1); &#125; else&#123; sort(exm_set,exm_set + size, cmp2); &#125; //set the split point value // 设置分割点值,取中值 SplitChoice.x = exm_set[size / 2].x; SplitChoice.y = exm_set[size / 2].y; &#125; Tnode* build_kdtree(data exm_set[], int size, Tnode* T)&#123; // call function ChooseSplit to choose the split dimension and split point if (size == 0)&#123; return NULL; &#125; else&#123; // 若为0则按x维切割，否则按y维切割 int split; // 选择实例 data dom_elt; // 调用ChooseSplit函数选择分割维度和分割点 ChooseSplit(exm_set, size, split, dom_elt); data exm_set_right [100]; data exm_set_left [100]; int sizeleft ,sizeright; sizeleft = sizeright = 0; if (split == 0) &#123; for (int i = 0; i &lt; size; ++i) &#123; // 判断是否等于分割点，若小于于则放入左子树，若大于则放入右子树,否则不做处理 if (!equal(exm_set[i],dom_elt) &amp;&amp; exm_set[i].x &lt;= dom_elt.x) &#123; exm_set_left[sizeleft].x = exm_set[i].x; exm_set_left[sizeleft].y = exm_set[i].y; sizeleft++; &#125; else if (!equal(exm_set[i],dom_elt) &amp;&amp; exm_set[i].x &gt; dom_elt.x) &#123; exm_set_right[sizeright].x = exm_set[i].x; exm_set_right[sizeright].y = exm_set[i].y; sizeright++; &#125; &#125; &#125; else&#123; for (int i = 0; i &lt; size; ++i) &#123; if (!equal(exm_set[i],dom_elt) &amp;&amp; exm_set[i].y &lt;= dom_elt.y) &#123; exm_set_left[sizeleft].x = exm_set[i].x; exm_set_left[sizeleft].y = exm_set[i].y; sizeleft++; &#125; else if (!equal(exm_set[i],dom_elt) &amp;&amp; exm_set[i].y &gt; dom_elt.y) &#123; exm_set_right[sizeright].x = exm_set[i].x; exm_set_right[sizeright].y = exm_set[i].y; sizeright++; &#125; &#125; &#125; T = new Tnode; T-&gt;dom_elt.x = dom_elt.x; T-&gt;dom_elt.y = dom_elt.y; T-&gt;split = split; // 递归 T-&gt;left = build_kdtree(exm_set_left, sizeleft, T-&gt;left); T-&gt;right = build_kdtree(exm_set_right, sizeright, T-&gt;right); return T; &#125; &#125; // 计算欧式距离 double Distance(data a, data b)&#123; double tmp = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); return sqrt(tmp); &#125; // 寻找最近点void searchNearest(Tnode * Kd, data target, data &amp;nearestpoint, double &amp; distance)&#123; //1. 如果Kd是空的，则设dist为无穷大返回 //2. 向下搜索直到叶子结点 stack&lt;Tnode*&gt; search_path; Tnode* pSearch = Kd; data nearest; double dist; while(pSearch != NULL) &#123; //pSearch加入到search_path中; // stack容器 - 先进后出 // 一开始放入根结点, 然后根据条件放入左右子树 // 支持在这里进行push(), pop(), top()操作 search_path.push(pSearch); if (pSearch-&gt;split == 0) &#123; if(target.x &lt;= pSearch-&gt;dom_elt.x) /* 如果小于就进入左子树 */ &#123; pSearch = pSearch-&gt;left; &#125; else &#123; pSearch = pSearch-&gt;right; &#125; &#125; else&#123; if(target.y &lt;= pSearch-&gt;dom_elt.y) /* 如果小于就进入左子树 */ &#123; pSearch = pSearch-&gt;left; &#125; else &#123; pSearch = pSearch-&gt;right; &#125; &#125; &#125; //取出search_path最后一个赋给nearest nearest.x = search_path.top()-&gt;dom_elt.x; nearest.y = search_path.top()-&gt;dom_elt.y; // printf(&quot;x=%f, y=%f\\n&quot;, nearest.x, nearest.y); // 弹出pSearch的top search_path.pop(); dist = Distance(nearest, target); // 计算找到的叶节点与目标点的欧式距离 //3. 回溯搜索路径 Tnode* pBack; while(search_path.size() != 0) &#123; //取出search_path最后一个结点赋给pBack // 回溯到上一层节点 pBack = search_path.top(); search_path.pop(); if(pBack-&gt;left == NULL &amp;&amp; pBack-&gt;right == NULL) /* 如果pBack为叶子结点 */ &#123; // 如果pBack为叶子结点，则计算pBack与目标点的欧式距离，并与nearestpoint比较，如果更小，则更新nearestpoint if( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) ) &#123; nearest = pBack-&gt;dom_elt; dist = Distance(pBack-&gt;dom_elt, target); &#125; &#125; else &#123; // 定义s为分割线 int s = pBack-&gt;split; // 为0时，分割线为x轴 if (s == 0) &#123; if( fabs(pBack-&gt;dom_elt.x - target.x) &lt; dist) /* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */ &#123; if( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) ) &#123; nearest = pBack-&gt;dom_elt; dist = Distance(pBack-&gt;dom_elt, target); &#125; if(target.x &lt;= pBack-&gt;dom_elt.x) /* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */ pSearch = pBack-&gt;right; else pSearch = pBack-&gt;left; /* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */ if(pSearch != NULL) //pSearch加入到search_path中 search_path.push(pSearch); &#125; &#125; else &#123; // 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交 if( fabs(pBack-&gt;dom_elt.y - target.y) &lt; dist) /* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */ &#123; // 若找到的最近点与目标点距离大于上层父节点,则将父节点变为最近节点 if( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) ) &#123; nearest = pBack-&gt;dom_elt; dist = Distance(pBack-&gt;dom_elt, target); &#125; if(target.y &lt;= pBack-&gt;dom_elt.y) /* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */ pSearch = pBack-&gt;right; else pSearch = pBack-&gt;left; /* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */ if(pSearch != NULL) // pSearch加入到search_path中 search_path.push(pSearch); &#125; &#125; &#125; &#125; nearestpoint.x = nearest.x; nearestpoint.y = nearest.y; distance = dist; &#125; int main()&#123; // x,y data exm_set[100]; //assume the max training set size is 100 double x,y; int id = 0; cout&lt;&lt;&quot;Please input the training data in the form x y. One instance per line. Enter -1 -1 to stop.&quot;&lt;&lt;endl; while (cin&gt;&gt;x&gt;&gt;y)&#123; if (x == -1) &#123; break; &#125; else&#123; exm_set[id].x = x; exm_set[id].y = y; id++; &#125; &#125; struct Tnode * root = NULL; root = build_kdtree(exm_set, id, root); data nearestpoint; double distance; data target; cout &lt;&lt;&quot;Enter search point&quot;&lt;&lt;endl; while (cin&gt;&gt;target.x&gt;&gt;target.y) &#123; searchNearest(root, target, nearestpoint, distance); cout&lt;&lt;&quot;The nearest distance is &quot;&lt;&lt;distance&lt;&lt;&quot;,and the nearest point is &quot;&lt;&lt;nearestpoint.x&lt;&lt;&quot;,&quot;&lt;&lt;nearestpoint.y&lt;&lt;endl; cout &lt;&lt;&quot;Enter search point&quot;&lt;&lt;endl; &#125; &#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"matlab导入","slug":"matlab导入","date":"2022-02-24T04:30:12.000Z","updated":"2022-02-28T12:23:54.395Z","comments":true,"path":"2022/02/24/matlab导入/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/matlab%E5%AF%BC%E5%85%A5/","excerpt":"","text":"参考网址 (110条消息) matlab 数据导入_哆啦A梦的博客-CSDN博客_matlab导入数据 (110条消息) MATLAB-读取pgm图像_FrankDura的博客-CSDN博客_matlab读取pgm (110条消息) matlab读写pgm文件_freshair9的专栏-CSDN博客_matlab打开pgm文件 load12% Load the file to the matrix, M :M = load(&#x27;sample_file.txt&#x27;) matlab读取pgm文件1234clc,clear,close all;im1 = imread(‘1.pgm’);imshow(im1)% 可知im1时一个二维数组,254表白色,0表黑色,205表未知 另一种方式 123456789101112131415161718192021222324252627282930313233% function disp_ pgm( pgm_image_name)%不支持文件中有注释pgm_image_name=&#x27;tmp. pgm&#x27;;f = fopen( pgm_image_name,&#x27;r&#x27;);if f == -1 error([&#x27;Could not open file &#x27;, pgm_image_name]);end[imgsize, num]=fscanf(f, &#x27;P5\\n%d\\n%d\\n255\\n&#x27;);if num~=2,error(&#x27;error num&#x27;);endimage=[];for h=1:imgsize(2) image=[image fread(f,imgsize(1),&#x27;uint8&#x27;)];endimage=image.&#x27;;fclose(f);imshow(image);写文件% Load image% image = imread(imageFile);% If you have the Image Processing Toolbox, you can uncomment the following% lines to allow input of color images, which will be converted to grayscale.if isrgb(image) image = rgb2gray(image);end[rows, cols] = size(image);% Convert into PGM imagefile, readable by &quot;keypoints&quot; executablef = fopen(&#x27;tmp. pgm&#x27;, &#x27;w&#x27;);if f == -1 error(&#x27;Could not create file tmp. pgm.&#x27;);endfprintf(f, &#x27;P5\\n%d\\n%d\\n255\\n&#x27;, cols, rows);fwrite(f, image&#x27;, &#x27;uint8&#x27;);fclose(f);","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"贝叶斯滤波学习笔记","slug":"贝叶斯滤波学习笔记","date":"2022-02-24T04:30:12.000Z","updated":"2022-02-28T13:04:58.702Z","comments":true,"path":"2022/02/24/贝叶斯滤波学习笔记/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/24/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考网址 忠厚老实的老王的个人空间_哔哩哔哩_bilibili 笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283随机过程:(无法做随机试验)大数定律:(1,可重复2,可能已知3,结果不可预知)例如:股票 (不可重复 - 时间)主观概率:(贝叶斯学派)引入外部观测(证据,信息)主观概率(先验概率)-------外部观测-----&gt;相对客观概率(后验概率)&lt;概率机器人&gt; pdf与cdf 概率密度,概率分布混用X,Y 随机变量x,y 随机变量取值,代表可能结果测温: 今天多少度?先验概率分布 : &#123; P(T=10) = 0.8 P(T=11) = 0.2&#125;温度计: Tm = 10.3 因 果 果 因后验概率: P(状态|观测) = nP(观测|状态)P(状态) pdf(概率密度)由果推测因 后验 似然概率 先验似然概率: 表示观测精度,误差(最有可能)由因推测果n = 求积分(1/(似然*先验))所以:P(T=10|Tm=10.3)=P(Tm=10.3|T=10)*P(T=10)/P(Tm=10.3)这里的1/P(Tm=10.3)=n 为常数推导:由于全概率公式:P(Tm=10.3) = P(T=10|Tm=10.3)*P(T=10)+P(T=11|Tm=10.3)*P(T=11)这里的似然是仪器误差是确定的,预测误差也是确定的,因此P(Tm=10.3)是一个常数&lt;概率论与数理统计&gt;连续随机变量下得贝叶斯公式 f(状态|观测) = nf(观测|状态)f(状态) cdf(概率分布)例:满足正太分布计算温度预测温度(10,1^2) 观测温度(9,0.2^2) 后验(9.0385,0.038^2)按照公式:f(状态|观测) = nf(观测|状态)*f(状态)先验概率:f(状态) = 1/(sqrt(2*pi)*1)*exp(-(x-10)^2/(2*1^2))似然概率:f(观测|状态) = 1/(sqrt(2*pi)*0.2)*exp(-(x-9)^2/(2*0.2^2))后验概率:f(状态|观测) = n*1/(2*pi*0.2)*exp(-0.5*((x-10)^2+((x-9)/2)^2))1/n = (积分)1/(2*pi*0.2)*exp(-0.5*((x-10)^2+((x-9)/2)^2))dx更简单的方式,直接套用公式:后验N(Ex,Dx),这里使用s代替sigma u1代表预测值,u2代表测量值Ex = s2^2/(s1^2+s2^2)*u2+s1^2/(s1^2+s2^2)*u1Dx = s1^2*s2^2/(s1^2+s2^2)贝叶斯滤波完整算法: - 设定初值 - x0pdf f0(x) - 预测步 - fk_minus = (积分)fQk[x-f(v)]*fk-1_plus(v)dv - 更新步 - fk_plus = nk*fRk[yk-h(x)]*fk_minus(x) - nk = ((积分)(fRk[yk-h(x)])*fk_minus(x)dx)^-1 由于算法中由三个无穷积分,大多数情况下无解析解所以产生了很多骚操作解决方法: 1, 作假设: - 假设f(xk-1),h(xk)为线性,Qk,Rk为正态分布:KF滤波 - f(-),h(-)为非线性,EKF,UKF 2,霸王硬上弓 - 直接对无穷积分做数值处理: - 高斯积分(不常用) - 蒙特卡洛积分(pf) - 直方图滤波","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"matlab打印函数","slug":"matlab打印函数","date":"2022-02-22T04:30:12.000Z","updated":"2022-02-22T02:04:36.761Z","comments":true,"path":"2022/02/22/matlab打印函数/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/22/matlab%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/","excerpt":"","text":"参考网址 (109条消息) Matlab之print,fprint,fscanf,disp函数_WITNESS-CSDN博客_matlab print Matlab之print,fprint,fscanf,disp函数print - 把函数图形保存下来1234567891011minbnd = -4*pi; maxbnd = 4*pi; t = minbnd:0.1*pi:maxbnd; plot(t, sin(t), &#x27;g&#x27;, &#x27;Linewidth&#x27;, 2); line([minbnd, maxbnd], [0, 0]); %绘制x轴 axis([-10, 10, -2, 2]) %定义显示的坐标区间:x在(-10,10)之间，y在(-2,2)之间 grid on; title(&#x27;sin(x)&#x27;); xlabel(&#x27;x&#x27;); ylabel(&#x27;sin(x)&#x27;); print(&#x27;-dpng&#x27;,&#x27;sin.png&#x27;); %保存为png图片，在Matlab当前的工作目录下 123456-dbmp：保存为bmp格式-djpeg：保存为jpeg格式-dpng：保存为png格式-dpcx：保存为pcx格式-dpdf：保存为pdf格式-dtiff：保存为tiff格式 fprintf - 按指定格式写入文本文件12345678% 输出到屏幕data = [5, 1, 2; 3, 7, 4]; [row, col] = size(data); for i=1:row % for循环 for j=1:col fprintf(&#x27;data(%d, %d) = %d\\n&#x27;, i, j, data(i, j)); %直接输出到屏幕；类似于C语言的输出格式 end end 12345678%c 单个字符 %d 有符号十进制数（%i也可以） %u 无符号十进制数 %f 浮点数（%8.4f表示对浮点数取8位宽度，同时4位小数） %o 无符号八进制数 %s 字符串 %x 小写a-f的十六进制数 %X 大小a-f的十六进制数 12345678910111213141516% 输出到文件data = [5, 1, 2; 3, 7, 4]; [row, col] = size(data); %求出矩阵data的行数和列数 %加t表示按Windows格式输出换行，即0xOD 0x0A，没有t表示按Linux格式输出换行，即0x0A fid=fopen(&#x27;test.txt&#x27;, &#x27;wt&#x27;); %打开文件 for i=1:row for j=1:col fprintf(fid, &#x27;%d &#x27;, data(i, j)); %类似于C语言的输出格式 end fprintf(fid, &#x27;\\n&#x27;); end fprintf(fid, &#x27;This is a string\\n&#x27;); fprintf(fid, &#x27;%X&#x27;, hex2dec(&#x27;ABCD&#x27;)); fclose(fid); %最后不要忘记关闭文件！ fscanf - 文件读取注意: fscanf读取数据时会忽略空格，直到回车为止! 123456789101112%加t的理由和上面一样 fid=fopen(&#x27;d:\\test.txt&#x27;, &#x27;rt&#x27;); %把数据读到data中。其中data是2*3的矩阵 data=fscanf(fid, &#x27;%d&#x27;, [2, 3]); s=fscanf(fid, &#x27;%s&#x27;); d=fscanf(fid, &#x27;%X&#x27;); %关闭文件 fclose(fid); %打印数据 disp(data); disp(s); disp(d); disp - 输出在Matlab命令窗口12345678%单字符串输出： disp(&#x27;Hello World!&#x27;); %不同类型数据输出： num1 = 1; num2 = 2; disp([ num2str(num1), &#x27; + &#x27;, num2str(num2), &#x27; = &#x27;, num2str(num1+num2)]); % 注意,这里的输出都是转换为string类型在输出的","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"matlab的plot","slug":"matlab的plot","date":"2022-02-22T04:30:12.000Z","updated":"2022-02-22T13:02:22.325Z","comments":true,"path":"2022/02/22/matlab的plot/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/22/matlab%E7%9A%84plot/","excerpt":"","text":"参考网址 (109条消息) 关于plot函数的一切（史上最全总结）_T_just_for_tomorrow的博客-CSDN博客_plot函数举例 基本输出形式1plot（X,Y，LineSpec）% 这里的X,Y为需要输入参数,LineApec为设置线性，颜色，标记类型 具体参数如下图 线性 描述 - 实线（默认） – 虚线 ： 虚线 -. 点划线 图像点的形状 描述 o 圈 + 加号 * 星号 . 点 x 十字 s 正方形 d 菱形 ^ 向上三角形 v 向下三角形 &gt; 向右三角形 &lt; 左三角形 p 五角星 h 六角形 颜色 描述 y 黄色 m 品红 c 青色 r 红色 g 绿色 b 蓝色 w 白色 k 黑色 绘制多条线12345x=linespace(-2*pi,2*pi); % linespace（x1.x2,n）是均分计算指令，生成x1到x2之间n个行线型矢量 % 默认n是100y1=sin(x);y2=cos(x);plot(x,y1,x,y2) 矩阵做图12y=magic(4) %magic:生成行列和对角线元素和相等的矩阵，第二章的文章中总结过plot(y) 指定线型，颜色和标记12345x = 0:pi/10:2*pi;y1 = sin(x);y2 = sin(x-0.25);y3 = sin(x-0.5);plot(x,y1,&#x27;g&#x27;,x,y2,&#x27;b--o&#x27;,x,y3,&#x27;c*&#x27;) 在特定点标记123x = linspace(0,10);y = sin(x);plot(x,y,&#x27;-o&#x27;,&#x27;MarkerIndices&#x27;,1:5:length(y)) 显示轴，标题1234567x = linspace(0,10,140);y = cos(3*x);plot(x,y,&#x27;Color&#x27;,[0,0.7,0.9]) title(&#x27;曲线图&#x27;) %标题xlabel(&#x27;x&#x27;) %显示x轴是xylabel(&#x27;cos(3x)&#x27;) %显示y轴","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"matlab简单教程","slug":"matlab简单教程","date":"2022-02-22T04:30:12.000Z","updated":"2022-02-22T12:40:27.211Z","comments":true,"path":"2022/02/22/matlab简单教程/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/22/matlab%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考网址 MATLAB 快速入门 - MathWorks 中国 (109条消息) 零基础入门Matlab（一篇两个小时就能学完的入门博客）灯火阑珊-CSDN博客_matlab 注释与窗口命令123%% 独占一行的注释（有上下横线分割）clear all % 普通注释, 清除Workspace中的所有变量（右侧工作区）clc % 清除Command Window中的所有命令 数据类型数字 12342 + 410-73*58/2 字符与字符串 1234567s = ‘a’ （单引号表示字符串）==abs(s)==ASCII码char(97) 输出 a （ASCII码转字符串）num2str(65) 输出数字65str=‘I love MATLAB &amp; Machine Learning’length(str) 字符串长度doc num2str 矩阵 123456789101112131415A = [1 2 3; 4 5 2; 3 2 7]% 转置B = A&#x27;% 竖向展开C = A(% 逆矩阵D = inv(A)% 创建三维全零矩阵(由三个二维矩阵组成)E = zeros(10,5,3)% 随机分布(0~1)E(:,:,1) = rand(10,5)% 均匀分布E(:,:,2) = randi(5,10,5)% 正态分布E(:,:,3) = randn(10,5) 元胞数组与结构体元胞数组 -&gt; 类12345%元胞数组A = cell(1,6)A&#123;2&#125; = eye(3) %2021版本前的matlab下标从1开始A&#123;5&#125; = magic(5)B = A&#123;5&#125; 结构体12345%结构体books = struct(&#x27;name&#x27;,&#123;&#123;&#x27;Machine Learning&#x27;,&#x27;Data Mining&#x27;&#125;&#125;,&#x27;price&#x27;,[30,40])books.name %属性books.name(1)books.name&#123;1&#125; 矩阵操作定义1234567A = [1,2,3,4,5,6,5,4,6]A = [1 2 3; 4 5 2; 3 2 7]B = 1:2:9 %第二个参数为步长，不可缺省B = 1:3:9C = repmat(B,3,2) %重复执行3行2列D = ones(2,4) %生成一个2行4列的全1矩阵E = zeros(2,4)%生成一个2行4列的全0矩阵 四则运算12345678A = [1 2 3 4; 5 6 7 8]B = [1 1 2 2; 2 2 1 1]C = A + BD = A - BE = A * B&#x27;F = A .* B % .*表示对应项相乘G = A / B %相当于A*B的逆 G*B = A G*B*pinv(B) = A*pinv(B) G = A*pinv(B),相当于A乘BH = A ./ B % ./表示对应项相除 矩阵下标123456A = magic(5)B = A(2,3)C = A(3,:) % :为取全部,那么这条语句表示取第三行D = A(:,4) %取第四列[m,n] = find(A &gt; 20) %找到大于20的序号值/矩阵%取的是索引值 控制流if……else……end123456789a = randi(100, 1);if a &lt; 30 disp(&#x27;small&#x27;)elseif a &lt; 80 disp(&#x27;medium&#x27;)else disp(&#x27;large&#x27;)end switch……case12345678910111213141516[dayNum, dayString] = weekday(date, &#x27;long&#x27;, &#x27;en_US&#x27;);switch dayString case &#x27;Monday&#x27; disp(&#x27;Start of the work week&#x27;) case &#x27;Tuesday&#x27; disp(&#x27;Day 2&#x27;) case &#x27;Wednesday&#x27; disp(&#x27;Day 3&#x27;) case &#x27;Thursday&#x27; disp(&#x27;Day 4&#x27;) case &#x27;Friday&#x27; disp(&#x27;Last day of the work week&#x27;) otherwise disp(&#x27;Weekend!&#x27;)end for123for n = 3:32 r(n) = rank(magic(n));end while(注意:break,continue,return)123456789101112a = 0; fa = -Inf;b = 3; fb = Inf;while b-a &gt; eps*b x = (a+b)/2; fx = x^3-2*x-5; if sign(fx) == sign(fa) a = x; fa = fx; else b = x; fb = fx; endendx 绘图123456789%1.二维平面绘图x = 0:0.01:2*pi %定义x的范围，第二个参数表示步长y = sin(x)figure %建立一个幕布plot(x,y) %绘制当前二维平面图title(&#x27;y = sin(x)&#x27;) %标题xlabel(&#x27;x&#x27;) %x轴ylabel(&#x27;sin(x)&#x27;) %y轴xlim([0 2*pi]) % x坐标值的范围 12345678910111213%2.多个二维平面绘图x = 0:0.01:20;y1 = 200*exp(-0.05*x).*sin(x);y2 = 0.8*exp(-0.5*x).*sin(10*x);figure[AX,H1,H2] = plotyy(x,y1,x,y2,&#x27;plot&#x27;); %共用一个x的坐标系，在y上有不同的取值%设置相应的标签set(get(AX(1),&#x27;Ylabel&#x27;),&#x27;String&#x27;,&#x27;Slow Decay&#x27;)set(get(AX(2),&#x27;Ylabel&#x27;),&#x27;String&#x27;,&#x27;Fast Decay&#x27;)xlabel(&#x27;Time(\\musec)&#x27;)title(&#x27;Multiple Decay Rates&#x27;)set(H1,&#x27;LineStyle&#x27;,&#x27;--&#x27;)set(H2,&#x27;LineStyle&#x27;,&#x27;:&#x27;) 12345678910%3.三维立体绘图t = 0: pi/50: 10*pi;plot3(sin(t),cos(t),t)xlabel(&#x27;sin(t)&#x27;)ylabel(&#x27;cos(t)&#x27;)zlabel(&#x27;t&#x27;)%hold on%hold off %不保留当前操作grid on %把图片绘制出来，在图片中加一些网格线axis square %使整个图（连同坐标系）呈方体","categories":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"}]},{"title":"思维导图与流程图","slug":"思维导图与流程图","date":"2022-02-22T04:30:12.000Z","updated":"2022-02-24T01:28:34.911Z","comments":true,"path":"2022/02/22/思维导图与流程图/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/22/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B8%8E%E6%B5%81%E7%A8%8B%E5%9B%BE/","excerpt":"","text":"参考网址 diagrams.net ProcessFlow - 免费在线作图，思维导图，流程图，实时协作 (sharehoo.cn) 亿图图示在线 (edrawmax.cn) xmind2020中文破解版 简介最强大的莫过于diagrams,但如果论好用便捷的话当属亿图,但有限制(土豪除外),prosessflow需要vip咱用不起,不过看样子挺好用的,当然还有破解版的xmind也不错, diagrams基本上能想到的都可以使用里边的插图也非常多,白嫖党最爱 prossesflow没使用过 亿图在线很好使用就是不是vip有限制,这就很折磨人了,后果断转diagrams,毕竟github开源王道 xmind思维导图神器,非常便于使用,学习,记录思路都用这个","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"通过项目学opencv","slug":"通过项目学opencv","date":"2022-02-21T04:30:12.000Z","updated":"2022-02-22T13:25:32.287Z","comments":true,"path":"2022/02/21/通过项目学opencv/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/21/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E5%AD%A6opencv/","excerpt":"","text":"参考网址 sudrag/line_follower_turtlebot: A repo created to simulate a line following turtlebot in Gazebo environment using ROS (github.com) 简介实际上是通过ros的一个巡线项目简单学习ros+c++中opencv的使用. lesson1[调用视频数据cv_bridge]参考网址: (109条消息) ROS学习笔记–cv_bridge_喵喵三三的博客-CSDN博客_cv_bridge cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages - ROS Wiki 实例:src/line_follower_turtlebot/src/linedetect.cpp中 1234567891011121314void LineDetect::imageCallback(const sensor_msgs::ImageConstPtr&amp; msg) &#123; cv_bridge::CvImagePtr cv_ptr; try &#123; // 总是复制，返回一个可变的CvImage cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8); // 将转换的数据存放到opencv矩阵格式的img中 img = cv_ptr-&gt;image; // cv::imshow(&quot;Image window&quot;, img); cv::waitKey(30); &#125; catch (cv_bridge::Exception&amp; e) &#123; ROS_ERROR(&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;, msg-&gt;encoding.c_str()); &#125;&#125; CvBridge提供几种用于转换为CvImage的函数 123456789101112// Case 1: 用于ros订阅复制使用CvImagePtr toCvCopy(const sensor_msgs::ImageConstPtr&amp; source, const std::string&amp; encoding = std::string());CvImagePtr toCvCopy(const sensor_msgs::Image&amp; source, const std::string&amp; encoding = std::string()); // Case 2: 用于ros订阅共享使用CvImageConstPtr toCvShare(const sensor_msgs::ImageConstPtr&amp; source, const std::string&amp; encoding = std::string());CvImageConstPtr toCvShare(const sensor_msgs::Image&amp; source, const boost::shared_ptr&lt;void const&gt;&amp; tracked_object, const std::string&amp; encoding = std::string()); 完整简单实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;ros/ros.h&gt;#include &lt;image_transport/image_transport.h&gt;#include &lt;cv_bridge/cv_bridge.h&gt;#include &lt;sensor_msgs/image_encodings.h&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt; static const std::string OPENCV_WINDOW = &quot;Image window&quot;; class ImageConverter&#123; ros::NodeHandle nh_; image_transport::ImageTransport it_; image_transport::Subscriber image_sub_; image_transport::Publisher image_pub_; public: ImageConverter() : it_(nh_) &#123; // 订阅输入视频，发布输出视频 image_sub_ = it_.subscribe(&quot;/camera/image_raw&quot;, 1, &amp;ImageConverter::imageCb, this); image_pub_ = it_.advertise(&quot;/image_converter/output_video&quot;, 1); // 创建OPENCV_WINDOWS窗口 cv::namedWindow(OPENCV_WINDOW); &#125; ~ImageConverter() &#123; // 销毁OPENCV_WINDOWS窗口 cv::destroyWindow(OPENCV_WINDOW); &#125; void imageCb(const sensor_msgs::ImageConstPtr&amp; msg) &#123; cv_bridge::CvImagePtr cv_ptr; try &#123; // 转换图像到cv_ptr用于之后opencv的使用 cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8); &#125; catch (cv_bridge::Exception&amp; e) &#123; ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what()); return; &#125; // 在视频流上画个圈 if (cv_ptr-&gt;image.rows &gt; 60 &amp;&amp; cv_ptr-&gt;image.cols &gt; 60) cv::circle(cv_ptr-&gt;image, cv::Point(50, 50), 10, CV_RGB(255,0,0)); // 更新并显示GUI界面 cv::imshow(OPENCV_WINDOW, cv_ptr-&gt;image); cv::waitKey(3); // 输出修改后的视频流 image_pub_.publish(cv_ptr-&gt;toImageMsg()); &#125;&#125;; int main(int argc, char** argv)&#123; // 初始化image_converter节点 ros::init(argc, argv, &quot;image_converter&quot;); // 实例化类 ImageConverter ic; ros::spin(); return 0;&#125; lesson2[对读取数据进行初步处理]参考网址: (109条消息) OpenCV-高斯滤波cv::GaussianBlur_翟天保的博客-CSDN博客 高斯滤波处理123void GaussianBlur( InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ); InputArray类型的src，输入图像，如Mat类型。 OutputArray类型的dst，输出图像。 Size类型的ksize，高斯内核的大小。 double类型的sigmaX，高斯核函数在X方向的标准偏差。 double类型的sigmaY，高斯核函数在Y方向的标准偏差。 int类型的borderType，推断图像边缘像素的边界模式。 实例1234567cv::Mat LineDetect::Gauss(cv::Mat input) &#123; cv::Mat output;// 使用高斯滤波对图像进行滤波 cv::GaussianBlur(input, output, cv::Size(3, 3), 0.1, 0.1); // cv::imshow(&quot;Gaussian&quot;, output); return output;&#125; lesson3[实现巡线检测]步骤 转换颜色空间为hsv 检测判断黄色,并找出路线轮廓 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的,并画出矩形 找出图像质心 判断质心在图像中间的左侧还是右侧,由此控制车体运动 参考网址 (109条消息) 【OpenCV3】颜色空间转换——cv::cvtColor()详解_guduruyu的专栏-CSDN博客_cv.cvtcolor 具体样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105int LineDetect::colorthresh(cv::Mat input) &#123; // Initializaing variables cv::Size s = input.size(); std::vector&lt;std::vector&lt;cv::Point&gt;&gt; v; auto w = s.width; auto h = s.height; auto c_x = 0.0; // Detect all objects within the HSV range // 颜色空间转换 输入,输出,映射码 cv::cvtColor(input, LineDetect::img_hsv, CV_BGR2HSV); LineDetect::LowerYellow = &#123;20, 100, 100&#125;; LineDetect::UpperYellow = &#123;30, 255, 255&#125;; // 检测黄线,判断颜色在&#123;20, 100, 100&#125;与&#123;30, 255, 255&#125;之间 // 输出的img_mask为二值图像 cv::inRange(LineDetect::img_hsv, LowerYellow,UpperYellow, LineDetect::img_mask); // cv::imshow(&quot;mask&quot;, LineDetect::img_mask); // 切掉图像上半部分 img_mask(cv::Rect(0, 0, w, 0.8*h)) = 0; // cv::imshow(&quot;mask&quot;, LineDetect::img_mask); // Find contours for better visualization // 找到可视化轮廓 cv::findContours(LineDetect::img_mask, v, CV_RETR_LIST, CV_CHAIN_APPROX_NONE); // If contours exist add a bounding,Choosing contours with maximum area // 如果轮廓存在,则添加边界,选择包含最大面积的轮廓 if (v.size() != 0) &#123; // printf(&quot;%ld\\n&quot;,v.size()); // 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的 // cv::Rect r = cv::boundingRect(v[0]); // c_x = r.x + r.width / 2; // // 把轮廓用方框框出来 // cv::rectangle(LineDetect::img_mask, r, cv::Scalar(255, 255, 255), 2); // cv::imshow(&quot;mask&quot;, LineDetect::img_mask); auto area = 0; auto idx = 0; auto count = 0; // v.size()表示轮廓的个数,v[count].size()表示轮廓面积 while (count &lt; v.size()) &#123; if (area &lt; v[count].size()) &#123; idx = count; area = v[count].size(); // printf(&quot;%ld\\n&quot;,v[count].size()); &#125; count++; &#125; // 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的 // rect: 格式为(x,y,w,h) cv::Rect rect = boundingRect(v[idx]); cv::Point pt1, pt2, pt3; // 坐上角坐标 pt1.x = rect.x; pt1.y = rect.y; // 右下角坐标 pt2.x = rect.x + rect.width; pt2.y = rect.y + rect.height; // 向右向上移动5个像素 pt3.x = pt1.x+5; pt3.y = pt1.y-5; // 画出矩形 cv::rectangle(input, pt1, pt2, CV_RGB(255, 0, 0), 2); // 画出文本框 cv::putText(input, &quot;Line Detected&quot;, pt3, CV_FONT_HERSHEY_COMPLEX, 1, CV_RGB(255, 0, 0)); &#125; // Mask image to limit the future turns affecting the output // 将左右两边0.3倍的图像清除 img_mask(cv::Rect(0.7*w, 0, 0.3*w, h)) = 0; img_mask(cv::Rect(0, 0, 0.3*w, h)) = 0; // cv::imshow(&quot;mask&quot;, LineDetect::img_mask); // Perform centroid detection of line // 质心检测 cv::Moments M = cv::moments(LineDetect::img_mask); if (M.m00 &gt; 0) &#123; // Calculating centroid // 计算质心坐标 cv::Point p1(M.m10/M.m00, M.m01/M.m00); // 画出质心 cv::circle(LineDetect::img_mask, p1, 10, cv::Scalar(255, 255, 255), 1); &#125; // 检测的质心的横坐标 c_x = M.m10/M.m00; // Tolerance to chooise directions // 方向宽容度 auto tol = 15; // 返回灰度值不为0的像素数，可用来判断图像是否全黑。若全黑，则返回0 auto count = cv::countNonZero(img_mask); // Turn left if centroid is to the left of the image center minus tolerance // Turn right if centroid is to the right of the image center plus tolerance // Go straight if centroid is near image center if (c_x &lt; w/2-tol) &#123; LineDetect::dir = 0; &#125; else if (c_x &gt; w/2+tol) &#123; LineDetect::dir = 2; &#125; else &#123; LineDetect::dir = 1; &#125; // Search if no line detected if (count == 0) &#123; LineDetect::dir = 3; &#125; // Output images viewed by the turtlebot cv::namedWindow(&quot;Turtlebot View&quot;); imshow(&quot;Turtlebot View&quot;, input); return LineDetect::dir;&#125; 颜色空间转换123456void cv::cvtColor( cv::InputArray src, // 输入序列 cv::OutputArray dst, // 输出序列 int code, // 颜色映射码 int dstCn = 0 // 输出的通道数 (0=&#x27;automatic&#x27;)); 程序样例12// 颜色空间转换 输入,输出,映射吗 cv::cvtColor(input, LineDetect::img_hsv, CV_BGR2HSV); 检测黄线12// 函数原型（C++）void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst) 程序样例1234567 cv::Mat img_hsv; cv::Scalar LowerYellow; cv::Scalar UpperYellow; LineDetect::LowerYellow = &#123;20, 100, 100&#125;; LineDetect::UpperYellow = &#123;30, 255, 255&#125;;// 检测黄线,判断颜色在&#123;20, 100, 100&#125;与&#123;30, 255, 255&#125;之间 cv::inRange(LineDetect::img_hsv, LowerYellow,UpperYellow, LineDetect::img_mask); 找出可视化轮廓参考网址: (109条消息) opencv cv.findContours 函数详解_Ibelievesunshine的博客-CSDN博客_cv.findcontours 两种调用方式:123456789101112131415void cv::findContours( cv::InputOutputArray image, // 输入的8位单通道“二值”图像 cv::OutputArrayOfArrays contours, // 包含points的vectors的vector cv::OutputArray hierarchy, // (可选) 拓扑信息 int mode, // 轮廓检索模式 int method, // 近似方法 cv::Point offset = cv::Point() // (可选) 所有点的偏移);void cv::findContours( cv::InputOutputArray image, // 输入的8位单通道“二值”图像 cv::OutputArrayOfArrays contours, // 包含points的vectors的vector int mode, // 轮廓检索模式 int method, // 近似方法 cv::Point offset = cv::Point() // (可选) 所有点的偏移); cv::RETR_EXTERNAL：表示只提取最外面的轮廓； cv::RETR_LIST：表示提取所有轮廓并将其放入列表； cv::RETR_CCOMP:表示提取所有轮廓并将组织成一个两层结构，其中顶层轮廓是外部轮廓，第二层轮廓是“洞”的轮廓； cv::RETR_TREE：表示提取所有轮廓并组织成轮廓嵌套的完整层级结构。 程序样例:1cv::findContours(LineDetect::img_mask, v, CV_RETR_LIST, CV_CHAIN_APPROX_NONE); 计算轮廓的垂直边界最小矩形123// 计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的// x, y, w, h = cv2.boundingRect(binary) x,y为左上角坐标 cv::Rect rect = boundingRect(v[idx]); 找出质心12cv::moments(LineDetect::img_mask);(i,j)-&gt;(M.m10/M.m00, M.m01/M.m00)质心的图像坐标 参考网址 (109条消息) opencv学习(四十三)之图像的矩moments()_烟雨博客-CSDN博客_cv::moments","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"f1c100s_buildroot","slug":"f1c100s_buildroot","date":"2022-02-17T04:30:12.000Z","updated":"2022-02-17T00:09:55.552Z","comments":true,"path":"2022/02/17/f1c100s_buildroot/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/17/f1c100s_buildroot/","excerpt":"","text":"参考网址 aodzip/buildroot-tiny200: Buildroot Package for F1C100s/200s (github.com) 使用安装库文件12sudo apt install wget unzip build-essential git bc swig libncurses-dev libpython3-dev libssl-devsudo apt install python3-distutils 下载1git clone https://github.com/aodzip/buildroot-tiny200 生成配置文件12cd buildroot-tiny200make widora_mangopi_r3_defconfig 生成文件1make -j4","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"tf转换","slug":"tf转换","date":"2022-02-17T04:30:12.000Z","updated":"2022-02-17T09:01:52.242Z","comments":true,"path":"2022/02/17/tf转换/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/17/tf%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"参考网址 (109条消息) 从零开始搭二维激光SLAM — 基于PL-ICP的激光雷达里程计_李想的博客-CSDN博客_base_to_laser (109条消息) ROS小白学习历程-map/odom/base_link坐标系的关系及其转换_kuai-的博客-CSDN博客 常见坐标系12345map: 地图坐标系，也被称为世界坐标系，是静止不动的odom: 里程计坐标系，相对于map来说一般情况下是静止的，有些情况下会变动（定位节点为了修正机器人的位姿从而改变了map-&gt;odom间的坐标变换）base_link: 代表机器人的旋转中心的坐标系，相对于odom来说base_link是运动的laser_link: 激光雷达的坐标系，相对于base_link来说是静止的，因为雷达装在机器人上，雷达不会自己飞起来一般依赖关系为:map -&gt; odom -&gt; base_link -&gt; laser_link 注意123451, odom一般相对于map是静止的但由于odom有累计误差,所以还是会有偏移,并且map与odom之间存在父子关系2, 参照系紧紧粘在移动机器人基座上的任何一个位置和角度,一般我取控制中心3, odom到base_link的坐标转换是从运动源计算出来广播的。4, map到base_link的坐标转换是被定位模块计算出来的. 但定位模块并不发布map到base_link的转换. 相反它先接受 从odom到base_link的转换, 再计算并广播map到odom的位置转换关系。","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"树莓派备份","slug":"树莓派镜像备份","date":"2022-02-16T04:30:12.000Z","updated":"2022-02-16T01:39:52.922Z","comments":true,"path":"2022/02/16/树莓派镜像备份/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD/","excerpt":"","text":"参考网址新树莓派安装低版本ubuntu 先烧录简单的ubuntu18 将已有文件拷贝覆盖到 boo目录下","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"win11关闭防火墙","slug":"win11关闭防火墙","date":"2022-02-15T04:30:12.000Z","updated":"2022-02-15T09:29:35.283Z","comments":true,"path":"2022/02/15/win11关闭防火墙/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/15/win11%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"参考网址: Windows11如何关闭防火墙-百度经验 (baidu.com) 步骤 搜索框搜索: Windows defender 防火墙 进入防火墙后,找到[ 启用或关闭Windows defender 防火墙 ],设置","categories":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/categories/win/"}],"tags":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/tags/win/"}]},{"title":"学写2d激光slam-lesson3","slug":"学写2d激光slam - lesson3","date":"2022-02-13T04:30:12.000Z","updated":"2022-02-15T11:32:34.005Z","comments":true,"path":"2022/02/13/学写2d激光slam - lesson3/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/13/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson3/","excerpt":"","text":"参考网址: xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主 (107条消息) ROS中点云学习（九）：sensor_msgs::LaserScan转sensor_msgs::PointCloud2_00 2的博客-CSDN博客 lesson3-PLICP简介 使用点到线距离最小的方式进行ICP的计算，收敛速度快很多，同时精度也更高一些． 常见坐标系12345map: 地图坐标系，也被称为世界坐标系，是静止不动的odom: 里程计坐标系，相对于map来说一般情况下是静止的，有些情况下会变动（定位节点为了修正机器人的位姿从而改变了map-&gt;odom间的坐标变换）base_link: 代表机器人的旋转中心的坐标系，相对于odom来说base_link是运动的laser_link: 激光雷达的坐标系，相对于base_link来说是静止的，因为雷达装在机器人上，雷达不会自己飞起来根据依赖关系:map -&gt; odom -&gt; base_link -&gt; laser_link 基于PL-ICP的帧间匹配作者在做此实验时采用的是csm库,代码中表现为 123input_.laser_ref = prev_ldp_scan_;input_.laser_sens = curr_ldp_scan;sm_icp(&amp;input_, &amp;output_); 基于PL-ICP的里程计由pl-icp匹配得到delta_x,delta_y,delta_theta乘以时间,并加入匀速模型,得到里程计,这里值得注意的是关于tf转换的使用,尤其麻烦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void ScanMatchPLICP::ScanMatchWithPLICP(LDP &amp;curr_ldp_scan, const ros::Time &amp;time)&#123; // CSM is used in the following way: // The scans are always in the laser frame // The reference scan (prevLDPcan_) has a pose of [0, 0, 0] // The new scan (currLDPScan) has a pose equal to the movement // of the laser in the laser frame since the last scan // The computed correction is then propagated using the tf machinery prev_ldp_scan_-&gt;odometry[0] = 0.0; prev_ldp_scan_-&gt;odometry[1] = 0.0; prev_ldp_scan_-&gt;odometry[2] = 0.0; prev_ldp_scan_-&gt;estimate[0] = 0.0; prev_ldp_scan_-&gt;estimate[1] = 0.0; prev_ldp_scan_-&gt;estimate[2] = 0.0; prev_ldp_scan_-&gt;true_pose[0] = 0.0; prev_ldp_scan_-&gt;true_pose[1] = 0.0; prev_ldp_scan_-&gt;true_pose[2] = 0.0; input_.laser_ref = prev_ldp_scan_; input_.laser_sens = curr_ldp_scan; // 匀速模型，速度乘以时间，得到预测的odom坐标系下的位姿变换 double dt = (time - last_icp_time_).toSec(); double pr_ch_x, pr_ch_y, pr_ch_a; GetPrediction(pr_ch_x, pr_ch_y, pr_ch_a, dt); tf2::Transform prediction_change; CreateTfFromXYTheta(pr_ch_x, pr_ch_y, pr_ch_a, prediction_change); // account for the change since the last kf, in the fixed frame // 将odom坐标系下的坐标变换 转换成 base_in_odom_keyframe_坐标系下的坐标变换 prediction_change = prediction_change * (base_in_odom_ * base_in_odom_keyframe_.inverse()); // the predicted change of the laser&#x27;s position, in the laser frame // 将base_link坐标系下的坐标变换 转换成 雷达坐标系下的坐标变换 tf2::Transform prediction_change_lidar; prediction_change_lidar = laser_to_base_ * base_in_odom_.inverse() * prediction_change * base_in_odom_ * base_to_laser_; input_.first_guess[0] = prediction_change_lidar.getOrigin().getX(); input_.first_guess[1] = prediction_change_lidar.getOrigin().getY(); input_.first_guess[2] = tf2::getYaw(prediction_change_lidar.getRotation()); // If they are non-Null, free covariance gsl matrices to avoid leaking memory if (output_.cov_x_m) &#123; gsl_matrix_free(output_.cov_x_m); output_.cov_x_m = 0; &#125; if (output_.dx_dy1_m) &#123; gsl_matrix_free(output_.dx_dy1_m); output_.dx_dy1_m = 0; &#125; if (output_.dx_dy2_m) &#123; gsl_matrix_free(output_.dx_dy2_m); output_.dx_dy2_m = 0; &#125; start_time_ = std::chrono::steady_clock::now(); // 调用csm进行plicp计算 sm_icp(&amp;input_, &amp;output_); end_time_ = std::chrono::steady_clock::now(); time_used_ = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(end_time_ - start_time_); // std::cout &lt;&lt; &quot;PLICP计算用时: &quot; &lt;&lt; time_used_.count() &lt;&lt; &quot; 秒。&quot; &lt;&lt; std::endl; tf2::Transform corr_ch; if (output_.valid) &#123; // 雷达坐标系下的坐标变换 tf2::Transform corr_ch_l; CreateTfFromXYTheta(output_.x[0], output_.x[1], output_.x[2], corr_ch_l); // 将雷达坐标系下的坐标变换 转换成 base_link坐标系下的坐标变换 corr_ch = base_to_laser_ * corr_ch_l * laser_to_base_; // 更新 base_link 在 odom 坐标系下 的坐标 base_in_odom_ = base_in_odom_keyframe_ * corr_ch; latest_velocity_.linear.x = corr_ch.getOrigin().getX() / dt; latest_velocity_.angular.z = tf2::getYaw(corr_ch.getRotation()) / dt; &#125; else &#123; ROS_WARN(&quot;not Converged&quot;); &#125; // 发布tf与odom话题 PublishTFAndOdometry(); // 检查是否需要更新关键帧坐标 if (NewKeyframeNeeded(corr_ch)) &#123; // 更新关键帧坐标 ld_free(prev_ldp_scan_); prev_ldp_scan_ = curr_ldp_scan; base_in_odom_keyframe_ = base_in_odom_; &#125; else &#123; ld_free(curr_ldp_scan); &#125; last_icp_time_ = time;&#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"学写2d激光slam-lesson2","slug":"学写2d激光slam - lesson2","date":"2022-02-12T04:30:12.000Z","updated":"2022-02-13T13:27:47.695Z","comments":true,"path":"2022/02/12/学写2d激光slam - lesson2/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/12/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson2/","excerpt":"","text":"参考网址: xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主 (107条消息) ROS中点云学习（九）：sensor_msgs::LaserScan转sensor_msgs::PointCloud2_00 2的博客-CSDN博客 lesson2格式转换(sensor_msgs/LaserScan -&gt; sensor_msgs/PointCloud2 )1234567891011# sensor_msgs/LaserScanstd_msgs/Header headerfloat32 angle_minfloat32 angle_maxfloat32 angle_incrementfloat32 time_incrementfloat32 scan_timefloat32 range_minfloat32 range_maxfloat32[] rangesfloat32[] intensities 12345678910111213141516171819202122# sensor_msgs/PointCloud2std_msgs/Header header# width - 以点数指定点云数据集的宽度。 WIDTH有两个含义：# * - 它可以为 无组织数据集 指定云中的总点数;# * - 它可以指定 有组织的点云数据集 的宽度（一行中的总点数）.uint32 height# height - 以点数指定点云数据集的高度。HEIGHT有两个含义：# * - 对于 无组织数据集，它设置为1（因此用于检查数据集是否ordered）。# * - 它可以指定 有组织的点云数据集 的高度（总行数）;uint32 width# 描述二进制数据blob中的通道及其布局。sensor_msgs/PointField[] fields# 是大端数据格式吗?bool is_bigendian# 以字节为单位的点的长度uint32 point_step# 行的长度（以字节为单位）uint32 row_step# 实际数据（二进制的数据流），大小为（row_step * height）uint8[] data# 如果包含Inf / NaN值，则为false，否则为真bool is_dense 123456# ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换std_msgs/Header headeruint32 heightuint32 widthPointT* point_tmpbool is_dense 相对来说比较简单,就是将scan数据转化为PointT数据发布,且ros自带转化成pointcloud2功能,需要注意的是对于无效数据需要特殊处理 1234// 注意，这里的发布器，发布的数据类型为 pcl::PointCloud&lt;PointT&gt;// ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换pointcloud2_publisher_ = node_handle_.advertise&lt;PointCloudT&gt;( &quot;pointcloud2_converted&quot;, 1, this); 无效点处理 1234567// 将 inf 与 nan 点 设置为无效点if (!std::isfinite(range))&#123; // std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; scan_msg-&gt;ranges[i]; point_tmp = invalid_point_; continue;&#125; point坐标 1234567891011121314// 有些雷达驱动会将无效点设置成 range_max+1// 所以要根据雷达的range_min与range_max进行有效值的判断if (range &gt; scan_msg-&gt;range_min &amp;&amp; range &lt; scan_msg-&gt;range_max)&#123; // 获取第i个点对应的角度 float angle = scan_msg-&gt;angle_min + i * scan_msg-&gt;angle_increment; // 获取第i个点在笛卡尔坐标系下的坐标 point_tmp.x = range * cos(angle); point_tmp.y = range * sin(angle); point_tmp.z = 0.0;&#125;else// 无效点 point_tmp = invalid_point_; 发布 123456789 cloud_msg-&gt;width = scan_msg-&gt;ranges.size(); cloud_msg-&gt;height = 1; cloud_msg-&gt;is_dense = false; // contains nans // 将scan_msg的消息头 赋值到 PointCloudT的消息头 pcl_conversions::toPCL(scan_msg-&gt;header, cloud_msg-&gt;header);// 由于ros中自动做了 pcl::PointCloud&lt;PointT&gt; 到 sensor_msgs/PointCloud2 的数据类型的转换// 所以这里直接发布 pcl::PointCloud&lt;PointT&gt; 即可pointcloud2_publisher_.publish(cloud_msg); icp算法12345678910111213141516171819202122232425// 1,将scan转成点云数据// 2,保存当前与上一次点云信息// 3,pcl自带的icp算法// ICP 输入数据,输出数据的设置,还可以进行参数配置,这里使用默认参宿icp_.setInputSource(last_pointcloud_);icp_.setInputTarget(current_pointcloud_);// 开始迭代计算pcl::PointCloud&lt;pcl::PointXYZ&gt; unused_result;icp_.align(unused_result);// 如果迭代没有收敛,不进行输出if (icp_.hasConverged() == false)&#123; std::cout &lt;&lt; &quot;not Converged&quot; &lt;&lt; std::endl; return;&#125;else&#123; // 收敛了之后, 获取坐标变换 Eigen::Affine3f transfrom; transfrom = icp_.getFinalTransformation(); // 将Eigen::Affine3f转换成x, y, theta, 并打印出来 float x, y, z, roll, pitch, yaw; pcl::getTranslationAndEulerAngles(transfrom, x, y, z, roll, pitch, yaw); std::cout &lt;&lt; &quot;transfrom: (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; yaw * 180 / M_PI &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125; 总结123456789101112迭代最近点（Iterative Closest Point, 下简称ICP）算法是一种点云匹配算法。其求解思路为：首先对于一幅点云中的每个点，在另一幅点云中计算匹配点（最近点）极小化匹配点间的匹配误差，计算位姿然后将计算的位姿作用于点云再重新计算匹配点如此迭代，直到迭代次数达到阈值，或者极小化函数的变化量小于设定阈值首先，ICP对初值比较敏感，初值给的不好，就需要花费更多的迭代次数进行匹配．其次，由于它是迭代很多次的，所以其花费的时间很长，这一点是非常致命的，之后我会通过程序来让大家体验ICP的费时．再次，精度与速度是矛盾的，ICP算法理论上可以实现很高的精度，但是要很多很多的迭代次数，以及很长的时间．所以，当限制了迭代次数的情况下，精度就不一定能保证了．","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"学写2d激光slam-lesson1","slug":"学写2d激光slam - lesson1","date":"2022-02-11T04:30:12.000Z","updated":"2022-02-12T14:36:48.301Z","comments":true,"path":"2022/02/11/学写2d激光slam - lesson1/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/11/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam%20-%20lesson1/","excerpt":"","text":"参考网址: xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主 lesson1了解激光雷达数据123456789101112131415# rosmsg show sensor_msgs/LaserScanstd_msgs/Header header // 数据的消息头 uint32 seq // 数据的序号 time stamp // 数据的时间戳 string frame_id // 数据的坐标系float32 angle_min // 雷达数据的起始角度（最小角度）float32 angle_max // 雷达数据的终止角度（最大角度）float32 angle_increment // 雷达数据的角度分辨率（角度增量）float32 time_increment // 雷达数据每个数据点的时间间隔float32 scan_time // 当前帧数据与下一帧数据的时间间隔float32 range_min // 雷达数据的最小值float32 range_max // 雷达数据的最大值float32[] ranges // 雷达数据每个点对应的在极坐标系下的距离值float32[] intensities // 雷达数据每个点对应的强度值 对数据进行简单处理1234567891011// 第5个点的欧式坐标为double range = scan_msg-&gt;ranges[4];double angle = scan_msg-&gt;angle_min + scan_msg-&gt;angle_increment * 4;double x = range * cos(angle);double y = range * sin(angle);// 通过ranges中数据的个数进行雷达数据的遍历for (int i = 0; i &lt; scan_msg-&gt;ranges.size(); i++)&#123; printf(&quot;range[i]=%f &quot;,scan_msg-&gt;ranges[i]);&#125; LIO_SLAM特征点提取简介:主要是提取特征角点 剔除 inf 或者 nan 点123456// std::isfinite ：输入的值是有效值，返回trueif (!std::isfinite(scan_msg-&gt;ranges[i]))&#123;// std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; scan_msg-&gt;ranges[i];continue;&#125; 计算曲率实际上是比较该点与前后各五个点之间差距,大于一定阈值认为是角点,也就是特侦点 123456789101112131415// 计算曲率值, 通过当前点前后5个点距离值的偏差程度来代表曲率// 如果是球面, 则当前点周围的10个点的距离之和 减去 当前点距离的10倍 应该等于0for (int i = 5; i &lt; count - 5; i++)&#123; float diff_range = new_scan[i - 5] + new_scan[i - 4] + new_scan[i - 3] + new_scan[i - 2] + new_scan[i - 1] - new_scan[i] * 10 + new_scan[i + 1] + new_scan[i + 2] + new_scan[i + 3] + new_scan[i + 4] + new_scan[i + 5]; // diffX * diffX + diffY * diffY scan_curvature_[i] = diff_range * diff_range; scan_smoothness_[i].value = scan_curvature_[i]; scan_smoothness_[i].index = i;&#125; 特侦点提取使用sort()对于scan_smoothness_进行排序,分成6组,从大到小每组最多选20个点 1234567891011121314151617181920212223242526272829// 进行角点的提取,将完整的scan分成6部分,每部分提取20个角点 for (int j = 0; j &lt; 6; j++)&#123; int start_index = (0 * (6 - j) + count * j) / 6; int end_index = (0 * (5 - j) + count * (j + 1)) / 6 - 1; // std::cout &lt;&lt; &quot;start_index: &quot; &lt;&lt; start_index &lt;&lt; &quot; end_index: &quot; &lt;&lt; end_index &lt;&lt; std::endl; if (start_index &gt;= end_index) continue; // 将这段点云按照曲率从小到大进行排序 std::sort(scan_smoothness_.begin() + start_index, scan_smoothness_.begin() + end_index, by_value()); int largestPickedNum = 0; // 最后的点 的曲率最大，如果满足条件，就是角点 for (int k = end_index; k &gt;= start_index; k--)&#123; int index = scan_smoothness_[k].index; if (scan_smoothness_[k].value &gt; edge_threshold_)&#123; // 每一段最多只取20个角点 largestPickedNum++; if (largestPickedNum &lt;= 20)&#123; corner_scan.ranges[map_index[index]] = scan_msg-&gt;ranges[map_index[index]]; &#125; else&#123; break; &#125; &#125; &#125; &#125;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"学写2d激光slam","slug":"学写2d激光slam","date":"2022-02-11T04:30:12.000Z","updated":"2022-02-12T14:36:41.447Z","comments":true,"path":"2022/02/11/学写2d激光slam/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/11/%E5%AD%A6%E5%86%992d%E6%BF%80%E5%85%89slam/","excerpt":"","text":"参考网址: xiangli0608/Creating-2D-laser-slam-from-scratch: 从零开始创建二维激光SLAM (github.com) 李想的博客_李太白lx_CSDN博客-从零开始搭二维激光SLAM,激光SLAM,cartographer领域博主 (105条消息) 在linux ubuntu18.04版本中安装ceres solver_YMWM_的博客-CSDN博客_linux 安装ceres (105条消息) 在Ubuntu16.04下安装Ceres_江南古镇的博客-CSDN博客_ceres安装 (105条消息) ubuntu16.04安装g2o_slzlincent的博客-CSDN博客_安装g2o (105条消息) 【已解决】error: no matching function for call to ‘g2o::BlockSolver…_Bungehurst-CSDN博客 环境搭建 melodic ceres g2o gtsam ubuntu18 ubuntu18安装ros1123456789sudo nano /etc/apt/sources.list.d/ros-latest.listdeb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic mainsudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt updatesudo apt-get install ros-melodic-desktop-full# 初始化sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essentialsudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 使用小于解决rosdep问题 1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros 下载github并安装必要库1get clone https://ghproxy.com/https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch ceres安装依赖安装 123456789sudo apt-get install cmakesudo apt-get install libgoogle-glog-devsudo apt-get install libatlas-base-devsudo apt-get install libeigen3-devsudo apt-get install libsuitesparse-devsudo apt-get install libgtest-devsudo add-apt-repository ppa:bzindovic/suitesparse-bugfix-1319687sudo apt-get updatesudo apt-get install libsuitesparse-dev 安装 123456cd Creating-2D-laser-slam-from-scratch/TrirdParty/ceres-solver-1.13.0mkdir buildcd buildcmake ..make -jmake install g2o安装123456789101112git clone https://github.com/RainerKuemmerle/g2o.gitsudo apt-get install libeigen3-devsudo apt-get install libsuitesparse-devsudo apt-get install qtdeclarative5-devsudo apt-get install qt5-qmakesudo apt-get install libqglviewer-devcd g2omkdir buildcd buildcmake ..make -jmake install gtsam安装123456cd Creating-2D-laser-slam-from-scratch/TrirdParty/gtsammkdir buildcd buildcmake ..make -jmake install 修改源文件123456789101112131415161718// src/Creating-2D-laser-slam-from-scratch/lesson6/src/g2o_solver/g2o_solver.cc中// 修改为如下G2oSolver::G2oSolver()&#123; // 第1步：创建一个线性求解器LinearSolver SlamLinearSolver *linearSolver = new SlamLinearSolver(); linearSolver-&gt;setBlockOrdering(false); // 第2步：创建BlockSolver。并用上面定义的线性求解器初始化 SlamBlockSolver *blockSolver = new SlamBlockSolver(std::unique_ptr&lt;SlamLinearSolver&gt;(linearSolver)); linearSolver-&gt;setBlockOrdering(true); // 第3步：创建总求解器solver。并从GN, LM, DogLeg 中选一个，再用上述块求解器BlockSolver初始化 g2o::OptimizationAlgorithmLevenberg *solver = new g2o::OptimizationAlgorithmLevenberg(std::unique_ptr&lt;SlamBlockSolver&gt;(blockSolver)); // 第4步：创建稀疏优化器（SparseOptimizer） mOptimizer.setAlgorithm(solver);&#125; 编译1234mkdir -p catkin_ws/srccd catkin_ws/srcgit clone https://ghproxy.com/https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratchcd .. &amp;&amp; catkin_make","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"Ubuntu中软件安装方法","slug":"apt使用","date":"2022-02-10T04:30:12.000Z","updated":"2022-02-10T06:27:13.082Z","comments":true,"path":"2022/02/10/apt使用/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/10/apt%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址: [(105条消息) ubuntu安装和查看已安装软件包_weixin_34293902的博客-CSDN博客](https://blog.csdn.net/weixin_34293902/article/details/91799108?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term= 查看apt安装的软件包 &amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-1-91799108.pc_search_result_control_group&amp;spm=1018.2226.3001.4187) apt安装/卸载12345678普通安装：apt-get install softname1 softname2 …;修复安装：apt-get -f install softname1 softname2... ;(-f Atemp to correct broken dependencies)重新安装：apt-get --reinstall install softname1 softname2...;移除式卸载：apt-get remove softname1 softname2 …;（移除软件包，当包尾部有+时，意为安装）清除式卸载 ：apt-get --purge remove softname1 softname2...;(同时清除配置)清除式卸载：apt-get purge sofname1 softname2...;(同上，也清除配置文件) dpkg安装/卸载1234普通安装：dpkg -i package_name.deb移除式卸载：dpkg -r pkg1 pkg2 ...;清除式卸载：dpkg -P pkg1 pkg2...; 源码安装12345678910# 下载解压a．解xx.tar.gz：tar zxf xx.tar.gz b．解xx.tar.Z：tar zxf xx.tar.Z c．解xx.tgz：tar zxf xx.tgz d．解xx.bz2：bunzip2 xx.bz2 e．解xx.tar：tar xf xx.tar# 运行安装./configuremakesudo make install 常用指令12345678910111213141516171819202122232425262728293031323334apt-cache search # ------(package 搜索包)apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)apt-get install # ------(package 安装包)apt-get install # -----(package --reinstall 重新安装包)apt-get -f install # -----(强制安装, &quot;-f = --fix-missing&quot;当是修复安装吧...)apt-get remove #-----(package 删除包)apt-get remove --purge # ------(package 删除包，包括删除配置文件等)apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)apt-get update #------更新源apt-get upgrade #------更新已安装的包apt-get dist-upgrade # ---------升级系统apt-get dselect-upgrade #------使用 dselect 升级apt-cache depends #-------(package 了解使用依赖)apt-cache rdepends # ------(package 了解某个具体的依赖,当是查看该包被哪些包依赖吧...)apt-get build-dep # ------(package 安装相关的编译环境)apt-get source #------(package 下载该包的源代码)apt-get clean &amp;&amp; apt-get autoclean # --------清理下载文件的存档 &amp;&amp; 只清理过时的包apt-get check #-------检查是否有损坏的依赖dpkg -S filename -----查找filename属于哪个软件包apt-file search filename -----查找filename属于哪个软件包apt-file list packagename -----列出软件包的内容apt-file update --更新apt-file的数据库dpkg --info &quot;软件包名&quot; --列出软件包解包后的包名称.dpkg -l --列出当前系统中所有的包.可以和参数less一起使用在分屏查看. (类似于rpm -qa)dpkg -l |grep -i &quot;软件包名&quot; --查看系统中与&quot;软件包名&quot;相关联的包.dpkg -s 查询已安装的包的详细信息.dpkg -L 查询系统中已安装的软件包所安装的位置. (类似于rpm -ql)dpkg -S 查询系统中某个文件属于哪个软件包. (类似于rpm -qf)dpkg -I 查询deb包的详细信息,在一个软件包下载到本地之后看看用不用安装(看一下呗).dpkg -i 手动安装软件包(这个命令并不能解决软件包之前的依赖性问题),如果在安装某一个软件包的时候遇到了软件依赖的问题,可以用apt-get -f install在解决信赖性这个问题.dpkg -r 卸载软件包.不是完全的卸载,它的配置文件还存在.dpkg -P 全部卸载(但是还是不能解决软件包的依赖性的问题)dpkg -reconfigure 重新配置","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"moxa配置","slug":"moxa配置","date":"2022-02-10T04:30:12.000Z","updated":"2022-02-10T06:43:39.419Z","comments":true,"path":"2022/02/10/moxa配置/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/10/moxa%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考网址: (105条消息) MOXA串口服务器的配置_MAYBE的博客-CSDN博客_moxa串口服务器 如何设置MOXA的无线AP和Client-百度经验 (baidu.com) moxa无线ap登录123# 新用户有线连接,网址输入 192.168.127.253username:adminpassword:moxa 修改静态ip1234# 选择network setting1\\ static2\\ 192.168.xx.xx3\\ 255.255.255.0 连接到路由1234567# WLAN-&gt;Basic WLAN Setup点击site survey查找需要接入apsubmit# WLAN-&gt;WLAN Security Settingpassphrase:密码# WLAN-&gt;Advanced WLAN Setting参考图片","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"在melodic下使用opencv巡线","slug":"在melodic下使用opencv巡线","date":"2022-02-10T04:30:12.000Z","updated":"2022-02-11T05:37:14.027Z","comments":true,"path":"2022/02/10/在melodic下使用opencv巡线/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/10/%E5%9C%A8melodic%E4%B8%8B%E4%BD%BF%E7%94%A8opencv%E5%B7%A1%E7%BA%BF/","excerpt":"","text":"参考网址: sudrag/line_follower_turtlebot: A repo created to simulate a line following turtlebot in Gazebo environment using ROS (github.com) (105条消息) ROS-Melodic下 Gazebo+Turtlebot安装_qty2898734013的博客-CSDN博客_melodic安装gazebo 另一位大佬的,不过没有我运行成功 ROS开发6——Gazebo环境下ROS+OpenCV搭建机器人图像开发案例 | Zenan’s Blog (zenanlin1999.github.io) 简介参考的是以为大佬的github项目,基本环境如下: 123456ROS KineticCatkinroscpp packagestd_msgs packagemessage_generation packageOpenCV 但由于melodic并没有办法直接安装turtlebot_gazebo所以需要先手动安装turtlebot_gazebo 方法如下 安装turtlebot_gazebo1234567891011121314# 安装gazebosudo apt-get install ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control# 修改配置文件sudo nano ~/.ignition/fuel/config.yaml# 注释掉,并加入# url: https://api.ignitionfuel.orgurl: https://api.ignitionrobotics.org# 如果是vmare虚拟机,需要加入export SVGA_VGPU10=0echo &quot;export SVGA_VGPU10=0&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc# 启动gazebo a\\安装依赖包12345678910111213sudo apt-get install ros-melodic-kobuki-*sudo apt-get install ros-melodic-ecl-streamssudo apt-get install ros-melodic-bflsudo apt-get install ros-melodic-map-serversudo apt-get install ros-melodic-move-basesudo apt-get install ros-melodic-amclsudo apt-get install ros-melodic-dwa-local-plannersudo apt-get install libusb-devsudo apt-get install libspnav-devsudo apt-get install ros-melodic-joystick-driverssudo apt-get install bluetoothsudo apt-get install libbluetooth-devsudo apt-get install libcwiid-dev b\\新建工作空间，准备相关包12345678910111213141516mkdir -p ~/turtlebot_ws/src cd ~/turtlebot_ws/src git clone git://github.com/turtlebot/turtlebot_simulatorgit clone git://github.com/turtlebot/turtlebot.gitgit clone git://github.com/turtlebot/turtlebot_apps.gitgit clone git://github.com/udacity/robot_pose_ekfgit clone git://github.com/ros-perception/depthimage_to_laserscan.git git clone git://github.com/yujinrobot/kobuki_msgs.gitgit clone git://github.com/yujinrobot/kobuki_desktop.gitgit clone git://github.com/ncnynl/turtlebot_vizgit clone git://github.com/turtlebot/turtlebot_create.gitcd kobuki_desktop/rm -r kobuki_qtestsuitegit clone git://github.com/toeklk/orocos-bayesian-filtering.gitgit clone git://github.com/turtlebot/turtlebot_msgs.gitgit clone git://github.com/ros-drivers/joystick_drivers.git c\\复制kobuki和yujin_ocs依赖库到turtlebot_ws/src工作空间下123456mkdir -p ~/repos/cd ~/repos/git clone git://github.com/yujinrobot/kobuki.gitcp -r kobuki/* ~/turtlebot_ws/src/git clone git://github.com/yujinrobot/yujin_ocs.gitcp -r yujin_ocs/yocs_cmd_vel_mux/ yujin_ocs/yocs_controllers ~/turtlebot_ws/src/ d\\编译与添加到环境变量1234cd ~/turtlebot_wscatkin_makeecho &quot;source ~/turtlebot_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc e\\测试1roslaunch turtlebot_gazebo turtlebot_world.launch 运行opencv巡线12345678mkdir catkin_wscd catkin_wsmkdir srccatkin_makecd ~/catkin_ws/srcgit clone https://github.com/sudrag/line_follower_turtlebot.gitcd ..catkin_make run123cd ~/catkin_wssource devel/setup.bashroslaunch line_follower_turtlebot lf.launch","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"状态空间表达式","slug":"状态方程","date":"2022-02-07T04:30:12.000Z","updated":"2022-03-01T02:39:01.646Z","comments":true,"path":"2022/02/07/状态方程/","link":"","permalink":"https://peitianyu.github.io/blog/2022/02/07/%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/","excerpt":"","text":"参考网址: (104条消息) 现控笔记（二）：状态空间表达式_sdhdwyx的博客-CSDN博客_状态空间表达式 例子对于二阶空间方程而言","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"linux报错","slug":"linux编译","date":"2022-01-15T04:30:12.000Z","updated":"2022-01-15T10:35:27.056Z","comments":true,"path":"2022/01/15/linux编译/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/15/linux%E7%BC%96%E8%AF%91/","excerpt":"","text":"参考网址: (99条消息) 编译警告：warning: Clock skew detected. Your build may be incomplete._竭尽全力的专栏-CSDN博客 warning: Clock skew detected1find . -type f | xargs -n 5 touch apt upgdate 失败1234sudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/locksudo dpkg --configure -a","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"linux报错","slug":"linux报错","date":"2022-01-15T04:30:12.000Z","updated":"2022-02-17T00:24:11.316Z","comments":true,"path":"2022/01/15/linux报错/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/15/linux%E6%8A%A5%E9%94%99/","excerpt":"","text":"参考网址: (99条消息) 编译警告：warning: Clock skew detected. Your build may be incomplete._竭尽全力的专栏-CSDN博客 warning: Clock skew detected1find . -type f | xargs -n 5 touch apt upgdate 失败12E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 123sudo rm /var/lib/dpkg/lock-frontendsudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock cannot create temp file for here-document: No space left on device的问题解决参考网址 Linux出现cannot create temp file for here-document: No space left on device的问题解决 - EasonJim - 博客园 (cnblogs.com) 问题 1bash: cannot create temp file for here-document: No space left on devic 123456# 查看/var/log路径下文件的大小du -h –max-depth=1 /var/log/* # 查看哪个目录最大，一步一步的查找大文件du -sh /*# 查找最大的文件，参考：http://www.cnblogs.com/kerrycode/p/4391859.htmldu -h --max-depth=1","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"常用好用的论文网站","slug":"论文网站","date":"2022-01-15T04:30:12.000Z","updated":"2022-01-15T08:46:48.482Z","comments":true,"path":"2022/01/15/论文网站/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/15/%E8%AE%BA%E6%96%87%E7%BD%91%E7%AB%99/","excerpt":"","text":"参考网址: Google 学术搜索 Sci-Hub (mksa.top) 科塔学术导航 - 最专业、准确、及时和全面的科研与学术资源导航平台 (sciping.com) 简介这里的几个网站中科塔网很全面,可以配合sci_hub使用,极易食用.","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"hex解析","slug":"hex解析","date":"2022-01-03T04:30:12.000Z","updated":"2022-01-09T13:20:36.766Z","comments":true,"path":"2022/01/03/hex解析/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/03/hex%E8%A7%A3%E6%9E%90/","excerpt":"","text":"参考网址: (94条消息) HEX文件格式解析_a1037488611的专栏-CSDN博客_hex文件格式解析 格式如下 1234567891011121314：(冒号)每个Intel HEX 记录 都由冒 号开头 ；LL 是 数 据 长 度域, 它 代表 记录当 中 数 据字 节 (dd) 的 数量 ；aaaa 是地址域, 它代表 记录当 中 数据的起始地址；TT是代表HEX 记录类 型的域 , 它 可能是以下 数 据 当 中的一 个： 00 – 数 据 记录（Data Record） 01 – 文件结 束 记录（End of FileRecord） 02 – 扩展段地址 记录（ExtendedSegment Address Record） 03 – 开始段地址 记录（Start Segment Address Record） 04 – 扩展 线 性地址 记录（Extended Linear Address Record） 05 – 开始线性地址 记录（Extended Segment Address Record）dd 是数 据域 , 它 代表一 个 字 节 的 数 据. 一 个记录 可以有 许 多 数 据字 节 . 记录当 中 数 据字 节 的 数 量必 须 和数 据 长 度域(ll) 中指定的 数字相符.cc 是校验 和域 , 它 表示 这个记录 的校 验 和. 校 验 和的 计 算是通 过将记录当 中所有十六 进 制 编码数 字 对 的 值相加, 以256 为 模 进 行以下 补 足.表示为：“：[1字节长度][2字节地址][1字节记录类型][n字节段][1字节校验和] ” 例如12:10 2462 00 464C5549442050524F46494C4500464C33：[10个数据长度][字节地址为:0x2462][记录类型为:00 数据记录][n字节段数据][crc校验:0x33]","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"嵌入式分层","slug":"嵌入式任务分层","date":"2022-01-03T04:30:12.000Z","updated":"2022-01-09T13:20:43.506Z","comments":true,"path":"2022/01/03/嵌入式任务分层/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B1%82/","excerpt":"","text":"参考网址: (94条消息) 例解嵌入式系统分层结构_和风化雨-CSDN博客_嵌入式系统分层 目的 分层的目的主要:1,是降低系统开发难度；2,是为了复用。 两层结构[硬件层, 软件层]12345678910111213/**********************************************************************************/#include &lt;reg51.h&gt;int main()&#123; int i=0; while(1) &#123; P1_1=0; for(i=0;i&lt;5000;i++); P1_1=1; for(i=0;i&lt;5000;i++); &#125;&#125; 三层结构[ 硬件层， 驱动层，应用层 ]虽然简单但很有逻辑,可以参考 123456789101112131415161718192021222324252627282930313233/*******************驱动头文件 driver.h***********************************************************/void delay();void led_on();void led_off();/*******************驱动源文件 driver.c************************************************************/#include &lt;reg51.h&gt;#include&quot;driver.h&quot;/*延时函数*/void delay()&#123; int i=0; for(i=0;i&lt;5000;i++);&#125;void led_on()&#123; P1_1=0;&#125;void led_off()&#123; P1_1=1;&#125;/******************应用系统****************************************************************/#include“../driver/driver.h”int main()&#123; while(1) &#123; led_on(); delay(); led_off(); delay(); &#125;&#125; 四层结构[ 硬件层，驱动层，操作系统层，应用层 ]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/******************************驱动****************************************************/#include&lt;linux/kerel.h&gt;#include&lt;linux/module.h&gt;#include&lt;asm/uaccess.h&gt;#include&lt;linux/mm/h&gt;#include&lt;linux/ioport.h&gt;#include&lt;asm/io.h&gt;#include&lt;linux/ioport.h&gt;#include&lt;linux/fs.h&gt;int led_init(void);void led_cleanup();static int device_open(struct inode *,struct file*);static int device_release(struct inode *,struct file*);static ssize_t device _write(struct file*,const char *,size_t,loff_t *);int init_model(void);void cleanup_module(void);struct file_operations led_ops=&#123;.owner=THIS_MODULE,..............................&#125;int led_init(void)&#123;..............................&#125;void led_cleanup()&#123;..............................&#125;static int device_open(struct inode * inode ,struct file* file)&#123;..............................&#125;static int device_release(struct inode *inode,struct file* file)&#123;..............................&#125;static ssize_t device _write(struct file *file,const char * buffer,size_t length,loff_t *offset)&#123;..............................int init_model(void)&#123;..............................&#125;modele_init(led_init);module_exit(led_cleanup);MODULE_LICENCE(&quot;GPL&quot;);/******************************应用****************************************************/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/ioctl.h&gt;#include&lt;sys/time.h&gt;#define LED &quot;/dev/led&quot;int main()&#123; File *fp=fopen(LED,RDWR); if(!fp)&#123; while(1)&#123; ioctl(fp,1); sleep(1); ioctl(fp,0); sleep(0); &#125; &#125; fclose(fp);&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"运算符标签操作","slug":"运算符标签操作","date":"2022-01-03T04:30:12.000Z","updated":"2022-01-09T13:20:51.481Z","comments":true,"path":"2022/01/03/运算符标签操作/","link":"","permalink":"https://peitianyu.github.io/blog/2022/01/03/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A0%87%E7%AD%BE%E6%93%8D%E4%BD%9C/","excerpt":"","text":"参考网址: (94条消息) 嵌入式学习之C语言运算符标签操作_foolish的博客-CSDN博客 加法运算12int *p=xxx； [0x12] //有一个int类型的指针，它的指针变量存储的地址为0x12。p=p+1；//指针加法,指向[0x13] 下标运算符[]1*(p+n)=p[n]; //n为下标,相当于,数组下标","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"linux程序开机启动与后台启动","slug":"自启动_后台启动","date":"2021-12-27T04:30:12.000Z","updated":"2021-12-27T07:28:24.371Z","comments":true,"path":"2021/12/27/自启动_后台启动/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/27/%E8%87%AA%E5%90%AF%E5%8A%A8_%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8/","excerpt":"","text":"参考网址: (91条消息) Ubuntu18.04 开机自启动脚本_cxh的博客-CSDN博客_ubuntu18.04开机自启动脚本 (91条消息) linux如何后台运行服务_六指黑侠i的博客-CSDN博客_linux 后台运行 自启动12# rc-local.service生成sudo nano /etc/systemd/system/rc-local.service 1234567891011121314[Unit]Description=/etc/rc.local CompatibilityConditionPathExists=/etc/rc.local #脚本文件位置 [Service]Type=forkingExecStart=/etc/rc.local start #配置的脚本文件rc.local为startTimeoutSec=0 StandardOutput=tty #标准输出RemainAfterExit=yesSysVStartPriority=99 #优先级，当有多个开机启动文件时可以设置不同的值 [Install]WantedBy=multi-user.target 12# 生成rc.localsudo nano /etc/rc.local 1234567891011121314#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.echo &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.logexit 0 12345# 给rc.local加上权限，启用服务，启动服务并检查状态sudo chmod +x /etc/rc.localsudo systemctl enable rc-localsudo systemctl start rc-local.servicesudo systemctl status rc-local.service 不挂断后台启动1nohup command &amp; 关闭1234# 查看进程jobs -l# 杀死进程sudo kill 7889","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"一种嵌入式设计模式","slug":"一种嵌入式设计模式","date":"2021-12-22T04:30:12.000Z","updated":"2021-12-22T07:41:08.688Z","comments":true,"path":"2021/12/22/一种嵌入式设计模式/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/22/%E4%B8%80%E7%A7%8D%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简介使用set与get方式实现的金字塔型架构,最下层仅提供函数调用,例如tcp,udp,uart,gpio等,第二层是模块层,这一层通过pthread线程实现自循环式模块实现,通过get与set对模块数据进行获取与设置.最后是逻辑层,仅对下层数据进行逻辑操作,不做模块实现. 文件结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145.├── CMakeLists.txt├── lib│ └── libcontrolcan.so└── src ├── GROUND_PANEL │ ├── Driver │ │ ├── Driver.h │ │ ├── Driver_utils.cpp │ │ ├── Driver_utils.h │ │ ├── Gpio.cpp │ │ ├── Gpio.h │ │ ├── controlcan.cpp │ │ ├── controlcan.h │ │ ├── socketCAN.cpp │ │ ├── socketCAN.h │ │ ├── tcp_cilent.cpp │ │ ├── tcp_cilent.h │ │ ├── usart.cpp │ │ └── usart.h │ ├── Math │ │ ├── Math.h │ │ ├── pid_control.cpp │ │ └── pid_control.h │ ├── ThirdParts │ │ ├── CFG_ini.cpp │ │ ├── CFG_ini.h │ │ ├── ModBUS │ │ │ ├── ascii │ │ │ │ ├── mbascii.c │ │ │ │ └── mbascii.h │ │ │ ├── functions │ │ │ │ ├── mbfunccoils.c │ │ │ │ ├── mbfuncdiag.c │ │ │ │ ├── mbfuncdisc.c │ │ │ │ ├── mbfuncholding.c │ │ │ │ ├── mbfuncinput.c │ │ │ │ ├── mbfuncother.c │ │ │ │ └── mbutils.c │ │ │ ├── include │ │ │ │ ├── mb.h │ │ │ │ ├── mbconfig.h │ │ │ │ ├── mbframe.h │ │ │ │ ├── mbfunc.h │ │ │ │ ├── mbport.h │ │ │ │ ├── mbproto.h │ │ │ │ └── mbutils.h │ │ │ ├── mb.c │ │ │ ├── port │ │ │ │ ├── port.h │ │ │ │ ├── portevent.c │ │ │ │ ├── portother.c │ │ │ │ ├── portserial.c │ │ │ │ └── porttimer.c │ │ │ ├── rtu │ │ │ │ ├── mbcrc.c │ │ │ │ ├── mbcrc.h │ │ │ │ ├── mbrtu.c │ │ │ │ └── mbrtu.h │ │ │ └── tcp │ │ │ ├── mbtcp.c │ │ │ └── mbtcp.h │ │ ├── cJSON.c │ │ ├── cJSON.h │ │ ├── tinyxml2.cpp │ │ └── tinyxml2.h │ └── param │ ├── AGVParameter.h │ ├── CFG.c │ ├── CFG.h │ ├── env_configure.c │ └── env_configure.h ├── Module │ ├── ActionCTRL │ │ ├── ActionCTRL.cpp │ │ ├── ActionCTRL.h │ │ └── ActionCTRLData.h │ ├── Battery │ │ ├── Battery.cpp │ │ ├── Battery.h │ │ ├── BatteryData.h │ │ ├── EIKTO_battery.cpp │ │ ├── EIKTO_battery.h │ │ ├── FR_battery.cpp │ │ └── FR_battery.h │ ├── CommWithPC │ │ ├── CommWithPC.cpp │ │ ├── CommWithPC.h │ │ └── CommWithPCData.h │ ├── Encoder │ │ ├── Encoder.cpp │ │ ├── Encoder.h │ │ ├── EncoderData.h │ │ ├── TOFI_encoder.cpp │ │ └── TOFI_encoder.h │ ├── HandShank │ │ ├── HandShank.cpp │ │ ├── HandShank.h │ │ ├── HandShankData.h │ │ ├── Logitech_controller.cpp │ │ └── Logitech_controller.h │ ├── IoBoard │ │ ├── IoBoard.cpp │ │ ├── IoBoard.h │ │ └── IoBoardData.h │ ├── Location │ │ ├── Location.cpp │ │ ├── Location.h │ │ └── LocationData.h │ ├── Map │ │ ├── LaserMAP.cpp │ │ ├── LaserMAP.h │ │ ├── Map.cpp │ │ ├── Map.h │ │ └── MapData.h │ ├── Module.cpp │ ├── Module.h │ ├── MoveCTRL │ │ ├── Kunhou │ │ │ ├── Kunhou_cJSON.cpp │ │ │ └── Kunhou_cJSON.h │ │ ├── MoveCTRL.cpp │ │ ├── MoveCTRL.h │ │ ├── MoveCtrlData.h │ │ └── Tongyi_Diff_Drive │ │ ├── Tongyi_Driver.cpp │ │ ├── Tongyi_Driver.h │ │ ├── diff_control.cpp │ │ └── diff_control.h │ ├── log.cpp │ └── log.h ├── Task │ ├── ModbusHMI.cpp │ ├── ModbusHMI.h │ ├── Music_Led.cpp │ ├── Music_Led.h │ ├── Safety.cpp │ ├── Safety.h │ ├── Task.cpp │ ├── Task.h │ ├── autoCtrl.cpp │ ├── autoCtrl.h │ ├── manualCtrl.cpp │ └── manualCtrl.h └── main.cpp 注意需要注意的一点是每个特定模块又三个对外文件,module.cpp module.h moduleData.h 模块使用,只有使用时初始化线程,如果不使用则注释掉 123456#include&quot;HandShank.h&quot;void init_HandShank()&#123; Logitech_thread();&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"pthread简单使用","slug":"pthread简单使用","date":"2021-12-17T04:30:12.000Z","updated":"2021-12-17T01:12:27.955Z","comments":true,"path":"2021/12/17/pthread简单使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/17/pthread%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:pthread 线程基本函数_chenwh_cn的博客-CSDN博客_pthread函数 Pthread线程基础学习_我的梦-CSDN博客_pthread教程 创建线程12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thread_fun(void* arg)&#123; int num = *((int*)arg); printf(&quot;int the new thread: num = %d\\n&quot;, num);&#125;int main(int argc, char *argv[])&#123; pthread_t tid; int test = 100; pthread_create(&amp;tid, NULL, thread_fun, (void *)&amp;test); while(1); return 0;&#125; 线程等待1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; static int ret = 5; // thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr] sleep(1); pthread_exit((void*)&amp;ret); //return (void*)&amp;ret;&#125;// 等待线程结束并回收线程资源，此函数会阻塞，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回int main(int argc, char *argv[])&#123; pthread_t tid; void *ret = NULL; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_join(tid, &amp;ret); printf(&quot;ret = %d\\n&quot;, *((int*)ret)); return 0;&#125; 分离线程1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; for(int i=0; i&lt;3; i++) &#123; printf(&quot;thread is runing\\n&quot;); sleep(1); &#125; return NULL;&#125;int main(int argc, char *argv[])&#123; pthread_t tid; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_detach(tid); if (pthread_join(tid, NULL)) // 立即返回，调用失败 &#123; printf(&quot;join not working\\n&quot;); &#125; printf(&quot;after join\\n&quot;); sleep(5); printf(&quot;master is leaving\\n&quot;); return 0;&#125; 退出线程1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; static int ret = 5; // thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr] sleep(1); pthread_exit((void*)&amp;ret); //return (void*)&amp;ret;&#125;int main(int argc, char *argv[])&#123; pthread_t tid; void *ret = NULL; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_join(tid, &amp;ret); printf(&quot;ret = %d\\n&quot;, *((int*)ret)); return 0;&#125; 取消线程123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *thread_fun(void *arg)&#123; int i=1; printf(&quot;thread start \\n&quot;); while(1) &#123; i++; // 调用pthread_testcancel，让内核去检测是否需要取消当前线程。 pthread_testcancel(); &#125; return (void *)0;&#125;int main()&#123; void *ret=NULL; int iret=0; pthread_t tid; pthread_create(&amp;tid,NULL,thread_fun,NULL); sleep(1); pthread_cancel(tid);//取消线程 pthread_join(tid, &amp;ret); printf(&quot;thread 3 exit code %d\\n&quot;, (int)ret); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"pthread_mutex使用","slug":"pthread_mutex使用","date":"2021-12-17T04:30:12.000Z","updated":"2021-12-17T01:29:20.523Z","comments":true,"path":"2021/12/17/pthread_mutex使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/17/pthread_mutex%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:pthread详解_networkhunter的博客-CSDN博客_phread 关于pthread_mutex_lock使用_无专精则不能成，无涉猎则不能通-CSDN博客_pthread_mutex_timedlock linux读写锁 pthread_rwlock/互斥锁pthread_mutex_三眼二郎-CSDN博客_pthread_mutex_t pthread_rwlock_t 常用pthread_mutex_lock12345678910#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict abs_timeout); 使用1234567891011121314151617181920212223242526272829// 创建pthread_mutex_t mtx;// 初始化互斥量// 第二个参数为 NULL，互斥锁的属性会设置为默认属性pthread_mutex_init(&amp;mtx, NULL);// 阻塞调用pthread_mutex_lock(&amp;mtx);// 非堵塞调用int err = pthread_mutex_trylock(&amp;mtx);if(0 != err) &#123; if(EBUSY == err) &#123; //The mutex could not be acquired because it was already locked. &#125;&#125;// 超时调用struct timespec abs_timeout;abs_timeout.tv_sec = time(NULL) + 1;abs_timeout.tv_nsec = 0;int err = pthread_mutex_timedlock(&amp;mtx, &amp;abs_timeout);if(0 != err) &#123; if(ETIMEDOUT == err) &#123; //The mutex could not be locked before the specified timeout expired. &#125;&#125;// 释放互斥锁pthread_mutex_unlock(&amp;mtx);// 销毁线程锁pthread_mutex_destroy(&amp;mtx) 简单使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;/*初始化互斥锁*/pthread_cond_t cond = PTHREAD_COND_INITIALIZER;//init cond void *thread1(void*);void *thread2(void*); int i = 1; //global int main(void)&#123; pthread_t t_a; pthread_t t_b;//two thread pthread_create(&amp;t_a,NULL,thread2,(void*)NULL); pthread_create(&amp;t_b,NULL,thread1,(void*)NULL);//Create thread printf(&quot;t_a:0x%x, t_b:0x%x:&quot;, t_a, t_b); pthread_join(t_b,NULL);//wait a_b thread end pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); exit(0);&#125; void *thread1(void *junk)&#123; for(i = 1;i&lt;= 9; i++)&#123; pthread_mutex_lock(&amp;mutex); //互斥锁 printf(&quot;call thread1 \\n&quot;); if(i%3 == 0) &#123; pthread_cond_signal(&amp;cond); //send sianal to t_b printf(&quot;thread1:******i=%d\\n&quot;, i); &#125; else printf(&quot;thread1: %d\\n&quot;,i); pthread_mutex_unlock(&amp;mutex); printf(&quot;thread1: sleep i=%d\\n&quot;, i); sleep(1); printf(&quot;thread1: sleep i=%d******end\\n&quot;, i); &#125;&#125; void *thread2(void*junk)&#123; while(i &lt; 9) &#123; pthread_mutex_lock(&amp;mutex); printf(&quot;call thread2 \\n&quot;); if(i%3 != 0) pthread_cond_wait(&amp;cond,&amp;mutex); //wait printf(&quot;thread2: %d\\n&quot;,i); pthread_mutex_unlock(&amp;mutex); printf(&quot;thread2: sleep i=%d\\n&quot;, i); sleep(1); printf(&quot;thread2: sleep i=%d******end\\n&quot;, i); &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"hexo安装","slug":"hexo安装","date":"2021-12-17T04:30:12.000Z","updated":"2022-05-12T01:36:42.372Z","comments":true,"path":"2021/12/17/hexo安装/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/17/hexo%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考网址: (91条消息) hexo史上最全搭建教程_Fangzh的技术博客-CSDN博客_hexo (91条消息) node版本如何升级_赵天铭的博客-CSDN博客_升级node版本 安装1234567# 安装gitsudo apt-get install git# 安装nodejssudo apt-get install nodejssudo apt-get install npm# 安装hexonpm install -g hexo-cli nodejs问题12345678npm i -g nnpm i -g n --force# 升级版本号n 版本号 如 n 14.0.0# 升级最新n latest# 升级最近稳定n stable _config.yml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 某飞行员的随笔subtitle: &#x27;&#x27;description: &#x27;向西可剃度,向东可寻欢,但山野笨拙,我也笨拙.&#x27;keywords:author: 某飞行员language: zh-CNtimezone: &#x27;&#x27;# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://peitianyu.github.io/blog/root: /blogpermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: Butterfly# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:peitianyu/blog.git branch: mastersearch: path: search.xml field: post content: true format: html# 文章加密encrypt: enable: true default_abstract: 加密文章 default_message: 输入密码，查看文章。 _config_butterfly.yml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016# Main menu navigation (導航目錄)# --------------------------------------# format: name: link || icon# sub-menu# name || icon:# name: link || iconmenu: 主页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 清单||fas fa-list: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video # 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart# Hide the child menu items in mobile sidebarhide_sidebar_menu_child: false# Code Blocks (代碼相關)# --------------------------------------highlight_theme: light # darker / pale night / light / ocean / mac / mac light / falsehighlight_copy: true # copy buttonhighlight_lang: true # show the code languagehighlight_shrink: false # true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the buttonhighlight_height_limit: false # unit: pxcode_word_wrap: false# copy settings# copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)copy: enable: true copyright: enable: false limit_count: 50# social settings (社交圖標設置)# formal:# icon: link || the descriptionsocial: fab fa-github: https://github.com/peitianyu || Github fas fa-envelope: mailto:peitianyu18@gmail.com || Email# search (搜索)# --------------------------------------# Algolia searchalgolia_search: enable: false hits: per_page: 6# Local searchlocal_search: enable: true labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot; # if there are no result# Math (數學)# --------------------------------------# About the per_page# if you set it to true, it will load mathjax/katex script in each page (true 表示每一頁都加載js)# if you set it to false, it will load mathjax/katex script according to your setting (add the &#x27;mathjax: true&#x27; in page&#x27;s front-matter)# (false 需要時加載，須在使用的 Markdown Front-matter 加上 mathjax: true)# MathJaxmathjax: enable: false per_page: false# KaTeXkatex: enable: false per_page: false hide_scrollbar: true# Image (圖片設置)# --------------------------------------# Favicon（網站圖標）favicon: /img/favicon.png# Avatar (頭像)avatar: img: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.wxcha.com%2Ffile%2F201603%2F04%2F274aab78d1.jpg&amp;refer=http%3A%2F%2Fimg.wxcha.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637633345&amp;t=66fe958a1bb4deedb5d227c6440f9e87 effect: false# Disable all banner imagedisable_top_img: false# The banner image of home pageindex_img: img/index.jpg# If the banner of page not setting, it will show the top_imgdefault_top_img:- https://s2.loli.net/2022/05/11/FsNqpO6wJnt2Gmo.jpg- https://s2.loli.net/2022/05/11/JUP8sHm3fqjAMwc.jpg- https://s2.loli.net/2022/05/11/3nzy9qG4pf6r1oD.jpg- https://s2.loli.net/2022/05/11/SjCm5qlzeYVvxUH.jpg- https://s2.loli.net/2022/05/11/cRUtWEmOV2gFjz7.jpg- https://s2.loli.net/2022/05/11/kcDf7sa4eQpKA6q.jpg- https://s2.loli.net/2022/05/11/XRUdjukhPpOTnCq.jpg- https://s2.loli.net/2022/05/11/8LVHxnaIP1jO2E9.jpg- https://s2.loli.net/2022/05/11/PZT5quMKzVEfF96.jpg- https://s2.loli.net/2022/05/11/qQIlH9WTM3yPjuJ.jpg- https://s2.loli.net/2022/05/11/Ekj3lI1mpt7DByL.jpg- https://s2.loli.net/2022/05/11/xq7I5YjzM3Cgw1P.jpg- https://s2.loli.net/2022/05/11/f9YMmQL2xgNclk3.jpg- https://s2.loli.net/2022/05/11/1IwGbKMJQtA8czR.jpg- https://s2.loli.net/2022/05/11/OZ6MsjoaS1m3n5I.jpg- https://s2.loli.net/2022/05/11/ulqbCaZsiXkyjpY.jpg- https://s2.loli.net/2022/05/11/8A5LltWwsB1Cquc.jpg- https://s2.loli.net/2022/05/11/NAaBOXTSmJoLeUn.jpg- https://s2.loli.net/2022/05/11/2pEyFdOzKGkJtjb.jpg- https://s2.loli.net/2022/05/11/XIYPuvtFcnm64bx.jpg- https://s2.loli.net/2022/05/11/qmbVdkCTH1lsNcx.jpg- https://s2.loli.net/2022/05/11/gs2ShWvZ3QHpki9.jpg- https://s2.loli.net/2022/05/11/vFfg9Vrwmy7uPbq.jpg- https://s2.loli.net/2022/05/11/SIi1zlnhPamDOTg.jpg- https://s2.loli.net/2022/05/11/G4Coj9YOPsZ7SA6.jpg- https://s2.loli.net/2022/05/11/ahOdyYz3WV15gnk.jpg- https://s2.loli.net/2022/05/11/3fuRTYqAeMZ2VlX.jpg- https://s2.loli.net/2022/05/11/KGx8sIvuFt3N9P7.jpg- https://s2.loli.net/2022/05/11/UxGlPip6knFAHdo.jpg- https://s2.loli.net/2022/05/11/pHewnOmv3NKE4jQ.jpg- https://s2.loli.net/2022/05/11/pf7L1ZKseCSNRlE.jpg- https://s2.loli.net/2022/05/11/QjKG5eupZdBSP82.jpg- https://s2.loli.net/2022/05/11/tsUxH2I9jrXgcYa.jpg- https://s2.loli.net/2022/05/11/MuSz9REYkmijcfK.jpg- https://s2.loli.net/2022/05/11/9Wg3sn1ktr8vObH.jpg- https://s2.loli.net/2022/05/11/Lfl71SWdTns4teH.jpg- https://s2.loli.net/2022/05/11/dF1hr2kwSmxQNWM.jpg- https://s2.loli.net/2022/05/11/DA7FhdWIbBNVK2Y.jpg- https://s2.loli.net/2022/05/11/LxeFRMkuP2OagbD.jpg- https://s2.loli.net/2022/05/11/AUkagSQ5vBHzEn4.jpg- https://s2.loli.net/2022/05/11/LuxNvEV9wGXkCcg.jpg- https://s2.loli.net/2022/05/11/Aeu9NBUKvo4FsfI.jpg- https://s2.loli.net/2022/05/11/DfjJiMPWGCsFV26.jpg# The banner image of archive pagearchive_img:# If the banner of tag page not setting, it will show the top_img# note: tag page, not tags page (子標籤頁面的 top_img)tag_img:# The banner image of tag page# format:# - tag name: xxxxxtag_per_img:# If the banner of category page not setting, it will show the top_img# note: category page, not categories page (子分類頁面的 top_img)category_img:# The banner image of category page# format:# - category name: xxxxxcategory_per_img:cover: # display the cover or not (是否顯示文章封面) index_enable: true aside_enable: true archives_enable: true # the position of cover in home page (封面顯示的位置) # left/right/both position: both # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示) default_cover: - https://s2.loli.net/2022/05/11/FsNqpO6wJnt2Gmo.jpg - https://s2.loli.net/2022/05/11/JUP8sHm3fqjAMwc.jpg - https://s2.loli.net/2022/05/11/3nzy9qG4pf6r1oD.jpg - https://s2.loli.net/2022/05/11/SjCm5qlzeYVvxUH.jpg - https://s2.loli.net/2022/05/11/cRUtWEmOV2gFjz7.jpg - https://s2.loli.net/2022/05/11/kcDf7sa4eQpKA6q.jpg - https://s2.loli.net/2022/05/11/XRUdjukhPpOTnCq.jpg - https://s2.loli.net/2022/05/11/8LVHxnaIP1jO2E9.jpg - https://s2.loli.net/2022/05/11/PZT5quMKzVEfF96.jpg - https://s2.loli.net/2022/05/11/qQIlH9WTM3yPjuJ.jpg - https://s2.loli.net/2022/05/11/Ekj3lI1mpt7DByL.jpg - https://s2.loli.net/2022/05/11/xq7I5YjzM3Cgw1P.jpg - https://s2.loli.net/2022/05/11/f9YMmQL2xgNclk3.jpg - https://s2.loli.net/2022/05/11/1IwGbKMJQtA8czR.jpg - https://s2.loli.net/2022/05/11/OZ6MsjoaS1m3n5I.jpg - https://s2.loli.net/2022/05/11/ulqbCaZsiXkyjpY.jpg - https://s2.loli.net/2022/05/11/8A5LltWwsB1Cquc.jpg - https://s2.loli.net/2022/05/11/NAaBOXTSmJoLeUn.jpg - https://s2.loli.net/2022/05/11/2pEyFdOzKGkJtjb.jpg - https://s2.loli.net/2022/05/11/XIYPuvtFcnm64bx.jpg - https://s2.loli.net/2022/05/11/qmbVdkCTH1lsNcx.jpg - https://s2.loli.net/2022/05/11/gs2ShWvZ3QHpki9.jpg - https://s2.loli.net/2022/05/11/vFfg9Vrwmy7uPbq.jpg - https://s2.loli.net/2022/05/11/SIi1zlnhPamDOTg.jpg - https://s2.loli.net/2022/05/11/G4Coj9YOPsZ7SA6.jpg - https://s2.loli.net/2022/05/11/ahOdyYz3WV15gnk.jpg - https://s2.loli.net/2022/05/11/3fuRTYqAeMZ2VlX.jpg - https://s2.loli.net/2022/05/11/KGx8sIvuFt3N9P7.jpg - https://s2.loli.net/2022/05/11/UxGlPip6knFAHdo.jpg - https://s2.loli.net/2022/05/11/pHewnOmv3NKE4jQ.jpg - https://s2.loli.net/2022/05/11/pf7L1ZKseCSNRlE.jpg - https://s2.loli.net/2022/05/11/QjKG5eupZdBSP82.jpg - https://s2.loli.net/2022/05/11/tsUxH2I9jrXgcYa.jpg - https://s2.loli.net/2022/05/11/MuSz9REYkmijcfK.jpg - https://s2.loli.net/2022/05/11/9Wg3sn1ktr8vObH.jpg - https://s2.loli.net/2022/05/11/Lfl71SWdTns4teH.jpg - https://s2.loli.net/2022/05/11/dF1hr2kwSmxQNWM.jpg - https://s2.loli.net/2022/05/11/DA7FhdWIbBNVK2Y.jpg - https://s2.loli.net/2022/05/11/LxeFRMkuP2OagbD.jpg - https://s2.loli.net/2022/05/11/AUkagSQ5vBHzEn4.jpg - https://s2.loli.net/2022/05/11/LuxNvEV9wGXkCcg.jpg - https://s2.loli.net/2022/05/11/Aeu9NBUKvo4FsfI.jpg - https://s2.loli.net/2022/05/11/DfjJiMPWGCsFV26.jpg# Replace Broken Images (替換無法顯示的圖片)error_img: flink: /img/friend_404.gif post_page: /img/404.jpg# A simple 404 pageerror_404: enable: false subtitle: &#x27;Page Not Found&#x27; background: https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.pngpost_meta: page: # Home Page date_type: created # created or updated or both 主頁文章日期是創建日或者更新日或都顯示 date_format: date # date/relative 顯示日期還是相對日期 categories: true # true or false 主頁是否顯示分類 tags: true # true or false 主頁是否顯示標籤 label: true # true or false 顯示描述性文字 post: date_type: both # created or updated or both 文章頁日期是創建日或者更新日或都顯示 date_format: date # date/relative 顯示日期還是相對日期 categories: true # true or false 文章頁是否顯示分類 tags: true # true or false 文章頁是否顯示標籤 label: true # true or false 顯示描述性文字# wordcount (字數統計)wordcount: enable: false post_wordcount: true min2read: true total_wordcount: true# Display the article introduction on homepage# 1: description# 2: both (if the description exists, it will show description, or show the auto_excerpt)# 3: auto_excerpt (default)# false: do not show the article introductionindex_post_content: method: 3 length: 500 # if you set method to 2 or 3, the length need to config# Post# --------------------------------------# toc (目錄)toc: enable: true number: true style_simple: falsepost_copyright: enable: true decode: false license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/# Sponsor/rewardreward: enable: false QR_code: # - img: /img/wechat.jpg # link: # text: wechat # - img: /img/alipay.jpg # link: # text: alipay# Post edit# Easily browse and edit blog source code online.post_edit: enable: false # url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/ # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/ url:# Related Articlesrelated_post: enable: false limit: 6 # Number of posts displayed date_type: created # or created or updated 文章日期顯示創建日或者更新日# figcaption (圖片描述文字)photofigcaption: false# post_pagination (分頁)# value: 1 || 2 || false# 1: The &#x27;next post&#x27; will link to old post# 2: The &#x27;next post&#x27; will link to new post# false: disable paginationpost_pagination: 1# anchor# when you scroll in post, the URL will update according to header id.anchor: false# Displays outdated notice for a post (文章過期提醒)noticeOutdate: enable: false style: flat # style: simple/flat limit_day: 500 # When will it be shown position: top # position: top/bottom message_prev: It has been message_next: days since the last update, the content of the article may be outdated.# Share System (分享功能)# --------------------------------------# AddThis# https://www.addthis.com/addThis: enable: false pubid:# Share.js# https://github.com/overtrue/share.jssharejs: enable: true sites: facebook,twitter,wechat,weibo,qq# AddToAny# https://www.addtoany.com/addtoany: enable: false item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link# Comments System# --------------------------------------comments: # Up to two comments system, the first will be shown as default # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo use: # - gitalk # - Disqus text: true # Display the comment name next to the button # lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport. # If you set it to true, the comment count will be invalid lazyload: false count: false # Display comment count in post&#x27;s top_img card_post_count: false # Display comment count in Home Page# disqus# https://disqus.com/disqus: shortname: apikey: # For newest comments widget# Alternative Disqus - Render comments with Disqus API# DisqusJS 評論系統，可以實現在網路審查地區載入 Disqus 評論列表，兼容原版# https://github.com/SukkaW/DisqusJSdisqusjs: shortname: siteName: apikey: api: nocomment: # display when a blog post or an article has no comment attached admin: adminLabel:# livere (來必力)# https://www.livere.com/livere: uid:# gitalk# https://github.com/gitalk/gitalkgitalk: client_id: 76b646089f2936c75ac4 client_secret: 6c9740733a2dacd1f9187dd719936b096290534c repo: blog owner: peitianyu admin: master language: zh-CN # en, zh-CN, zh-TW, es-ES, fr, ru perPage: 10 # Pagination size, with maximum 100. distractionFreeMode: false # Facebook-like distraction free mode. pagerDirection: last # Comment sorting direction, available values are last and first. createIssueManually: false # Gitalk will create a corresponding github issue for your every single page automatically option:# valine# https://valine.js.orgvaline: appId: # leancloud application app id appKey: # leancloud application app key pageSize: 10 # comment list page size avatar: monsterid # gravatar style https://valine.js.org/#/avatar lang: en # i18n: zh-CN/zh-TW/en/ja placeholder: Please leave your footprints # valine comment input placeholder (like: Please leave your footprints) guest_info: nick,mail,link # valine comment header info (nick/mail/link) recordIP: false # Record reviewer IP serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in) bg: # valine background emojiCDN: # emoji CDN enableQQ: false # enable the Nickname box to automatically get QQ Nickname and QQ Avatar requiredFields: nick,mail # required fields (nick/mail) visitor: false option:# waline - A simple comment system with backend support fork from Valine# https://waline.js.org/waline: serverURL: # Waline server address url avatar: monsterid # gravatar style https://zh-tw.gravatar.com/site/implement/images/#default-image avatarCDN: # Gravatar CDN baseURL bg: # waline background visitor: false option:# utterances# https://utteranc.es/utterances: repo: # Issue Mapping: pathname/url/title/og:title issue_term: pathname # Theme: github-light/github-dark/github-dark-orange/icy-dark/dark-blue/photon-dark light_theme: github-light dark_theme: photon-dark# Facebook Comments Plugin# https://developers.facebook.com/docs/plugins/comments/facebook_comments: app_id: user_id: # optional pageSize: 10 # The number of comments to show order_by: social # social/time/reverse_time lang: en_US # Language en_US/zh_CN/zh_TW and so on# Twikoo# https://github.com/imaegoo/twikootwikoo: envId: region: visitor: false option:# Chat Services# --------------------------------------# Chat Button [recommend]# It will create a button in the bottom right corner of website, and hide the origin buttonchat_btn: false# The origin chat button is displayed when scrolling up, and the button is hidden when scrolling downchat_hide_show: false# chatra# https://chatra.io/chatra: enable: false id:# tidio# https://www.tidio.com/tidio: enable: false public_key:# daovoice# http://daovoice.io/daovoice: enable: false app_id:# gitter# https://gitter.im/gitter: enable: false room:# crisp# https://crisp.chat/en/crisp: enable: false website_id:# Footer Settings# --------------------------------------footer: owner: enable: true since: 2020 custom_text: Hi, welcome to my blog! copyright: true # Copyright of theme and framework# Analysis# --------------------------------------# Baidu Analytics# https://tongji.baidu.com/web/welcome/loginbaidu_analytics:# Google Analytics# https://analytics.google.com/analytics/web/google_analytics:# Tencent Analytics ID# https://mta.qq.comtencent_analytics:# CNZZ Analytics# https://www.umeng.com/cnzz_analytics:# Cloudflare Analytics# https://www.cloudflare.com/zh-tw/web-analytics/cloudflare_analytics:# Microsoft Clarity# https://clarity.microsoft.com/microsoft_clarity:# Advertisement# --------------------------------------# Google Adsense (谷歌廣告)google_adsense: enable: false auto_ads: true js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js client: enable_page_level_ads: true# Insert ads manually (手動插入廣告)# ad:# index:# aside:# post:# Verification (站長驗證)# --------------------------------------site_verification: # - name: google-site-verification # content: xxxxxx # - name: baidu-site-verification # content: xxxxxxx# Beautify/Effect (美化/效果)# --------------------------------------# Theme color for customize# Notice: color value must in double quotes like &quot;#000&quot; or may cause error!# theme_color:# enable: true# main: &quot;#49B1F5&quot;# paginator: &quot;#00c4b6&quot;# button_hover: &quot;#FF7242&quot;# text_selection: &quot;#00c4b6&quot;# link_color: &quot;#99a9bf&quot;# meta_color: &quot;#858585&quot;# hr_color: &quot;#A4D8FA&quot;# code_foreground: &quot;#F47466&quot;# code_background: &quot;rgba(27, 31, 35, .05)&quot;# toc_color: &quot;#00c4b6&quot;# blockquote_padding_color: &quot;#49b1f5&quot;# blockquote_background_color: &quot;#49b1f5&quot;# The top_img settings of home page# default: top img - full screen, site info - middle (默認top_img全屏，site_info在中間)# The position of site info, eg: 300px/300em/300rem/10% (主頁標題距離頂部距離)index_site_info_top:# The height of top_img, eg: 300px/300em/300rem (主頁top_img高度)index_top_img_height:# The user interface setting of category and tag page (category和tag頁的UI設置)# index - same as Homepage UI (index 值代表 UI將與首頁的UI一樣)# default - same as archives UI 默認跟archives頁面UI一樣category_ui: # 留空或 indextag_ui: # 留空或 index# Website Background (設置網站背景)# can set it to color or image (可設置圖片 或者 顔色)# The formal of image: url(http://xxxxxx.com/xxx.jpg)background:# Footer Backgroundfooter_bg: false# the position of bottom right button/default unit: px (右下角按鈕距離底部的距離/默認單位為px)rightside-bottom:# Enter transitions (開啓網頁進入效果)enter_transitions: true# Background effects (背景特效)# --------------------------------------# canvas_ribbon (靜止彩帶背景)# See: https://github.com/hustcc/ribbon.jscanvas_ribbon: enable: false size: 150 alpha: 0.6 zIndex: -1 click_to_change: false mobile: false# Fluttering Ribbon (動態彩帶)canvas_fluttering_ribbon: enable: false mobile: false# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest: enable: false color: &#x27;0,0,255&#x27; #color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(note: use &#x27;,&#x27; to separate.) opacity: 0.7 # the opacity of line (0~1), default: 0.5. zIndex: -1 # z-index property of the background, default: -1. count: 99 # the number of lines, default: 99. mobile: false# Typewriter Effect (打字效果)# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: false colorful: true # open particle animation (冒光特效) shake: true # open shake (抖動特效) mobile: false# Mouse click effects: fireworks (鼠標點擊效果: 煙火特效)fireworks: enable: false zIndex: 9999 # -1 or 9999 mobile: false# Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)click_heart: enable: false mobile: false# Mouse click effects: words (鼠標點擊效果: 文字)ClickShowText: enable: false text: # - I # - LOVE # - YOU fontSize: 15px random: false mobile: false# Default display mode (網站默認的顯示模式)# light (default) / darkdisplay_mode: light# Beautify (美化頁面顯示)beautify: enable: false field: post # site/post title-prefix-icon: &#x27;\\f0c1&#x27; title-prefix-icon-color: &#x27;#F47466&#x27;# Global font settings# Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)font: global-font-size: code-font-size: font-family: code-font-family:# Font settings for the site title and site subtitle# 左上角網站名字 主頁居中網站名字blog_title_font: font_link: font-family:# The setting of divider icon (水平分隔線圖標設置)hr_icon: enable: true icon: # the unicode value of Font Awesome icon, such as &#x27;\\3423&#x27; icon-top:# the subtitle on homepage (主頁subtitle)subtitle: enable: true # Typewriter Effect (打字效果) effect: true # loop (循環打字) loop: false # source調用第三方服務 # source: false 關閉調用 # source: 1 調用搏天api的隨機語錄（簡體） # source: 2 調用一言網的一句話（簡體） # source: 3 調用一句網（簡體） # source: 4 調用今日詩詞（簡體） # subtitle 會先顯示 source , 再顯示 sub 的內容 source: false # 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44; # 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot; # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住 # 如果關閉打字效果，subtitle只會顯示sub的第一行文字 sub: &quot;树枝想去撕裂天空 / 却只戳了几个微小的窟窿 / 它透出天外的光亮 / 人们把它叫做月亮和星星&quot;# Loading Animation (加載動畫)preloader: false# aside (側邊欄)# --------------------------------------aside: enable: true hide: false button: true mobile: true # display on mobile position: right # left or right card_author: enable: true description: button: enable: true icon: fab fa-github text: Follow Me link: https://github.com/peitianyu card_announcement: enable: false content: This is my Blog card_recent_post: enable: false limit: 5 # if set 0 will show all sort: date # date or updated sort_order: # Don&#x27;t modify the setting unless you know how it works card_categories: enable: true limit: 8 # if set 0 will show all expand: none # none/true/false sort_order: # Don&#x27;t modify the setting unless you know how it works card_tags: enable: true limit: 40 # if set 0 will show all color: false sort_order: # Don&#x27;t modify the setting unless you know how it works card_archives: enable: true type: monthly # yearly or monthly format: MMMM YYYY # eg: YYYY年MM月 order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending limit: 8 # if set 0 will show all sort_order: # Don&#x27;t modify the setting unless you know how it works card_webinfo: enable: false post_count: true last_push_date: true sort_order: # Don&#x27;t modify the setting unless you know how it works# busuanzi count for PV / UV in site# 訪問人數busuanzi: site_uv: true site_pv: true page_pv: true# Time difference between publish date and now (網頁運行時間)# Formal: Month/Day/Year Time or Year/Month/Day Timeruntimeshow: enable: false publish_date:# Aside widget - Newest Commentsnewest_comments: enable: false sort_order: # Don&#x27;t modify the setting unless you know how it works limit: 6 storage: 10 # unit: mins, save data to localStorage avatar: true# Bottom right button (右下角按鈕)# --------------------------------------# Change font sizechange_font_size: false# Conversion between Traditional and Simplified Chinese (簡繁轉換)translate: enable: true # 默認按鈕顯示文字(網站是簡體，應設置為&#x27;default: 繁&#x27;) default: 簡 #網站默認語言，1: 繁體中文, 2: 簡體中文 defaultEncoding: 1 #延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0 translateDelay: 0 #當文字是簡體時，按鈕顯示的文字 msgToTraditionalChinese: &quot;繁&quot; #當文字是繁體時，按鈕顯示的文字 msgToSimplifiedChinese: &quot;簡&quot;# Read Mode (閲讀模式)readmode: true# dark modedarkmode: enable: true # Toggle Button to switch dark/light mode button: true # Switch dark/light mode automatically (自動切換 dark mode和 light mode) # autoChangeMode: 1 Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am # autoChangeMode: 2 Switch dark mode between 6 pm to 6 am # autoChangeMode: false autoChangeMode: false# Lightbox (圖片大圖查看模式)# --------------------------------------# You can only choose one, or neither (只能選擇一個 或者 兩個都不選)# medium-zoom# https://github.com/francoischalifour/medium-zoommedium_zoom: false# fancybox# http://fancyapps.com/fancybox/3/fancybox: true# Tag Plugins settings (標籤外掛)# --------------------------------------# mermaid# see https://github.com/mermaid-js/mermaidmermaid: enable: false # built-in themes: default/forest/dark/neutral theme: default# Note (Bootstrap Callout)note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# other# --------------------------------------# Pjax# It may contain bugs and unstable, give feedback when you find the bugs.# https://github.com/MoOx/pjaxpjax: enable: false exclude: # - xxxx # - xxxx# Inject the css and script (aplayer/meting)aplayerInject: enable: false per_page: true# Snackbar (Toast Notification 彈窗)# https://github.com/polonel/SnackBar# position 彈窗位置# 可選 top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar: enable: false position: bottom-left bg_light: &#x27;#49b1f5&#x27; # The background color of Toast Notification in light mode bg_dark: &#x27;#121212&#x27; # The background color of Toast Notification in dark mode# https://instant.page/# prefetch (預加載)instantpage: false# https://github.com/vinta/pangu.js# Insert a space between Chinese character and English character (中英文之間添加空格)pangu: enable: false field: site # site/post# Lazyload (圖片懶加載)# https://github.com/verlok/vanilla-lazyloadlazyload: enable: false field: site # site/post placeholder: blur: false# PWA# See https://github.com/JLHwung/hexo-offline# ---------------# pwa:# enable: false# manifest: /pwa/manifest.json# apple_touch_icon: /pwa/apple-touch-icon.png# favicon_32_32: /pwa/32.png# favicon_16_16: /pwa/16.png# mask_icon: /pwa/safari-pinned-tab.svg# Open graph meta tags# https://developers.facebook.com/docs/sharing/webmasters/Open_Graph_meta: true# Add the vendor prefixes to ensure compatibilitycss_prefix: true# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)# 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前inject: head: # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt; bottom: # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;# CDN# Don&#x27;t modify the following settings unless you know how they work# 非必要請不要修改CDN: # main main_css: /css/index.css jquery: https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js main: /js/main.js utils: /js/utils.js # pjax pjax: https://cdn.jsdelivr.net/npm/pjax/pjax.min.js # comments gitalk: https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js gitalk_css: https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css valine: https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js disqusjs: https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js disqusjs_css: https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css utterances: https://utteranc.es/client.js twikoo: https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js waline: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js # share addtoany: https://static.addtoany.com/menu/page.js sharejs: https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js sharejs_css: https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css # search local_search: /js/search/local-search.js algolia_js: /js/search/algolia.js algolia_search: https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js algolia_search_css: https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css # math mathjax: https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js katex: https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css katex_copytex: https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js katex_copytex_css: https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css mermaid: https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js # count busuanzi: //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js # background effect canvas_ribbon: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js canvas_fluttering_ribbon: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js canvas_nest: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js lazyload: https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js instantpage: https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js typed: https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js pangu: https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js # photo fancybox_css: https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css fancybox: https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js medium_zoom: https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js # snackbar snackbar_css: https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css snackbar: https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js # effect activate_power_mode: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js fireworks: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js click_heart: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js ClickShowText: https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js # fontawesome fontawesome: https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css # Conversion between Traditional and Simplified Chinese translate: /js/tw_cn.js # justifiedGallery justifiedGallery_js: https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js justifiedGallery_css: https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css # aplayer aplayer_css: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css aplayer_js: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js meting_js: https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js # Prism.js prismjs_js: https://cdn.jsdelivr.net/npm/prismjs/prism.min.js prismjs_lineNumber_js: https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js prismjs_autoloader: https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js","categories":[{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/tags/blog/"}]},{"title":"简单pid控制","slug":"pid控制","date":"2021-12-16T04:30:12.000Z","updated":"2021-12-16T05:03:07.454Z","comments":true,"path":"2021/12/16/pid控制/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/16/pid%E6%8E%A7%E5%88%B6/","excerpt":"","text":"参考网址:[P、I、D参数分析及倒立摆心得_一念之间、-CSDN博客_pid 倒立摆](https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p表示 i表示 d表示&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-8-75249145.pc_search_em_sort&amp;spm=1018.2226.3001.4187) PID控制算法的C语言实现_我的博客-CSDN博客_pid算法c程序 PID作用12345P-------作用是提高系统响应速度,过大会出现震荡---------------------------快速性I-------作用是消除静差----------------------------------------------准确性D-------作用是抑制震荡----------------------------------------------稳定性/预测性 例程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// pid控制测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// P:响应 I:稳差 D:预判struct PID_CTRL&#123; float kp; float ki; float kd;&#125;;float pos_pid_control(float target, float current, struct PID_CTRL pid)&#123; static float err_last; float out,err_sum=0,err_d,err; err = target - current; err_sum += err; err_d = err - err_last; out = pid.kp * err + pid.ki * err_sum + pid.kd * err_d; err_last = err; return out;&#125;float gain_pid_control(float target, float current, struct PID_CTRL pid)&#123; static float err_last; float out=0; float err = target - current; out += pid.kp * (err-err_last) + pid.ki * err; err_last = err; return out;&#125;void test_pos_pid_control()&#123; struct PID_CTRL pid&#123;0.5,0.1,0.1&#125;; pid.kp = 0.5; pid.ki = 0.2; pid.kd = 0.1; float target = 10.0; float current = 0.0; for(int i = 0; i &lt; 100; i++) &#123; current += 0.1; printf(&quot;target: %f, current: %f, out: %f\\n&quot;, target, current, pos_pid_control(target, current, pid)); &#125;&#125;void test_gain_pid_control()&#123; struct PID_CTRL pid&#123;0.5,0.1,0.1&#125;; pid.kp = 0.5; pid.ki = 0.2; pid.kd = 0.1; float target = 10.0; float current = 0.0; for(int i = 0; i &lt; 100; i++) &#123; current += 0.1; printf(&quot;target: %f, current: %f, out: %f\\n&quot;, target, current, gain_pid_control(target, current, pid)); &#125;&#125;int main()&#123; test_pos_pid_control(); printf(&quot;********************************************\\n&quot;); test_gain_pid_control(); return 0;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"修改和校正树莓派时间","slug":"树莓派更新与校正时间","date":"2021-12-16T04:30:12.000Z","updated":"2021-12-16T03:32:36.086Z","comments":true,"path":"2021/12/16/树莓派更新与校正时间/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%A0%A1%E6%AD%A3%E6%97%B6%E9%97%B4/","excerpt":"","text":"参考网址:修改和校正树莓派时间_胡嘿嘿-CSDN博客_树莓派修改时间 步骤1234567891011# 修改时区sudo dpkg-reconfigure tzdata# 选择亚洲时区 Asia# 选择上海时间 Shanghai# 检查是否设置成功date# 校正时间sudo ntpd -s -d# 强制设置时间sudo date --s=&quot;2017-07-25 10:43:00&quot;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"c语言的三种传参方式","slug":"c语言的三种传参方式","date":"2021-12-15T04:30:12.000Z","updated":"2021-12-15T08:45:10.864Z","comments":true,"path":"2021/12/15/c语言的三种传参方式/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/15/c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include &lt;stdint.h&gt;using namespace std; int fun1(int a)&#123; return a*a;&#125; void man(int &amp;a)&#123; a=a*a;&#125; void cubeByReference(int *a)&#123; *a=*a * *a;&#125;void fun2(uint8_t* *buffer)&#123; uint8_t buf[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; *buffer = buf;&#125;int main()&#123; int a=5,b=5,number=5; cout&lt;&lt;fun1(a)&lt;&lt;endl; man(b); cout&lt;&lt;b&lt;&lt;endl; cubeByReference(&amp;number); cout&lt;&lt;number&lt;&lt;endl; uint8_t *buf; fun2(&amp;buf); printf(&quot;%d\\n&quot;, buf[0]); // for (int i = 0; i &lt; 10; ++i) // &#123; // printf(&quot;%d\\n&quot;, buf[i]); // &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"镜像源","slug":"镜像源","date":"2021-12-12T04:30:12.000Z","updated":"2021-12-12T13:05:28.462Z","comments":true,"path":"2021/12/12/镜像源/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/12/%E9%95%9C%E5%83%8F%E6%BA%90/","excerpt":"","text":"参考网址:华为镜像源: https://mirrors.huaweicloud.com/home 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"0ohm电阻作用","slug":"0ohm电阻目的","date":"2021-12-11T04:30:12.000Z","updated":"2021-12-11T03:55:31.183Z","comments":true,"path":"2021/12/11/0ohm电阻目的/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/11/0ohm%E7%94%B5%E9%98%BB%E7%9B%AE%E7%9A%84/","excerpt":"","text":"零欧姆电阻的主要作用有如下： 1,在电路中没有任何功能，只是在PCB上为了调试方便或兼容设计等原因。2,可以做跳线用，如果某段线路不用，直接不贴该电阻即可（不影响外观）。3,在匹配电路参数不确定的时候，以0欧姆代替，实际调试的时候，确定参数，再以具体数值的元件代替。4,想测某部分电路的耗电流的时候，可以去掉0ohm电阻，接上电流表，这样方便测耗电流。5,在布线时,如果实在布不过去了,也可以加一个0欧的电阻。6,在高频信号下，充当电感或电容。（与外部电路特性有关）电感用，主要是解决EMC问题。如地与地，电源和IC Pin间。7,单点接地（指保护接地、工作接地、直流接地在设备上相互分开,各自成为独立系统。）8,熔丝作用；9，单点接地，只要是地，最终都要接到一起，然后入大地。如果不接在一起就是”浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上有四种方法解决此问题：1、用磁珠连接；2、用电容连接；3、用电感连接；4、用0欧姆电阻连接。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。电容隔直通交，造成浮地。电感体积大，杂散参数多，不稳定。0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。10，跨接时用于电流回路，当分割电地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。11，配置电路，一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子。空置跳线在高频时相当于天线，用贴片电阻效果好。12，其他用途，布线时跨线；调试/测试用；临时取代其他贴片器件；作为温度补偿器件；更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔）。","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"}]},{"title":"pip","slug":"pip","date":"2021-12-11T04:30:12.000Z","updated":"2021-12-11T03:58:55.879Z","comments":true,"path":"2021/12/11/pip/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/11/pip/","excerpt":"","text":"参考网址:(8条消息) pip安装镜像_转载_qq_2711624322-CSDN博客_pip安装镜像 设pip默认镜像源_SimpleLikeMe的博客-CSDN博客 配置1234#临时使用pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple package#配置成固定镜像pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"k60_can_bootloader","slug":"k60_can_bootloader","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-10T12:58:35.323Z","comments":true,"path":"2021/12/10/k60_can_bootloader/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/k60_can_bootloader/","excerpt":"","text":"参考demo:peitianyu/k60_bootloader (github.com) main.c文件配置进入mian.c文件加入头文件并引用bootloader_entry()函数 使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app 判断bootflag是否制一，若是，进入boot模式 canbus.c文件配置在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1 keil配置将hex烧录地址改为从0x6000开始 树莓派使用./bootloader can0 xx.hex 挂载win101sudo mount -t cifs //192.168.2.101/2021.04/CH-K-Lib/Project/1/bootloader/MDK/mk60d10/flash /k60 -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"linux定时器","slug":"linux内核定时器","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-11T01:59:23.774Z","comments":true,"path":"2021/12/10/linux内核定时器/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"参考网址:LInux下几种定时器的比较和使用_weixin_34358365的博客-CSDN博客 1、sleep，usleep和nanosleep123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;sched.h&gt;#define COUNT 1000#define MILLION 1000000Lint main(void)&#123; int i; struct timespec slptm; long tdif; struct timeval tend, tstart; slptm.tv_sec = 0; slptm.tv_nsec = 1000; //1000 ns = 1 us //struct sched_param param; //param.sched_priority = 0; //sched_setscheduler(getpid(), SCHED_FIFO, &amp;param); if (gettimeofday(&amp;tstart, NULL) == -1) &#123; fprintf(stderr, &quot;Failed to get start time\\n&quot;); return 1; &#125; for (i = 0; i &lt; COUNT; i++) &#123; if (nanosleep(&amp;slptm, NULL) == -1) &#123; perror(&quot;Failed to nanosleep&quot;); return 1; &#125; &#125; if (gettimeofday(&amp;tend, NULL) == -1) &#123; fprintf(stderr, &quot;Failed to get end time\\n&quot;); return 1; &#125; tdif = MILLION * (tend.tv_sec - tstart.tv_sec) + (tend.tv_usec - tstart.tv_usec); printf(&quot;nanosleep() time is %ld us\\n&quot;, tdif/COUNT); return 0;&#125; 2、使用信号量SIGALRM + alarm(),只能秒级123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;signal.h&gt;void timer(int sig)&#123; if(SIGALRM == sig) &#123; printf(&quot;timer\\n&quot;); alarm(1); //重新继续定时1s &#125; return ;&#125;int main()&#123; signal(SIGALRM, timer); //注册安装信号 alarm(1); //触发定时器 getchar(); return 0;&#125; 3、使用RTC(系统硬件提供的RTC，精度可调)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;linux/rtc.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[])&#123; unsigned long i = 0; unsigned long data = 0; int retval = 0; int fd = open (&quot;/dev/rtc&quot;, O_RDONLY); if(fd &lt; 0) &#123; perror(&quot;open&quot;); exit(errno); &#125; /*Set the freq as 4Hz*/ if(ioctl(fd, RTC_IRQP_SET, 1) &lt; 0) &#123; perror(&quot;ioctl(RTC_IRQP_SET)&quot;); close(fd); exit(errno); &#125; /* Enable periodic interrupts */ if(ioctl(fd, RTC_PIE_ON, 0) &lt; 0) &#123; perror(&quot;ioctl(RTC_PIE_ON)&quot;); close(fd); exit(errno); &#125; for(i = 0; i &lt; 100; i++) &#123; if(read(fd, &amp;data, sizeof(unsigned long)) &lt; 0) &#123; perror(&quot;read&quot;); close(fd); exit(errno); &#125; printf(&quot;timer\\n&quot;); &#125; /* Disable periodic interrupts */ ioctl(fd, RTC_PIE_OFF, 0); close(fd); return 0;&#125; 4、使用select()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/select.h&gt;#include &lt;time.h&gt;int Callback_1(int x) // Callback Function 1&#123; printf(&quot;Hello, this is Callback_1: x = %d \\n&quot;, x); return 0;&#125;//设置模板template&lt;typename T&gt;void setTimer(int seconds, int mseconds,T arg,int (*callback)(T)) // Set Timer&#123; struct timeval temp; temp.tv_sec = seconds; temp.tv_usec = mseconds; select(0, NULL, NULL, NULL, &amp;temp); callback(arg); return ;&#125;float last_time;float get_diff_time(void)&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); float time = tv.tv_sec%10 + tv.tv_usec / 1000000.0; if (time &lt; last_time) time += 10; float time_diff = time - last_time; last_time = time; return time_diff;&#125;int main()&#123; int a = 2; for (size_t i = 0; i &lt; 5; i++) &#123; float time_diff = get_diff_time(); printf(&quot;time_diff = %f \\n&quot;, time_diff); setTimer(1, 0, a, Callback_1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"ros2安装","slug":"ros2安装","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-13T14:04:24.498Z","comments":true,"path":"2021/12/10/ros2安装/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/ros2%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考网址:Ubuntu18.04 安装ROS Melodic &amp;&amp; Ros2 Dashing踩坑笔记_LukeyAlvin的博客-CSDN博客_ubuntu18安装ros2 鱼香ROS (fishros.com) 简介由于ros2很多并不完善,所以采用ros1+ros2的方式实现,这里采用常规+fishros的方式实现安装.最后采用在初始化使用shell脚本选择使用ros版本 Ros1安装ros安装 | 某飞行员的随笔 (peitianyu.github.io) Ros2安装12345678910111213141516171819# 设置UTF-8编码sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8# 更新软件源sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27;# 安装wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros# 通过如下命令添加到.bashrc(注意这里如果需要使用两个版本,这一步不需要设置)echo &quot;source /opt/ros/dashing/setup.bash&quot; &gt;&gt; ~/.bashrc# RWM功能sudo apt updatesudo apt install ros-dashing-rmw-opensplice-cpp # for OpenSplicesudo apt install ros-dashing-rmw-connext-cpp # for RTI Connext (requires license agreement)# ros1与ros2通信sudo apt updatesudo apt install ros-dashing-ros1-bridge 12345678910111213141516171819202122232425262728293031323334# 安装编译工具sudo apt update &amp;&amp; sudo apt install -y \\build-essential \\cmake \\git \\python3-colcon-common-extensions \\python3-pip \\python-rosdep \\python3-vcstool \\wget# install some pip packages needed for testingsudo -H python3 -m pip install -U \\argcomplete \\flake8 \\flake8-blind-except \\flake8-builtins \\flake8-class-newline \\flake8-comprehensions \\flake8-deprecated \\flake8-docstrings \\flake8-import-order \\flake8-quotes \\pytest-repeat \\pytest-rerunfailures# [Ubuntu 16.04] install extra packages not available or recent enough on Xenialpython3 -m pip install -U \\pytest \\pytest-cov \\pytest-runner \\setuptools# install Fast-RTPS dependenciessudo apt install --no-install-recommends -y \\libasio-dev \\libtinyxml2-dev 12345678910111213# 测试mkdir ~/ros2_wscd /ros2_wsgit clone https://ghproxy.com/https://github.com/zhangrelay/ros2_tutorialscd ros2_tutorialscolcon build# 设置环境变量(也可以将之放入.bashrc中)source /install/setup.sh # 第一个终端cd /ros_ws/ros2_tutorials/installros2 run demo_nodes_cpp listener# 第二个终端ros2 run demo_nodes_cpp talker 使用多个ros版本保存一个脚本文件,使用前运行1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi !注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的# source /opt/ros/melodic/setup.bash# source /opt/ros/dashing/setup.bash注释掉","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"树莓派CAN","slug":"树莓派CAN","date":"2021-12-10T04:30:12.000Z","updated":"2022-01-13T06:37:03.009Z","comments":true,"path":"2021/12/10/树莓派CAN/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/%E6%A0%91%E8%8E%93%E6%B4%BECAN/","excerpt":"","text":"参考网址:树莓派CAN通讯教程 - MCP2515_j353838430的博客-CSDN博客_树莓派can通信 (86条消息) SPI协议、MCP2515裸机驱动详解—-主流SPI总线接口原理_csshuke的专栏-CSDN博客_mcp2515 spi极性 mcp2515模块资料:http://pan.baidu.com/s/1hsi3I4k 简介使用mcp2515实现的spi转can通信 原理图 需要注意的是这里的片选,也就是说可以通过片选CS信号实现一个spi转多个can通信,INT引脚用于中断缓存数据,当接收到数据时会将数据先放入缓冲区 环境准备12345678910111213# 安装cantoolssudo apt install can-utilspip3 install cantools# 检测挂载ifconfig# 查看是否进入read状态sudo ip -s -d link show can0# 使能树莓派SPI并加载MCP2515内核驱动dtparam=spi=ondtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25dtoverlay=spi1-1cs# 重启sudo reboot -h now 12345678910111213141516# 关闭can0sudo ip link set can0 down# 设置波特率sudo ip link set can0 type can bitrate 1000000# 开启can0sudo ip link set can0 up# 查看sudo ip -s -d link show can0# 接收报文candump any,0:0,#FFFFFFFF# 过滤candump can0,620:1fffffff,255:7ff# 发送报文cansend can0 123#1122334455667788# 设置回环 波特率 250K ,用于测试can通路,在没有其它硬件连接测试的情况下，可以设定成回环，自发自收sudo ip link set can0 type can bitrate 500000 loopback on C语言使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180// test.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/can.h&gt;#include &lt;linux/can/raw.h&gt;#define command &quot;ip link set can0 type can bitrate 1000000&quot;//将CAN0波特率设置为500K#define up &quot;ifconfig can0 up&quot;//打开CAN0#define down &quot;ifconfig can0 down&quot;//关闭CAN0int can_init()&#123; //关闭CAN设备，设置波特率后，重新打开CAN设备 system(down); system(command); system(up); return 0;&#125;int can_send(can_frame frame)&#123; int s, nbytes; struct sockaddr_can addr; struct ifreq ifr; //创建套接字 s = socket(PF_CAN, SOCK_RAW, CAN_RAW); strcpy(ifr.ifr_name, &quot;can0&quot; ); //指定 can0 设备 ioctl(s, SIOCGIFINDEX, &amp;ifr); addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; //将套接字与 can0 绑定 bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)); //发送 frame[0] nbytes = write(s, &amp;frame, sizeof(frame)); if(nbytes != sizeof(frame)) &#123; printf(&quot;Send Error frame[0]\\n!&quot;); &#125; close(s); return 0;&#125;int can_receive(struct can_frame * r_frame,unsigned int filter_id)&#123; int s, nbytes = 0; struct sockaddr_can addr; struct ifreq ifr; struct can_frame frame; struct can_filter rfilter; // Initial fram memset(&amp;frame,0,sizeof(can_frame)); //创建套接字 s = socket(PF_CAN, SOCK_RAW, CAN_RAW); strcpy(ifr.ifr_name, &quot;can0&quot; ); //指定 can0 设备 ioctl(s, SIOCGIFINDEX, &amp;ifr); addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; //将套接字与 can0 绑定 bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)); //设置过滤规则，取消当前注释为禁用过滤规则，即不接收所有报文， // 不设置此项（即如当前代码被注释）为接收所有ID的报文。 if (filter_id != 0) &#123; rfilter.can_id = 0x123; // CAN_EFF_MASK | CAN_SFF_MASK rfilter.can_mask = CAN_SFF_MASK; setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, sizeof(rfilter)); &#125; while (nbytes == 0) &#123; //接收总线上的报文保存在frame中 nbytes = read(s, &amp;frame, sizeof(frame)); &#125; *r_frame = frame;#ifdef MSG_DEBUG printf(&quot;the nbytes:%d\\n&quot;, nbytes); printf(&quot;length:%d&quot;, sizeof(frame)); printf(&quot;ID=0x%X DLC=%d\\n&quot;, frame.can_id, frame.can_dlc); printf(&quot;data0=0x%02x\\n&quot;,frame.data[0]); printf(&quot;data1=0x%02x\\n&quot;,frame.data[1]); printf(&quot;data2=0x%02x\\n&quot;,frame.data[2]); printf(&quot;data3=0x%02x\\n&quot;,frame.data[3]); printf(&quot;data4=0x%02x\\n&quot;,frame.data[4]); printf(&quot;data5=0x%02x\\n&quot;,frame.data[5]); printf(&quot;data6=0x%02x\\n&quot;,frame.data[6]); printf(&quot;data7=0x%02x\\n&quot;,frame.data[7]);#endif return 0;&#125;int led_ctl_on(void)&#123; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); frame.can_id = 0x101; frame.can_dlc = 8; frame.data[0] = 1; can_send(frame); return 0;&#125;int led_ctl_off(void)&#123; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); frame.can_id = 0x101; frame.can_dlc = 8; frame.data[0] = 2; can_send(frame); return 0;&#125;float can_get_vol(void)&#123; float vol_vle = 0; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); // wait until can frame 100 received can_receive(&amp;frame,0); printf(&quot;###############################\\n&quot;); printf(&quot;length:%d&quot;, sizeof(frame)); printf(&quot;ID=0x%X DLC=%d\\n&quot;, frame.can_id, frame.can_dlc); printf(&quot;data0=0x%02x\\n&quot;,frame.data[0]); printf(&quot;data1=0x%02x\\n&quot;,frame.data[1]); printf(&quot;data2=0x%02x\\n&quot;,frame.data[2]); printf(&quot;data3=0x%02x\\n&quot;,frame.data[3]); printf(&quot;data4=0x%02x\\n&quot;,frame.data[4]); printf(&quot;data5=0x%02x\\n&quot;,frame.data[5]); printf(&quot;data6=0x%02x\\n&quot;,frame.data[6]); printf(&quot;data7=0x%02x\\n&quot;,frame.data[7]); vol_vle = (float)frame.data[0]/50; return vol_vle;&#125;int main(int argc, char* argv[])&#123; char control_str[15]; float vol_val = 0; if (argc &lt; 2) &#123; printf(&quot;can_control service_type\\n&quot; &quot; example: ./can_control led_off/led_on/get_vol\\n&quot; ); return 0; &#125; strcpy(control_str,argv[1]); // debug printf(&quot;Argc : %d\\n&quot;,argc); printf(&quot;Argv : %s\\n , %s\\n&quot;,argv[0], argv[1]); // can_init(); if (strcmp(control_str,&quot;led_off&quot;)==0) &#123; led_ctl_off(); &#125; else if (strcmp(control_str,&quot;led_on&quot;)==0) &#123; led_ctl_on(); &#125; else if (strcmp(control_str,&quot;get_vol&quot;)==0) &#123; vol_val = can_get_vol(); printf(&quot;Voltage is : %5.2f V\\n&quot;, vol_val); &#125; else &#123; /* Do nothing */ &#125; return 0;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"linux_shell","slug":"linux_shell","date":"2021-12-09T04:30:12.000Z","updated":"2021-12-09T09:56:42.091Z","comments":true,"path":"2021/12/09/linux_shell/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/09/linux_shell/","excerpt":"","text":"删除除某文件以外其他文件参考网址:linux删除指定文件夹中某个文件除外的其他文件 - He元素 - 博客园 (cnblogs.com) 1234shopt -s extglobrm -fr !(file1)# 如果是多个要排除的，可以这样：rm -rf !(file1|file2) 挂载参考网址ubuntu 挂载windows共享目录的方法 - Supper阿欣 - 博客园 (cnblogs.com) linux挂载文件报错mount error(13): Permission denied - 风中追风h - 博客园 (cnblogs.com) win10 家庭版 cmd运行gpedit.msc找不到文件？ - 知乎 (zhihu.com) (2条消息) ubuntu挂载Windows共享文件夹_深藏功与名-CSDN博客_ubuntu挂载windows共享目录 pi挂载Ubuntu1sudo mount 192.168.2.111:/home/pty/nfs/ /mnt pi挂载win1sudo mount -t cifs //192.168.10.1/d /mnt -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw,dir_mode=0777,file_mode=0777","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"树莓派GPIO","slug":"树莓派GPIO","date":"2021-12-06T04:30:12.000Z","updated":"2021-12-10T08:59:49.090Z","comments":true,"path":"2021/12/06/树莓派GPIO/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/06/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO/","excerpt":"","text":"参考网址:树莓派GPIO控制–C语言篇_hu7850的博客-CSDN博客_树莓派c语言控制gpio IO表示 123456789101112131415161718192021222324252627ubuntu@ubuntu:~/Cmake/build$ gpio readall +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | | | 3.3v | | | 1 || 2 | | | 5v | | | | 2 | 8 | SDA.1 | ALT0 | 1 | 3 || 4 | | | 5v | | | | 3 | 9 | SCL.1 | ALT0 | 1 | 5 || 6 | | | 0v | | | | 4 | 7 | GPIO. 7 | IN | 1 | 7 || 8 | 1 | ALT5 | TxD | 15 | 14 | | | | 0v | | | 9 || 10 | 1 | ALT5 | RxD | 16 | 15 | | 17 | 0 | GPIO. 0 | IN | 1 | 11 || 12 | 0 | IN | GPIO. 1 | 1 | 18 | | 27 | 2 | GPIO. 2 | IN | 0 | 13 || 14 | | | 0v | | | | 22 | 3 | GPIO. 3 | IN | 0 | 15 || 16 | 0 | IN | GPIO. 4 | 4 | 23 | | | | 3.3v | | | 17 || 18 | 0 | IN | GPIO. 5 | 5 | 24 | | 10 | 12 | MOSI | ALT0 | 0 | 19 || 20 | | | 0v | | | | 9 | 13 | MISO | ALT0 | 0 | 21 || 22 | 0 | IN | GPIO. 6 | 6 | 25 | | 11 | 14 | SCLK | ALT0 | 0 | 23 || 24 | 1 | OUT | CE0 | 10 | 8 | | | | 0v | | | 25 || 26 | 1 | OUT | CE1 | 11 | 7 | | 0 | 30 | SDA.0 | IN | 1 | 27 || 28 | 1 | IN | SCL.0 | 31 | 1 | | 5 | 21 | GPIO.21 | IN | 1 | 29 || 30 | | | 0v | | | | 6 | 22 | GPIO.22 | IN | 1 | 31 || 32 | 0 | IN | GPIO.26 | 26 | 12 | | 13 | 23 | GPIO.23 | IN | 0 | 33 || 34 | | | 0v | | | | 19 | 24 | GPIO.24 | IN | 1 | 35 || 36 | 0 | IN | GPIO.27 | 27 | 16 | | 26 | 25 | GPIO.25 | IN | 0 | 37 || 38 | 0 | IN | GPIO.28 | 28 | 20 | | | | 0v | | | 39 || 40 | 0 | IN | GPIO.29 | 29 | 21 | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+ wiringpi安装wiring直接安装1234git clone git://git.drogon.net/wiringPicd wiringPi./buildbuild脚本会帮助你编译和安装wiringPi 或者通过此[下载](WiringPi/WiringPi: Gordon’s Arduino wiring-like WiringPi Library for the Raspberry Pi (Unofficial Mirror for WiringPi bindings) (github.com))安装 raspbian上安装1sudo apt-get install wiringpi 测试github上有examples可以测试 cmake使用wiringpi库12345678cmake_minimum_required(VERSION 2.8)project(display)find_library(WIRINGPI_LIBRARIES NAMES wiringPi)add_executable(display display.cpp)target_link_libraries(display $&#123;WIRINGPI_LIBRARIES&#125;) PYTHON1https://code.google.com/p/raspberry-gpio-python/ BCM2835 C Library安装123456wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.35.tar.gztar xvzf bcm2835-1.35.tar.gzcd bcm2835-1.35./configure makesudo make checksudo make install 测试可以使用examples测试","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"cmake实现多文件编译","slug":"cmake实现多文件编译","date":"2021-12-03T04:30:12.000Z","updated":"2021-12-06T06:18:58.802Z","comments":true,"path":"2021/12/03/cmake实现多文件编译/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/03/cmake%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/","excerpt":"","text":"Cmake文件结构123456789101112131415161718192021root@LAPTOP-49LFJ4NT:/root/cmake# tree.├── build└── src ├── CMakeLists.txt ├── Queue │ ├── CMakeLists.txt │ └── src │ ├── QUE.cpp │ ├── QUE.h │ └── main.cpp └── canalyst_test ├── CMakeLists.txt ├── lib │ └── libcontrolcan.so └── src ├── Tongyi_Driver.cpp ├── Tongyi_Driver.h ├── controlcan.cpp ├── controlcan.h └── main.cpp shell.sh12# 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译cd .. &amp;&amp; cd build &amp;&amp; cmake ../src &amp;&amp; make -j CmakeLists.txt12345678# 指定cmake版本cmake_minimum_required(VERSION 3.0)# 工程名project(Cmake)# 添加下层cmakeadd_subdirectory(canalyst_test)add_subdirectory(Queue) 执行文件1cd build &amp;&amp; bin/./queue","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"wsl使用串口","slug":"wsl使用串口","date":"2021-12-01T04:30:12.000Z","updated":"2021-12-01T13:06:01.257Z","comments":true,"path":"2021/12/01/wsl使用串口/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/01/wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3/","excerpt":"","text":"参考网址:Win10的Linux子系统Ubuntu使用串口_晨之清风-CSDN博客 WSL | 上的 USB 到串行适配器科学计算|科学视讯 (scivision.dev) 由于本人技术原因usb转串行没成功 Linux下串口收发通信_颜言研的博客-CSDN博客_linux串口通信 minicom使用安装配置12345678# 安装minicomsudo apt-get install minicom# 设置串口,主要该串口号ttyS1,以及将硬件流改为nosudo minicom -s# 保存Save setup as df1# 运行sudo minicom 命令12345Ctrl+A E:回显Ctrl+A W：当显示的内容超过一行之后自动换行Ctrl+A C：清屏Ctrl+A O：打开配置选项Ctrl+A X：退出minicom c语言123456789101112131415161718192021222324252627// usart.h#ifndef _USART_H#define _USART_H //串口相关的头文件 #include&lt;stdio.h&gt; /*标准输入输出定义*/ #include&lt;stdlib.h&gt; /*标准函数库定义*/ #include&lt;unistd.h&gt; /*Unix 标准函数定义*/ #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; /*文件控制定义*/ #include&lt;termios.h&gt; /*PPSIX 终端控制定义*/ #include&lt;errno.h&gt; /*错误号定义*/ #include&lt;string.h&gt; //宏定义 #define FALSE -1 #define TRUE 0int UART0_Open(int fd,char*port);void UART0_Close(int fd) ; int UART0_Set(int fd,int speed,int flow_ctrl,int databits,int stopbits,int parity);int UART0_Init(int fd, int speed,int flow_ctrl,int databits,int stopbits,int parity) ;int UART0_Recv(int fd, char *rcv_buf,int data_len);int UART0_Send(int fd, char *send_buf,int data_len); #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280// usart.c#include&quot;usart.h&quot;/******************************************************************* *名称： UART0_Open *功能： 打开串口并返回串口设备文件描述 *入口参数： fd 文件描述符 port 串口号(ttyS0,ttyS1,ttyS2) *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Open(int fd,char*port)&#123; fd = open( port, O_RDWR|O_NOCTTY|O_NDELAY); if (fd&lt;0) &#123; perror(&quot;Can&#x27;t Open Serial Port&quot;); return(FALSE); &#125; //恢复串口为阻塞状态 if(fcntl(fd, F_SETFL, 0) &lt; 0) &#123; printf(&quot;fcntl failed!\\n&quot;); return(FALSE); &#125; else &#123; printf(&quot;fcntl=%d\\n&quot;,fcntl(fd, F_SETFL,0)); &#125; //测试是否为终端设备 if(0 == isatty(STDIN_FILENO)) &#123; printf(&quot;standard input is not a terminal device\\n&quot;); return(FALSE); &#125; else &#123; printf(&quot;isatty success!\\n&quot;); &#125; printf(&quot;fd-&gt;open=%d\\n&quot;,fd); return fd; &#125; /******************************************************************* *名称： UART0_Close *功能： 关闭串口并返回串口设备文件描述 *入口参数： fd 文件描述符 port 串口号(ttyS0,ttyS1,ttyS2) *出口参数：void *******************************************************************/ void UART0_Close(int fd) &#123; close(fd); &#125; /******************************************************************* *名称： UART0_Set *功能： 设置串口数据位，停止位和效验位 *入口参数： fd 串口文件描述符* speed 串口速度 * flow_ctrl 数据流控制 * databits 数据位 取值为 7 或者8 * stopbits 停止位 取值为 1 或者2 * parity 效验类型 取值为N,E,O,,S *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Set(int fd,int speed,int flow_ctrl,int databits,int stopbits,int parity) &#123; int i; int status; int speed_arr[] = &#123; B115200, B19200, B9600, B4800, B2400, B1200, B300&#125;; int name_arr[] = &#123;115200, 19200, 9600, 4800, 2400, 1200, 300&#125;; struct termios options; /* tcgetattr(fd,&amp;options)得到与fd指向对象的相关参数，并将它们保存于options,该函数还可以测试配置是否正确， 该串口是否可用等。若调用成功，函数返回值为0，若调用失败，函数返回值为1. */ if( tcgetattr( fd,&amp;options) != 0) &#123; perror(&quot;SetupSerial 1&quot;); return(FALSE); &#125; //设置串口输入波特率和输出波特率 for ( i= 0; i &lt; sizeof(speed_arr) / sizeof(int); i++) &#123; if (speed == name_arr[i]) &#123; cfsetispeed(&amp;options, speed_arr[i]); cfsetospeed(&amp;options, speed_arr[i]); &#125; &#125; //修改控制模式，保证程序不会占用串口 options.c_cflag |= CLOCAL; //修改控制模式，使得能够从串口中读取输入数据 options.c_cflag |= CREAD; //设置数据流控制 switch(flow_ctrl) &#123; case 0 ://不使用流控制 options.c_cflag &amp;= ~CRTSCTS; break; case 1 ://使用硬件流控制 options.c_cflag |= CRTSCTS; break; case 2 ://使用软件流控制 options.c_cflag |= IXON | IXOFF | IXANY; break; &#125; //设置数据位 //屏蔽其他标志位 options.c_cflag &amp;= ~CSIZE; switch (databits) &#123; case 5 : options.c_cflag |= CS5; break; case 6 : options.c_cflag |= CS6; break; case 7 : options.c_cflag |= CS7; break; case 8: options.c_cflag |= CS8; break; default: fprintf(stderr,&quot;Unsupported data size\\n&quot;); return (FALSE); &#125; //设置校验位 switch (parity) &#123; case &#x27;n&#x27;: case &#x27;N&#x27;: //无奇偶校验位。 options.c_cflag &amp;= ~PARENB; options.c_iflag &amp;= ~INPCK; break; case &#x27;o&#x27;: case &#x27;O&#x27;://设置为奇校验 options.c_cflag |= (PARODD | PARENB); options.c_iflag |= INPCK; break; case &#x27;e&#x27;: case &#x27;E&#x27;://设置为偶校验 options.c_cflag |= PARENB; options.c_cflag &amp;= ~PARODD; options.c_iflag |= INPCK; break; case &#x27;s&#x27;: case &#x27;S&#x27;: //设置为空格 options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; break; default: fprintf(stderr,&quot;Unsupported parity\\n&quot;); return (FALSE); &#125; // 设置停止位 switch (stopbits) &#123; case 1: options.c_cflag &amp;= ~CSTOPB; break; case 2: options.c_cflag |= CSTOPB; break; default: fprintf(stderr,&quot;Unsupported stop bits\\n&quot;); return (FALSE); &#125; //修改输出模式，原始数据输出 options.c_oflag &amp;= ~OPOST; options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); //options.c_lflag &amp;= ~(ISIG | ICANON); //设置等待时间和最小接收字符 options.c_cc[VTIME] = 1; /* 读取一个字符等待1*(1/10)s */ options.c_cc[VMIN] = 1; /* 读取字符的最少个数为1 */ //如果发生数据溢出，接收数据，但是不再读取 刷新收到的数据但是不读 tcflush(fd,TCIFLUSH); //激活配置 (将修改后的termios数据设置到串口中） if (tcsetattr(fd,TCSANOW,&amp;options) != 0) &#123; perror(&quot;com set error!\\n&quot;); return (FALSE); &#125; return (TRUE); &#125; /******************************************************************* *名称： UART0_Init() *功能： 串口初始化 *入口参数： fd 文件描述符 * speed 串口速度 * flow_ctrl 数据流控制 * databits 数据位 取值为 7 或者8 * stopbits 停止位 取值为 1 或者2 * parity 效验类型 取值为N,E,O,,S * *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Init(int fd, int speed,int flow_ctrl,int databits,int stopbits,int parity) &#123; int err; //设置串口数据帧格式 if (UART0_Set(fd,115200,0,8,1,&#x27;N&#x27;) == FALSE) &#123; return FALSE; &#125; else &#123; return TRUE; &#125; &#125; /******************************************************************* * 名称： UART0_Recv * 功能： 接收串口数据 * 入口参数： fd 文件描述符 * rcv_buf 接收串口中数据存入rcv_buf缓冲区中 * data_len 一帧数据的长度 * 出口参数： 正确返回为1，错误返回为0 *******************************************************************/ int UART0_Recv(int fd, char *rcv_buf,int data_len) &#123; int len,fs_sel; fd_set fs_read; struct timeval time; FD_ZERO(&amp;fs_read); FD_SET(fd,&amp;fs_read); time.tv_sec = 10; time.tv_usec = 0; //使用select实现串口的多路通信 fs_sel = select(fd+1,&amp;fs_read,NULL,NULL,&amp;time); printf(&quot;fs_sel = %d\\n&quot;,fs_sel); if(fs_sel) &#123; len = read(fd,rcv_buf,data_len); return len; &#125; else &#123; return FALSE; &#125; &#125; /******************************************************************** * 名称： UART0_Send * 功能： 发送数据 * 入口参数： fd 文件描述符 * send_buf 存放串口发送数据 * data_len 一帧数据的个数 * 出口参数： 正确返回为1，错误返回为0 *******************************************************************/ int UART0_Send(int fd, char *send_buf,int data_len) &#123; int len = 0; len = write(fd,send_buf,data_len); if (len == data_len ) &#123; printf(&quot;send data is %s\\n&quot;,send_buf); return len; &#125; else &#123; tcflush(fd,TCOFLUSH); return FALSE; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// main.c#include &quot;usart.h&quot;#include&lt;stdio.h&gt; /*标准输入输出定义*/ #include&lt;stdlib.h&gt; /*标准函数库定义*/ #include&lt;unistd.h&gt; /*Unix 标准函数定义*/ #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; /*文件控制定义*/ #include&lt;termios.h&gt; /*PPSIX 终端控制定义*/ #include&lt;errno.h&gt; /*错误号定义*/ #include&lt;string.h&gt;int main(int argc, char **argv) &#123; int fd = -1; //文件描述符，先定义一个与程序无关的值，防止fd为任意值导致程序出bug int err; //返回调用函数的状态 int len; int i; char rcv_buf[256]; char send_buf[256]; fd = UART0_Open(fd,&quot;ttyS1&quot;); //打开串口，返回文件描述符 do &#123; err = UART0_Init(fd,115200,0,8,1,&#x27;N&#x27;); printf(&quot;Set Port Exactly!\\n&quot;); sleep(1); &#125;while(FALSE == err || FALSE == fd); if(0) //开发板向pc发送数据的模式 &#123; send_buf = (char*) &quot;hello world!&quot;; while(1) &#123; len = UART0_Send(fd,send_buf,40); if(len &gt; 0) printf(&quot;send data successful\\n&quot;); sleep(1); &#125; UART0_Close(fd); &#125; else //开发板收到pc发送的数据的模式 &#123; while (1) //循环读取数据 &#123; len = UART0_Recv(fd, rcv_buf,sizeof(rcv_buf)); if(len &gt; 0) &#123; rcv_buf[len] = &#x27;\\0&#x27;; printf(&quot;receive data is %s\\n&quot;,rcv_buf); &#125; else &#123; printf(&quot;cannot receive data\\n&quot;); &#125; sleep(1); &#125; UART0_Close(fd); &#125; &#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"查看程序使用情况","slug":"查看程序使用","date":"2021-12-01T04:30:12.000Z","updated":"2021-12-01T12:37:33.447Z","comments":true,"path":"2021/12/01/查看程序使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/01/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址Linux下查看某个进程所占用的资源_mayue_web的博客-CSDN博客_查看进程占用资源 shell例程12345678910111213141516#!/bin/bash# 更改这里的./Tungray运行程序,用于查看pidps -aux | grep ./Tungray &gt; pid# 读取第一行,并解析pidpid=`awk &#x27;NR==1&#123;print $2&#125;&#x27; pid`cat /proc/$pid/status &gt; pid# 读取第一行,并解析pidstate=`awk &#x27;NR==2&#123;print $2&#125;&#x27; pid`echo &quot;state:&quot;$state`awk &#x27;NR==2&#123;print $3&#125;&#x27; pid`VmSize=`awk &#x27;NR==12&#123;print $2&#125;&#x27; pid`echo &quot;VmSize:&quot;$VmSize`awk &#x27;NR==12&#123;print $3&#125;&#x27; pid`VmRSS=`awk &#x27;NR==15&#123;print $2&#125;&#x27; pid`echo &quot;VmRSS:&quot;$VmRSS`awk &#x27;NR==15&#123;print $3&#125;&#x27; pid`Threads=`awk &#x27;NR==21&#123;print $2&#125;&#x27; pid`echo &quot;Threads:&quot;$Threads 1234567891011121314151617181920212223242526272829Name 应用程序或命令的名字 State 任务的状态，运行/睡眠/僵死/ SleepAVG 任务的平均等待时间(以nanosecond为单位)，交互式任务因为休眠次数多、时间长，它们的 sleep_avg 也会相应地更大一些，所以计算出来的优先级也会相应高一些。 Tgid 线程组号 Pid 任务ID Ppid 父进程ID TracerPid 接收跟踪该进程信息的进程的ID号 Uid Uid euid suid fsuid Gid Gid egid sgid fsgid FDSize 文件描述符的最大个数，file-&gt;fds Groups VmSize(KB) 任务虚拟地址空间的大小 (total_vm-reserved_vm)，其中total_vm为进程的地址空间的大小，reserved_vm：进程在预留或特殊的内存间的物理页 VmLck(KB) 任务已经锁住的物理内存的大小。锁住的物理内存不能交换到硬盘 (locked_vm) VmRSS(KB) 应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss) VmData(KB) 程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据； (total_vm-shared_vm-stack_vm) VmStk(KB) 任务在用户态的栈的大小 (stack_vm) VmExe(KB) 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库 (end_code-start_code) VmLib(KB) 被映像到任务的虚拟内存空间的库的大小 (exec_lib) VmPTE 该进程的所有页表的大小，单位：kb Threads 共享使用该信号描述符的任务的个数，在POSIX多线程序应用程序中，线程组中的所有线程使用同一个信号描述符。 SigQ 待处理信号的个数 SigPnd 屏蔽位，存储了该线程的待处理信号 ShdPnd 屏蔽位，存储了该线程组的待处理信号 SigBlk 存放被阻塞的信号 SigIgn 存放被忽略的信号 SigCgt 存放被俘获到的信号 CapInh Inheritable，能被当前进程执行的程序的继承的能力 CapPrm Permitted，进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的，CapEff是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性 CapEff Effective，进程的有效能力","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"easy_logger","slug":"easy_log","date":"2021-11-26T04:30:12.000Z","updated":"2021-11-28T03:38:08.768Z","comments":true,"path":"2021/11/26/easy_log/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/26/easy_log/","excerpt":"","text":"参考网址:一款超轻量级(ROM&lt;1.6K, RAM&lt;0.3k)、高性能的 C/C++ 日志库 移植到linuxpeitianyu/easy_log (github.com) 注意修改log文件保存路径,在easy_log/include/elog_file_cfg.h中 一款更加轻量化的log工具,可以自行更改函数,实现功能 peitianyu/light_log (github.com)","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"Mk60+shell_letter","slug":"shell_letter","date":"2021-11-26T04:30:12.000Z","updated":"2021-11-26T06:12:11.961Z","comments":true,"path":"2021/11/26/shell_letter/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/26/shell_letter/","excerpt":"","text":"参考网址:letter-shell | 一个功能强大的嵌入式shell_Mculover666的博客（嵌入式）-CSDN博客_letter shell 实例12345678910111213141516171819202122232425262728293031323334353637383940414243//shell_port.c/** * @brief shell移植到STM32L431时的接口实现 * @author mculover666 * @date 2020/03/27 */#include &quot;shell.h&quot;#include &quot;uart.h&quot;#include &quot;shell_port.h&quot;/* 1. 创建shell对象，开辟shell缓冲区 */Shell shell;char shell_buffer[512];/* 2. 自己实现shell写函数 *///shell写函数原型：typedef void (*shellWrite)(const char);/** * @brief 用户shell写 * * @param data 数据 * @param len 数据长度 * * @return short 实际写入的数据长度 */short userShellWrite(char *data, unsigned short len)&#123; for(int i = 0;i&lt;len;i++) &#123; UART_WriteByte(HW_UART0, data[i]); &#125; return len;&#125;/* 3. 编写初始化函数 */void User_Shell_Init(void)&#123; //注册自己实现的写函数 shell.write = userShellWrite; //调用shell初始化函数 shellInit(&amp;shell, shell_buffer, 512);&#125; 12345678910111213// shell_port.h#ifndef _SHELL_PORT_H_#define _SHELL_PORT_H_#include &quot;shell.h&quot;/* 将shell定义为外部变量，在串口中断回调函数中还要使用 */extern Shell shell;/* 声明自己编写的初始化函数 */void User_Shell_Init(void);#endif /* _SHELL_PORT_H_ */ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;gpio.h&quot;#include &quot;common.h&quot;#include &quot;uart.h&quot;#include &quot;cpuidy.h&quot;#include &quot;shell_port.h&quot;uint16_t recv_buf = 0;/* USER CODE BEGIN 0 */int test(int i, char ch, char *str)&#123; printf(&quot;input int: %d, char: %c, string: %s\\r\\n&quot;, i, ch, str); return 0;&#125;static void UART_RX_ISR(uint16_t byteReceived)&#123; //调用shell处理数据的接口 recv_buf = byteReceived; shellHandler(&amp;shell, recv_buf);&#125;int main(void)&#123; DelayInit(); uint32_t instance = GPIO_QuickInit(HW_GPIOE, 0, kGPIO_Mode_OPP); UART_QuickInit(UART0_RX_PA01_TX_PA02, 115200); /* 配置UART 中断配置 打开接收中断 安装中断回调函数 */ UART_CallbackRxInstall(HW_UART0, UART_RX_ISR); /* 打开串口接收中断功能 IT 就是中断的意思*/ UART_ITDMAConfig(HW_UART0, kUART_IT_Rx, true); User_Shell_Init(); while(1) &#123; /* 闪烁小灯 */ GPIO_ToggleBit(HW_GPIOE, 0); DelayMs(500); &#125;&#125;//导出到命令列表里SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), test, test, test);","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"amcl原理分析","slug":"amcl原理分析","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T09:33:29.720Z","comments":true,"path":"2021/11/25/amcl原理分析/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/amcl%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"参考网址:slam 学习之 AMCL 概念与原理分析_学之知之的博客-CSDN博客_amcl定位原理 机器人定位技术：AMCL的参数你真的会调了吗？(一） - 知乎 (zhihu.com) 改写amcl ROS导航包源码学习2 — 定位 - 知乎 (zhihu.com) 概念算法 运动模型(里程计模型) 测量模型(波束模型与似然域模型) 采样算法(KLD采样) 蒙特卡洛算法 自适应蒙特卡洛算法 运动模型关于速度模型与里程计模型 ,主要采取采样模型 概率机器人 这里主要使用里程计模型 测量模型波束模型主要调整六个参数: ， ， ， ， （ 的方差）和λ（动态障碍物的影响力度) 似然域模型主要调整两个参数 。 KLD采样目的:将估计的概率分布转化为真实的概率分布。 蒙特卡洛算法","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"amcl简单使用","slug":"amcl简单使用","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T08:55:51.979Z","comments":true,"path":"2021/11/25/amcl简单使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/amcl%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:AMCL介绍及参数说明_走过_冬天的博客-CSDN博客_amcl参数配置 深入AMCL(三):AMCL手动初始化后如何自动定位_yuanguobin01的博客-CSDN博客 配置amcl_demo.launch 1234567891011121314151617181920212223242526&lt;launch&gt; &lt;!-- r2000驱动 --&gt; &lt;include file=&quot;$(find pepperl_fuchs_r2000)/launch/gui_example.launch&quot;/&gt; &lt;!-- Map server --&gt; &lt;!-- 发布map.yaml,其中包含了pgm文件位置--&gt; &lt;arg name=&quot;map_file&quot; default=&quot;$(find run)/map/mymap.yaml&quot;/&gt; &lt;node name=&quot;map_server&quot; pkg=&quot;map_server&quot; type=&quot;map_server&quot; args=&quot;$(arg map_file)&quot; /&gt; &lt;!-- Localization --&gt; &lt;include file=&quot;$(find run)/launch/amcl.launch&quot;/&gt; &lt;!-- 获取odom数据 --&gt; &lt;!-- 由于采用的是里程计模型,注意里程计的位置输出尤为关键 --&gt; &lt;!-- &lt;node name=&quot;tcp_server&quot; pkg=&quot;tcp_server&quot; type=&quot;tcp_server&quot; /&gt; --&gt; &lt;!-- 注意坐标转换:map-&gt;odom-&gt;base_link-&gt;laser_link --&gt; &lt;!-- 如果转换多了,会报错,多转换可能会报laserscan超时,少了,rviz会报没有上级坐标系 --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;map_to_odom_broadcaster&quot; args=&quot;0 0 0 0 0 0 /map /odom 100&quot;/&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0 0 0 0 /base_link /laser_link 100&quot;/&gt; &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find run)/rviz/hector_map.rviz&quot;/&gt;&lt;/launch&gt; amcl.launch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;launch&gt; &lt;arg name=&quot;use_map_topic&quot; default=&quot;false&quot;/&gt; &lt;arg name=&quot;scan_topic&quot; default=&quot;scan&quot;/&gt; &lt;arg name=&quot;initial_pose_x&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;initial_pose_y&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;initial_pose_a&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;odom_frame_id&quot; default=&quot;odom&quot;/&gt; &lt;arg name=&quot;base_frame_id&quot; default=&quot;base_link&quot;/&gt; &lt;arg name=&quot;global_frame_id&quot; default=&quot;map&quot;/&gt; &lt;node pkg=&quot;amcl&quot; type=&quot;amcl&quot; name=&quot;amcl&quot;&gt; &lt;param name=&quot;use_map_topic&quot; value=&quot;$(arg use_map_topic)&quot;/&gt; &lt;!-- Publish scans from best pose at a max of 10 Hz --&gt; &lt;!-- 差分模型 --&gt; &lt;param name=&quot;odom_model_type&quot; value=&quot;diff&quot;/&gt; &lt;!-- 速度模型参数 --&gt; &lt;param name=&quot;odom_alpha5&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;gui_publish_rate&quot; value=&quot;10.0&quot;/&gt; &lt;param name=&quot;laser_max_beams&quot; value=&quot;810&quot;/&gt; &lt;param name=&quot;laser_max_range&quot; value=&quot;-1&quot;/&gt; &lt;param name=&quot;min_particles&quot; value=&quot;500&quot;/&gt; &lt;param name=&quot;max_particles&quot; value=&quot;5000&quot;/&gt; &lt;param name=&quot;kld_err&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;kld_z&quot; value=&quot;0.99&quot;/&gt; &lt;!-- 里程计模型调节超参 --&gt; &lt;param name=&quot;odom_alpha1&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha2&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha3&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha4&quot; value=&quot;0.2&quot;/&gt; &lt;!-- 一般情况而言,高斯误差会比较大,可以设置大一些 --&gt; &lt;param name=&quot;laser_z_hit&quot; value=&quot;0.95&quot;/&gt; &lt;param name=&quot;laser_z_short&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_max&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_rand&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_sigma_hit&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_lambda_short&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;laser_model_type&quot; value=&quot;likelihood_field&quot;/&gt; &lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt; &lt;param name=&quot;laser_likelihood_max_dist&quot; value=&quot;2.0&quot;/&gt; &lt;param name=&quot;update_min_d&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;update_min_a&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_frame_id&quot; value=&quot;$(arg odom_frame_id)&quot;/&gt; &lt;param name=&quot;base_frame_id&quot; value=&quot;$(arg base_frame_id)&quot;/&gt; &lt;param name=&quot;global_frame_id&quot; value=&quot;$(arg global_frame_id)&quot;/&gt; &lt;param name=&quot;resample_interval&quot; value=&quot;1&quot;/&gt; &lt;!-- Increase tolerance because the computer can get quite busy --&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;1.0&quot;/&gt; &lt;!-- 快慢指针,一般slow会小一些,良好的值可能为0.001,fast可能为0.01 --&gt; &lt;param name=&quot;recovery_alpha_slow&quot; value=&quot;0.0&quot;/&gt; &lt;param name=&quot;recovery_alpha_fast&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 初始位姿 --&gt; &lt;param name=&quot;initial_pose_x&quot; value=&quot;$(arg initial_pose_x)&quot;/&gt; &lt;param name=&quot;initial_pose_y&quot; value=&quot;$(arg initial_pose_y)&quot;/&gt; &lt;param name=&quot;initial_pose_a&quot; value=&quot;$(arg initial_pose_a)&quot;/&gt; &lt;remap from=&quot;scan&quot; to=&quot;$(arg scan_topic)&quot;/&gt; &lt;/node&gt;&lt;/launch&gt;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"boost_thread","slug":"boost_thread","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T08:34:45.643Z","comments":true,"path":"2021/11/25/boost_thread/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/boost_thread/","excerpt":"","text":"参考网址:了解boost C++ Boost库分类总结（个人收藏） - 知乎 (zhihu.com) boost教程 Highscore - Boost C++ 库 - 多线程 boost多线程同步简单使用12345678910111213141516171819202122232425262728#include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) &#123; boost::this_thread::sleep(boost::posix_time::seconds(seconds)); &#125; boost::mutex mutex; void thread() &#123; for (int i = 0; i &lt; 5; ++i) &#123; wait(1); mutex.lock(); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; mutex.unlock(); &#125; &#125; int main() &#123; boost::thread t1(thread); boost::thread t2(thread); t1.join(); t2.join(); &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"boost安装与测试","slug":"boost安装与测试","date":"2021-11-25T04:30:12.000Z","updated":"2021-12-27T02:25:20.164Z","comments":true,"path":"2021/11/25/boost安装与测试/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/boost%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/","excerpt":"","text":"参考网址:Ubuntu下安装boost库_上善若水-CSDN博客 在Ubuntu上安装boost库_一点一滴-CSDN博客 Ubuntu20.04安装boost库_vanyongqi-CSDN博客_ubuntu 安装boost 安装apt安装1sudo apt-get install libboost-dev build安装 下载boost库:Boost C++ Libraries 解压: tar -xzvf boost_1_xx_xx.tar.gz 进入解压目录,执行脚本,sudo ./bootstrap.sh 安装, sudo ./b2 install 测试环境变量 123456sudo gedit /etc/profile #在文件末尾添加export CPLUS_INCLUDE_PATH=/usr/local/include/boost:$CPLUS_INCLUDE_PATHexport LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATHexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 测试1sudo nano test.cpp 12345678910#include&lt;iostream&gt;#include&lt;boost/bind.hpp&gt;using namespace std;using namespace boost;int fun(int x,int y)&#123;return x+y;&#125;int main()&#123; int m=1;int n=2; cout&lt;&lt;boost::bind(fun,_1,_2)(m,n)&lt;&lt;endl; return 0;&#125; 1g++ test.cpp -o test cmake使用boost库1234567// CMakeLists.txtcmake_minimum_required(VERSION 2.8.3)project(boost_test)find_package(Boost REQUIRED COMPONENTS system thread)include_directories($&#123;Boost_INCLUDE_DIRS&#125;)add_executable(boost_test boost_test.cpp)target_link_libraries(boost_test $&#123;Boost_LIBRARIES&#125;) 1234567891011// boost_test.cpp#include&lt;iostream&gt;#include&lt;boost/bind.hpp&gt;using namespace std;using namespace boost;int fun(int x,int y)&#123;return x+y;&#125;int main()&#123; int m=1;int n=2; cout&lt;&lt;boost::bind(fun,_1,_2)(m,n)&lt;&lt;endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"strcpy重写","slug":"strcpy重写","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T05:41:55.590Z","comments":true,"path":"2021/11/25/strcpy重写/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/strcpy%E9%87%8D%E5%86%99/","excerpt":"","text":"参考网址:什么？面试官让我写strcpy()函数_m0_57304511的博客-CSDN博客 strpy1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;assert.h&gt;char * my_strcpy(char* dest, const char* src)//const可以防止源字符串被改变&#123; // 使用断言避免传入空指针 assert( dest &amp;&amp; src ); char* ret = dest; // 按地址复制,直到为空 while(*dest++ = *src++) &#123; ; &#125; return ret;&#125;int main()&#123; char arr1[20] = &#123; 0 &#125;; char arr2[] = &quot;hello&quot;; printf(&quot;%s\\n&quot;, my_strcpy(arr1, arr2)); return 0;&#125; mempy12345678910void * memcpy(void *dest, const void *src, unsigned int count); &#123; if ((src == NULL) || (dest == NULL)) return; while (count--) *dest++ = *src++; return dest; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"cjson精度丢失","slug":"cjson精度丢失","date":"2021-11-24T04:30:12.000Z","updated":"2021-11-24T05:45:10.708Z","comments":true,"path":"2021/11/24/cjson精度丢失/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/24/cjson%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/","excerpt":"","text":"参考网址:(80条消息) cJSON精度丢失问题_weixin_33858485的博客-CSDN博客 在cJSON.c中的print_number函数中的sprintf((char*)number_buffer, &quot;%1.17g&quot;, d);更改为 sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* Render the number nicely from the given item into a string. */static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)&#123; unsigned char *output_pointer = NULL; double d = item-&gt;valuedouble; int length = 0; size_t i = 0; unsigned char number_buffer[26] = &#123;0&#125;; /* temporary buffer to print the number into */ unsigned char decimal_point = get_decimal_point(); double test = 0.0; if (output_buffer == NULL) &#123; return false; &#125; /* This checks for NaN and Infinity */ if (isnan(d) || isinf(d)) &#123; length = sprintf((char*)number_buffer, &quot;null&quot;); &#125; else &#123; /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */ // 更改这里的1.4,这里指的是保留4位小数 length = sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); /* Check whether the original double can be recovered */ if ((sscanf((char*)number_buffer, &quot;%lg&quot;, &amp;test) != 1) || !compare_double((double)test, d)) &#123; /* If not, print with 17 decimal places of precision */ // 更改这里的1.4,这里指的是保留4位小数 length = sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); &#125; &#125; /* sprintf failed or buffer overrun occurred */ if ((length &lt; 0) || (length &gt; (int)(sizeof(number_buffer) - 1))) &#123; return false; &#125; /* reserve appropriate space in the output */ output_pointer = ensure(output_buffer, (size_t)length + sizeof(&quot;&quot;)); if (output_pointer == NULL) &#123; return false; &#125; /* copy the printed number to the output and replace locale * dependent decimal point with &#x27;.&#x27; */ for (i = 0; i &lt; ((size_t)length); i++) &#123; if (number_buffer[i] == decimal_point) &#123; output_pointer[i] = &#x27;.&#x27;; continue; &#125; output_pointer[i] = number_buffer[i]; &#125; output_pointer[i] = &#x27;\\0&#x27;; output_buffer-&gt;offset += (size_t)length; return true;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"FTP服务","slug":"FTP","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T13:34:07.537Z","comments":true,"path":"2021/11/23/FTP/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/FTP/","excerpt":"","text":"参考网址:在虚拟机的Ubuntu上部署FTP服务器_ncut_wxj的博客-CSDN博客 安装1sudo apt-get install vsftpd 配置1sudo nano /etc/vsftpd.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# Example config file /etc/vsftpd.conf## The default compiled in settings are fairly paranoid. This sample file# loosens things up a bit, to make the ftp daemon more usable.# Please see vsftpd.conf.5 for all compiled in defaults.## READ THIS: This example file is NOT an exhaustive list of vsftpd options.#Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd&#x27;s# capabilities.### Run standalone? vsftpd can run either from an inetd or as a standalone# daemon started from an initscript.listen=NO## This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.listen_ipv6=YES## Allow anonymous FTP? (Disabled by default).#这个是设置是否允许匿名登录ftp服务器，不允许。anonymous_enable=NO## Uncomment this to allow local users to log in.#是否允许本机用户登录local_enable=YES## Uncomment this to enable any form of FTP write command.#允许上传文件到ftp服务器write_enable=YES## Default umask for local users is 077. You may wish to change this to 022,# if your users expect that (022 is used by most other ftpd&#x27;s)#local_umask=022## Uncomment this to allow the anonymous FTP user to upload files. This only# has an effect if the above global write enable is activated. Also, you will# obviously need to create a directory writable by the FTP user.#anon_upload_enable=YES## Uncomment this if you want the anonymous FTP user to be able to create# new directories.#anon_mkdir_write_enable=YES## Activate directory messages - messages given to remote users when they# go into a certain directory.dirmessage_enable=YES## If enabled, vsftpd will display directory listings with the time# in your local time zone. The default is to display GMT. The# times returned by the MDTM FTP command are also affected by this# option.use_localtime=YES## Activate logging of uploads/downloads.xferlog_enable=YES## Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES## If you want, you can arrange for uploaded anonymous files to be owned by# a different user. Note! Using &quot;root&quot; for uploaded files is not# recommended!#chown_uploads=YES#chown_username=whoever## You may override where the log file goes if you like. The default is shown# below.#xferlog_file=/var/log/vsftpd.log## If you want, you can have your log file in standard ftpd xferlog format.# Note that the default log file location is /var/log/xferlog in this case.#xferlog_std_format=YES## You may change the default value for timing out an idle session.#idle_session_timeout=600## You may change the default value for timing out a data connection.#data_connection_timeout=120## It is recommended that you define on your system a unique user which the# ftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure## Enable this and the server will recognise asynchronous ABOR requests. Not# recommended for security (the code is non-trivial). Not enabling it,# however, may confuse older FTP clients.#async_abor_enable=YES## By default the server will pretend to allow ASCII mode but in fact ignore# the request. Turn on the below options to have the server actually do ASCII# mangling on files when in ASCII mode.# Beware that on some FTP servers, ASCII support allows a denial of service# attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd# predicted this attack and has always been safe, reporting the size of the# raw file.# ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES## You may fully customise the login banner string:#ftpd_banner=Welcome to blah FTP service.## You may specify a file of disallowed anonymous e-mail addresses. Apparently# useful for combatting certain DoS attacks.#deny_email_enable=YES# (default follows)#banned_email_file=/etc/vsftpd.banned_emails## You may restrict local users to their home directories. See the FAQ for# the possible risks in this before using chroot_local_user or# chroot_list_enable below.#chroot_local_user=YES## You may specify an explicit list of local users to chroot() to their home# directory. If chroot_local_user is YES, then this list becomes a list of# users to NOT chroot().# (Warning! chroot&#x27;ing can be very dangerous. If using chroot, make sure that# the user does not have write access to the top level directory within the# chroot)chroot_local_user=YESchroot_list_enable=YES# (default follows) 允许chroot_list文件中配置的用户登录此ftp服务器。chroot_list_file=/etc/vsftpd.chroot_list# You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by# default to avoid remote users being able to cause excessive I/O on large# sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume# the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.#ls_recurse_enable=YES## Customization## Some of vsftpd&#x27;s settings don&#x27;t fit the filesystem layout by# default.## This option should be the name of a directory which is empty. Also, the# directory should not be writable by the ftp user. This directory is used# as a secure chroot() jail at times vsftpd does not require filesystem# access.secure_chroot_dir=/var/run/vsftpd/empty## This string is the name of the PAM service vsftpd will use.pam_service_name=vsftpd## This option specifies the location of the RSA certificate to use for SSL# encrypted connections.rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyallow_writeable_chroot=YESssl_enable=NO## Uncomment this to indicate that vsftpd use a utf8 filesystem.#utf8_filesystem=YES#配置ftp服务器的上传下载文件所在的目录。#这个地址中的 “/home/python” 是这个Ubuntu系统的用户主目录#它的用户名叫 “python”，文件夹 “ftpfile” 是后来创建的local_root=/home/python/ftpfile 给ftp服务器配置使用用户等信息1sudo nano /etc/vsftpd.chroot_list 12rootftp_user 使用文件夹内输入1ftp:/192.168.xx.xx","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"linux_gpio","slug":"linux_gpio","date":"2021-11-23T04:30:12.000Z","updated":"2021-12-09T12:35:13.862Z","comments":true,"path":"2021/11/23/linux_gpio/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/linux_gpio/","excerpt":"","text":"参考网址:Linux操作GPIO（文件IO方式）_Leon-CSDN博客 在Linux 中的应用层操作gpio的方法_仗劍走天涯-CSDN博客 位置控制GPIO的目录位于/sys/class/gpio 例子1234567891011121. 导出/sys/class/gpio# echo 44 &gt; export2. 设置方向/sys/class/gpio/gpio44# echo out &gt; direction3. 查看方向/sys/class/gpio/gpio44# cat direction4. 设置输出/sys/class/gpio/gpio44# echo 1 &gt; value5. 查看输出值/sys/class/gpio/gpio44# cat value6. 取消导出/sys/class/gpio# echo 44 &gt; unexport 以echo的形式调用system函数进行操作，这种形式编程比较简单，结构比较清晰，如下 123456void set_gpio64_low(void) &#123; system(&quot;echo 64 &gt; /sys/class/gpio/export&quot;); system(&quot;echo out &gt; /sys/class/gpio/gpio64/direction&quot;); system(&quot;echo 0 &gt; /sys/class/gpio/gpio64/value&quot;); &#125; 通过文件的形式来调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; //define O_WRONLY and O_RDONLY void initGpio(int n)&#123; FILE * fp =fopen(&quot;/sys/class/gpio/export&quot;,&quot;w&quot;); if (fp == NULL) perror(&quot;export open filed&quot;); else fprintf(fp,&quot;%d&quot;,n); fclose(fp);&#125; //create gpio file void setGpioDirection(int n,char *direction)&#123; char path[100] = &#123;0&#125;; sprintf(path,&quot;/sys/class/gpio/gpio%d/direction&quot;,n); FILE * fp =fopen(path,&quot;w&quot;); if (fp == NULL) perror(&quot;direction open filed&quot;); else fprintf(fp,&quot;%s&quot;,direction); fclose(fp);&#125; //set gpio &quot;in&quot; or &quot;out&quot; int getGpioValue(int n)&#123; char path[64]; char value_str[3]; int fd; snprintf(path, sizeof(path), &quot;/sys/class/gpio/gpio%d/value&quot;, n); fd = open(path, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;Failed to open gpio value for reading!&quot;); return -1; &#125; if (read(fd, value_str, 3) &lt; 0) &#123; perror(&quot;Failed to read value!&quot;); return -1; &#125; close(fd); return (atoi(value_str));&#125; //get gpio(n)&#x27;s valuevoid setGpioValue(int n,int value)&#123; char path[64]; char value_str[3]; int fd; snprintf(path, sizeof(path), &quot;/sys/class/gpio/gpio%d/value&quot;, n); fd = open(path, O_WRONLY); if (fd &lt; 0) &#123; perror(&quot;Failed to open gpio value for writing!&quot;); return; &#125; if (value) strcpy(value_str,&quot;1&quot;); else strcpy(value_str,&quot;0&quot;); if (write(fd, value_str, 1) != 1) &#123; perror(&quot;Failed to write value!&quot;); return; &#125; close(fd);&#125; //set gpio(n)&#x27;s value int main() &#123; initGpio(18); setGpioDirection(18,(char*)&quot;out&quot;); while(1) &#123; setGpioValue(18,0); printf(&quot;%d\\n&quot;,getGpioValue(18));//每隔1s输出一次gpio18的值 sleep(1); setGpioValue(18,1); printf(&quot;%d\\n&quot;,getGpioValue(18));//每隔1s输出一次gpio18的值 sleep(1); &#125; return 0; &#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"shm","slug":"shm","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T14:17:34.247Z","comments":true,"path":"2021/11/23/shm/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/shm/","excerpt":"","text":"参考网址:进程间通信——共享内存（Shared Memory）_ypt-CSDN博客_共享内存 例程12345678910111213141516//comm.h#ifndef _COMM_H__#define _COMM_H__ #include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt; #define PATHNAME &quot;.&quot;#define PROJ_ID 0x6666 int CreateShm(int size);int DestroyShm(int shmid);int GetShm(int size);#endif 123456789101112131415161718192021222324252627282930313233343536//comm.c#include&quot;comm.h&quot; static int CommShm(int size,int flags)&#123; key_t key = ftok(PATHNAME,PROJ_ID); if(key &lt; 0) &#123; perror(&quot;ftok&quot;); return -1; &#125; int shmid = 0; if((shmid = shmget(key,size,flags)) &lt; 0) &#123; perror(&quot;shmget&quot;); return -2; &#125; return shmid;&#125;int DestroyShm(int shmid)&#123; if(shmctl(shmid,IPC_RMID,NULL) &lt; 0) &#123; perror(&quot;shmctl&quot;); return -1; &#125; return 0;&#125;int CreateShm(int size)&#123; return CommShm(size,IPC_CREAT | IPC_EXCL | 0666);&#125;int GetShm(int size)&#123; return CommShm(size,IPC_CREAT);&#125; 123456789101112131415161718192021222324//client.c#include&quot;comm.h&quot; int main()&#123; // 获得共享内存的id int shmid = GetShm(4096); sleep(1); // 将共享内存映射到本进程的地址空间 char *addr = shmat(shmid,NULL,0); sleep(2); int i = 0; while(i &lt; 26) &#123; addr[i] = &#x27;A&#x27; + i; i++; addr[i] = 0; sleep(1); &#125; // 将共享内存从本进程的地址空间中卸载 shmdt(addr); sleep(2); return 0;&#125; 1234567891011121314151617181920212223//server.c#include&quot;comm.h&quot; int main()&#123; // 创建并获得共享内存的id int shmid = CreateShm(4096); // 将共享内存映射到本进程的地址空间 char *addr = shmat(shmid,NULL,0); sleep(2); int i = 0; while(i++ &lt; 26) &#123; printf(&quot;client# %s\\n&quot;,addr); sleep(1); &#125; // 将共享内存从本进程的地址空间中卸载 shmdt(addr); sleep(2); // 删除共享内存 DestroyShm(shmid); return 0;&#125; 123456789101112//Makefile.PHONY:allall:server client client:client.c comm.c gcc -o $@ $^server:server.c comm.c gcc -o $@ $^ .PHONY:cleanclean: rm -f client server","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"ubuntu14","slug":"ubuntu14","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T12:30:28.295Z","comments":true,"path":"2021/11/23/ubuntu14/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/ubuntu14/","excerpt":"","text":"安装ssh12345678910111213141516171819202122# 安装服务sudo apt-get install openssh-server# 查看ssh服务是否启动sudo ps -e |grep ssh# 启动ssh服务sudo service ssh start# 配置服务sudo gedit /etc/ssh/sshd_config#找到下面相关配置：# Authentication:LoginGraceTime 120PermitRootLogin prohibit-passwordStrictModes yes#更改为：# Authentication:LoginGraceTime 120#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes# 重启sshsudo service ssh restart 换源12cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo nano /etc/apt/sources.list 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse # 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse 12sudo apt updatesudo apt upgrade 右键没有terminal12sudo apt-get install nautilus-open-terminal sudo reboot","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"状态机","slug":"状态机","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T14:54:12.528Z","comments":true,"path":"2021/11/23/状态机/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/%E7%8A%B6%E6%80%81%E6%9C%BA/","excerpt":"","text":"参考网址:什么是状态机？用C语言实现进程5状态模型_一口Linux的专栏-CSDN博客 例程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// stateMachine.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;typedef enum &#123; sta_origin=0, sta_running, sta_owencpu, sta_sleep_int, sta_sleep_unint&#125;State;static const char *statename[]=&#123; &quot;origin&quot;, &quot;running&quot;, &quot;owencpu&quot;, &quot;sleep_int&quot;, &quot;sleep_unint&quot;, &#125;;typedef enum&#123; evt_fork=0, evt_sched, evt_wait, evt_wait_unint, evt_wake_up, evt_wake, &#125;EventID;typedef void (*CallBack)(void *) ;typedef struct &#123; State curState;//当前状态 EventID eventId;//事件ID State nextState;//下个状态 CallBack action;//回调函数&#125;StateTransform ; State globalState = sta_origin;pthread_t pid;void action_callback(void *arg)&#123; StateTransform *statTran = (StateTransform *)arg; if(statename[statTran-&gt;curState] == statename[statTran-&gt;nextState]) &#123; printf(&quot;invalid event,state not change\\n&quot;); &#125;else&#123; printf(&quot;call back state from %s --&gt; %s\\n&quot;, statename[statTran-&gt;curState], statename[statTran-&gt;nextState]); &#125;&#125; /*origin*/StateTransform stateTran_0[]=&#123; &#123;sta_origin,evt_fork, sta_running,action_callback&#125;, &#123;sta_origin,evt_sched, sta_origin,NULL&#125;, &#123;sta_origin,evt_wait, sta_origin,NULL&#125;, &#123;sta_origin,evt_wait_unint,sta_origin,NULL&#125;, &#123;sta_origin,evt_wake_up, sta_origin,NULL&#125;, &#123;sta_origin,evt_wake, sta_origin,NULL&#125;,&#125;; /*running*/StateTransform stateTran_1[]=&#123; &#123;sta_running,evt_fork, sta_running,NULL&#125;, &#123;sta_running,evt_sched, sta_owencpu,action_callback&#125;, &#123;sta_running,evt_wait, sta_running,NULL&#125;, &#123;sta_running,evt_wait_unint,sta_running,NULL&#125;, &#123;sta_running,evt_wake_up, sta_running,NULL&#125;, &#123;sta_running,evt_wake, sta_running,NULL&#125;,&#125;; /*owencpu*/StateTransform stateTran_2[]=&#123; &#123;sta_owencpu,evt_fork, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_sched, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_wait, sta_sleep_int,action_callback&#125;, &#123;sta_owencpu,evt_wait_unint,sta_sleep_unint,action_callback&#125;, &#123;sta_owencpu,evt_wake_up, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_wake, sta_owencpu,NULL&#125;,&#125;; /*sleep_int*/StateTransform stateTran_3[]=&#123; &#123;sta_sleep_int,evt_fork, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_sched, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wait, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wait_unint,sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wake_up, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wake, sta_running,action_callback&#125;,&#125;; /*sleep_unint*/StateTransform stateTran_4[]=&#123; &#123;sta_sleep_unint,evt_fork, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_sched, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wait, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wait_unint,sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wake_up, sta_running,action_callback&#125;, &#123;sta_sleep_unint,evt_wake, sta_sleep_unint,NULL&#125;,&#125;; void init_machine(void)&#123; globalState = sta_origin;&#125;/*显示当前状态*/void *show_stat(void *arg)&#123; int len; char buf[64]=&#123;0&#125;; while(1) &#123; sleep(1); printf(&quot;cur stat:%s\\n&quot;,statename[globalState]); &#125; &#125;#define STATETRANS(n) (stateTran_##n)/*change state &amp; call callback()*/void do_action(StateTransform *statTran)&#123; if(NULL == statTran) &#123; perror(&quot;statTran is NULL\\n&quot;); return; &#125; globalState = statTran-&gt;nextState; if(statTran-&gt;action != NULL) &#123; statTran-&gt;action((void*)statTran); &#125;else&#123; printf(&quot;invalid event,state not change\\n&quot;); &#125;&#125;void event_happen(unsigned int event)&#123; switch(globalState) &#123; case sta_origin: do_action(&amp;STATETRANS(0)[event]); break; case sta_running: do_action(&amp;STATETRANS(1)[event]); break; case sta_owencpu: do_action(&amp;STATETRANS(2)[event]); break; case sta_sleep_int: do_action(&amp;STATETRANS(3)[event]); break; case sta_sleep_unint: do_action(&amp;STATETRANS(4)[event]); break; default: printf(&quot;state is invalid\\n&quot;); break; &#125; &#125;void main(void)&#123; init_machine(); pthread_create(&amp;pid, NULL,show_stat, NULL); sleep(5); event_happen(evt_fork); sleep(5); event_happen(evt_sched); sleep(5); event_happen(evt_sched); sleep(5); event_happen(evt_wait); sleep(5); event_happen(evt_wake); &#125; 1gcc -o main stateMachine.c -pthread -g","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"ros教程","slug":"ros教程","date":"2021-11-13T04:30:12.000Z","updated":"2021-11-13T03:15:23.044Z","comments":true,"path":"2021/11/13/ros教程/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/13/ros%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考网址:古月居21讲 博客 - 古月居 (guyuehome.com) 创客智造 ROS入门教程-目录 - 创客智造 (ncnynl.com) (70条消息) ros机器人_wuzhishiwo的博客-CSDN博客 ROS资源整理-学习ROS用得到的一些资料（持续更新）_Jiali Zhang的博客-CSDN博客 国外教程(需要科学上网),可在线模拟,有开源代码 Learn Robotics from Zero - Robotics &amp; ROS Online Courses (theconstructsim.com) 很现成的模拟舒爽 智能机器人系统_国防科技大学_中国大学MOOC(慕课) (icourse163.org) 外文教程 Webots: tutorial- (cyberbotics.com) 环境通过WSL+melodic+vscode+xlaunch实现ros环境模拟 wsl安装:wsl安装与使用 | 某飞行员的随笔 (peitianyu.github.io) melodic安装:ros安装 | 某飞行员的随笔 (peitianyu.github.io) vscode安装:vscode | 某飞行员的随笔 (peitianyu.github.io) vscode配置ros:安装C/C++，CMake，CMake Tools，Code Runner，ROS，Chinese 这些插件 使用VScode搭建ROS开发环境_白鸟无言的博客-CSDN博客 xlaunch安装:(https://windows.podnova.com/software/3151375.htm) 下载好之后,配置~/.bashrc 12345sudo nano ~/.bashrc# 进入编辑文件,在最后添加上export DISPLAY=localhost:0# CTRL+S + CTRL+X保存退出source ~/.bashrc 学习路径古月居二十一讲这一步需要每一个实验都过一遍,编译一遍,不必要太过详尽,重在了解ros流程,之后回来重新复习 古月居二十一讲视频 古月居二十一讲笔记 古月居二十一讲讲义与代码 密码:4n76 ROS探索总结 - 古月居 ROS-Academy-for-Beginners 中国大学MOOC《机器人操作系统入门》讲义 中国大学MOOC《机器人操作系统入门》课程代码示例 注意下载自己需要的版本,别下错了,然后有显示的问题,可以试试 rosdep install --from-paths src --ignore-src --rosdistro=melodic -y navigation ros navigation stack源码学习 - 知乎 (zhihu.com) ROS Navigation stack源码 激光slam根据以下的几种尝试看源码 对比几种在ROS中常用的几种SLAM算法 激光SLAM学习 移动机器人_少磊的博客 路径参考记得收藏丨ROS开发工程师学习指南 (qq.com) 几款适合copy的源码ros_tutorials ros_tutorials: ROS Tutorials for beginner ros_basic_tutorials ROS进阶攻略系列视频课程 Tutorials about using the ROS Navigation stack Agvs robot simulation packages for ROS","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"vscode","slug":"vscode","date":"2021-11-13T04:30:12.000Z","updated":"2021-11-13T01:22:17.748Z","comments":true,"path":"2021/11/13/vscode/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/13/vscode/","excerpt":"","text":"参考网址:VsCode安装和配置c/c++环境（超完整，小白专用）_黄化的多多-CSDN博客_vscode配置c++环境 vscode 与 WSL 进行linux开发_从零开始-CSDN博客_vscode wsl 在WSL中安装并配置VSCode_reeeeein的博客-CSDN博客_wsl安装vscode WIN10安装WSL并使用VScode连接WSL_作业君的博客-CSDN博客_vscode wsl 简介vscode配置wsl 流程下载安装vscode:Download Visual Studio Code - Mac, Linux, Windows 安装win版,一直下一步,注意改一下安装位置 连接wslctrl + shift + x打开应用商店,输入Remote - WSL安装由于事先安装好wsl了 打开左侧小电脑图标,点击进入即可进入wsl终端,可以通过点击左下角⚪,▲进入终端命令行","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"USBCAN/CANalyst-II","slug":"USBCAN","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-13T01:04:27.331Z","comments":true,"path":"2021/11/11/USBCAN/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/USBCAN/","excerpt":"","text":"参考网址:(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动 Ubuntu16.04 （ROS）下通过CAN分析仪（USBCAN/CANalyst-II）调试无人车助力转向电机（1）_秋名山的过客-CSDN博客 USBCAN在Linux系统下使用说明 (gcgd.net) ubuntu下研华工控机CAN卡驱动的安装与测试_星辰和大海都需要门票的博客-CSDN博客 简介介绍两款使用过的usb转can的使用方法 一款是广成科技的USBCAN-I PRO资料下载 (gcgd.net) 一款是创芯科技的CANalyst珠海创芯科技有限公司 - 珠海创芯科技 (zhcxgd.com) 软件安装与使用USBCAN:沈阳广成科技USBCAN系列产品驱动安装及ECANTools软件使用方法 (gcgd.net) GC-USBCAN—–点击进入文件夹选择需要下载的文件_免费高速下载|百度网盘-分享无限制 (baidu.com) CANalyst:(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动 编程!建议采用官方例程至少不会出错这里推荐两个例程可以验证学习VincentCheungM/ESR_canalyst_ros: A warped ROS driver for CANalyst-II and ESR Radar (github.com) Andy-jg/RaspberryCanalyst-2: linux use the canalyst-2 (github.com) !注意由于can驱动使用时每次都需要sudo,可以加配置,这样就不需要每次都sudo了 方法1sudo nano /etc/udev/rules.d/99-myusb.rules 输入 12ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;,GROUP=&quot;users&quot;, MODE=&quot;0777&quot;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"io扩展","slug":"io扩展","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-11T13:15:31.977Z","comments":true,"path":"2021/11/11/io扩展/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/io%E6%89%A9%E5%B1%95/","excerpt":"","text":"参考网址:IO口不够了？基于I2C的 IO扩展芯片驱动和开发_arenascat的博客-CSDN博客_io扩展芯片 单片机扩展IO口_我的博客-CSDN博客 74HC164(三八译码器),矩阵键盘这种方式可以实现简单的io扩展,但不可以保持,也就是说,治理只是三位二进制转为八个数,虽然也可以通过加快频率的方式实现.仅用于对时序要求不高的电路,比如led流水灯,而尤其是通讯不太适用的. 采用可编程I/O接口扩展芯片这种方式可以实现io扩展,不过需要一定的编程经验. 采用芯片有 8255a 与 MCP23016 i/o扩展芯片_i/o扩展芯片采购信息-立创电子元器件商城 (szlcsc.com) 采用A/D获取按键的位置通过不同电压对应不通按键,挺不错的思路","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"linux解压","slug":"linux解压","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-11T11:25:51.951Z","comments":true,"path":"2021/11/11/linux解压/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/linux%E8%A7%A3%E5%8E%8B/","excerpt":"","text":"参考网址:Linux解压.tgz，.tar.gz文件（tar详细参数使用介绍）_echo-CSDN博客_linux解压.tar.gz文件 压缩1234567tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg //rar格式的压缩，需要先下载 rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载 zip for linux 解压1234567tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Ztar -Jxvf file.tar.xzunrar e file.rar //解压rarunzip file.zip //解压zip 总结123456789*.tar 用 tar -xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar -xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar -xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar -xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"cJSON","slug":"cJSON","date":"2021-11-10T04:30:12.000Z","updated":"2021-11-11T12:45:27.407Z","comments":true,"path":"2021/11/10/cJSON/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/10/cJSON/","excerpt":"","text":"参考网址:(65条消息) cJSON使用详细教程 | 一个轻量级C语言JSON解析器_Mculover666的博客（嵌入式_) cJSON-github 生成12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot;int main(void)&#123; cJSON* cjson_test = NULL; cJSON* cjson_address = NULL; cJSON* cjson_skill = NULL; char* str = NULL; /* 创建一个JSON数据对象(链表头结点) */ cjson_test = cJSON_CreateObject(); /* 添加一条字符串类型的JSON数据(添加一个链表节点) */ cJSON_AddStringToObject(cjson_test, &quot;name&quot;, &quot;mculover666&quot;); /* 添加一条整数类型的JSON数据(添加一个链表节点) */ cJSON_AddNumberToObject(cjson_test, &quot;age&quot;, 22); /* 添加一条浮点类型的JSON数据(添加一个链表节点) */ cJSON_AddNumberToObject(cjson_test, &quot;weight&quot;, 55.5); /* 添加一个嵌套的JSON数据（添加一个链表节点） */ cjson_address = cJSON_CreateObject(); cJSON_AddStringToObject(cjson_address, &quot;country&quot;, &quot;China&quot;); cJSON_AddNumberToObject(cjson_address, &quot;zip-code&quot;, 111111); cJSON_AddItemToObject(cjson_test, &quot;address&quot;, cjson_address); /* 添加一个数组类型的JSON数据(添加一个链表节点) */ cjson_skill = cJSON_CreateArray(); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;C&quot; )); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;Java&quot; )); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;Python&quot; )); cJSON_AddItemToObject(cjson_test, &quot;skill&quot;, cjson_skill); /* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */ cJSON_AddFalseToObject(cjson_test, &quot;student&quot;); /* 打印JSON对象(整条链表)的所有数据 */ str = cJSON_Print(cjson_test); printf(&quot;%s\\n&quot;, str); return 0;&#125; 解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot;char *message = &quot;&#123; \\ \\&quot;name\\&quot;:\\&quot;mculover666\\&quot;, \\ \\&quot;age\\&quot;: 22, \\ \\&quot;weight\\&quot;: 55.5, \\ \\&quot;address\\&quot;: \\ &#123; \\ \\&quot;country\\&quot;: \\&quot;China\\&quot;,\\ \\&quot;zip-code\\&quot;: 111111\\ &#125;, \\ \\&quot;skill\\&quot;: [\\&quot;c\\&quot;, \\&quot;Java\\&quot;, \\&quot;Python\\&quot;],\\ \\&quot;student\\&quot;: false \\&#125;&quot;;int main(void)&#123; cJSON* cjson_test = NULL; cJSON* cjson_name = NULL; cJSON* cjson_age = NULL; cJSON* cjson_weight = NULL; cJSON* cjson_address = NULL; cJSON* cjson_address_country = NULL; cJSON* cjson_address_zipcode = NULL; cJSON* cjson_skill = NULL; cJSON* cjson_student = NULL; int skill_array_size = 0, i = 0; cJSON* cjson_skill_item = NULL; /* 解析整段JSO数据 */ cjson_test = cJSON_Parse(message); if(cjson_test == NULL) &#123; printf(&quot;parse fail.\\n&quot;); return -1; &#125; /* 依次根据名称提取JSON数据（键值对） */ cjson_name = cJSON_GetObjectItem(cjson_test, &quot;name&quot;); cjson_age = cJSON_GetObjectItem(cjson_test, &quot;age&quot;); cjson_weight = cJSON_GetObjectItem(cjson_test, &quot;weight&quot;); printf(&quot;name: %s\\n&quot;, cjson_name-&gt;valuestring); printf(&quot;age:%d\\n&quot;, cjson_age-&gt;valueint); printf(&quot;weight:%.1f\\n&quot;, cjson_weight-&gt;valuedouble); /* 解析嵌套json数据 */ cjson_address = cJSON_GetObjectItem(cjson_test, &quot;address&quot;); cjson_address_country = cJSON_GetObjectItem(cjson_address, &quot;country&quot;); cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, &quot;zip-code&quot;); printf(&quot;address-country:%s\\naddress-zipcode:%d\\n&quot;, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint); /* 解析数组 */ cjson_skill = cJSON_GetObjectItem(cjson_test, &quot;skill&quot;); skill_array_size = cJSON_GetArraySize(cjson_skill); printf(&quot;skill:[&quot;); for(i = 0; i &lt; skill_array_size; i++) &#123; cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i); printf(&quot;%s,&quot;, cjson_skill_item-&gt;valuestring); &#125; printf(&quot;\\b]\\n&quot;); /* 解析布尔型数据 */ cjson_student = cJSON_GetObjectItem(cjson_test, &quot;student&quot;); if(cjson_student-&gt;valueint == 0) &#123; printf(&quot;student: false\\n&quot;); &#125; else &#123; printf(&quot;student:error\\n&quot;); &#125; return 0;&#125; 相关 - JSMN(仅解析)JSMN介绍和使用_心飞的博客-CSDN博客 The most simple JSON parser in C for small systems (zserge.com) zserge/jsmn: Jsmn is a world fastest JSON parser/tokenizer. This is the official repo replacing the old one at Bitbucket (github.com)","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_常见电路","slug":"电路设计_常见电路","date":"2021-11-08T04:30:12.000Z","updated":"2021-11-09T10:17:19.739Z","comments":true,"path":"2021/11/08/电路设计_常见电路/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/","excerpt":"","text":"驱动输出电路 这里需要注意的是,uln2803是一种npn输出,输出低电平,因此在其输出端会有上拉电阻.在uln2803左侧接gnd右侧接24v. 这里的74hct245为三态输出八路收发器作用是增加单片机的驱动能力. 将同样用74hct245此电路改为pnp型输出,需要将uln2803换为tbd62783,需要注意输出端需要接下拉电阻. **!注意:**由于改驱动芯片uln2803输出最大电流为500ma可能出现烧芯片的情况,可以加一个500ma熔断 放大电路(opa2333) 这里通过R64,R65阻值的变化来实现放大,具体详细可参考:(61条消息) 基本运算放大器原理_小神兵之技术篇-CSDN博客_运算放大器 值得注意的是,由于是轨到轨的放大电路,输入24v,最大放大电压同样也可以达到24v 模拟量采样电路 这里两个二极管用以防过压,电压大于3.3v小于26.7v时直接通过+3.3v,输出,而大于26.7v击穿二极管,直接导地. 模拟量采集,还需要注意一点就是,对于电源要进行滤波处理,使电源信号更干净 普通光耦(TLP290-4)与单向高速光耦(PC4D10) TLP290-4为一种普通光耦,可以实现双向导通,这里原理图左边部分有些出入需要注意一下,输出为npn型输出,注意上拉电阻 pc4d10为告诉光耦,实现的npn型输出,所以注意需要有上拉电阻. 防反接电路参考网址:(62条消息) 直流电源输入防反接保护电路总结_cgy8919的博客-CSDN博客","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_稚晖君机械臂","slug":"电路设计_稚晖君机械臂学习","date":"2021-11-08T04:30:12.000Z","updated":"2021-11-11T11:13:57.930Z","comments":true,"path":"2021/11/08/电路设计_稚晖君机械臂学习/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E7%A8%9A%E6%99%96%E5%90%9B%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"参考网址:peng-zhihui/Dummy-Robot: 我的超迷你机械臂机器人项目。 (github.com) 电源部分:采用TPS61040DBV芯片实现的5v转9v电路,该芯片支持1.8v到6v输入,高达28v输出,同时还支持400ma的电流输出,具体可参考: TPS6104x Low-Power DC-DC Boost Converter in SOT-23 and WSON Packages datasheet (Rev. J) (ti.com) LP2992线性稳压器,输入2.2v到16v输出1.5v到5v,指定250毫安输出电流 LP2992 Micropower 250-mA Low-Noise Ultra-Low-Dropout Regulator in SOT-23 and WSON Packages Designed for Use With Very Low-ESR Output Capacitors datasheet (Rev. J) (ti.com) ME3116 是一款内部集成了 MOSFET 的异步整流降压型 稳压器。它在很宽的输入电压范围内（4.75V-40V）能够提供 高达 1A 的负载能力。 ME6206:降压稳压器,高精度输出电压：±2% 输出电压：1.5V~5.0V(步长 0.1V) 最大工作电压：6V 带载能力强：当 Vin=4.3V 且 Vout=3.3V 时 Iout=300mA 极低的输入输出电压差： 0.2V at 90mA and 0.40V at 200mA 这里使用了ss54实现防反接,sy8303降压型dc-dc芯片 自动下载电路采用cp2101usb转串口芯片,通过三极管,实现串口自动下载","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派串口通信","slug":"树莓派串口通信","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-06T07:46:11.413Z","comments":true,"path":"2021/11/06/树莓派串口通信/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","excerpt":"","text":"参考网址:树莓派4b ubuntu系统开启串口_benchuspx的博客-CSDN博客 树莓派4B如何使用串口与外部进行通信 - 程序员大本营 (pianshen.com) 介绍树莓派原本的抽是用于串口控制台的,即/ttyAMA0,且此硬件串口也与蓝牙连接到一块,因此需要将控制台与蓝牙关闭才能使用 方法 /boot/firmware/nobtcmd.txt里删除console = /ttyAMA 921600从而禁用串口控制台.这个txt文件也可以用读卡器把sd卡插到windows系统里在system-boot里找到 /boot/firmware/config.txt 里设置enable_uart=1（默认就是）.如果=0表示启用minicom串口，而不是这个硬件串口. /boot/firmware/config.txt 里加入一行dtoverlay=disable-bt从而禁用蓝牙. sudo systemctl disable bluetooth…… 禁用掉和蓝牙有关的开机启动项.直到桌面不再显示蓝牙标志，但是还有/ttyAMA0存在.","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派备份","slug":"树莓派备份","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-06T13:10:22.879Z","comments":true,"path":"2021/11/06/树莓派备份/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/","excerpt":"","text":"参考网址:收藏！最简单的树莓派系统备份方法！ - 知乎 (zhihu.com) 树莓派学习笔记 篇四：树莓派4B 的系统备份方法大全（全卡+压缩备份）_其他智能设备_什么值得买 (smzdm.com) 烧写之前备份过的树莓派镜像到SD卡，证明这样备份恢复是可行的！！！！！！！_TYINY的博客-CSDN博客 最简单的方式win10下新建一个.img格式文件,通过Win32DiskImager,read插入卡的系统,read完就备份好了 脚本方式(推荐) 在Linux系统中一键备份树莓派系统SD卡的脚本 (github.com) 下载下来脚本rpi-backup.sh放入到Linux系统 插入需备份的树莓派系统,用df -h命令查询SD卡设备名 运行sudo chmod +x rpi-backup.sh后,运行./rpi-backup.sh /dev/sdb1 /dev/sdb2 注意第一个参数是树莓派SD卡/boot分区的设备名：/dev/sdb1，第二个参数是/分区的设备名：/dev/sdb2，视情况修改） 终 img 文件会生成在~/backupimg/文件夹下","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派安装Ubuntu18_server","slug":"树莓派安装ubuntu18_server","date":"2021-11-06T04:30:12.000Z","updated":"2021-12-29T09:07:40.182Z","comments":true,"path":"2021/11/06/树莓派安装ubuntu18_server/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/","excerpt":"","text":"参考网址:树莓派raspberry 安装ubuntu18.04 server + desktop + ros1_越来越胖了_mengleijin的博客-CSDN博客 树莓派4b安装带桌面的ubuntu18.04 server和ROS melodic系统 - 灰信网（软件开发博客聚合） (freesion.com) 树莓派4B安装Ubuntu18.04 + vnc远程桌面_我是大一菜鸡-CSDN博客 img镜像下载pi烧录软件:https://downloads.raspberrypi.org/imager/imager_latest.exe 树莓派操作系统镜像下载地址 ubuntu18_server https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/ 将系统烧入SD卡使用win32diskimager或者balenaetcher烧录进去 启动树莓派将SD卡插入树莓派，并为树莓派连接好电源，显示器，鼠标，键盘，网线。启动树莓派，默认用户名密码都是ubuntu，之后需要马上修改密码，按提示操作即可。 SSH打开 system-boot 磁盘下根目录的 network-config 文件1234567891011121314151617181920# This file contains a netplan-compatible configuration which cloud-init# will apply on first-boot. Please refer to the cloud-init documentation and# the netplan reference for full details:## https://cloudinit.readthedocs.io/# https://netplan.io/reference## Some additional examples are commented out belowversion: 2ethernets: eth0: dhcp4: false addresses: [192.168.30.110/24]wifis: wlan0: access-points: HUAWEI_PTY: password: pty123456787 dhcp4: true 修改在相同目录下的 user-data 文件，expire：后改成false。 启动树莓派如果是刷完固件后第一次启动，因为第一次需要进行系统配置，所以第一次不会自动连接。第一次上电过两分钟后重新上电稍等片刻就会自动连接wifi了。 连网可以参考: Ubuntu Server 18.04 连接 WIFI_zyr920425的博客-CSDN博客 编辑,注意需要使用Tab键对齐,建议使用能看到对其线的对其工具,比如sublime 1sudo nano /etc/netplan/xxxxxxx.yaml 123456789101112131415161718# This file is generated from information provided by the datasource. Changes# to it will not persist across an instance reboot. To disable cloud-init&#x27;s# network configuration capabilities, write a file# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:# network: &#123;config: disabled&#125;network: version: 2 ethernets: eth0: dhcp4: false addresses: [192.168.8.110/24] wifis: wlan0: access-points: HUAWEI_PTY: password: pty123456787 dhcp4: true optional: true 1sudo netplan apply 换源1sudo nano /etc/apt/sources.list 参考:树莓派4安装 18.04ubuntu server（2020.11.2）_lovely_yoshino的博客-CSDN博客_树莓派ubuntu18.04 123456789101112131415161718192021deb http://mirrors.aliyun.com/ubuntu-ports bionic main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic universedeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates universedeb http://mirrors.aliyun.com/ubuntu-ports bionic multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic-security universedeb http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports bionic main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse 1sudo apt-get update SSH连接网线连接好,通过ip a查看是否配置好,然后在物理机上尝试ping通后连接 1ssh.exe ubuntu@192.168.xx.xx 安装gcc与g++1sudo apt-get install build-essential","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_最小系统设计","slug":"电路设计_最小系统设计","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-08T06:22:13.129Z","comments":true,"path":"2021/11/06/电路设计_最小系统设计/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"参考网址:(60条消息) STM32最小系统设计_little_ox的博客-CSDN博客 最小系统组成:主芯片,复位电路,时钟电路,电源电路,下载电路 主芯片根据自己需要的io数量,功能选择好主芯片 复位电路,时钟电路,下载电路由于低电平复位,因此可以通过上拉电阻实现,由于复位电路与时钟电路一般芯片都会提供参考电路或者查查资料都很容易找到,就不再赘述,下载电路的话直接clk,dio给他,通过SWD,或者JTAG下载,这里使用的时SWD下载 **!注意:**一般芯片都会有电源滤波,因此在布线的过程中注意将电容尽量放的里芯片近些. 晶振的选择有源晶振:自供电,有内部电路,精度会高些,当然价格也贵些 无源晶振:内部不供电,与芯片直接相连,精度差些,在对时钟要求没那么高的情况下一般够用 电源电路比较麻烦的是电源电路,或者降压,或者稳压,根据需要实现. 这里提供一种从24v转3.3v的思路电源思路.这里使用TPS5430芯片实现的一种电源降压的方式,这里D2指的是瞬态抑制起到当电压超过24v(比如打火花)进来时,D2导通,24v直接接地,同事使用了F1保险丝做保护","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_通讯设计","slug":"电路设计_通讯设计","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-08T06:21:47.065Z","comments":true,"path":"2021/11/06/电路设计_通讯设计/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"CAN: 两张图用的都是TJA1050,速度1Mbps,不过后期的处理略有些不同,上图can信号分两路输出,而下图,为保护电路,加入了fuse(熔断器),SMAJ30CA(瞬态抑制二极管) 这张图用的是max30513.3v供电,高速运行1Mbps,这里使用了ACT45B共模电感起EMI滤波的作用，用于抑制高速信号线产生的电磁波向外辐射发射. RS485 由于采用3.3v供电,使用芯片为sp3485,参考图二,5v供电可更换为max485,电路设计上也还是同样,图一,采用熔断器与瞬态一直二极管保护电路 这张图就是max485实现的RS485电路,同样对于电路保护也采用熔断器与瞬态一直二极管,同时采用电容进行进一步滤波.这里发送接收通过EN控制,三极管做开关功能,EN为0时接收,为1时发送. 232 数据手册: 具有 ±15kV ESD 保护功能的 MAX3232 3V 至 5.5V 多通道 RS-232 线路驱动器和接收器 datasheet 布板参考: USB转串口 这张图是type_c转串口的图,图中使用CH340N实现板子最小化,非常nice 下面是他的开源链接:TYPE C usb转串口 - 立创EDA开源硬件平台 (oshwhub.com) 当然为了保护电路,我们也可以在上边加上熔断与瞬时抑制二极管 以太网参考渡鸦卡发版设计 大佬的串口转以太网设计: 串口转以太网模块-CH9121 - 立创EDA开源硬件平台 (oshwhub.com)","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"}]},{"title":"hector基础使用","slug":"hector基础使用","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T06:14:45.991Z","comments":true,"path":"2021/11/05/hector基础使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:思岚A1激光雷达hector_mapping建图与定位_欧俊岑的博客-CSDN博客 tx2+r2000激光雷达 hector建图_大家安静啊的博客-CSDN博客 hectorslam之EAI雷达(ydlidar_x2l)配置过程_sunshine-CSDN博客 NickL77/RPLidar_Hector_SLAM: Hector SLAM without odometry data on ROS with the RPLidar A1 (github.com) 简介hector是纯粹基于laserscan数据的算法,只需要提供scan数据即可,这里使用r2000做实验.因此第一步应该发布scan数据. Scan激光数据发布r2000提供了ros发布的驱动文件,因此只需要修改些配置即可. 驱动网址: dillenberger/pepperl_fuchs: Pepperl+Fuchs R2000 Driver (github.com) 修改一下配置: 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;node pkg=&quot;pepperl_fuchs_r2000&quot; type=&quot;r2000_node&quot; name=&quot;r2000_driver_node&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;scanner_ip&quot; value=&quot;192.168.1.19&quot;/&gt; &lt;param name=&quot;frame_id&quot; value=&quot;laser_link&quot;/&gt; &lt;param name=&quot;scan_frequency&quot; value=&quot;35&quot;/&gt; &lt;param name=&quot;samples_per_scan&quot; value=&quot;3600&quot;/&gt; &lt;!-- &lt;remap from=&quot;/r2000_driver_node/scan&quot; to=&quot;scan&quot;/&gt; --&gt; &lt;/node&gt; &lt;!--&lt;node pkg=&quot;dummy_slam_broadcaster&quot; type=&quot;dummy_slam_broadcaster_node&quot; name=&quot;dummy_slam_broadcaster&quot;/&gt; &lt;node name=&quot;rvizLocal&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; respawn=&quot;false&quot; output=&quot;screen&quot; args=&quot;-d $(find pepperl_fuchs_r2000)/rviz/test.rviz&quot; required=&quot;true&quot;/&gt;--&gt;&lt;/launch&gt; 1234567scanner_ip r2000的配置激光ip地址frame_id 发布出去的框架id(用于tf转换)scan_frequency 扫描频率samples_per_scan 每圈的扫描数# 值得注意的是这里r2000发不出去的scan节点为/r2000_driver_node/scan# 可以通过remap重定义为/scan最后通过rviz显示 ros执行命令: 1roslaunch pepperl_fuchs_r2000 gui_example.launch 使用hector_mapping建图并定位这里可以直接在系统中安装hector,并新建hector_mapping.launch文件,指令如下: 12345sudo apt-get install ros-melodic-hector-slamcd catkin_ws/srccatkin_create_pkg run_launch # 因为内部都是launch文件并不需要依赖包cd run_launch &amp;&amp; sudo mkdir launch &amp;&amp; cd launchsudo nano hector_mapping.launch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;launch&gt;&lt;node pkg=&quot;hector_mapping&quot; type=&quot;hector_mapping&quot; name=&quot;hector_mapping&quot; output=&quot;screen&quot;&gt; &lt;!-- Frame names --&gt; &lt;!-- 确定map-&gt; odom转换是否应该由系统发布 --&gt; &lt;param name=&quot;pub_map_odom_transform&quot; value=&quot;true&quot;/&gt; &lt;!-- 坐标系id,hector会将map与车体做tf连接到一块,而车体与激光之间的连接需要我们自己做 --&gt; &lt;param name=&quot;map_frame&quot; value=&quot;map&quot; /&gt; &lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot; /&gt; &lt;!-- 由于没有使用里程计,改为base_link即可 --&gt; &lt;param name=&quot;odom_frame&quot; value=&quot;base_link&quot; /&gt; &lt;!-- Tf use --&gt; &lt;param name=&quot;use_tf_scan_transformation&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;use_tf_pose_start_estimate&quot; value=&quot;false&quot;/&gt; &lt;!-- Map size / start point --&gt; &lt;param name=&quot;map_resolution&quot; value=&quot;0.05&quot;/&gt; &lt;!-- 地图尺寸需要注意一下,如果地图太小,可能导致激光范围过大,超出地图,这样匹配坐标会很挫 --&gt; &lt;param name=&quot;map_size&quot; value=&quot;512&quot;/&gt; &lt;param name=&quot;map_start_x&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;map_start_y&quot; value=&quot;0.5&quot; /&gt; &lt;param name=&quot;laser_z_min_value&quot; value = &quot;-1.0&quot; /&gt; &lt;param name=&quot;laser_z_max_value&quot; value = &quot;1.0&quot; /&gt; &lt;param name=&quot;map_multi_res_levels&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;map_pub_period&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;laser_min_dist&quot; value=&quot;0.4&quot; /&gt; &lt;!-- 激光扫描距离要适中,如果太小也会出现建图建的很挫的现象 --&gt; &lt;param name=&quot;laser_max_dist&quot; value=&quot;5.5&quot; /&gt; &lt;param name=&quot;output_timing&quot; value=&quot;false&quot; /&gt; &lt;!-- 确定scanmatcher到map的转换是否发布到TF --&gt; &lt;param name=&quot;pub_map_scanmatch_transform&quot; value=&quot;true&quot; /&gt; &lt;!-- 发布的坐标名 --&gt; &lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt; &lt;!-- Map update parameters --&gt; &lt;param name=&quot;update_factor_free&quot; value=&quot;0.4&quot;/&gt; &lt;param name=&quot;update_factor_occupied&quot; value=&quot;0.7&quot; /&gt; &lt;param name=&quot;map_update_distance_thresh&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;map_update_angle_thresh&quot; value=&quot;0.06&quot; /&gt; &lt;!-- Advertising config --&gt; &lt;param name=&quot;advertise_map_service&quot; value=&quot;true&quot;/&gt; &lt;!-- 扫描订阅器的队列大小 --&gt; &lt;param name=&quot;scan_subscriber_queue_size&quot; value=&quot;5&quot;/&gt; &lt;!-- 这里更改一下scan_topic 如果我们做了重定向,需要改为/scan--&gt; &lt;param name=&quot;scan_topic&quot; value=&quot;/r2000_driver_node/scan&quot;/&gt;&lt;/node&gt;&lt;!-- !注意:这一步需要将车体坐标系与激光坐标系进行tf转换连接起来 --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0.105 0 0 0 /base_link /laser_link 100&quot;/&gt;_ &lt;!-- 这里使用的是hector自带的rviz配置,我们也可以在他的基础上增减功能,另存到我们自己的文件src/run_launch/rviz/map/hector_map.rviz --&gt; &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;/&gt; &lt;/launch&gt; 执行步骤: 1234# 发布scan数据roslaunch pepperl_fuchs_r2000 gui_example.launch# 启动hector_mappingroslaunch run_launch hector_mapping.launch 一些图片 总结1.订阅/scan不要出错 2.tf转换尤为需要注意,map-&gt;base_link-&gt;laser_link 3.激光距离与地图大小需要注意一下,这里设不好容易崩","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"hector源码理解","slug":"hector源码阅读","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-06T07:29:40.188Z","comments":true,"path":"2021/11/05/hector源码阅读/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"参考网址:大佬的分析,包含代码注释解析与源码重写,论文翻译 Hector_slam源码框架分析_翎风的博客-CSDN博客 Hector SLAM解读（1）原文翻译 - cyberniklee - 博客园 (cnblogs.com) HectorSLAM论文解析・代码重写（2） - scomup - 博客园 (cnblogs.com) zhangwenxiao/HectorSlamWithoutROS: 脱离ROS的hector slam算法 (github.com) 代码框架该开源系统的主要代码在hector_mapping文件夹中，文件夹里有src文件夹和include文件夹，包含了算法所有的核心代码。通过对源码的梳理，整理出了如下流程图： 大佬的图非常清晰的可以看到,整个代码分为地图匹配与地图更新 地图匹配主要采用非线性优化—-高斯牛顿法,实际上就是通过激光数据与现有地图的差距(双线性插补),通过最小二乘法,计算概率,从而更新位移增量,计算出机器人最可能存在位置 双线性插值计算栅格概率一篇文章为你讲透双线性插值 - 知乎 (zhihu.com) 通过双线性插补得到一个位置,然后通过最小二乘法,更新位移增量 高斯牛顿法高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客 【泡泡机器人公开课】第三十课：非线性优化与g2o-高翔_哔哩哔哩_bilibili 地图更新用bresenham划线算法计算激光途经栅格 (60条消息) Bresenham 算法原理_yzh1994414的博客-CSDN博客_bresenham 画线算法-Bresenham算法_天才樱木-CSDN博客_bresenham画线算法 优缺点1.优点（1）不需要使用里程计，可以用于地面不平坦区域及空中飞行器。（2）使用多分辨率地图能避免局部最小值。 2.缺点（1）要求雷达更新频率较高，测量噪声小；或者机器人运动速度低。（2）无法利用精确的里程计信息。","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"map_server","slug":"map_server","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T07:26:41.799Z","comments":true,"path":"2021/11/05/map_server/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/map_server/","excerpt":"","text":"参考网址:(60条消息) map server 功能和作用_天才樱木-CSDN博客_map_server 保存1rosrun map_server map_saver -f mymap 我们会得到两个文件,mymap.pgm,mymap.yaml mymap.pgm为0到1的灰度图 mymap.yaml为配置文件 123456789101112# 文件名image: testmap.png# 分辨率resolution: 0.1# 初始点origin: [0.0, 0.0, 0.0]# 占用阈值occupied_thresh: 0.65# 为自由阈值free_thresh: 0.196# 是否应该颠倒白/黑 自由/被占用的语义(阈值的解释不受影响)negate: 0 发布节点1rosrun map_server map_server mymap.yaml 主题map_metadata (nav_msgs/MapMetaData) 123456789101112# 这包含了关于占领网格特征的基本信息# 地图加载的时间time map_load_time# 地图的分辨率 [m/cell]float32 resolution# Map width [cells]uint32 width# Map height [cells]uint32 height# 地图的原点[m, m, rad]。这是地图中单元格(0,0)的真实姿态。geometry_msgs/Pose origin map (nav_msgs/OccupancyGrid) 123456789101112# 这代表了一个二维网格地图，其中每个单元格代表占用概率。Header header # uint32 seq# time stamp# string frame_id#地图的元数据MapMetaData info# 映射数据，按行主顺序，从(0,0)开始。占用概率在[0,100]范围内。未知是1。int8[] data static_map (nav_msgs/GetMap) 123# Get the map as a nav_msgs/OccupancyGrid---nav_msgs/OccupancyGrid map","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"梯度下降法","slug":"梯度下降法","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T12:21:42.907Z","comments":true,"path":"2021/11/05/梯度下降法/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/","excerpt":"","text":"参考网址:(60条消息) 高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客 信赖域狗腿（dogleg）方法_LSEC小陆的博客-CSDN博客 高斯牛顿(Gauss Newton)、列文伯格-马夸尔特(Levenberg-Marquardt)最优化算法与VSLAM_weixin_30463341的博客-CSDN博客 LM算法——列文伯格-马夸尔特算法（最速下降法，牛顿法，高斯牛顿法）（完美解释负梯度方向）_三眼二郎-CSDN博客_lm算法 从上倒下为梯度下降法的前世今生已经未来的演化：最速下降法（一阶梯度法）牛顿法（二阶梯度法）高斯牛顿法列文伯格法马夸尔特法 梯度下降主要用于slam中的非线性优化,实际上就是对一个最小二乘问题的求解,这也是上述几种方法的用途. 问题 最速下降(一阶梯度法)最速下降法（一阶梯度法）就是保留泰勒展开的一阶项用来近似非线性函数**F ( x )**，即：$$F(xk​+Δxk​)≈F(xk​)+J(xk​)TΔxk$$ $$Δxk​=−J(xk)$$ **缺点:**由于仅保留一阶的雅可比矩阵,该方法过于贪心，容易走出锯齿线，反而增加迭代次数。 牛顿法和阻尼牛顿法（二阶梯度法）$$H(xk​ )Δxk​ =−J(xk​ )$$ **牛顿法的缺点:**海塞矩阵H计算量太大 阻尼牛顿法(可以看成是牛顿法与最速法的结合) 阻尼牛顿法就是在使用牛顿法获得增量方向后，进一步对最优步长进行搜索： 高斯牛顿法(仅用于最小二乘)原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)增量方程:$$H(xk​ )Δxk​ =g(xk​ )$$算法流程: 12341.给定初始值X02.对于第k次迭代,求出当前雅可比矩阵J与误差f(x)3.求解增量方程:H*deltaxk=g4.若的了他xk足够小,则停止,否则,xk+1 = xk + deltaxk 缺点: 由于是通过雅各比矩阵做的JH(海瑟矩阵)的近似,因此会遇见奇异矩阵与病态矩阵,可能出现算法不收敛. L-M方法，阻尼牛顿法列文伯格-马夸尔特方法的思想针对高斯牛顿法的不足，L-M方法做了两点改进： 在求解增量Δ xk 时，对其设置了信赖区域 在求得增量Δ xk对其近似效果进行了量化，并根据量化结果对信赖区域进行调整， 再从新计算增量Δ x k，直到近似效果量化结果达到阈值。 增量方程$$(H+λDT D)Δxk​ =g(xk​ )$$近似程度的量化$$ρ=(f(xk​+Δx k​)−f(x k​ ))/(J(x k​)TΔxk​)​$$ 当ρ接近1时，近似效果好； 当ρ太小时，实际减小的值远小于近似函数减小的值，近似效果差，需要缩小近似范围μ 当ρ较大时，实际减小的值大于近似函数减小的值，近似效果差，需要增大近似范围μ 算法流程:","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"Jupyter Notebooks","slug":"Jupyter","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-23T13:10:25.284Z","comments":true,"path":"2021/11/03/Jupyter/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/Jupyter/","excerpt":"","text":"安装Jupyter1conda install jupyter # 或 pip install jupyter Ubuntu下使用jupyterUbuntu 下 Jupyter 的使用_yaoyz105-CSDN博客 Vscode使用jupyter在VS Code中编写Jupyter Notebook_云水木石-CSDN博客 win10Jupyter Notebooks的安装和使用介绍_LarsCheng’s Blog-CSDN博客","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"罗技遥控","slug":"Logitechcontrol","date":"2021-11-03T04:30:12.000Z","updated":"2021-12-06T01:15:18.572Z","comments":true,"path":"2021/11/03/Logitechcontrol/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/Logitechcontrol/","excerpt":"","text":"参考网址:罗技F310与F710游戏手柄驱动（附C++源码）_冬瓜-CSDN博客 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Logitech_controller.h/* define ----------------------------------------------------------------*/#ifndef Logitech_DRIVER#define Logitech_DRIVER/* Includes ---------------------------------------------------------------*/#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;linux/input.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;#define JSKEY_A 0x001#define JSKEY_B 0x101#define JSKEY_X 0x201#define JSKEY_Y 0x301#define JSKEY_LB 0x401#define JSKEY_RB 0x501#define JSKEY_BACK 0x601#define JSKEY_START 0x701#define JSKEY_HOME 0x801#define JSKEY_LT 0x202#define JSKEY_RT 0x502#define JSKEY_CROSS_X 0x602#define JSKEY_CROSS_Y 0x702#define JSKEY_LEFTSTICK_X 0x002#define JSKEY_LEFTSTICK_Y 0x102#define JSKEY_RIGHTSTICK_X 0x302#define JSKEY_RIGHTSTICK_Y 0x402#define JSKEY_PRESS 0x001 #define JSKEY_RELEASE 0x0 #define JSKEY_CROSS_LOW_VALUE 0xffff8001 #define JSKEY_CROSS_HIGH_VALUE 0x7fff using namespace std;class Logitech&#123;private: char *dev; ssize_t n; int fd; int buf[2];public: Logitech(char* device); map&lt;int, int&gt; Keystate_map; int init(); void listen_input(); void print_key_state();&#125;;#endif //Logitech_DRIVER 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// Logitech_controller.c #include &quot;Logitech_controller.h&quot;using namespace std;Logitech::Logitech(char* device)&#123; dev = device; memset(buf, 0, sizeof buf);&#125;int Logitech::init()&#123; fd = open(dev, O_RDONLY); if (fd == -1) &#123; fprintf(stderr, &quot;Cannot open %s: %s.\\n&quot;, dev, strerror(errno)); return EXIT_FAILURE; &#125; /*Key Status*/ /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_A] =0; Keystate_map[JSKEY_B] =0; Keystate_map[JSKEY_X] =0; Keystate_map[JSKEY_Y] =0; /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_LB] =0; Keystate_map[JSKEY_RB] =0; /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_BACK] =0; Keystate_map[JSKEY_START] =0; Keystate_map[JSKEY_HOME] =0; /* 0 is released */ /* -1 is the left or up button is pressed */ /* 1 is the right or down button is pressed*/ Keystate_map[JSKEY_CROSS_X] =0; Keystate_map[JSKEY_CROSS_Y] =0; /* the result is the value of the key(0~99)*/ Keystate_map[JSKEY_LT] =0; Keystate_map[JSKEY_RT] =0; /* the result is the value of the key(-100~100)*/ Keystate_map[JSKEY_LEFTSTICK_X] =0; Keystate_map[JSKEY_LEFTSTICK_Y] =0; Keystate_map[JSKEY_RIGHTSTICK_X] =0; Keystate_map[JSKEY_RIGHTSTICK_Y] =0; return 0;&#125;void Logitech::listen_input()&#123; while (1) &#123; memset(buf, 0, sizeof buf); n = read(fd, &amp;buf, sizeof buf); n = n / sizeof(int); if (n == (ssize_t)-1) &#123; if (errno == EINTR) continue; else break; &#125; unsigned short btn = buf[1] &gt;&gt; 16; short val = (short)(buf[1] &amp; 0xffff); /*Test for button ID*/ //cout&lt;&lt;&quot;0x&quot;&lt;&lt;hex&lt;&lt;btn&lt;&lt;endl; if (btn == JSKEY_LT || btn == JSKEY_RT) &#123; unsigned short prs_val = val + 32768; val = (unsigned short) (((long)prs_val)*100/65536); Keystate_map[btn]= val; &#125; else if (btn == JSKEY_LEFTSTICK_X || btn == JSKEY_LEFTSTICK_Y || btn == JSKEY_RIGHTSTICK_X || btn == JSKEY_RIGHTSTICK_Y) &#123; /* y-axis reverse */ if(btn==JSKEY_LEFTSTICK_Y||btn == JSKEY_RIGHTSTICK_Y) &#123;val=(-1)*val;&#125; val = val*100/32767; Keystate_map[btn]= val; &#125; else &#123; switch (val) &#123; case JSKEY_PRESS: Keystate_map[btn]=1; break; case JSKEY_RELEASE: Keystate_map[btn]=0; break; case JSKEY_CROSS_LOW_VALUE: Keystate_map[btn]=-1; break; case JSKEY_CROSS_HIGH_VALUE: Keystate_map[btn]=1; break; default: break; &#125; /* y-axis reverse */ if(btn==JSKEY_CROSS_Y) &#123;Keystate_map[btn]=(-1)*Keystate_map[btn];&#125; &#125; print_key_state(); &#125;&#125;void Logitech::print_key_state()&#123; cout&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_A = &quot;&lt;&lt;Keystate_map[JSKEY_A]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_B = &quot;&lt;&lt;Keystate_map[JSKEY_B]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_X = &quot;&lt;&lt;Keystate_map[JSKEY_X]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_Y = &quot;&lt;&lt;Keystate_map[JSKEY_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LB = &quot;&lt;&lt;Keystate_map[JSKEY_LB]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RB = &quot;&lt;&lt;Keystate_map[JSKEY_RB]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_BACK = &quot;&lt;&lt;Keystate_map[JSKEY_BACK]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_START = &quot;&lt;&lt;Keystate_map[JSKEY_START]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_HOME = &quot;&lt;&lt;Keystate_map[JSKEY_HOME]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LT = &quot;&lt;&lt;Keystate_map[JSKEY_LT]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RT = &quot;&lt;&lt;Keystate_map[JSKEY_RT]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_CROSS_X = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_X]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_CROSS_Y = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LEFTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_X] &lt;&lt;&quot; JSKEY_LEFTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RIGHTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_X]&lt;&lt;&quot; JSKEY_RIGHTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_Y]&lt;&lt;endl;&#125; 123456789101112131415// main.cpp#include &quot;Logitech_controller.h&quot;using namespace std;int main()&#123; char path[] = &quot;/dev/input/js0&quot;; Logitech gamepad(path); gamepad.init(); gamepad.listen_input(); return 0;&#125; !注意:由于不同遥控对于io定义不同,所以需要改动一下**Logitech_controller.h中的#define**","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派入门","slug":"树莓派入门","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-03T13:51:08.689Z","comments":true,"path":"2021/11/03/树莓派入门/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/","excerpt":"","text":"树莓派入门1、树莓派安装12345678教程网站：https://blog.csdn.net/bhniunan/article/details/104783321 https://blog.csdn.net/W17330937835/article/details/105351273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603417716780255273810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161603417716780255273810&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-105351273.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b https://ubuntu-mate.org/noobs安装系统：https://blog.csdn.net/diandianxiyu_geek/article/details/78949393https://shumeipai.nxez.com/downloadhttps://make.quwj.com/member/2/bookmarks?category=36 2、汉化Raspbian操作系统12https://blog.csdn.net/bhniunan/article/details/104842773中文输入法：https://blog.csdn.net/qq_33475105/article/details/113488707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161605416616780261948746%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161605416616780261948746&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-113488707.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95 3、树莓派gpio控制1https://wiki.jikexueyuan.com/project/raspberry-pi/gpio.html 4、树莓派命令行连接wifihttps://blog.csdn.net/u010875635/article/details/70170145 5、树莓派用rc.local设置开机启动12进入etc/rc.local编辑需要打开的设置，直接编辑命令","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"hexo模板","slug":"模板","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-03T13:51:18.385Z","comments":true,"path":"2021/11/03/模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考网址:","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ros_rosbag","slug":"rosbag","date":"2021-11-02T04:30:12.000Z","updated":"2021-11-02T05:47:29.407Z","comments":true,"path":"2021/11/02/rosbag/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/02/rosbag/","excerpt":"","text":"参考网址:(59条消息) Rosbag详细操作_Sun的博客-CSDN博客 rosbag –clock_newbeixue的博客-CSDN博客 Rosbag基础使用保存12345678# 保存所有topicrosbag record -a# 只记录某些感兴趣的 topicrosbag record /topic_name1 /topic_name2 /topic_name3# 指定生成数据包的名字，则用-O /-o 参数rosbag record -O filename.bag /topic_name1# launch 文件中使用 rosbag record 命令&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; 显示信息123456789101112131415161718192021rosbag info filename.bagrosbag info -y filename.bag# 示例xiaohu@xiaohu:~/bagfiles$ rosbag info -y 1.bagpath: 1.bagversion: 2.0duration: 3.295966start: 1566653873.351150end: 1566653876.647117size: 8103messages: 20indexed: Truecompression: nonetypes: - type: geometry_msgs/Twist md5: 9f195f881246fdfa2798d1d3eebca84atopics: - topic: /turtle1/cmd_vel type: geometry_msgs/Twist messages: 20 rosbag play1234567891011# 简单播放rosbag play &lt;bagfile&gt;# -r 2 表示2倍速播放rosbag play -r 2 &lt;bagfile&gt;# 循环播放rosbag play -l &lt;bagfile&gt; # -l== --loop# 只播放一部分topicrosbag play &lt;bagfile&gt; --topic /topic1# 开始播放立刻暂停，按空格继续rosbag play --pause record.bag rosbag –clock123456rosbag play --clock recorded1.bag# -k， --keep-aliverosbag play -k --clock recorded1.bag# -r FACTOR, --rate=FACTOR# 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。rosbag play -r 0.1 --clock recorded1.bag 常用命令12rosparam set /use_sim_time truerosbag play --pause --clock -k scan_odom.bag --topic /topic1","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"三维空间内旋转","slug":"三维空间内旋转","date":"2021-11-02T04:30:12.000Z","updated":"2021-11-02T13:07:47.696Z","comments":true,"path":"2021/11/02/三维空间内旋转/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/","excerpt":"","text":"参考网址:旋转矩阵_ahelloyou的博客-CSDN博客_旋转矩阵 机器人运动学基础——旋转矩阵_太初有泪的博客-CSDN博客 三维重建学习(1)：基础知识：旋转矩阵与旋转向量_hongbin_xu的博客-CSDN博客_旋转向量 简记","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"RTOS多任务访问同一个UART的操作方法","slug":"RTOS多任务访问同一个UART的操作方法","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-04T00:46:00.546Z","comments":true,"path":"2021/11/01/RTOS多任务访问同一个UART的操作方法/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"参考网址:RTOS多任务访问同一个UART的操作方法 在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。 处理“混乱”局面的方法比较多，下面基于FreeRTOS，以UART为例讲讲常见的互斥、队列这两种方法。 互斥访问方法123456789101112131415161718//创建互斥量资源SemaphoreHandle_t xSemaphore = NULL;xSemaphore = xSemaphoreCreateMutex();void TaskA(void *pvParameters)&#123; for(;;) &#123; //占用资源 if(xSemaphoreTake(xSemaphore, 10 ) == pdTRUE) &#123; //使用资源(发送数据) USART_SendNByte(); //释放资源 xSemaphoreGive(xSemaphore); &#125; &#125;&#125; 信号量与互斥量区别： 信号量：多个任务同步使用某个资源； 一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作； 互斥量：多任务互斥使用某个资源； 一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源； 队列操作方法队列操作方法就是FIFO，先入先出的原理。比如：任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据。 1234567891011121314151617181920212223242526272829303132333435363738QueueHandle_t xQueue;xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);xTaskCreate(UART_Send_Task, &quot;UART_Send&quot;, STACK_SIZE, NULL, TASK_PRIORITY, NULL);void TaskA(void *pvParameters)&#123; for(;;) &#123; //任务相关操作 //加入队列 xQueueSend(xQueue, &amp;TaskA_Buf, 10) &#125;&#125;void TaskB(void *pvParameters)&#123; for(;;) &#123; //任务相关操作 //加入队列 xQueueSend(xQueue, &amp;TaskB_Buf, 10) &#125;&#125;void UART_Send_Task(void *pvParameters)&#123; for(;;) &#123; //循环读取队列BUF if(xQueueReceive(xQueue, &amp;Buf, 10) == pdTRUE) &#123; USART_SendNByte(&amp;Buf); &#125; &#125;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"C程序注意点","slug":"c语言编写注意","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:08:52.756Z","comments":true,"path":"2021/11/01/c语言编写注意/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/","excerpt":"","text":"参考网址:https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A 意想不到的八进制12// b为八进制int a=34, b=034; 指针加减运算123456int a=1; int *p=(int *)0x00001000; a=a+1; p=p+1; // 这里的p是指针,// p+1实际上是按照公式p+1*sizeof(int)来计算的。 比如RAM初始化零操作,如下,只有4字节空间被初始化为零 1234567unsigned int *pRAMaddr; //定义地址指针变量 // pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节for(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=4) &#123; *pRAMaddr=0x00000000; //指定RAM地址清零 // 这里清除了四个字节&#125; 关键字sizeofsizeof是一个关键字,需要注意的是,使用sizeof获取数组长度时，不要对指针应用sizeof操作符. 123456789101112131415void ClearRAM(char array[]) &#123; int i ; for(i=0;i&lt;sizeof(array)/sizeof(array[0]);i++) //这里用法错误，array实际上是指针 &#123; array[i]=0x00; &#125; &#125; int main(void) &#123; char Fle[20]; ClearRAM(Fle); //只能清除数组Fle中的前四个元素 &#125; 结构体填充结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体： 第一个结构体： 12345struct &#123; char c； short s； int x； &#125;str_test1; 第二个结构体： 12345struct &#123; char c； int x； short s； &#125;str_test2; 这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？ 其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下第一个结构体变量占用8个字节，第二个结构体占用12个字节，差别很大。第一个结构体变量在内存中的存储格式如图所示： 121~4字节 cc填充SSSS5~8字节 XXXXXXXX 第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。 1231~4字节 cc填充5~8字节 XXXXXXXX9~12字节 ssss填充","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"软件开发中各种开发模型的优缺点","slug":"几种软件开发模型","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:06:25.100Z","comments":true,"path":"2021/11/01/几种软件开发模型/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"参考网址:软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com) 可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。 但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。 瀑布模型该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示： 在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。 优点 该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。 比较适用于前期的软件开发与小型软件系统的开发中。 缺点 无法评估项目进度。因为不知道哪个阶段会造成项目的延期 无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果 快速原型模型快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示： 优点 解决需求不明确带来的风险，适用于不能提前确定项目需求的项目 缺点 不利于开发人员对产品进行扩展 迭代模型迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示： 优点 第一个可交付版本的软件所需的成本与时间较小 能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。 缺点 如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。 最终集成各个组件时，可能会出现集成失败的风险。 喷泉模型该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示： 优点 支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。 缺点 由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。 大量开发人员不利于项目的管理。 该模型需要严格管理文档，会增加审核的难度增大。 螺旋模型螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示： 该模型共有四个象限，每个象限的含义如下： 制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。 风险分析:评价所制订的实施方案，识别风险并消除风险。 实施工程:开发产品并进行验证。 客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。 优点 螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。 缺点 过多的迭代次数会增加开发成本，延迟提交时间。 敏捷模型在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。 敏捷开发模型的价值与原则 个体和交互重于过程和工具 可用软件重于完备文档 客户协作重于合同谈判 响应变化重于遵循计划 优点 用户很快可以看到一个基线架构版的产品 敏捷注重市场快速反应能力，客户前期满意度高。 缺点 注重人员的沟通 忽略文档的重要性 如果项目人员流动大太，会增加项目维护难度 软件之前版本的可重现性、可回溯性较低 对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"变量初始化多种操作","slug":"变量初始化多种操作","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-29T05:07:51.246Z","comments":true,"path":"2021/11/01/变量初始化多种操作/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/","excerpt":"","text":"参考网址:嵌入式C语言编程时，变量、数组、指针初始化的多种操作 数值初始化123int inum = 0;float fnum = 0.00f;double dnum = 0.00; 字符初始化1char ch = &#x27;\\0&#x27;; 字符串初始化实际上就是将字符数组中的字符都初始化为&#39;\\0&#39; 1234567891011// 使用&quot;&quot;实现char str[10] = &quot;&quot;;// 使用memsetchar str[10];memset(str, 0, sizeof(str));//使用循环char str[10];for(int i = 0; i &lt; 10; i++)&#123; str[i] = &#x27;\\0&#x27;;&#125; 一般使用memset最合适,一般采用+1的方式参考: 123char year[4+1];memset(year, 0, sizeof(year));strcpy(year,&quot;2018&quot;); 指针初始化需要使用malloc申请动态内存 123456789101112char *p = NULL; p=(char *)malloc(100); if(NULL == p)&#123; printf(&quot;Memory Allocated at: %x\\n&quot;,p); &#125;else&#123; printf(&quot;Not Enough Memory!\\n&quot;); &#125; free(p); p = NULL; //这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题 结构体初始化1234567891011121314typedef struct student&#123; int id; char name[20]; char sex;&#125;STU;STU stu1;memset((char *)&amp;stu1, 0, sizeof(stu1));// struct tm * tmp_time;// memset(tmp_time, 0, sizeof(struct tm));// task_send_data task_data;// task_rcv_data rcv_data;// memset(&amp;task_data, 0, sizeof(task_data));// memset(&amp;rcv_data, 0, sizeof(rcv_data)); 注意初始化结构体数组时 12345STU stus[10];memset((char *)&amp;stus, 0, sizeof(stus)); //正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度memset((char *)&amp;stus, 0, sizeof(STU)); //错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化memset((char *)&amp;stus, 0, sizeof(STU)*10); //正确，效果与第一个是一样的memset((char *)&amp;stu1, 0x00, sizeof(stu1)); //正确,效果与第一个是一样的","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"嵌入式相关的开源项目","slug":"嵌入式相关开源项目","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T08:22:56.607Z","comments":true,"path":"2021/11/01/嵌入式相关开源项目/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"参考网址:https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw 1.Avem这是一个轻量级无人机飞控项目。 2.Awesome-Embedded这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源： 3.soft-and-hard这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。 4.FreeModbusFreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要收费的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。 5. EmbedSummary精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"时间触发嵌入式系统设计模式","slug":"时间片调度","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:13:36.281Z","comments":true,"path":"2021/11/01/时间片调度/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/","excerpt":"","text":"参考网址:时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式 SimpleTimer [Linux下C实现的自定义定时器](voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)) [CppTimer](berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)) [simple-timer-for-c-language](ielife/simple-timer-for-c-language: high performance timer for linux (github.com)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// main.c// GPIO_LED : GPIO output to control an on-board red LED// // EVB : Nu-LB-NUC140// MCU : NUC140VE3CN// low-active output control by GPC12#include &lt;stdio.h&gt;#include &quot;NUC100Series.h&quot;#include &quot;MCU_init.h&quot;#include &quot;SYS_init.h&quot;#include &quot;scheduler.h&quot;extern void SCH_Init(void) ; extern void SCH_Update(void) ;void SysTick_Handler(void)&#123; SCH_Update(); &#125;void InitSysTickClk()&#123; SCH_Init(); SysTick-&gt;LOAD = 1000 *CyclesPerUs -1; SysTick-&gt;VAL = (0x00); NVIC_EnableIRQ(SysTick_IRQn); SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk; &#125;void LED_Flash_Update(void)&#123; GPIO_TOGGLE(PC14); &#125;void LED_Flash_UpdateD(void)&#123; GPIO_TOGGLE(PC12); &#125;int main(void)&#123; SYS_Init(); UART_Open(UART0, 115200); printf(&quot;Hello World \\r\\n&quot;); GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT); GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT); GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT); InitSysTickClk(); SCH_Add_Task(LED_Flash_Update, 0, 1000); SCH_Add_Task(LED_Flash_UpdateD, 0, 2000); while(1) &#123; SCH_Dispatch_Tasks(); &#125; &#125; 12345678910111213141516171819202122// scheduler.h#ifndef _SCHEDULER_H#define _SCHEDULER_H// ------ 公用的函数原型 -------------------------------// 调度器内核函数void SCH_Dispatch_Tasks(void);unsigned char SCH_Add_Task(void (*) (void), const unsigned int, const unsigned int); unsigned char SCH_Delete_Task(const unsigned char);void SCH_Report_Status(void);// ------ 公用的常数 -----------------------------------------// 在程序的运行期间任一时刻请求的任务最大数目// 在程序的运行期间// 每个新建项目都必须调整#define SCH_MAX_TASKS (3) #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389// scheduler.c/*------------------------------------------------------------------*- SCH51.C (v1.00) ------------------------------------------------------------------ /// 这里是调度器内核函数 /// *** 这里是调度器内核函数 *** --- 这些函数可以用于所有 8051 芯片 --- *** hSCH_MAX_TASKS 必须由用户设置 *** --- 参见 &quot;Sch51.h&quot; --- *** 包括省电模式*** --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----） --- 诸如 c515c, c509,等等才需要 ----*------------------------------------------------------------------*/#include &quot;scheduler.h&quot;typedef unsigned char tByte;typedef unsigned int tWord;typedef unsigned long tLong;#define ERROR_SCH_TOO_MANY_TASKS (1)#define ERROR_SCH_CANNOT_DELETE_TASK (2)#define ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)#define ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)#define ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)#define ERROR_SCH_LOST_SLAVE (5)#define ERROR_SCH_CAN_BUS_ERROR (6)#define ERROR_I2C_WRITE_BYTE (10)#define ERROR_I2C_READ_BYTE (11)#define ERROR_I2C_WRITE_BYTE_AT24C64 (12)#define ERROR_I2C_READ_BYTE_AT24C64 (13)#define ERROR_I2C_DS1621 (14)#define ERROR_USART_TI (21)#define ERROR_USART_WRITE_CHAR (22)#define ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)#define ERROR_SPI_X25_TIMEOUT (32)#define ERROR_SPI_MAX1110_TIMEOUT (33)#define ERROR_ADC_MAX150_TIMEOUT (44)#define RETURN_NORMAL 0#define RETURN_ERROR 1// ------ 公用变量定义 ------------------------------// ------ 公用数据类型声明 ----------------------------// 如果可能的话，存储在 DATA 区, 以供快速存取 // 每个任务的存储器总和是 7个字节typedef struct &#123; // 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数) void (* pTask)(void); //延迟 (时标) 直到函数将 (下一次) 运行 // - 详细说明参见 SCH_Add_Task() unsigned int Delay; // 在连续的运行之间的间隔 (时标) // - 详细说明参见 SCH_Add_Task() unsigned int Period; // 当任务需要运行时 (由调度器) 加1 unsigned char RunMe; &#125; sTask; // 任务队列sTask SCH_tasks_G[SCH_MAX_TASKS];// 用来显示错误代码// 错误代码的详细资料参见 Main.H // 关于错误端口的详细资料参见 Port.H unsigned char Error_code_G = 0;// ------ 私有函数原型 ------------------------------static void SCH_Go_To_Sleep(void);// ------ 私有变量 ----------------------------------------// 跟踪自从上一次记录错误以来的时间 (见下文)static unsigned int Error_tick_count_G;// 上次的错误代码 (在1分钟之后复位)static unsigned char Last_error_code_G;/*------------------------------------------------------------------*- SCH_Dispatch_Tasks() 这是“调度”函数. 当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它. 这个函数必须被主循环 (重复)调用.-*------------------------------------------------------------------*/void SCH_Dispatch_Tasks(void) &#123; unsigned char Index; // 调度 (运行) 下一个任务 (如果有任务就绪) for (Index = 0; Index &lt; SCH_MAX_TASKS; Index++) &#123; if (SCH_tasks_G[Index].RunMe &gt; 0) &#123; (*SCH_tasks_G[Index].pTask)(); // 运行任务 SCH_tasks_G[Index].RunMe -= 1; // RunMe 标志复位/减1 // 周期性的任务将自动的再次运行 // - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除 if (SCH_tasks_G[Index].Period == 0) &#123; SCH_Delete_Task(Index); &#125; &#125; &#125; // 报告系统状况 SCH_Report_Status(); // 这里调度器进行空闲模式 SCH_Go_To_Sleep(); &#125;/*------------------------------------------------------------------*- SCH_Add_Task() 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行 Fn_P - 将被调度的函数的名称. 注意: 所有被调度的函数必须是 &#x27;void, void&#x27; - 即函数没有参数, 并且返回类型为 void DELAY - 在任务第一次被运行之前的间隔（时标） PERIOD - &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次. &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些） //PERIOD 返回值 : 返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中 (空间不够). 如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。 注意: 如果以后要删除任务, 将需要这个返回值，参见 SCH_Delete_Task(). 例子: Task_ID = SCH_Add_Task(Do_X,1000,0,0); 使函数 Do_X() 在1000 个调度器时标之后运行一次 Task_ID = SCH_Add_Task(Do_X,0,1000,1); 使函数 Do_X() 每隔1000 个调度器时标运行一次 Task_ID = SCH_Add_Task(Do_X,300,1000,0); 使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标， 2300个时标 ，等等 -*------------------------------------------------------------------*/unsigned char SCH_Add_Task(void (* pFunction)(), const unsigned int DELAY, const unsigned int PERIOD) &#123; unsigned char Index = 0; // 首先在队列中找到一个空隙(如果有的话) while ((SCH_tasks_G[Index].pTask != 0) &amp;&amp; (Index &lt; SCH_MAX_TASKS)) &#123; Index++; &#125; // 是否已经到达队列的结尾 ？？ if (Index == SCH_MAX_TASKS) &#123; // 任务队列已满 // // 设置全局错误变量 Error_code_G = ERROR_SCH_TOO_MANY_TASKS; // 同时返回错误代码 return SCH_MAX_TASKS; &#125; // 如果能运行到这里，说明任务队列中有空间 SCH_tasks_G[Index].pTask = pFunction; SCH_tasks_G[Index].Delay = DELAY; SCH_tasks_G[Index].Period = PERIOD; SCH_tasks_G[Index].RunMe = 0; return Index; // 返回任务的位置 (以便以后删除) &#125;/*------------------------------------------------------------------*- SCH_Delete_Task() 从调度器删除任务. 注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 参数: TASK_INDEX - 任务索引. 由 SCH_Add_Task()提供. 返回值: RETURN_ERROR or RETURN_NORMAL-*------------------------------------------------------------------*/unsigned char SCH_Delete_Task(const tByte TASK_INDEX) &#123; unsigned char Return_code; if (SCH_tasks_G[TASK_INDEX].pTask == 0) &#123; // 这里没有任务 // // 设置全局错误变量 Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK; // ...同时返回错误代码 Return_code = RETURN_ERROR; &#125; else &#123; Return_code = RETURN_NORMAL; &#125; SCH_tasks_G[TASK_INDEX].pTask = 0x0000; SCH_tasks_G[TASK_INDEX].Delay = 0; SCH_tasks_G[TASK_INDEX].Period = 0; SCH_tasks_G[TASK_INDEX].RunMe = 0; return Return_code; // 返回状态 &#125;/*------------------------------------------------------------------*- SCH_Report_Status() 用来显示错误代码的简单的函数. 这个版本将在连接到端口的LED上显示错误代码， 如果需要的话，可以修改为通过串行连接等方式报告错误。 错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。). 此后错误代码被复位为0. 这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。 更加详尽的资料参见第10章。-*------------------------------------------------------------------*/void SCH_Report_Status(void) &#123;#ifdef SCH_REPORT_ERRORS // 只在需要报告错误时适用 // 检查新的错误代码 if (Error_code_G != Last_error_code_G) &#123; // 假定LED采用负逻辑 Error_port = 255 - Error_code_G; Last_error_code_G = Error_code_G; if (Error_code_G != 0) &#123; Error_tick_count_G = 60000; &#125; else &#123; Error_tick_count_G = 0; &#125; &#125; else &#123; if (Error_tick_count_G != 0) &#123; if (--Error_tick_count_G == 0) &#123; Error_code_G = 0; // 复位错误代码 &#125; &#125; &#125;#endif &#125;/*------------------------------------------------------------------*- SCH_Go_To_Sleep() 本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。 注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。 然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计 调度器的性能。这方面的例子参见第14章。 *** 如果使用看门狗的话，可能需要禁止这个功能 *** *** 根据硬件的需要修改 ***-*------------------------------------------------------------------*/void SCH_Go_To_Sleep() &#123; &#125; /*------------------------------------------------------------------*- SCH_Update 中断调用 这是调度器的中断服务程序. 初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。 这个版本由定时器1中断触发 -*------------------------------------------------------------------*/void SCH_Update(void) &#123; tByte Index; // 重装定时器 // 注意：计算单位为“时标”（不是毫秒） for (Index = 0; Index &lt; SCH_MAX_TASKS; Index++) &#123; // 检测这里是否有任务 if (SCH_tasks_G[Index].pTask) &#123; if (SCH_tasks_G[Index].Delay == 0) &#123; // 任务需要运行 SCH_tasks_G[Index].RunMe += 1; // &#x27;RunMe&#x27; 标志加1 if (SCH_tasks_G[Index].Period) &#123; // 调度定期的任务再次运行 SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period; &#125; &#125; else &#123; //还没有准备好运行，延迟减 1 SCH_tasks_G[Index].Delay -= 1; &#125; &#125; &#125; &#125; void SCH_Init(void) &#123; unsigned char i; for (i = 0; i &lt; SCH_MAX_TASKS; i++) &#123; SCH_Delete_Task(i); &#125; // 复位全局错误变量 // - SCH_Delete_Task() 将产生一个错误代码 // (因为任务队列是空的) Error_code_G = 0; &#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"注释软件","slug":"注释软件","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:07:34.012Z","comments":true,"path":"2021/11/01/注释软件/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"参考网址:几款注释软件推荐 javEhttp://www.jave.de/ 里边的字体,图片生成挺有意思,不过需要装java 原理图https://josoansi.de/download.php 流程图ascii-art 有很多有意思的注释,可知看一下直接复制粘贴,很舒爽 CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject 类似于”Visio”的一款工具","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"回调函数","slug":"回调函数","date":"2021-10-29T04:30:12.000Z","updated":"2021-10-29T10:23:09.856Z","comments":true,"path":"2021/10/29/回调函数/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"参考网站c语言回调函数 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/**************************************** * 函数指针结构体 ***************************************/typedef struct _OP &#123; float (*p_add)(float, float); float (*p_sub)(float, float); float (*p_mul)(float, float); float (*p_div)(float, float); &#125; OP; /**************************************** * 加减乘除函数 ***************************************/float ADD(float a, float b) &#123; return a + b;&#125;float SUB(float a, float b) &#123; return a - b;&#125;float MUL(float a, float b) &#123; return a * b;&#125;float DIV(float a, float b) &#123; return a / b;&#125;/**************************************** * 初始化函数指针 ***************************************/void init_op(OP *op)&#123; op-&gt;p_add = ADD; op-&gt;p_sub = SUB; op-&gt;p_mul = &amp;MUL; op-&gt;p_div = &amp;DIV;&#125;/**************************************** * 库函数 ***************************************/float add_sub_mul_div(float a, float b, float (*op_func)(float, float))&#123; return (*op_func)(a, b);&#125;int main(int argc, char *argv[]) &#123; OP *op = (OP *)malloc(sizeof(OP)); init_op(op); /* 直接使用函数指针调用函数 */ printf(&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\\n&quot;, (op-&gt;p_add)(1.3, 2.2), (*op-&gt;p_sub)(1.3, 2.2), (op-&gt;p_mul)(1.3, 2.2), (*op-&gt;p_div)(1.3, 2.2)); /* 调用回调函数 */ printf(&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\\n&quot;, add_sub_mul_div(1.3, 2.2, ADD), add_sub_mul_div(1.3, 2.2, SUB), add_sub_mul_div(1.3, 2.2, MUL), add_sub_mul_div(1.3, 2.2, DIV)); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"局部全局坐标转换","slug":"局部全局坐标转换","date":"2021-10-29T04:30:12.000Z","updated":"2021-10-29T10:24:19.049Z","comments":true,"path":"2021/10/29/局部全局坐标转换/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"局部全局坐标转换模型 公式: ROS 中里程计的计算代码理解12345678double dt = (current_time - last_time).toSec();double delta_x = (vx * cos(th) - vy * sin(th)) * dt;double delta_y = (vx * sin(th) + vy * cos(th)) * dt;double delta_th = vth * dt;x += delta_x;y += delta_y;th += delta_th;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"概率机器人","slug":"概率机器人","date":"2021-10-28T04:30:12.000Z","updated":"2021-10-28T12:14:44.215Z","comments":true,"path":"2021/10/28/概率机器人/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"参考网址:概率机器人 5.机器人运动模型速度模型(概率运动规划)闭式算法 采样算法 数学推导精确运动 真实运动加入扰动,模型表达为 加入噪声,求得概率公式为: 里程计模型(估计)模型为: 闭式算法 采样算法 数学推导三次转换: 加入噪声: 求出坐标: 求得最终概率:","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"STL库","slug":"STL","date":"2021-10-28T04:30:12.000Z","updated":"2021-10-28T13:39:17.249Z","comments":true,"path":"2021/10/28/STL/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/28/STL/","excerpt":"","text":"参考网址:C++中STL用法超详细总结 MyTinySTL STL中六大组件：容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；仿函数（Functor）适配器（Adaptor）分配器（allocator） 2.1 容器STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list； Vector：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时； Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时； List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。 Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找； Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。 2.2 STL迭代器Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator. 2.3 算法STL中算法大致分为四类：非可变序列算法：指不直接修改其所操作的容器内容的算法。可变序列算法：指可以修改它们所操作的容器内容的算法。排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。数值算法：对容器内容进行数值计算。以下对所有算法进行细致分类并标明功能： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的 一个InputIterator。find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一 个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代 替等于操作。find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使 用了用户自定义操作符。find_if: 使用输入的函数代替等于操作符执行find。lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函 数使用自定义比较操作。upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志 一个大于value的值。重载函数使用自定义比较操作。search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位 置，查找失败指向last1。重载版本使用自定义的比较操作。search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重 载版本使用自定义的比较操作。partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。reverse: 将指定范围内元素重新反序排序。reverse_copy: 与reverse类似，不过将结果写入另一个容器。rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。rotate_copy: 与rotate类似，不过将结果写入另一个容器。sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个)copy: 复制序列copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。iter_swap: 交换两个ForwardIterator的值。remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和 remove_if函数。remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。remove_if: 删除指定范围内输入操作结果为true的所有元素。remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。replace: 将指定范围内所有等于vold的元素都用vnew代替。replace_copy: 与replace类似，不过将结果写入另一个容器。replace_if: 将指定范围内所有操作结果为true的元素用新值代替。replace_copy_if: 与replace_if，不过将结果写入另一个容器。swap: 交换存储在两个对象中的值。swap_range: 将指定范围内的元素与另一个序列元素值进行交换。unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。fill_n: 将输入值赋给first到first+n范围内的所有元素。for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。generate: 连续调用输入的函数来填充指定的范围。generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。max: 返回两个元素中较大一个。重载版本使用自定义比较操作。max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。min: 返回两个元素中较小一个。重载版本使用自定义比较操作。min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用 自定义的比较操作。set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 2.4 仿函数2.4.1 概述 仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。 有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。 1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。 2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。 2.4.2 仿函数(functor)在编程语言中的应用1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int sort_function( const void *a, const void *b);int sort_function( const void *a, const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; int list[5] = &#123; 54, 21, 11, 67, 22 &#125;; qsort((void *)list, 5, sizeof(list[0]), sort_function);//起始地址，个数，元素大小，回调函数 int x; for (x = 0; x &lt; 5; x++) printf(&quot;%i\\n&quot;, list[x]); return 0;&#125; 2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; for_each(ia, ia + 5, display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 2.4.3 仿函数在STL中的定义要使用STL内建的仿函数，必须包含头文件。而头文件中包含的仿函数分类包括 1）算术类仿函数 加：plus&lt;T&gt; 减：minus&lt;T&gt; 乘：multiplies&lt;T&gt; 除：divides&lt;T&gt; 模取：modulus&lt;T&gt; 否定：negate&lt;T&gt; 例子： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;vector&gt; #include &lt;functional&gt; using namespace std;int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; vector&lt;int&gt; iv(ia, ia + 5); //120 cout &lt;&lt; accumulate(iv.begin(), iv.end(), 1, multiplies&lt;int&gt;()) &lt;&lt; endl; //15 cout &lt;&lt; multiplies&lt;int&gt;()(3, 5) &lt;&lt; endl; modulus&lt;int&gt; modulusObj; cout &lt;&lt; modulusObj(3, 5) &lt;&lt; endl; // 3 system(&quot;pause&quot;); return 0;&#125; 2）关系运算类仿函数 等于：equal_to&lt;T&gt; 不等于：not_equal_to&lt;T&gt; 大于：greater&lt;T&gt; 大于等于：greater_equal&lt;T&gt; 小于：less&lt;T&gt; 小于等于：less_equal&lt;T&gt; 从大到小排序： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;functional&gt;#include &lt;vector&gt; using namespace std;template &lt;class T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,5,4,3,2 &#125;; vector&lt;int&gt; iv(ia, ia + 5); sort(iv.begin(), iv.end(), greater&lt;int&gt;()); for_each(iv.begin(), iv.end(), display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 3）逻辑运算仿函数 逻辑与：logical_and&lt;T&gt; 逻辑或：logical_or&lt;T&gt; 逻辑否：logical_no&lt;T&gt; 除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结 2.5 容器适配器标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈) 什么是容器适配器 ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack&lt;int, vector &gt;实现了栈的功能，但其内部使用顺序容器vector来存储数据。（相当于是vector表现出 了栈的行为）。 容器适配器 要使用适配器，需要加入一下头文件： #include &lt;stack&gt; //stack #include&lt;queue&gt; //queue、priority_queue 种类 默认顺序容器 可用顺序容器 说明stack deque vector、list、dequequeue deque list、deque 基础容器必须提供push_front()运算priority_queue vector vector、deque 基础容器必须提供随机访问功能定义适配器 1、初始化 stack&lt;int&gt; stk(dep); 2、覆盖默认容器类型 stack&lt;int,vector&lt;int&gt; &gt; stk; 使用适配器 2.5.1 stackstack s;stack&lt; int, vector &gt; stk; //覆盖基础容器类型，使用vector实现stks.empty(); //判断stack是否为空，为空返回true，否则返回falses.size(); //返回stack中元素的个数s.pop(); //删除栈顶元素，但不返回其值s.top(); //返回栈顶元素的值，但不删除此元素s.push(item); //在栈顶压入新元素item实例：括号匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;int main()&#123; string s; stack&lt;char&gt; ss; while (cin &gt;&gt; s) &#123; bool flag = true; for (char c : s) //C++11新标准，即遍历一次字符串s &#123; if (c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27;) &#123; ss.push(c); continue; &#125; if (c == &#x27;&#125;&#x27;) &#123; if (!ss.empty() &amp;&amp; ss.top() == &#x27;&#123;&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;]&#x27;) &#123; if (ss.top() == &#x27;[&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;)&#x27;) &#123; if (ss.top() == &#x27;(&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; &#125; if (flag) cout &lt;&lt; &quot;Match!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Not Match!&quot; &lt;&lt; endl; &#125;&#125; 2.5.2 queue &amp; priority_queuequeue q; //priority_queue q;q.empty(); //判断队列是否为空q.size(); //返回队列长度q.push(item); //对于queue，在队尾压入一个新元素 //对于priority_queue，在基于优先级的适当位置插入新元素 //queue only:q.front(); //返回队首元素的值，但不删除该元素q.back(); //返回队尾元素的值，但不删除该元素 //priority_queue only:q.top(); //返回具有最高优先级的元素值，但不删除该元素 常用容器用法介绍vector基本函数实现1.构造函数vector():创建一个空vectorvector(int nSize):创建一个vector,元素个数为nSizevector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为tvector(const vector&amp;):复制构造函数vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数void push_back(const T&amp; x):向量尾部增加一个元素Xiterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素xiterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素xiterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数iterator erase(iterator it):删除向量中迭代器指向元素iterator erase(iterator first,iterator last):删除向量中[first,last)中元素void pop_back():删除向量中最后一个元素void clear():清空向量中所有元素 4.遍历函数reference at(int pos):返回pos位置元素的引用reference front():返回首元素的引用reference back():返回尾元素的引用iterator begin():返回向量头指针，指向第一个元素iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置reverse_iterator rbegin():反向迭代器，指向最后一个元素reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数int size() const:返回向量中元素的个数int capacity() const:返回当前向量张红所能容纳的最大元素值int max_size() const:返回最大可允许的vector元素数量值 7.其他函数void swap(vector&amp;):交换两个同类型向量的数据void assign(int n,const T&amp; x):设置向量中第n个元素的值为xvoid assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 8.看着清楚1.push_back 在数组的最后添加一个数据 2.pop_back 去掉数组的最后一个数据 3.at 得到编号位置的数据 4.begin 得到数组头的指针 5.end 得到数组的最后一个单元+1的指针 6．front 得到数组头的引用 7.back 得到数组的最后一个单元的引用 8.max_size 得到vector最大可以是多大 9.capacity 当前vector分配的大小 10.size 当前使用数据的大小 11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 12.reserve 改变当前vecotr所分配空间的大小 13.erase 删除指针指向的数据项 14.clear 清空当前的vector 15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) 16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1) 17.empty 判断vector是否为空 18.swap 与另一个vector交换数据 基本用法#include &lt; vector&gt;using namespace std; 简单介绍Vector&lt;类型&gt;标识符Vector&lt;类型&gt;标识符(最大容量)Vector&lt;类型&gt;标识符(最大容量,初始所有值)Int i[5]={1,2,3,4,5}Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过 实例3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据1234567891011121314151617181920212223242526272829#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj;//创建一个向量存储容器 int for(int i=0;i&lt;10;i++) // push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; for(int i=0;i&lt;5;i++)//去掉数组最后一个数据 &#123; obj.pop_back(); &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++)//size()容器中实际数据个数 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 1230,1,2,3,4,5,6,7,8,9,0,1,2,3,4, clear()清除容器中所有数据1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++)//push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; obj.clear();//清除容器中所以数据 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;endl; &#125; return 0;&#125; 输出结果为： 10,1,2,3,4,5,6,7,8,9, 排序123456789101112131415161718192021222324252627282930313233#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; obj.push_back(1); obj.push_back(3); obj.push_back(0); sort(obj.begin(),obj.end());//从小到大 cout&lt;&lt;&quot;从小到大:&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; cout&lt;&lt;&quot;从大到小:&quot;&lt;&lt;endl; reverse(obj.begin(),obj.end());//从大到小 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 12345从小到大:0,1,3,从大到小:3,1,0, 1.注意 sort 需要头文件 #include 2.如果想 sort 来降序，可重写 sort bool compare(int a,int b){ return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序}int a[20]={2,4,1,23,5,76,0,43,24,65},i;for(i=0;i&lt;20;i++) cout&lt;&lt; a[i]&lt;&lt; endl;sort(a,a+20,compare); 访问（直接数组访问&amp;迭代器访问）1234567891011121314151617181920212223242526272829303132#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; //顺序访问 vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++) &#123; obj.push_back(i); &#125; cout&lt;&lt;&quot;直接利用数组：&quot;; for(int i=0;i&lt;10;i++)//方法一 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;利用迭代器：&quot; ; //方法二，使用迭代器将容器中数据输出 vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for(it=obj.begin();it!=obj.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 输出结果为： 12直接利用数组：0 1 2 3 4 5 6 7 8 9 利用迭代器：0 1 2 3 4 5 6 7 8 9 二维数组两种定义方法（结果一样）方法一 123456789101112131415161718192021222324252627#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N); //定义二维动态数组大小5行 for(int i =0; i&lt; obj.size(); i++)//动态二维数组为5行6列，值全为0 &#123; obj[i].resize(M); &#125; for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 方法二 1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 输出结果为： 1234560 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3.2 deque 所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。 deque#include // 头文件deque deq; // 声明一个元素类型为type的双端队列quedeque deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque deq(mydeque); // deq是mydeque的一个副本deque deq(first, last); // 使用迭代器first、last范围内的元素初始化deq deque的常用成员函数deque deq;deq[ ]：用来访问双向队列中单个的元素。deq.front()：返回第一个元素的引用。deq.back()：返回最后一个元素的引用。deq.push_front(x)：把元素x插入到双向队列的头部。deq.pop_front()：弹出双向队列的第一个元素。deq.push_back(x)：把元素x插入到双向队列的尾部。deq.pop_back()：弹出双向队列的最后一个元素。 deque的一些特点支持随机访问，即支持[ ]以及at()，但是性能没有vector好。可以在内部进行插入和删除操作，但性能不及list。deque两端都能够快速插入和删除元素，而vector只能在尾端进行。deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。deque不支持对容量和内存分配时机的控制。在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。deque不提供容量操作：capacity()和reverse()，但是vector可以。 实例12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;deque&gt;using namespace std;int main(void)&#123; int i; int a[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; deque&lt;int&gt; q; for (i = 0; i &lt;= 9; i++) &#123; if (i % 2 == 0) q.push_front(a[i]); else q.push_back(a[i]); &#125; /*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/ q.pop_front(); printf(&quot;%d\\n&quot;, q.front()); /*清除第一个元素后输出第一个(6)*/ q.pop_back(); printf(&quot;%d\\n&quot;, q.back()); /*清除最后一个元素后输出最后一个(7)*/ deque&lt;int&gt;::iterator it; for (it = q.begin(); it != q.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &#x27;\\t&#x27;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 输出结果： listlist定义List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件 #include list定义和初始化123456789list&lt;int&gt;lst1; //创建空listlist&lt;int&gt; lst2(5); //创建含有5个元素的listlist&lt;int&gt;lst3(3,2); //创建含有3个元素的listlist&lt;int&gt;lst4(lst2); //使用lst2初始化lst4list&lt;int&gt;lst5(lst2.begin(),lst2.end()); //同lst4 list常用操作函数Lst1.assign() 给list赋值Lst1.back() 返回最后一个元素Lst1.begin() 返回指向第一个元素的迭代器Lst1.clear() 删除所有元素Lst1.empty() 如果list是空的则返回trueLst1.end() 返回末尾的迭代器Lst1.erase() 删除一个元素Lst1.front() 返回第一个元素Lst1.get_allocator() 返回list的配置器Lst1.insert() 插入一个元素到list中Lst1.max_size() 返回list能容纳的最大元素数量Lst1.merge() 合并两个listLst1.pop_back() 删除最后一个元素Lst1.pop_front() 删除第一个元素Lst1.push_back() 在list的末尾添加一个元素Lst1.push_front() 在list的头部添加一个元素Lst1.rbegin() 返回指向第一个元素的逆向迭代器Lst1.remove() 从list删除元素Lst1.remove_if() 按指定条件删除元素Lst1.rend() 指向list末尾的逆向迭代器Lst1.resize() 改变list的大小Lst1.reverse() 把list的元素倒转Lst1.size() 返回list中的元素个数Lst1.sort() 给list排序Lst1.splice() 合并两个listLst1.swap() 交换两个listLst1.unique() 删除list中相邻重复的元素 List使用实例迭代器遍历list12345for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++) &#123; cout&lt;&lt;*iter; &#125; cout&lt;&lt;endl; 综合实例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;using namespace std;typedef list&lt;int&gt; LISTINT;typedef list&lt;int&gt; LISTCHAR;void main()&#123; //用LISTINT创建一个list对象 LISTINT listOne; //声明i为迭代器 LISTINT::iterator i; listOne.push_front(3); listOne.push_front(2); listOne.push_front(1); listOne.push_back(4); listOne.push_back(5); listOne.push_back(6); cout &lt;&lt; &quot;listOne.begin()--- listOne.end():&quot; &lt;&lt; endl; for (i = listOne.begin(); i != listOne.end(); ++i) cout &lt;&lt; *i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; LISTINT::reverse_iterator ir; cout &lt;&lt; &quot;listOne.rbegin()---listOne.rend():&quot; &lt;&lt; endl; for (ir = listOne.rbegin(); ir != listOne.rend(); ir++) &#123; cout &lt;&lt; *ir &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; int result = accumulate(listOne.begin(), listOne.end(), 0); cout &lt;&lt; &quot;Sum=&quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl; //用LISTCHAR创建一个list对象 LISTCHAR listTwo; //声明i为迭代器 LISTCHAR::iterator j; listTwo.push_front(&#x27;C&#x27;); listTwo.push_front(&#x27;B&#x27;); listTwo.push_front(&#x27;A&#x27;); listTwo.push_back(&#x27;D&#x27;); listTwo.push_back(&#x27;E&#x27;); listTwo.push_back(&#x27;F&#x27;); cout &lt;&lt; &quot;listTwo.begin()---listTwo.end():&quot; &lt;&lt; endl; for (j = listTwo.begin(); j != listTwo.end(); ++j) cout &lt;&lt; char(*j) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; j = max_element(listTwo.begin(), listTwo.end()); cout &lt;&lt; &quot;The maximum element in listTwo is: &quot; &lt;&lt; char(*j) &lt;&lt; endl; system(&quot;pause&quot;);&#125; 输出结果 综合实例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt; #include &lt;list&gt; using namespace std;typedef list&lt;int&gt; INTLIST;//从前向后显示list队列的全部元素 void put_list(INTLIST list, char *name)&#123; INTLIST::iterator plist; cout &lt;&lt; &quot;The contents of &quot; &lt;&lt; name &lt;&lt; &quot; : &quot;; for (plist = list.begin(); plist != list.end(); plist++) cout &lt;&lt; *plist &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;//测试list容器的功能 void main(void)&#123; //list1对象初始为空 INTLIST list1; INTLIST list2(5, 1); INTLIST list3(list2.begin(), --list2.end()); //声明一个名为i的双向迭代器 INTLIST::iterator i; put_list(list1, &quot;list1&quot;); put_list(list2, &quot;list2&quot;); put_list(list3, &quot;list3&quot;); list1.push_back(7); list1.push_back(8); cout &lt;&lt; &quot;list1.push_back(7) and list1.push_back(8):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.push_front(6); list1.push_front(5); cout &lt;&lt; &quot;list1.push_front(6) and list1.push_front(5):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.insert(++list1.begin(), 3, 9); cout &lt;&lt; &quot;list1.insert(list1.begin()+1,3,9):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); //测试引用类函数 cout &lt;&lt; &quot;list1.front()=&quot; &lt;&lt; list1.front() &lt;&lt; endl; cout &lt;&lt; &quot;list1.back()=&quot; &lt;&lt; list1.back() &lt;&lt; endl; list1.pop_front(); list1.pop_back(); cout &lt;&lt; &quot;list1.pop_front() and list1.pop_back():&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.erase(++list1.begin()); cout &lt;&lt; &quot;list1.erase(++list1.begin()):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list2.assign(8, 1); cout &lt;&lt; &quot;list2.assign(8,1):&quot; &lt;&lt; endl; put_list(list2, &quot;list2&quot;); cout &lt;&lt; &quot;list1.max_size(): &quot; &lt;&lt; list1.max_size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.size(): &quot; &lt;&lt; list1.size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.empty(): &quot; &lt;&lt; list1.empty() &lt;&lt; endl; put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); cout &lt;&lt; &quot;list1&gt;list3: &quot; &lt;&lt; (list1 &gt; list3) &lt;&lt; endl; cout &lt;&lt; &quot;list1&lt;list3: &quot; &lt;&lt; (list1 &lt; list3) &lt;&lt; endl; list1.sort(); put_list(list1, &quot;list1&quot;); list1.splice(++list1.begin(), list3); put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); system(&quot;pause&quot;);&#125; 输出结果： map/multimapmap和multimap都需要#include，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。 C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。 Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 基本操作函数12345678910111213141516171819202122232425262728293031323334353637begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数 声明1234//头文件#include&lt;map&gt;map&lt;int, string&gt; ID_Name; // 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012 1234map&lt;int, string&gt; ID_Name = &#123; &#123; 2015, &quot;Jim&quot; &#125;, &#123; 2016, &quot;Tom&quot; &#125;, &#123; 2017, &quot;Bob&quot; &#125; &#125;; 迭代器共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。 二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示： 123456789map&lt;int,int&gt;::iterator it;map&lt;int,int&gt; mmap;const map&lt;int,int&gt; const_mmap;it = mmap.begin(); //iteratormmap.cbegin(); //const_iteratorconst_mmap.begin(); //const_iteratorconst_mmap.cbegin(); //const_iterator 返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。 插入操作用insert插入pair数据//数据的插入–第一种：用insert函数插入pair数据 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 用insert函数插入value_type数据//第二种：用insert函数插入value_type数据，下面举例说明 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125; 用insert函数进行多个插入insert共有4个重载函数： // 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败pair&lt;iterator,bool&gt; insert (const value_type&amp; val); //在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排iterator insert (const_iterator position, const value_type&amp; val); // 插入多个void insert (InputIterator first, InputIterator last); //c++11开始支持，使用列表插入多个void insert (initializer_list il);下面是具体使用示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;map&gt;int main()&#123; std::map&lt;char, int&gt; mymap; // 插入单个值 mymap.insert(std::pair&lt;char, int&gt;(&#x27;a&#x27;, 100)); mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 200)); //返回插入位置以及是否插入成功 std::pair&lt;std::map&lt;char, int&gt;::iterator, bool&gt; ret; ret = mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 500)); if (ret.second == false) &#123; std::cout &lt;&lt; &quot;element &#x27;z&#x27; already existed&quot;; std::cout &lt;&lt; &quot; with a value of &quot; &lt;&lt; ret.first-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; //指定位置插入 std::map&lt;char, int&gt;::iterator it = mymap.begin(); mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;b&#x27;, 300)); //效率更高 mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;c&#x27;, 400)); //效率非最高 //范围多值插入 std::map&lt;char, int&gt; anothermap; anothermap.insert(mymap.begin(), mymap.find(&#x27;c&#x27;)); // 列表形式插入 anothermap.insert(&#123; &#123; &#x27;d&#x27;, 100 &#125;, &#123;&#x27;e&#x27;, 200&#125; &#125;); return 0;&#125; 用数组方式插入数据//第三种：用数组方式插入数据，下面举例说明 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[2] = &quot;student_two&quot;; mapStudent[3] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明 123mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;)); 上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下 123pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); 我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。 下面给出完成代码，演示插入成功与否问题 //验证插入函数的作用效果 1234567891011121314151617181920212223#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_two&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 大家可以用如下程序，看下用数组插入在数据覆盖上的效果 //验证数组形式插入数据的效果 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[1] = &quot;student_two&quot;; mapStudent[2] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 查找、删除、交换查找 // 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器// 根据map的类型，返回的迭代器为 iterator 或者 const_iteratoriterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; 删除 // 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器iterator erase( iterator pos ) // 删除一定范围内的元素，并返回一个指向下一元素的迭代器iterator erase( const_iterator first, const_iterator last ); // 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1size_t erase( const key_type&amp; key ); // 清空map，清空后的size为0void clear();交换 // 就是两个map的内容互换void swap( map&amp; other ); 容量// 查询map是否为空bool empty(); // 查询map中键值对的数量size_t size(); // 查询map所能包含的最大键值对数量，和系统和应用库有关。// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了size_t max_size(); // 查询关键字为key的元素的个数，在map里结果非0即1size_t count( const Key&amp; key ) const; // 排序map中的元素是自动按Key升序排序，所以不能对map用sort函数； 这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。 小于号 &lt; 重载12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std;typedef struct tagStudentinfo&#123; int niD; string strName; bool operator &lt; (tagStudentinfo const&amp; _A) const &#123; //这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序 if (niD &lt; _A.niD) return true; if (niD == _A.niD) return strName.compare(_A.strName) &lt; 0; return false; &#125;&#125;Studentinfo, *PStudentinfo; //学生信息 int main()&#123; int nSize; //用学生信息映射分数 map&lt;Studentinfo, int&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;&#125; 仿函数的应用，这个时候结构体中没有直接的小于号重载//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std;typedef struct tagStudentinfo&#123; int niD; string strName;&#125;Studentinfo, *PStudentinfo; //学生信息 class sort&#123;public: bool operator() (Studentinfo const &amp;_A, Studentinfo const &amp;_B) const &#123; if (_A.niD &lt; _B.niD) return true; if (_A.niD == _B.niD) return _A.strName.compare(_B.strName) &lt; 0; return false; &#125;&#125;;int main()&#123; //用学生信息映射分数 map&lt;Studentinfo, int, sort&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; system(&quot;pause&quot;);&#125; unordered_map在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？ map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。 unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。 还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。 最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。 至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。 set/multisetstd::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。 set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。 由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。 multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。 set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。 set常用成员函数 begin()–返回指向第一个元素的迭代器 clear()–清除所有元素 count()–返回某个值元素的个数 empty()–如果集合为空，返回true end()–返回指向最后一个元素的迭代器 equal_range()–返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 代码示例 以下代码涉及的内容：1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？ 2、set容器中，如何让元素类型为自定义类型？ 3、set容器的insert函数的返回值为什么类型？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;/* 仿函数CompareSet，在test02使用 */class CompareSet&#123;public: //从大到小排序 bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125; //从小到大排序 //bool operator()(int v1, int v2) //&#123; // return v1 &lt; v2; //&#125;&#125;;/* Person类，用于test03 */class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person);public: Person(string name, int age) &#123; mName = name; mAge = age; &#125;public: string mName; int mAge;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person)&#123; out &lt;&lt; &quot;name:&quot; &lt;&lt; person.mName &lt;&lt; &quot; age:&quot; &lt;&lt; person.mAge &lt;&lt; endl; return out;&#125;/* 仿函数ComparePerson,用于test03 */class ComparePerson&#123;public: //名字大的在前面，如果名字相同，年龄大的排前面 bool operator()(const Person &amp;p1, const Person &amp;p2) &#123; if (p1.mName == p2.mName) &#123; return p1.mAge &gt; p2.mAge; &#125; return p1.mName &gt; p2.mName; &#125;&#125;;/* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;void test01()&#123; //set容器默认从小到大排序 set&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //输出set PrintSet(s); //结果为:10 20 30 /* set的insert函数返回值为一个对组(pair)。 对组的第一个值first为set类型的迭代器： 1、若插入成功，迭代器指向该元素。 2、若插入失败，迭代器指向之前已经存在的元素 对组的第二个值seconde为bool类型： 1、若插入成功，bool值为true 2、若插入失败，bool值为false */ pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(40); if (true == ret.second) cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入成功&quot; &lt;&lt; endl; else cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入失败&quot; &lt;&lt; endl;&#125;void test02()&#123; /* 如果想让set容器从大到小排序，需要给set容 器提供一个仿函数,本例的仿函数为CompareSet */ set&lt;int, CompareSet&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印set PrintSet(s); //结果为:30,20,10&#125;void test03()&#123; /* set元素类型为Person，当set元素类型为自定义类型的时候 必须给set提供一个仿函数，用于比较自定义类型的大小， 否则无法通过编译 */ set&lt;Person,ComparePerson&gt; s; s.insert(Person(&quot;John&quot;, 22)); s.insert(Person(&quot;Peter&quot;, 25)); s.insert(Person(&quot;Marry&quot;, 18)); s.insert(Person(&quot;Peter&quot;, 36)); //打印set PrintSet(s);&#125;int main(void)&#123; //test01(); //test02(); //test03(); return 0;&#125; multiset容器的insert函数返回值为什么？ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;/* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;void test(void)&#123; multiset&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印multiset PrintSet(s); /* multiset的insert函数返回值为multiset类型的迭代器， 指向新插入的元素。multiset允许插入相同的值，因此 插入一定成功，因此不需要返回bool类型。 */ multiset&lt;int&gt;::iterator iter = s.insert(10); cout &lt;&lt; *iter &lt;&lt; endl; &#125;int main(void)&#123; test(); return 0;&#125; unordered_setC++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。 unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用: 使用unordered_set需要包含#include头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。 除此之外unordered_multiset也是一种可选的容器。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"cpp学习","slug":"cpp学习","date":"2021-10-24T04:30:12.000Z","updated":"2021-10-27T12:02:39.994Z","comments":true,"path":"2021/10/24/cpp学习/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"参考网址:C++ 教程 (github.com) C++ 教程 | 菜鸟教程 (runoob.com) c++基础const关键字声明指定类型的常量,此类型不会发生变化. 比如常用的字符串const char* str,例如 1const char* str = &quot;hello world!&quot;; 当然也会有常数,常指针等.只需要记住它修饰的是它后边的那个.例如 123const char* str #值不能改char const *str #值不能改char* const str #修饰的是常数指针,该指针不能修改 static修饰静态变量,在程序的生命周期内保持局部变量的存在,用于保存上一次运行数据,比如计数等 1static int i = 5; #define预处理器,例如 1#define PORT 7070 extern储存类extern 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.例如 12345678910// main.cpp#include &lt;iostream&gt;int count ;extern void write_extern(); int main()&#123; count = 5; write_extern();&#125; 12345678// support.cpp#include &lt;iostream&gt;extern int count; void write_extern(void)&#123; std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 两个文件之间传递参数. register 存储类寄存器局部变量,用于快速访问.因此也意味着最大尺寸只有寄存器尺寸. 1register int a; thread_local 存储类量在创建线程时创建，并在销毁线程时销毁。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。thread_local 说明符可以与 static 或 extern 合并。 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; 成员运算符1234struct Employee &#123; char first_name[16]; int age;&#125; emp; （.）点运算符下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员 1strcpy(emp.first_name, &quot;zara&quot;); （-&gt;）箭头运算符如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： 1strcpy(p_emp-&gt;first_name, &quot;zara&quot;); 条件运算符 ? :12345if(y &lt; 10)&#123; var = 30;&#125;else&#123; var = 40;&#125; 可写为: 1var = (y &lt; 10) ? 30 : 40; sizeof 运算符sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。 1sizeof (data type) 指针运算符（&amp; 和 *）取地址运算符 &amp; 间接寻址运算符 *顾名思义,挺形象的. 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std; int main ()&#123; int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = &amp;var; // 获取 ptr 的值 val = *ptr; cout &lt;&lt; &quot;Value of var :&quot; &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; &quot;Value of ptr :&quot; &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; &quot;Value of val :&quot; &lt;&lt; val &lt;&lt; endl; return 0;&#125; 传参三种方式传值、传址、传引用123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include &lt;stdint.h&gt;using namespace std;int fun1(int a) return a*a;void man(int &amp;a) a=a*a;void cubeByReference(int *a) *a=*a * *a;void fun2(uint8_t* *buffer)&#123; uint8_t buf[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; *buffer = buf;&#125;int main()&#123; int a=5,b=5,number=5; cout&lt;&lt;fun1(a)&lt;&lt;endl; man(b); cout&lt;&lt;b&lt;&lt;endl; cubeByReference(&amp;number); cout&lt;&lt;number&lt;&lt;endl; return 0;&#125; Lambda 函数与表达式1[capture](parameters)-&gt;return-type&#123;body&#125; 例如: 1[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125; 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 值得注意的是this指针 1[this]() &#123; this-&gt;someFunc(); &#125;(); 数学运算 #include &lt;cmath12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; int main ()&#123; // 数字定义 short s = 10; int i = -1000; long l = 100000; float f = 230.47; double d = 200.374; // 数学运算 cout &lt;&lt; &quot;sin(d) :&quot; &lt;&lt; sin(d) &lt;&lt; endl; cout &lt;&lt; &quot;abs(i) :&quot; &lt;&lt; abs(i) &lt;&lt; endl; cout &lt;&lt; &quot;floor(d) :&quot; &lt;&lt; floor(d) &lt;&lt; endl; cout &lt;&lt; &quot;sqrt(f) :&quot; &lt;&lt; sqrt(f) &lt;&lt; endl; cout &lt;&lt; &quot;pow( d, 2) :&quot; &lt;&lt; pow(d, 2) &lt;&lt; endl; return 0;&#125; 通过time实现的伪随机数123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt; using namespace std; int main ()&#123; int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ) &#123; // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; &#125; return 0;&#125; setw() 函数12345678910111213141516#include &lt;iomanip&gt;using std::setw;cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;# 结果Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 字符串操作 #include &lt;string123456789101112strcpy(s1, s2); // s2复制到s1strcat(s1, s2); // s2拼接到s1后边,类似于:string str = str1 + str2;strlen(s1); // 字符串长度strcmp(s1, s2); // 比较两字符串,相同回0,s1&lt;s2返回小于0,反之,大于0strchr(s1, ch); // 返回字符ch第一次在s1中出现得位置指针strstr(s1, s2); // 返回字符串s2在s1中出现的位姿指针// 复制 str1 到 str3 str3 = str1;// 连接 str1 和 str2 str3 = str1 + str2;// 连接后，str3 的总长度 len = str3.size(); 时间 #include &lt;ctime123456789time_t time(time_t *time); // 返回当前时间char *ctime(const time_t *time); // 返回 day month year hours:minutes:seconds year\\n\\0struct tm *localtime(const time_t *time); // 返回tm时间结构体clock_t clock(void); // 该函数返回程序执行起,处理器时钟所使用的时间char * asctime ( const struct tm * time ); // 返回 day month date hours:minutes:seconds year\\n\\0struct tm *gmtime(const time_t *time); // 用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示time_t mktime(struct tm *time); // 该函数返回日历时间double difftime ( time_t time2, time_t time1 ); // 该函数返回 time1 和 time2 之间相差的秒数size_t strftime(); // 该函数可用于格式化日期和时间为指定的格式 12345678910111213141516#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; &quot;本地日期和时间：&quot; &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; &quot;UTC 日期和时间：&quot;&lt;&lt; dt &lt;&lt; endl;&#125; cin、cout、cerr 和 clog 标准输入输出1234cin :一个istream对象,用来从标准输入读取数据。cout:一个ostream对象，经过缓冲区而直接输出.cerr:一个ostream对象,写到cerr数据是不缓冲clog:一个ostream对象,被缓冲的 结构体12345678910111213141516171819202122// 模板// 使用 Books Book;struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;// 使用 books Book;typedef struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;books;// 取别名 pin32typedef long int pint32;pint32 x, y, z; 结构体指针 12345struct Books *struct_pointer;// 取地址struct_pointer = &amp;Book1;// 访问成员struct_pointer-&gt;title; 面向对象c++对象123456789101112131415161718192021222324252627282930313233343536373839class Line&#123; // 访问修饰符 public: // 类成员函数 double getLength( void ); Line(); // 构造函数声明 friend void printWidth( Box box ); // 友元函数 Line( const Line &amp;obj); //拷贝构造函数 ~Line(); // 析构函数声明 private: double length;&#125;; // 成员函数定义，包括构造函数Line::Line(void)&#123; cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;&#125;Line::~Line(void)&#123; cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;&#125;Line::Line(const Line &amp;obj)&#123; cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值&#125;double Line::getLength( void )&#123; return length;&#125;// 请注意：printWidth() 不是任何类的成员函数void printWidth( Box box )&#123; /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;&#125; 内联函数inline引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神: 1.在内联函数内不允许使用循环语句和开关语句； 2.内联函数的定义必须出现在内联函数第一次调用之前； 3.类结构中所在的类说明内部定义的函数是内联函数。 结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用! 123456789101112131415#include &lt;iostream&gt;using namespace std;inline int Max(int x, int y)&#123; return (x &gt; y)? x : y;&#125;// 程序的主函数int main( )&#123; cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl; cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl; cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl; return 0;&#125; this指针友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 this 指针的类型可理解为 Box* 12# 实际上就是指针引用结构体成员this-&gt;Volume(); 继承12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; // 基类class Shape &#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;; // 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;; int main(void)&#123; Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0;&#125; 多继承另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如： 1234class D&#123;......&#125;;class B: public D&#123;......&#125;;class A: public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 重载运算符类内重调用 12345678Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; 算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，**-&gt;(成员访问)，,(逗号)，[]**(下标) 多态123456789101112131415161718192021222324252627class Shape &#123; protected: int width, height; public: Shape( int a=0, int b=0) &#123; width = a; height = b; &#125; // 虚函数 virtual int area() &#123; cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl; return 0; &#125; // 纯虚数 virtual int area1() = 0;&#125;;class Rectangle: public Shape&#123; public: Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl; return (width * height); &#125;&#125;; 文件和流头文件:iostream 和 fstream 读写文件模板123456789101112131415161718192021222324252627282930313233343536#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std; int main ()&#123; char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Enter your name: &quot;; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;Enter your age: &quot;; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;&#125; 文件位置指针123456// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end ); 异常处理123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;double division(int a, int b)&#123; if( b == 0 ) &#123; throw &quot;Division by zero condition!&quot;; &#125; return (a/b);&#125;int main ()&#123; int x = 50; int y = 0; double z = 0; try &#123; z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; &#125;catch (const char* msg) &#123; cerr &lt;&lt; msg &lt;&lt; endl; &#125; return 0;&#125; 动态内存变量动态内存123double* pvalue = NULL; // 初始化为 null 的指针pvalue = new double; // 为变量请求内存delete pvalue; // 释放 pvalue 所指向的内存 数组动态内存1234567char* pvalue = NULL; // 初始化为 null 的指针pvalue = new char[20]; // 为变量请求内存for(int i = 0; i &lt; COL; i++) &#123; delete[] pvalue[i];&#125;delete [] pvalue; 对象的动态内存分配12Box* myBoxArray = new Box[4];delete [] myBoxArray; // Delete array 模板123456789101112131415#include &lt;iostream&gt;using namespace std;int main ()&#123; double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl; delete pvalue; // 释放内存 return 0;&#125; 命名空间12345namespace namespace_name &#123; func(); // 代码声明&#125;name::func(); // code 可以是变量或函数 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;template&lt;typename T1,typename T2&gt;class Test&#123;public: Test(T1 i,T2 j):a(i),b(j)&#123;cout&lt;&lt;&quot;模板类&quot;&lt;&lt;endl;&#125;private: T1 a; T2 b;&#125;;template&lt;&gt; //全特化，由于是全特化，参数都指定了，参数列表故为空。class Test&lt;int ,char&gt;&#123;public: Test(int i,char j):a(i),b(j)&#123;cout&lt;&lt;&quot;全特化&quot;&lt;&lt;endl;&#125;private: int a; int b;&#125;;template&lt;typename T2&gt; //由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。class Test&lt;char,T2&gt;&#123;public: Test(char i,T2 j):a(j),b(j)&#123;cout&lt;&lt;&quot;个数偏特化&quot;&lt;&lt;endl;&#125;private: char a; T2 b;&#125;;template&lt;typename T1,typename T2&gt; //这是范围上的偏特化class Test&lt;T1*,T2*&gt;&#123;public: Test(T1* i,T2* j):a(i),b(j)&#123;cout&lt;&lt;&quot;指针偏特化&quot;&lt;&lt;endl;&#125;private: T1* a; T2* b;&#125;;template&lt;typename T1,typename T2&gt;//同理这也是范围上的偏特化class Test&lt;T1 const,T2 const&gt;&#123;public: Test(T1 i,T2 j):a(i),b(j)&#123;cout&lt;&lt;&quot;const偏特化&quot;&lt;&lt;endl;&#125;private: T1 a; T2 b;&#125;;int main()&#123; int a; Test&lt;double,double&gt; t1(0.1,0.2); Test&lt;int,char&gt; t2(1,&#x27;A&#x27;); Test&lt;char,bool&gt; t3(&#x27;A&#x27;,true); Test&lt;int*,int*&gt; t4(&amp;a,&amp;a); Test&lt;const int,const int&gt; t5(1,2); return 0;&#125; 预处理器12#define PI 3.14159#define MIN(a,b) (((a)&lt;(b)) ? a : b) 条件编译1234#define DEBUG#ifdef DEBUG cerr &lt;&lt;&quot;Trace: Coming out of main function&quot; &lt;&lt; endl;#endif # 和 ## 运算符1234567# 将x转换为字符串#define MKSTR( x ) #xcout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;## 将x,y连接#define CONCAT( x, y ) x ## yint xy = 100;cout &lt;&lt; concat(x, y); 预定义宏1234cout &lt;&lt; &quot;Value of __LINE__ : &quot; &lt;&lt; __LINE__ &lt;&lt; endl; //当前行号cout &lt;&lt; &quot;Value of __FILE__ : &quot; &lt;&lt; __FILE__ &lt;&lt; endl; //当前文件名cout &lt;&lt; &quot;Value of __DATE__ : &quot; &lt;&lt; __DATE__ &lt;&lt; endl; //当前年月日cout &lt;&lt; &quot;Value of __TIME__ : &quot; &lt;&lt; __TIME__ &lt;&lt; endl; //当前时分秒 信号处理信号类型1SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;csignal&gt;using namespace std;void signalHandler( int signum )&#123; cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\\n&quot;; // 清理并关闭 // 终止程序 exit(signum); &#125;int main ()&#123; int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i)&#123; cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl; if( i == 3 )&#123; // 信号抬起 raise( SIGINT); &#125; sleep(1); &#125; return 0;&#125; 多线程12345#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) // 参数:线程指针,线程属性,线程函数,函数参数// 线程显性退出pthread_exit (NULL); 向线程传递参数123456struct thread_data&#123; int thread_id; char *message;&#125;;struct thread_data td[NUM_THREADS];rc = pthread_create(threadid, NULL,PrintHello, (void *)&amp;td[i]); 连接和分离线程12pthread_join (threadid, status) pthread_detach (threadid) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM_THREADS 5void *wait(void *t)&#123; int i; long tid; tid = (long)t; sleep(1); cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot; ...exiting &quot; &lt;&lt; endl; pthread_exit(NULL);&#125;int main ()&#123; int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)i ); if (rc)&#123; cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; // 删除属性，并等待其他线程 pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ )&#123; rc = pthread_join(threads[i], &amp;status); if (rc)&#123; cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ; cout &lt;&lt; &quot; exiting with status :&quot; &lt;&lt; status &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl; pthread_exit(NULL);&#125; vector与iterator1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123; // 创建一个向量存储 int vector&lt;int&gt; vec; int i; // 显示 vec 的原始大小 cout &lt;&lt; &quot;vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl; // 推入 5 个值到向量中 for(i = 0; i &lt; 5; i++)&#123; vec.push_back(i); &#125; // 显示 vec 扩展后的大小 cout &lt;&lt; &quot;extended vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl; // 访问向量中的 5 个值 for(i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; &quot;value of vec [&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; vec[i] &lt;&lt; endl; &#125; // 使用迭代器 iterator 访问值 vector&lt;int&gt;::iterator v = vec.begin(); while( v != vec.end()) &#123; cout &lt;&lt; &quot;value of v = &quot; &lt;&lt; *v &lt;&lt; endl; v++; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"Socket编程","slug":"socket","date":"2021-10-20T04:30:12.000Z","updated":"2021-10-26T06:14:17.420Z","comments":true,"path":"2021/10/20/socket/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/20/socket/","excerpt":"","text":"参考网址：peitianyu/TcpIpBook: TCP/IP网络编程 (github.com) TCP/IP网络通信之Socket编程入门_哔哩哔哩_bilibili 套接字操作12345678910111213141516#include&lt;sys/socket.h&gt;# 创建套接字int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1# 分配地址信息int bind(int sockfd, struct sockaddr* pSockAddr, socklen_t addrLen);//成功时返回0， 失败时返回-1# 设置监听int listen(int sockfd, int backlog);//成功时返回0， 失败时返回-1# 受理连接int accept(int sockfd, struct sockaddr* pSockAddr, socklen_t* pAddrLen);//成功时返回文件描述符，失败时返回-1# 请求连接int connect(in sockfd, struct sockaddr* pSockAddr, socklen_t sockLen);//成功时返回0， 失败时返回-1 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 打开文件#include&lt;fcntl.h&gt;int open(const char* path, int flag);//成功时返回文件描述符， 失败时返回-1# 关闭文件#include&lt;unistd.h&gt;int close(int fd);//成功时返回0， 失败时返回-1# 写入文件#include&lt;unistd.h&gt;ssize_t write(int sockfd, const void* buf, size_t nBytes);//成功时返回写入的字节数，失败时返回-1# 读取文件ssize_t read(int sockfd, void* buf, size_t nBytes);//成功时返回读到的字节数（若遇到文件结尾则返回0），失败时返回-1#include&lt;sys/uio.h&gt;# 写文件ssize_t writev(int sockfd, const struct iovec* iov, int iovcnt);//成功时返回发送的字节数，失败时返回-1# 读文件ssize_t readv(int sockfd, const struct iovec* iov, int iovcnt);//成功时返回发送的字节数，失败时返回-1// TCP// 发送文件ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);//成功时返回发送的字节数，失败时返回-1// 接收文件ssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1// UDP接收发送ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen);//成功时返回发送的字节数，失败时返回-1,参数flags 一般设0ssize_t recvfrom(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen);//成功时返回接收的字节数，失败时返回-1,参数flags 一般设0struct iovec&#123; void* iov_base; //缓冲地址 size_t iov_len; //缓冲大小&#125;# 断开连接int shutdown(int sock, int howto);//成功时返回0，失败时返回-1 套接字的可选项和IO缓冲大小12345#include&lt;sys/socket.h&gt;int getsockopt(int sock, int level, int optname,void* optval,socklen_t* optlen);//成功时返回0，失败时返回-1int setsockopt(int sock, int level, int optname, void* optval,socklen_t optlen);//成功时返回0，失败时返回-1 12345678int sock = socket(PF_INET,SOCK_STREAM,0);int optval;socklen_t optlen;int state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,(void*)&amp;optval, &amp;optlen);optval = 1024*3;optlen = sizeof(optval);state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,(void*)&amp;optval,optlen); IO复用 FD_ZERO(fd_set* fdset): 将fdset变量的所有位初始化位0 FD_SET(int fd, fd_set* fdset): 向fdset变量中注册文件描述符fd FD_CLR(int fd, fd_set* fdset): 清除fdset变量中的文件描述符fd FD_ISSET(int fd, fd_set* fdset): fdset变量中是否存在fd文件描述符 123456789101112131415# 设置监视范围及超时#include&lt;sys/select.h&gt;#include&lt;sys/time.h&gt;int select(int maxfd, fd_set* readset, fd_set* writeset,fd_set* exceptset, const struct timeval* timeout );//失败时返回-1，超时返回0，成功时返回发生事件的文件描述符数量struct timeval&#123; long tv_sec; long tv_usec;&#125; maxfd: 监视的文件描述符数量（最大的文件描述符+1） readset: 将关注“是否存在待读取数据”的文件描述符存放在readset变量中 writeset: 将关注”是否可写“的文件描述符存放在writeset变量中 exceptset: 将关注”是否有异常“的文件描述符放在exceptset变量中 -timeout: 为了防止调用select函数后陷入无限阻塞状态，可以传递超时信息","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"git使用","slug":"git","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-13T13:28:18.968Z","comments":true,"path":"2021/10/19/git/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/git/","excerpt":"","text":"推送新创建git1234567891011121314151617# 进入本地文件夹cd tool# 添加需要上传文件echo &quot;# tool&quot; &gt;&gt; README.md# 初始化gitgit init# 添加需要上传文件# git add -A 上传全部git add README.md# 注释git commit -m &quot;first commit&quot;# 添加分支git branch -M main# 添加默认远程库git remote add origin git@github.com:peitianyu/tool.git# 推送git push -u origin main 推送已存在的库123git remote add origin git@github.com:peitianyu/tool.gitgit branch -M maingit push -u origin main git删除远程库文件123456git --help # 帮助命令git pull origin master # 将远程仓库里面的项目拉下来dir # 查看有哪些文件夹git rm -r --cached yun_app # 删除yun_app文件夹git commit -m ‘删除了yun_app’ # 提交,添加操作说明git push -u origin master # 将本次更改更新到github项目上去 git删除远程分支123456789# 快速创建分支并切换分支 (dev 分支)git checkout -b dev# 删除分支 ： 如分支名为devgit branch -d dev 会在删除前检查merge状态（其与上游分支或者与head）。git branch -D dev 它会直接删除,不检查# 删除远程分支git push origin --delete dev# 清理本地不存在的远程分支，如别人删除了dev,但是你本地查看还有，就可以执行该条命令git remote prune origin git 分支1234567891011* 查看分支：git branch* 创建分支：git branch &lt;name&gt;* 切换分支：git checkout &lt;name&gt;* 创建+切换分支：git checkout -b &lt;name&gt;* 合并某分支到当前分支：git merge &lt;name&gt;* 删除分支：git branch -d &lt;name&gt; git clone文件代理12345678git clonegit clone https://ghproxy.com/https://github.com/stilleshan/ServerStatuswget &amp; curlwget https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zipwget https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfilecurl -O https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zipcurl -O https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"cmake配置模板","slug":"cmake模板","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-03T08:27:39.384Z","comments":true,"path":"2021/10/19/cmake模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"Cmake教程参考网址:CMake 入门实战 | HaHack Cmake文件结构1234567891011root@LAPTOP-49LFJ4NT:/root/cmake# tree.├── CMakeLists.txt├── bin├── build├── include│ └── func.h└── src ├── func.cpp ├── main.cpp └── shell.sh shell.sh12# 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译cd .. &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j &amp;&amp; ./main CmakeLists.txt123456789101112131415161718192021222324252627282930313233# 指定cmake版本cmake_minimum_required(VERSION 3.0)# 工程名project(canalyst)#cmake的c++设置# 告知當前使用的是交叉編譯方式，必須配置SET(CMAKE_SYSTEM_NAME Linux)SET(CMAKE_C_COMPILER &quot;gcc&quot;)SET(CMAKE_CXX_COMPILER &quot;g++&quot;)# 执行路径设置SET(EXECUTABLE_OUTPUT_PATH ../bin)# 设置编译选项set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -Wall -pthread -std=c++11 -fPIC &quot;)# 添加.h文件include_directories(src)# 添加.cpp文件aux_source_directory(src SRC_LIST)# 链接库link_directories(lib)set(LIB_LIST libcontrolcan.so)# 输出调试信息# message(&quot;src :$&#123;SRC_LIST&#125; &quot;)# 执行文件add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC_LIST&#125; )target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIB_LIST&#125;) 运行12# 在src文件夹下运行shell.sh./shell","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"hugo配置","slug":"hugo","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:08:31.508Z","comments":true,"path":"2021/10/19/hugo/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/hugo/","excerpt":"","text":"git安装与配置12345678# git安装sudo apt updatesudo apt install git #git配置git config --global user.name &quot;zoey&quot;git config --global user.email &quot;zoey686@163.com&quot;#查看设置用户名与密码git config --list hugo安装12345678# 安装sudo apt install hugo# 手动安装wget https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.debsudo dpkg -i hugo_0.54.0_Linux-64bit.deb# 查看hugo --helphugo version 建立博客新建git文件夹用以git模板等，并在文件夹下新建myblog，用来存放博客页面 12345# 新建git文件夹并git初始化mkdir gitFile git init# 新建myblog文件夹用来存放博客页面hugo new site myblog myblog下面就会有以下几个文件夹自动生成 文件夹名 作用 archetypes 文章开头形式 content 内容 data 自定义模板 layouts 网页模板文件 static 存储图片一些其他的资源 themes 主题 config.toml 配置文件 设置主题在（https://themes.gohugo.io/）中挑选主题,这里选择的是diary主题（[Diary | Hugo Themes (gohugo.io)](https://themes.gohugo.io/themes/hugo-theme-diary/)） 例子：（浅蓝色 (gitee.io)） 1234# 下载diary主题到themes文件夹下并重命名为diarygit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary# 配置config.toml文件nano config.toml 12345678910111213141516171819202122232425262728293031323334353637baseURL = &quot;https://peitianyu.github.io/pty_blog.github.io&quot;DefaultContentLanguage = &quot;zh&quot; # Theme&#x27;s display language, supports: en, fr, zh, zh-hantlanguageCode = &quot;zh-hant&quot;title = &quot;武装带你&quot;copyright = &quot;This is a customized copyright.&quot;theme = &quot;diary&quot;[markup] [markup.highlight] codeFences = true guessSyntax = false hl_Lines = &quot;&quot; lineNoStart = 1 lineNos = false lineNumbersInTable = true noClasses = true style = &quot;perldoc&quot; tabWidth = 4enableOpenGraph = trueenableTwitterCards = truetitle = &quot;My Blog&quot; description = &quot;My HomePage Description&quot; [taxonomies] ros = &quot;Ros&quot; blog = &quot;Blog&quot;[[menu.main]]url = &quot;/blog&quot;name = &quot;Blog&quot;weight = 1[[menu.main]]url = &quot;/ros&quot;name = &quot;Ros&quot;weight = 2 创建文章默认主目录文章在content/post下 1234567# 创建文章hugo new post/my_first_blog.md#创建文章在需要目录(Archive)下hugo new posts/my_first_blog.mdcd content/postnano my_first_blog.md# 注意将draft参数改为false，否则跳过草稿文件，无法预览 123456---title: &quot;my_first_blog&quot;date: 2021-10-12T10:49:31+08:00draft : false---文本内容 本地调试 1hugo server --theme=blackburn --buildDrafts 其中 –theme 选项可以指定主题，–buildDrafts 包括标记为草稿然后在浏览器里打开： http://localhost:1313 即可访问到你的博客 部署到github如果你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：pty_blog.github.io （pty_blog替换为你的github用户名的小写） 进入仓库，点击Settings进入，找到GitHub Pages并点击Check it out here!，配置Source并save，会发现绿色框中显现 Your site is published at https://peitianyu.github.io/pty_blog.github.io/ 此处https://peitianyu.github.io/pty_blog.github.io/就是我们的网址，也是config.toml文件中设置的网址，设置hugo登陆网址 1hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot; 注意：这里的 –baseUrl 一定是https://（Hugo中文文档里为http://），不然你部署后的博客会没有样式！ 可看到根目录下多出 /public文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。然后继续在你的站点根目录执行git 命令，添加远程仓库。 123456cd publicgit initgit remote add origin git@github.com:peitianyu/pty_blog.github.io.gitgit add -Agit commit -m &quot;first commit&quot;git push -u origin master 然后浏览器里访问：https://peitianyu.github.io/pty_blog.github.io/即可看到刚刚搭建的博客。 发布博客并更新： 123456789# 新建博客markdown文件，并编辑博客内容(文件名为 **.md )hugo new post/newBlog.md# 生成静态页面hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;# 发布cd publicgit add .git commit -m &quot;new blog added&quot;git push origin master","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"jetson_nano 踩坑","slug":"jetson_nano","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:03.171Z","comments":true,"path":"2021/10/19/jetson_nano/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/jetson_nano/","excerpt":"","text":"参考网址:玩转智能硬件之Jetson Nano(一)安装篇 - 知乎 (zhihu.com) Jetson Nano-配置环境_Ay_yzx的博客-CSDN博客 预先下载:balenaEtcher balenaEtcher - Flash OS images to SD cards &amp; USB drives 系统下载 官方默认系统: https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw Ubuntu18.04: https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig 密码 : tun3 sd卡格式化工具 SD Memory Card Formatter for Windows Download | SD Association (sdcard.org) 安装步骤:1231.格式化sd卡2.使用balenaEtcher烧录下载好的系统3.插上卡后做初始化设置 jetson三种供电方式:参考网址:Jetson nano 的三种供电方式_Dunkle.T的博客-CSDN博客_jetson nano供电 分别为: USB供电(默认5v2a 仅低功率),使用时拔去条线帽 使用 DC 供电(默认5v 4A),使用时插上跳线帽 使用引脚供电(5v3a 无所谓跳线帽) 查看cuda配置12sudo pip3 install jetson-statssudo jtop 关于ros安装参考网址:ROS_安装 (peitianyu.github.io) 其他部分按ros安装教程来即可比较实用的方案是先按照我的步骤安装ros,之后再通过fishros一行代码解决rosdep问题 远程连接nanossh.exe usrname@192.168.xxx.xxx jetson nano初始化配置网络配置静态ip设置:Ubuntu 18.04配置静态IP地址) root免密登录参考网址:ubuntu设置root免密登陆 vscode连接jetson nano参考网址:vscode设置ssh进行远程编辑_Quan的博客-CSDN博客","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"make配置模板","slug":"make模板","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:25.577Z","comments":true,"path":"2021/10/19/make模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"make文件目录123456root@LAPTOP-49LFJ4NT:/root/make# tree.├── Makefile├── conf.sh├── main.cpp└── shell.sh 这里使用了shell脚本来实现对于make的编译，由于使用的是wsl在windows下操作导致编码格式含有\\r\\n，以此有两个shell脚本。 conf.sh12345678# 实现对于make的编译与运行#!/bin/bashif [[ $1 == clean ]]; then make cleanelif [[ $1 == all ]]; then make clean &amp;&amp; make -j8 &amp;&amp; ./mainelse make -j8 &amp;&amp; ./main shell.sh123# 实现将conf.sh的dos编码转化为unix编码，并执行#!/bin/bashdos2unix conf.sh &amp;&amp; ./conf.sh Makefile123456789101112131415161718192021222324252627282930313233343536373839# 自动捕捉符合c/c++编译#指定编译工具CC = gccCPP = g++LINK = g++LIBS = -lsqlite3 -lpthread#编译.so 必须添加 -fPIC 和 -shared 选项CCFLAGS = -c -g -fPICCPPFLAGS = -c -g -fPIC#期望得到的执行文件或动态库.so#TARGET=libxx.soTARGET=mainINCLUDES = -I. #-I../../CPPFILES = $(wildcard *.cpp )#遍历得到当前目录及上层目录中的所有.cpp文件CFILES = $(wildcard *.c )#遍历得到当前目录及上层目录中的所有.c文件OBJFILE = $(CFILES:.c=.o) $(CPPFILES:.cpp=.o)all:$(TARGET)$(TARGET):$(OBJFILE)# 编译得到 .so 文件用下面的代码# $(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@# 编译得到可执行文件用下面的代码 $(LINK) $^ $(LIBS) -Wall -O2 -o $@%.o:%.c $(CC) -o $@ $(CCFLAGS) $&lt; $(INCLUDES)%.o:%.cpp $(CPP) -o $@ $(CPPFLAGS) $&lt; $(INCLUDES)clean: rm -rf $(TARGET) rm -rf $(OBJFILE) main.c12345678#include &lt;stdio.h&gt; int main()&#123; printf(&quot;Hello, World! \\n&quot;); return 0;&#125; 运行1./shell","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"mpg处理","slug":"mpg处理","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:53.801Z","comments":true,"path":"2021/10/19/mpg处理/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/mpg%E5%A4%84%E7%90%86/","excerpt":"","text":"参考网址:(47条消息) ROS开发实践（十三）——ROS中SLAM地图（.pgm格式）编辑软件的安装与使用_Ehang_Maker的博客-CSDN博客 安装:参考网址:Gimp中文网 (baisheng999.com) windows安装流程:1注意选择安装路径,其他下一步即可 流程:12341.选择使用笔刷工具2.设置笔刷大小,硬度为100,力度为100,线型为直线3.按住Ctrl选择颜色4.释放后刷刷刷","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"nano操作","slug":"nano操作","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:46.628Z","comments":true,"path":"2021/10/19/nano操作/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/nano%E6%93%8D%E4%BD%9C/","excerpt":"","text":"参考网址 nano使用技巧大全_Xav Pun的博客-CSDN博客_nano使用教程 便捷快捷键注意前缀键Ctrl+b按完后松开，再按下其他键。 快捷键 含义 Alt+x 切换帮助栏 ALT-# 显示行号 CTRL-K 剪切到行末 ALT+6 复制 SHIFT+方向 选择 CTRL+u 粘贴 Alt + u 撤销 Alt + e 重复 ALT+&lt; 切换到上一个文件 ALT+&gt; / alt + 切换到下一个文件 CTRL+X 关闭 CTRL+R CTRL+T 文件浏览器 CTRL+C 退出文件选择界面 CTRL+S 保存","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"ros_cmake配置模板","slug":"ros_cmake","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:56.706Z","comments":true,"path":"2021/10/19/ros_cmake/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros_cmake/","excerpt":"","text":"简易CmakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243cmake_minimum_required(VERSION 2.8.3)# 工程名project(hmi)# 支持编译add_compile_options(-std=c++11)# 查找包find_package(catkin REQUIRED COMPONENTS roscpp sensor_msgs pcl_ros perception_msgs)# catkin库catkin_package( INCLUDE_DIRS include CATKIN_DEPENDS roscpp sensor_msgs pcl_ros)# 头文件库include_directories( include $&#123;catkin_INCLUDE_DIRS&#125;)# 链接库文件夹link_directories($&#123;PCL_LIBRARY_DIRS&#125;)# 生成执行文件add_executable($&#123;PROJECT_NAME&#125;_node src/hmi_node.cpp src/hmi_core.cpp)# 依赖包add_dependencies($&#123;PROJECT_NAME&#125;_node perception_msgs_generate_messages_cpp)# 链接库target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125; $&#123;PCL_LIBRARIES&#125;) 详细CmakeLists.txt1234567891011121314151617181920212223242526272829cmake_minimum_required() #CMake的版本号project() #项目名称find_package() #找到编译需要的其他CMake/Catkin package catkin_python_setup() #catkin新加宏，打开catkin的Python Module的支持add_message_files() #catkin新加宏，添加自定义Message文件 add_service_files() #catkin新加宏，添加自定义Service文件 add_action_files() #catkin新加宏，添加自定义Action文件 generate_message() #catkin新加宏，生成不同语言版本的msg/srv/action接口 catkin_package() #catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 add_library() #生成库 add_executable() #生成可执行二进制文件add_dependencies() #定义目标文件依赖于其他目标文件，确保其他目标已被构建 target_link_libraries() #链接catkin_add_gtest() #catkin新加宏，生成测试install() #安装至本机 对照实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242cmake_minimum_required(VERSION 3.0.2) # catkin至少需要3.0.2版本以上的Cmake#通过project()这个函数指定包的名字，在CMake中指定后，你可在其他地方通过使用变量$&#123;PROJECT_NAME&#125;来引用它project(ultrasonic_data) ## Compile as C++11, supported in ROS Kinetic and newer# add_compile_options(-std=c++11)## 查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package(） ##find_package(catkin REQUIRED COMPONENTS xyz) 被用于找其他依赖的功能包##这里指明构建这个package需要依赖的package，我们使用catkin_make的编译方式，至少需要catkin这个包。find_package(catkin REQUIRED COMPONENTS message_generation roscpp sensor_msgs std_msgs visualization_msgs can_msgs)## 系统依赖关系是通过CMake的约定找到的# find_package(Boost REQUIRED COMPONENTS system)##启动Python模块支持：catkin_python_package()##如果功能包中提供了一些Python模块.这个宏定义可以确保包中声明的模块和全局脚本被安装## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html# catkin_python_setup()############################## 声明ROS消息、服务和动作 ################################ 消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()##当我们需要使用.msg.srv.action形式的文件时，我们需要特殊的预处理器把他们转化为系统可以识别特定编程语言（.h.cpp）。##注意：这些宏必须在catkin_package() 宏前面##请执行以下步骤：## * 在package.xml中:## *1.添加&quot;message_generation&quot;在build_depend标记中## *2.添加&quot;message_runtime&quot;在exec_depend标记中## * 在CMakeLists.txt中:## *1、在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;message_generation&quot; ## *2、在catkin_package(CATKIN_DEPENDS ...)添加&quot;message_runtime&quot;## 根据需要取消下面“add_######_files”部分的注释## * 取消下面的generate_messages(DEPENDENCIES...注释## * add every package to generate_messages(DEPENDENCIES ...)## 在&#x27;msg&#x27; 文件夹生成消息 add_message_files( FILES Ultrasonic.msg# Message2.msg )##在 &#x27;srv&#x27; 文件夹生成服务# add_service_files(# FILES# Service1.srv# Service2.srv# )## 在 &#x27;action&#x27; 文件夹生成动作# add_action_files(# FILES# Action1.action# Action2.action# )## 在此处列出的任何添加的消息和服务生成的依赖项##调用消息/服务/操作生成：generate_messages() generate_messages( DEPENDENCIES# sensor_msgs std_msgs# visualization_msgs )##################################################声明ROS动态配置参数 #################################################### 声明和生成动态重新配置参数包:遵循以下步骤## * 在package.xml中:## *添加&quot;dynamic_reconfigure&quot;在build_depend和exec_depend标记中## * 在CMakeLists.txt中:## *在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;dynamic_reconfigure&quot; ## * 取消下面 &quot;generate_dynamic_reconfigure_options&quot; 的注释## 列出要处理的每个.cfg文件## Generate dynamic reconfigure parameters in the &#x27;cfg&#x27; folder# generate_dynamic_reconfigure_options(# cfg/DynReconf1.cfg# cfg/DynReconf2.cfg# )##################################### catkin 特定的配置 ####################################### catkin_package为包生成cmake配置文件 这是一个catkin提供的cmake宏，当我们要给构建系统指定catkin的特定的信息时就需要了## 或者反过来利用他产生pkg-config和CMake文件。##指定包编译信息导出：catkin_package()## 该函数必须在使用 add_library()或add_executable()声明任何targets之前调用。## INCLUDE_DIRS: 如果包包含头文件，请取消对INCLUDE_DIRS的注释## LIBRARIES: 此项目中创建的依赖项目需要的库LIBRARIES## CATKIN_DEPENDS: catkin_packages依赖的项目## DEPENDS: 依赖项目需要的系统依赖项catkin_package( INCLUDE_DIRS include# LIBRARIES ultrasonic_data CATKIN_DEPENDS message_runtime# DEPENDS system_lib)############# Build ############### include_directories用来设置头文件的相对路径##include_directories的参数是通过find_package产生的*_INCLUDE_DIRS变量和其他所有额外的头文件路径##这里&quot;include&quot;表示你的pacakge里面的include这个路径也包含在里面include_directories( include $&#123;catkin_INCLUDE_DIRS&#125;)############################################################################添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()############################################################################## add_library()用来指定编译产生的库。默认的catkin编译产生共享库：# add_library($&#123;PROJECT_NAME&#125;# src/$&#123;PROJECT_NAME&#125;/ultrasonic_data.cpp# )## add_dependencies用于设置依赖##如果你有一个包编译.msg .srv，并且可执行文件要使用他们，那么你就需要创建一个显式的依赖项，## 我们定义的语言无关的消息类型，消息类型会在编译过程中产生相应的语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要## 使用add_dependencies($&#123;PROJECT_NAME&#125;_generate_messages_cpp)## add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)## add_executable用于设置需要编译的代码和生成的可执行文件##第一个参数为期望生成的可执行文件名称；后面的参数为参与编译的源文件（cpp),如果需要多个代码文件，用空格区分开## 推荐的前缀可以确保跨包的目标名称不会冲突# add_executable($&#123;PROJECT_NAME&#125;_node src/ultrasonic_data_node.cpp)## 重命名C++无前缀可执行文件## 利用set_target_properties()函数将这个target进行重命名，在catkin中target的名字必须是唯一的# set_target_properties($&#123;PROJECT_NAME&#125;_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)## 添加可执行文件的cmake目标依赖项## same as for the library above与上面的库相同# add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)##target_link_libraries用于设置链接库# target_link_libraries($&#123;PROJECT_NAME&#125;_node# $&#123;catkin_LIBRARIES&#125;# )add_executable(ultrasonic_activate_node src/ultrasonic_activate_node.cpp)add_dependencies(ultrasonic_activate_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries(ultrasonic_activate_node $&#123;catkin_LIBRARIES&#125;)add_executable(ultrasonic_node src/ultrasonic_node.cpp src/ultrasonic_filter.cpp)add_dependencies(ultrasonic_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries(ultrasonic_node $&#123;catkin_LIBRARIES&#125;)################安装至本机 ################ 所有安装目标都应该使用catkin目标变量# See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html##安装Python可执行脚本# catkin_install_python(PROGRAMS# scripts/my_python_script# DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## 安装的可执行文件## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html# install(TARGETS $&#123;PROJECT_NAME&#125;_node# RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## 要安装的库##编译完成后，目标被放入catkin工作空间下的devel目录。一般希望将目标安装到系统上，以使其他用户使用，##或者安装到本地目录来测试系统级别的安装。也就是说，如果希望能够对代码进行make install，就需要明确目标结束的位置。##上述过程可以使用CMake的 install()函数实现。##该函数的参数有##TARGETS：要安装的目标##ARCHIVE DESTINATION：静态库和动态链接库DLL(Windows).lib存根##LIBRARY DESTINATION：非DLL共享库和模块##RUNTIME DESTINATION：可执行目标和DLL(Windows)模式共享库## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html# install(TARGETS $&#123;PROJECT_NAME&#125;# ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;# LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;# RUNTIME DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;# )## 安装头文件##头文件必须安装到include目录下，这通常通过安装整个文件夹的文件来完成（可以根据文件名模式进行过滤，并排除SVN子文件夹）##可以通过以下安装规则实现：# install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/# DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;# FILES_MATCHING PATTERN &quot;*.h&quot;# PATTERN &quot;.svn&quot; EXCLUDE# )## 安装roslaunch文件或其他源##其他像launchfiles的资源可以安装到 $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;# install(FILES# # myfile1# # myfile2# DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;# )############################### 测试编译：catkin_add_gtest()################################# 基于gtest测试目标和链接库# catkin_add_gtest($&#123;PROJECT_NAME&#125;-test test/test_ultrasonic_data.cpp)# if(TARGET $&#123;PROJECT_NAME&#125;-test)# target_link_libraries($&#123;PROJECT_NAME&#125;-test $&#123;PROJECT_NAME&#125;)# endif()## 添加要由python osetests运行的文件夹# catkin_add_nosetests(test) 具体可参考网址ROS中的CMake List详解_yangtao420902的博客-CSDN博客 ROS下CmakeLists.txt模板_CipherPolzz的博客-CSDN博客 ROS新建程序包CmakeLists和package详解_JayLee719的博客-CSDN博客 (46条消息) ROS中CMakeLists.txt文件 使用 讲解与总结_月照银海似蛟龙的博客-CSDN博客","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ros安装","slug":"ros安装","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-13T03:03:53.549Z","comments":true,"path":"2021/10/19/ros安装/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装环境12Ubuntu18.04ros-melodic-desktop-full 安装1234567891011vim /etc/apt/sources.list.d/ros-latest.listdeb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic mainsudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt updatesudo apt-get install ros-melodic-desktop-full# 初始化sudo rosdep initrosdep updatesudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essentialsudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 一行代码安装ros（包含问题处理）1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros 参考视频： 玩着游戏听着歌，就把ROS装好了！一行代码搞定系列！ (qq.com) 安装问题rosdep init不成功 1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros 卸载12345sudo apt-get autoremove --purge ros-melodic# 先卸载包sudo apt-get purge ros-*# 然后删除依赖，配置sudo apt-get autoremove 测试12345mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_makesource devel/setup.bashroscore 打开新窗口执行 1rosrun turtlesim turtlesim_node 出现小乌龟则安装完成。","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ros错误集锦","slug":"ros错误集锦","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-13T03:24:32.797Z","comments":true,"path":"2021/10/19/ros错误集锦/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/","excerpt":"","text":"“cv_bridge“解决办法出现问题:123456CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package):Could not find a package configuration file provided by “cv_bridge” withany of the following names:cv_bridgeConfig.cmakecv_bridge-config.cmake 解决办法:CMake Error ：Could not find a package configuration file provided by “cv_bridge“解决办法 WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决1234567891011121314# 卸载gazebo与rossudo apt-get remove gazebo11 gazebo11-*sudo apt-get purge ros-*sudo apt-get install ros-melodic-desktop-full# 卸载gazebo9sudo apt-get remove gazebo9 gazebo9-common gazebo9-plugin-base libgazebo9:amd64 libgazebo9-dev:amd64 ros-melodic-gazebo-* # 查看dpkg -l | grep gazebo# 清楚残余包sudo dpkg --purge gazebo9# 安装gazebo11sudo apt-get install gazebo11 -ysudo apt-get install libgazebo11-devgazebo 通过重新安装的方式绕过 WSL折腾记录之三：WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决与升级安装gazebo11 rosdep init不成功命令行输入 1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros Could not find a package configuration file provided by “xxxx”1sudo apt-get install ros-melodic-xxxx","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ssh","slug":"ssh","date":"2021-10-19T04:30:12.000Z","updated":"2022-05-12T01:46:39.729Z","comments":true,"path":"2021/10/19/ssh/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ssh/","excerpt":"","text":"参考网址 SSH简介及两种远程登录的方法_德prince-CSDN博客_ssh 安装:12345678sudo apt-get install openssh-client sudo apt-get install openssh-server # 查看启动情况ps -e | grep ssh# 启动 停止 重启sudo /etc/init.d/ssh start sudo /etc/init.d/ssh stop #server停止ssh服务 sudo /etc/init.d/ssh restart #server重启ssh服务 登录口令登录12345678# 基础登录ssh ldz@192.168.0.1# 调用图形界面ssh -X ldz@192.168.0.1# 如果客户机的用户名和服务器的用户名相同，登录时可以省略用户名。ssh 192.168.0.1# -p修改端口,默认22端口ssh -p 1234 ldz@192.168.0.1 第一次连时需要确认连接,选yes,即可成功 遇到问题: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOT bug解决: ssh-keygen -R 192.168.0.1 退出Ctrl+d或者exit 公钥登录在本机生成密钥对12ssh-keygen -t rsa #-t表示类型选项，这里采用rsa加密算法cat ~/.ssh/id_rsa.pub 将公钥复制到远程主机1ssh-copy-id ldz@192.168.0.1","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"几款terminal","slug":"terminal","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:55:58.329Z","comments":true,"path":"2021/10/19/terminal/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/terminal/","excerpt":"","text":"终端Powershell,Windows terminal,wsl-terminal,fluent terminal,xshell,Mobaxterm,putty Powershell最基础的远程终端,只需要通过ssh指令连接远程终端即可.如,ssh.exe pty@192.168.30.100 Windows terminal同样可以用指令打开,同时也可以配置,打开wsl,ssh都比较方便,点击即用.但有些丑.当然也可以配置网上教程挺多,再次不做过多介绍. 安装:1234# powershell输入winget install --id=Microsoft.WindowsTerminal -e# 通过Chocolateychoco upgrade microsoft-windows-terminal 右键打开windows terimnal(未测试)保存为install.bat文件打开 1234567891011121314151617Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Windows Terminal]; 右键菜单中显示的名称@=&quot;Windows Terminal&quot;; 右键菜单中显示的图标&quot;Icon&quot;=&quot;C:\\\\Toolkits\\\\Icons\\\\App\\\\WindowsTerminal.ico&quot;; 仅支持在按住Shift+右键的时候才显示&quot;Extended&quot;=&quot;&quot;; &quot;NoWorkingDirectory&quot;=&quot;&quot;; 在菜单中显示或隐藏&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Windows Terminal\\Command]@=&quot;C:\\\\Users\\\\xyz\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe -d \\&quot;%V\\&quot;&quot; fluent terminal好看但没有windows terminal那么方便,不过可以设置快捷键,也还行. 安装1choco install fluent-terminal 12# 下载zip文件解压安装https://github.com/felixse/FluentTerminal/releases 下载完毕后解压，选择 Install.ps1 文件，右键使用 powershell 运行。 右键打开保存为install.bat文件打开 12345reg add &quot;HKCU\\Software\\Classes\\Directory\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%1\\&quot;&quot; /freg add &quot;HKCU\\Software\\Classes\\Directory\\Background\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%V\\&quot;&quot; /freg add &quot;HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%V\\&quot;&quot; /f 右键关闭保存为Uninstall.bat文件打开 1234reg delete &quot;HKCU\\Software\\Classes\\Directory\\shell\\Open Fluent Terminal here&quot; /freg delete &quot;HKCU\\Software\\Classes\\Directory\\Background\\shell\\Open Fluent Terminal here&quot; /freg delete &quot;HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\Open Fluent Terminal here&quot; /f wsl-terminal加u个人使用而言,如果多个wsl,则没那么舒爽.当然也可以像powershell那样wsl -d Ubuntu这样切换版本 参考网址:使用 wsl-terminal 更好地体验 Win 10 WSL 终端环境 写的比较详细就不具体赘述了 putty是一款集合ssh,串口的远程软件,但每次都需要开启后配置参数,对于懒人不友好. 参考网址:putty使用教程(总结) xshell具有putty相似的功能,同时还有stfp文件传输,只需点击即可使用.但对于需要调试gui程序而言,需要购买正式版,嗯…………大佬随意. 参考网址:Xshell使用基础教程_ Mobaxterm集百家之长于一身,因此使用起来没那么方便,但使用后非常舒爽.值得一提的是,远程文件是可以根据终端实时更新的,同时支持拖拽文件,新建文件,文件夹,本地编辑文件,这就很爽了. 参考网址:全能终端神器mobaxterm入坑指南","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"tmux使用","slug":"tmux","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:56:24.420Z","comments":true,"path":"2021/10/19/tmux/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/tmux/","excerpt":"","text":"参考网址 Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com) A Quick and Easy Guide to tmux Tactical tmux: The 10 Most Important Commands Getting started with Tmux 便捷快捷键注意前缀键Ctrl+b按完后松开，再按下其他键。 快捷键 含义 Ctrl+d 退出 Ctrl+b s 列出所有会话 Ctrl+b % 划分左右两个窗格 Ctrl+b “ 划分上下两个窗格 Ctrl+b o 切换到下一个窗格 Ctrl+b x 关闭当前窗格 Ctrl+b c 创建一个新窗口 Ctrl+b n 切换到下一个窗口","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"ubuntu18源","slug":"ubuntu更新源","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:56:51.336Z","comments":true,"path":"2021/10/19/ubuntu更新源/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90/","excerpt":"","text":"更新软件源参考网址：Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源 阿里源 （Ubuntu 18.04）1sudo vim /etc/apt/sources.list 1234567891011121314deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 123sudo apt-get updatesudo apt-get -f installsudo apt-get upgrade 西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）1234567891011121314deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse 清华源12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 网易源12345678910deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse 中科大12345678910111213##中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 树莓派更换国内源123# 备份sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak 1sudo nano /etc/apt/sources.list 12# 添加入,Ctrl+s保存,Ctrl+X退出.deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 12# 修改系统更新源sudo nano /etc/apt/sources.list.d/raspi.list 12# 加入deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 12sudo apt-get updatesud apt upgrade Ubuntu18换回原来源1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic universedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team, and may not be under a free licence. Please satisfy yourself as to## your rights to use the software. Also, please note that software in## multiverse WILL NOT receive any review or updates from the Ubuntu## security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic multiversedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse## N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.## Also, please note that software in backports WILL NOT receive any review## or updates from the Ubuntu security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse## Uncomment the following two lines to add software from Canonical&#x27;s## &#x27;partner&#x27; repository.## This software is not part of Ubuntu, but is offered by Canonical and the## respective vendors as a service to Ubuntu users.# deb http://archive.canonical.com/ubuntu bionic partner# deb-src http://archive.canonical.com/ubuntu bionic partnerdeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricteddeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security universedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"win自启动程序","slug":"win自启动","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:08:05.700Z","comments":true,"path":"2021/10/19/win自启动/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/win%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"","text":"记事本写入脚本12345time /t &gt;&gt;c:\\test\\log1.logecho %username% &gt;&gt;c:\\test\\log1.logecho %computername% &gt;&gt;c:\\test\\log1.log 另存为start.bat，无人见类型为所有类型 配置系统点击运行，输入gpedit.msc,具体操作如下： 重启电脑可以发现，脚本运行了","categories":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/categories/win/"}],"tags":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/tags/win/"}]},{"title":"wsl安装与使用","slug":"wsl","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-08T11:31:57.700Z","comments":true,"path":"2021/10/19/wsl/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/wsl/","excerpt":"","text":"wsl安装参考网址： Windows 终端安装 | Microsoft Docs 玩转Linux(1)——安装Windows亲儿子Linux系统之WSL之最全攻略之最佳体验之究极无敌舒服_衡与墨的博客-CSDN博客 管理员身份运行Powershell 12Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux wsl --install -d Ubuntu wsl使用 进入linux系统 命令行输入wsl或者bash，进入linux系统 linux初始配置 添加sudo，这样就不用输密码了 修改 123%sudo ALL=(ALL:ALL) ALL# 改为%sudo ALL=(ALL:ALL) NOPASSWD:ALL 图形界面 参考网址： WSL2运行图像应用或图形界面_Alisebeast的博客-CSDN博客_wsl2 图形界面 在WSL中打开与显示图片的简单方法_neetneves的博客-CSDN博客 12echo &quot;export DISPLAY=localhost:0&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 测试查看 123echo $DISPLAY# 或者xclock 更新软件源 参考网址：Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源 wsl命令详解 命令 含义 wsl或bash 打开默认子系统 wsl -d Ubuntu18 打开Ubuntu18子系统 wsl -l -o 可安装的有效分发的列表 wsl –install -d Ubuntu 安装默认Ubuntu wsl –shutdown 关闭子系统 wsl –import Ubuntu-20.04 e:\\ubuntu d:\\ubuntu20.04.tar –version 2 导入已存的操作系统 wsl –export Ubuntu-20.04 e:\\ubuntu20.04.tar 导出操作子系统 wsl -l -v 显示所有子系统 wsl -s Ubuntu-20.04 将分发版设置为默认值 bash -c “ls” windows命令提示符 wsl –unregister Ubuntu-20.04 注销分发版 wslconfig /s Ubuntu-18.04 修改默认子系统 wsl-terminal 参考网址： mskyaxl/wsl-terminal: Terminal emulator for Windows Subsystem for Linux (WSL) (github.com) 最常用的依旧是Windows Terminal参考网址 [Windows Terminal配置_人间世-CSDN博客](https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows terminal&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-4-111354738.pc_search_ecpm_flag&amp;spm=1018.2226.3001.4187) Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载 Windows Terminal安装方式一： 微软商店安装 购买 Windows Terminal - Microsoft Store zh-CN 方式二： Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载 方式三： https://github.com/microsoft/Terminal 使用Visual Studio打开构建运行","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"嵌入式业务逻辑","slug":"嵌入式业务逻辑","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-23T14:40:36.386Z","comments":true,"path":"2021/10/19/嵌入式业务逻辑/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/","excerpt":"","text":"参考网址:嵌入式架构到底有多重要？看完惊呆了_连志安-CSDN博客 史上最详细！嵌入式系统知识和接口技术总结_连志安-CSDN博客 嵌入式开发中为什么很少用设计模式？_strongerHuang-CSDN博客 嵌入式架构_分享嵌入式,移动端,智能应用,数据库等专业板块,记录知识碎片！！！-CSDN博客 应用架构、业务架构、技术架构和业务流程图详解_代码帮-CSDN博客_业务架构 提高RTOS应用程序稳定可靠的几点技巧-面包板社区 (eet-china.com) RTOS 是如何进行任务划分的？_wenzi嵌入式软件的博客-CSDN博客 UCOS 等 RTOS的任务划分原则（转载整理）_Dr树树的博客-CSDN博客","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"项目模板","slug":"模板案例","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:51:25.222Z","comments":true,"path":"2021/10/19/模板案例/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B/","excerpt":"","text":"天穹飞控项目将模块细分非常细致值得嵌入式借鉴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161SRC# tree.├── CONTROL│ ├── flightControl.c│ ├── flightControl.h│ ├── missionControl.c│ ├── missionControl.h│ ├── motor.c│ ├── motor.h│ ├── rc.c│ ├── rc.h│ ├── safeControl.c│ ├── safeControl.h│ ├── userControl.c│ ├── userControl.h│ ├── waypointControl.c│ └── waypointControl.h├── DRIVER│ ├── board.c│ ├── board.h│ ├── boardConfigBlueSkyV3.h│ ├── drv_adc.c│ ├── drv_adc.h│ ├── drv_can.c│ ├── drv_can.h│ ├── drv_flash.c│ ├── drv_flash.h│ ├── drv_i2c_soft.c│ ├── drv_i2c_soft.h│ ├── drv_ppm.c│ ├── drv_ppm.h│ ├── drv_pwm.c│ ├── drv_pwm.h│ ├── drv_sbus.c│ ├── drv_sbus.h│ ├── drv_spi.c│ ├── drv_spi.h│ ├── drv_usart.c│ ├── drv_usart.h│ ├── drv_usb.c│ └── drv_usb.h├── LOG│ ├── logger.c│ ├── logger.h│ ├── ulog.c│ ├── ulog.h│ ├── ulog_data.c│ └── ulog_data.h├── MATH│ ├── LevenbergMarquardt.c│ ├── LevenbergMarquardt.h│ ├── declination.c│ ├── declination.h│ ├── kalman3.c│ ├── kalman3.h│ ├── kalmanVel.c│ ├── kalmanVel.h│ ├── lowPassFilter.c│ ├── lowPassFilter.h│ ├── mathTool.c│ ├── mathTool.h│ ├── matrix3.c│ ├── matrix3.h│ ├── matrix6.c│ ├── matrix6.h│ ├── pid.c│ ├── pid.h│ ├── quaternion.c│ ├── quaternion.h│ ├── rotation.c│ ├── rotation.h│ ├── vector3.c│ └── vector3.h├── MESSAGE│ ├── bsklink.c│ ├── bsklink.h│ ├── bsklinkDecode.c│ ├── bsklinkDecode.h│ ├── bsklinkSend.c│ ├── bsklinkSend.h│ ├── mavlinkDecode.c│ ├── mavlinkDecode.h│ ├── mavlinkNotice.c│ ├── mavlinkNotice.h│ ├── mavlinkParam.c│ ├── mavlinkParam.h│ ├── mavlinkSend.c│ ├── mavlinkSend.h│ ├── message.c│ └── message.h├── MODULE│ ├── 2smpb.c│ ├── 2smpb.h│ ├── battery.c│ ├── battery.h│ ├── icm20602.c│ ├── icm20602.h│ ├── icm20689.c│ ├── icm20689.h│ ├── ist8310.c│ ├── ist8310.h│ ├── mmc3630.c│ ├── mmc3630.h│ ├── module.c│ ├── module.h│ ├── mpu6000.c│ ├── mpu6000.h│ ├── mpu6500.c│ ├── mpu6500.h│ ├── ms5611.c│ ├── ms5611.h│ ├── qmc5883.c│ ├── qmc5883.h│ ├── rgb.c│ ├── rgb.h│ ├── ublox.c│ └── ublox.h├── NAVIGATION│ ├── ahrs.c│ ├── ahrs.h│ ├── ahrsAux.c│ ├── ahrsAux.h│ ├── navigation.c│ └── navigation.h├── SENSOR│ ├── accelerometer.c│ ├── accelerometer.h│ ├── barometer.c│ ├── barometer.h│ ├── gps.c│ ├── gps.h│ ├── gyroscope.c│ ├── gyroscope.h│ ├── magnetometer.c│ ├── magnetometer.h│ ├── sensor.c│ └── sensor.h├── SYSTEM│ ├── faultDetect.c│ ├── faultDetect.h│ ├── flightStatus.c│ ├── flightStatus.h│ ├── parameter.c│ └── parameter.h├── TASK│ ├── TaskConfig.h│ ├── control_task.c│ ├── control_task.h│ ├── log_task.c│ ├── log_task.h│ ├── messageQueue.c│ ├── messageQueue.h│ ├── message_task.c│ ├── message_task.h│ ├── module_task.c│ ├── module_task.h│ ├── navigation_task.c│ ├── navigation_task.h│ ├── sensor_task.c│ └── sensor_task.h└── main.c 待添加……","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"编程规范","slug":"编程规范","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:29.530Z","comments":true,"path":"2021/10/19/编程规范/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","excerpt":"","text":"编程规范规范1. 原则 简洁明了，提高代码可读性，读的是代码而不是注释，注释永远都是辅助的。 零告警，严谨的语法才能保障代码表达和编译器理解的是一至的。 2. 排版 程序块之间、变量声明之间，用空行分隔 突出语法关键字 一行不要太长，换行增加可读性 Tab键排版 3. 注释 注释的目的是阐明意图目的，而不是翻译某行代码的动作 注释的原则是尽量代码自注释，代码越清晰，可读性越高 统一格式 **/* 注释内容 */**， *号与注释内容之间有一个空格 1234567891011/*************************************************Copyright //版权File name: // 文件名Author： //作者Version: //版本号Description: // 用于详细说明此程序文件完成的主要功能，与其他模块 // 或函数的接口，输出值、取值范围、含义及参数间的控 // 制、顺序、独立或依赖等关系Others: // 其它内容的说明Log: // 修改日志，包括修改内容，日期，修改人等*************************************************/ 123456/**@ Description: 函数描述，描述本函数的基本功能* @param 1 – 参数 1.* @param 2 – 参数 2* @return – 返回值*/ 4. 定义 命名风格 模块名+文件名+功能描述，之间采用短下划线分隔 功能描述部分，采用驼峰风格 例如， 1void SAFE_LASER_setLaserShield(uint8_t _EN); 宏定义 define 必须大写 typedef 可以小写 例如， 12#define OS_TASK_R200RXID1 0x198 /* HEX格式 */typedef uint32_t StackSize_t； /* 仅用于堆栈 */ 类型定义 使用linux自带类型定义规则 123456789101112#define uint8_t unsigned char#define int8_t char#define uint16_t unsigned short#define int16_t short#define uint32_t unsigned int#define int32_t int#define uint64_t unsigned long long#define int64_t long long#define TRUE 1#define FALSE 0#define NULL 0 5. 变量 变量通用规则 采用驼峰风格,首字母大写 在函数开始是全部定义，不允许在函数中间定义 变量命名必须可以表示其含义 必须初始化 局部变量 本地局部变量必须用static关键字修饰 全局变量 全局变量必须以g开头 函数变量 变量必须以_开头 123static uint8_t SafeLaserSet = 0;uint8_t gSafeLaserSet = 0;static uint8_t _SafeLaserSet = 0; 6. 函数 函数名必须能够自注释，必要是需要增加注释写明意图 内部函数必须使用static定义，命名可以不加模块名 外部函数 必须在头文件中声明， 命名时必须带模块名， 必须给出带注释，并写明函数意图，参数说明，返回值 12static uint_t SAFE_LASER_setLaseShield(uint8_t _EN);void SAFE_LASER_setLaseShield(uint8_t _EN); 7. 文件 头文件 命名规则模块名+功能，小写，例如os_task.h 格式如下 12345678#ifndef __OS_TASK_H__#define __OS_TASK_H__..../* 开放的宏定义 */..../* 开放的全局变量声明 */..../* 开放的函数声明 */#endif 源文件 命名规则模块名+功能，小写，例如os_task.c 格式如下，举例只为说明源文件中，各元素的顺序 123456789101112131415161718192021222324252627&lt;- 1 - 引用头文件 -&gt;#include &quot;os_task.h&quot;&lt;- 2 - 定义本文件用到的宏 -&gt;#define OS_TASK_SWITCH_INTERVAL 10 /* 单位ms */typedef uint32_t StackSize_t ； /* 仅用于堆栈 */typedef enum&#123;&#125;;typedef union&#123;&#125;;typedef struct&#123;&#125;;&lt;- 3 - 本地变量 -&gt;static StackSize_t *TopStack = NULL；&lt;- 4 - 开放的全局变量 -&gt;uint32_t gOsTaskEventBitMap = 0; &lt;- 5 - 本地函数，仅在本文件使用 -&gt;static void TASK_TaskSwitch(void)&#123; return；&#125;&lt;- 6 - 开放的函数 -&gt;void OS_TASK_TaskDelay(uint16_t _ms)&#123; return； &#125; 8.约定俗成简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354addition add 加subtraction sub 减multiplication mul 乘法division div 除法answer ans 响应、回答array arr 数组、集合average avg 平均buffer buf或buff 缓冲区capture cap或capt 捕获check chk 检查count cnt 计数器column col 列control ctrl 控制decode dec 解码、译码define def 定义delete del 删除destination dst或dest 目的display disp 显示encode enc 编码environment env 环境error err 错误float flt 浮动、浮点frequency freq 频率header hdr 开始、开头index idx 索引、指示、image img 影像、镜像increment inc 增加、增量initalize init 初始化iteration itr 循环、迭代length len 长度memory mem 内存middle mid 中值make mk 制造、形成message msg 消息number num 数量、编号operand opnd 操作数optimization opt 最优operator optr 操作packet pkt 消息包positon pos 位置previous pre或prev 以前的pointer ptr 指针record rcd 记录receive recv 收到、接收result res 结果return ret 返回source src 源头stack stk 栈string str 字符串table tab 表temporary tmp或temp 临时total tot 全部的time stamp ts 时间戳value val 值 有互斥意义的变量或者动作相反的函数应该是用互斥词组命名 12345add/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/deletelock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down 9. 模块 模块必须具有封装性，且对外提供尽量少的必要接口，接口必须提供详细的注释描述 模块的组织形式可以是文件夹形式，也可以是文件形式 文件都以小写命名 例如： 123456789101112. ├── src /* 应用层代码 */ │ ├── main.c /* 应用入口 */ │ ├── test.c │ ├── test1.c ├── include /* 设备驱动代码 */ │ ├── test.h │ ├── test1.h ├── debug /* 芯片厂家提供的库代码 */ │ ├── MakeFile │ ├── CMake │ └── main","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"hexo插件","slug":"hexo插件","date":"2021-05-12T04:30:12.000Z","updated":"2022-05-12T01:38:42.255Z","comments":true,"path":"2021/05/12/hexo插件/","link":"","permalink":"https://peitianyu.github.io/blog/2021/05/12/hexo%E6%8F%92%E4%BB%B6/","excerpt":"","text":"参考网址: (133条消息) hexo博客添加本地搜索功能_玖涯的博客-CSDN博客_hexo 本地搜索 (133条消息) Hexo（sakura）设置文章置顶+私密文章_cungudafa的博客-CSDN博客_hexo隐藏文章 本地搜索123456789101112# 未配置淘宝的数据源npm install hexo-generator-json-content --save#_config.yml中添加search: path: search.xml field: post content: true format: html# 在_config_butterfly.yml,将local_search,enable改为true# 本地搜索local_search: enable: true 私密文章1234567891011121314# 下载安装encryptnpm install hexo-blog-encrypt --save# _config.yml加入# 文章加密encrypt: enable: true abstract: 加密文章 message: 输入密码，查看文章# 使用---title: hexo插件date: 2021-5-12 12:30:12password: 123456---","categories":[{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/tags/blog/"}]}],"categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"},{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/categories/path-plan/"},{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/categories/matlab/"},{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/categories/path-tracking/"},{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/categories/win/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"},{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/categories/blog/"},{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"},{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"path_plan","slug":"path-plan","permalink":"https://peitianyu.github.io/blog/tags/path-plan/"},{"name":"matlab","slug":"matlab","permalink":"https://peitianyu.github.io/blog/tags/matlab/"},{"name":"path_tracking","slug":"path-tracking","permalink":"https://peitianyu.github.io/blog/tags/path-tracking/"},{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/tags/win/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"blog","slug":"blog","permalink":"https://peitianyu.github.io/blog/tags/blog/"},{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]}