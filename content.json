{"meta":{"title":"某飞行员的随笔","subtitle":"","description":"向西可剃度,向东可寻欢,但山野笨拙,我也笨拙.","author":"某飞行员","url":"https://peitianyu.github.io/blog","root":"/blog/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2021-10-24T05:07:09.649Z","comments":false,"path":"about/index.html","permalink":"https://peitianyu.github.io/blog/about/index.html","excerpt":"","text":"飞行员语录“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我QQ：1216582461 （嘀嘀~，麻烦让一下，我要开车了！）GitHub: https://github.com/peitianyu"},{"title":"tags","date":"2021-10-24T06:04:32.000Z","updated":"2021-10-24T06:04:51.547Z","comments":true,"path":"tags/index.html","permalink":"https://peitianyu.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-24T06:02:33.000Z","updated":"2021-10-24T06:05:58.328Z","comments":true,"path":"categories/index.html","permalink":"https://peitianyu.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"一种嵌入式设计模式","slug":"一种嵌入式设计模式","date":"2021-12-22T04:30:12.000Z","updated":"2021-12-22T07:41:08.688Z","comments":true,"path":"2021/12/22/一种嵌入式设计模式/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/22/%E4%B8%80%E7%A7%8D%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简介使用set与get方式实现的金字塔型架构,最下层仅提供函数调用,例如tcp,udp,uart,gpio等,第二层是模块层,这一层通过pthread线程实现自循环式模块实现,通过get与set对模块数据进行获取与设置.最后是逻辑层,仅对下层数据进行逻辑操作,不做模块实现. 文件结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145.├── CMakeLists.txt├── lib│ └── libcontrolcan.so└── src ├── GROUND_PANEL │ ├── Driver │ │ ├── Driver.h │ │ ├── Driver_utils.cpp │ │ ├── Driver_utils.h │ │ ├── Gpio.cpp │ │ ├── Gpio.h │ │ ├── controlcan.cpp │ │ ├── controlcan.h │ │ ├── socketCAN.cpp │ │ ├── socketCAN.h │ │ ├── tcp_cilent.cpp │ │ ├── tcp_cilent.h │ │ ├── usart.cpp │ │ └── usart.h │ ├── Math │ │ ├── Math.h │ │ ├── pid_control.cpp │ │ └── pid_control.h │ ├── ThirdParts │ │ ├── CFG_ini.cpp │ │ ├── CFG_ini.h │ │ ├── ModBUS │ │ │ ├── ascii │ │ │ │ ├── mbascii.c │ │ │ │ └── mbascii.h │ │ │ ├── functions │ │ │ │ ├── mbfunccoils.c │ │ │ │ ├── mbfuncdiag.c │ │ │ │ ├── mbfuncdisc.c │ │ │ │ ├── mbfuncholding.c │ │ │ │ ├── mbfuncinput.c │ │ │ │ ├── mbfuncother.c │ │ │ │ └── mbutils.c │ │ │ ├── include │ │ │ │ ├── mb.h │ │ │ │ ├── mbconfig.h │ │ │ │ ├── mbframe.h │ │ │ │ ├── mbfunc.h │ │ │ │ ├── mbport.h │ │ │ │ ├── mbproto.h │ │ │ │ └── mbutils.h │ │ │ ├── mb.c │ │ │ ├── port │ │ │ │ ├── port.h │ │ │ │ ├── portevent.c │ │ │ │ ├── portother.c │ │ │ │ ├── portserial.c │ │ │ │ └── porttimer.c │ │ │ ├── rtu │ │ │ │ ├── mbcrc.c │ │ │ │ ├── mbcrc.h │ │ │ │ ├── mbrtu.c │ │ │ │ └── mbrtu.h │ │ │ └── tcp │ │ │ ├── mbtcp.c │ │ │ └── mbtcp.h │ │ ├── cJSON.c │ │ ├── cJSON.h │ │ ├── tinyxml2.cpp │ │ └── tinyxml2.h │ └── param │ ├── AGVParameter.h │ ├── CFG.c │ ├── CFG.h │ ├── env_configure.c │ └── env_configure.h ├── Module │ ├── ActionCTRL │ │ ├── ActionCTRL.cpp │ │ ├── ActionCTRL.h │ │ └── ActionCTRLData.h │ ├── Battery │ │ ├── Battery.cpp │ │ ├── Battery.h │ │ ├── BatteryData.h │ │ ├── EIKTO_battery.cpp │ │ ├── EIKTO_battery.h │ │ ├── FR_battery.cpp │ │ └── FR_battery.h │ ├── CommWithPC │ │ ├── CommWithPC.cpp │ │ ├── CommWithPC.h │ │ └── CommWithPCData.h │ ├── Encoder │ │ ├── Encoder.cpp │ │ ├── Encoder.h │ │ ├── EncoderData.h │ │ ├── TOFI_encoder.cpp │ │ └── TOFI_encoder.h │ ├── HandShank │ │ ├── HandShank.cpp │ │ ├── HandShank.h │ │ ├── HandShankData.h │ │ ├── Logitech_controller.cpp │ │ └── Logitech_controller.h │ ├── IoBoard │ │ ├── IoBoard.cpp │ │ ├── IoBoard.h │ │ └── IoBoardData.h │ ├── Location │ │ ├── Location.cpp │ │ ├── Location.h │ │ └── LocationData.h │ ├── Map │ │ ├── LaserMAP.cpp │ │ ├── LaserMAP.h │ │ ├── Map.cpp │ │ ├── Map.h │ │ └── MapData.h │ ├── Module.cpp │ ├── Module.h │ ├── MoveCTRL │ │ ├── Kunhou │ │ │ ├── Kunhou_cJSON.cpp │ │ │ └── Kunhou_cJSON.h │ │ ├── MoveCTRL.cpp │ │ ├── MoveCTRL.h │ │ ├── MoveCtrlData.h │ │ └── Tongyi_Diff_Drive │ │ ├── Tongyi_Driver.cpp │ │ ├── Tongyi_Driver.h │ │ ├── diff_control.cpp │ │ └── diff_control.h │ ├── log.cpp │ └── log.h ├── Task │ ├── ModbusHMI.cpp │ ├── ModbusHMI.h │ ├── Music_Led.cpp │ ├── Music_Led.h │ ├── Safety.cpp │ ├── Safety.h │ ├── Task.cpp │ ├── Task.h │ ├── autoCtrl.cpp │ ├── autoCtrl.h │ ├── manualCtrl.cpp │ └── manualCtrl.h └── main.cpp 注意需要注意的一点是每个特定模块又三个对外文件,module.cpp module.h moduleData.h 模块使用,只有使用时初始化线程,如果不使用则注释掉 123456#include&quot;HandShank.h&quot;void init_HandShank()&#123; Logitech_thread();&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"pthread_mutex使用","slug":"pthread_mutex使用","date":"2021-12-17T04:30:12.000Z","updated":"2021-12-17T01:29:20.523Z","comments":true,"path":"2021/12/17/pthread_mutex使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/17/pthread_mutex%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:pthread详解_networkhunter的博客-CSDN博客_phread 关于pthread_mutex_lock使用_无专精则不能成，无涉猎则不能通-CSDN博客_pthread_mutex_timedlock linux读写锁 pthread_rwlock/互斥锁pthread_mutex_三眼二郎-CSDN博客_pthread_mutex_t pthread_rwlock_t 常用pthread_mutex_lock12345678910#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict abs_timeout); 使用1234567891011121314151617181920212223242526272829// 创建pthread_mutex_t mtx;// 初始化互斥量// 第二个参数为 NULL，互斥锁的属性会设置为默认属性pthread_mutex_init(&amp;mtx, NULL);// 阻塞调用pthread_mutex_lock(&amp;mtx);// 非堵塞调用int err = pthread_mutex_trylock(&amp;mtx);if(0 != err) &#123; if(EBUSY == err) &#123; //The mutex could not be acquired because it was already locked. &#125;&#125;// 超时调用struct timespec abs_timeout;abs_timeout.tv_sec = time(NULL) + 1;abs_timeout.tv_nsec = 0;int err = pthread_mutex_timedlock(&amp;mtx, &amp;abs_timeout);if(0 != err) &#123; if(ETIMEDOUT == err) &#123; //The mutex could not be locked before the specified timeout expired. &#125;&#125;// 释放互斥锁pthread_mutex_unlock(&amp;mtx);// 销毁线程锁pthread_mutex_destroy(&amp;mtx) 简单使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;/*初始化互斥锁*/pthread_cond_t cond = PTHREAD_COND_INITIALIZER;//init cond void *thread1(void*);void *thread2(void*); int i = 1; //global int main(void)&#123; pthread_t t_a; pthread_t t_b;//two thread pthread_create(&amp;t_a,NULL,thread2,(void*)NULL); pthread_create(&amp;t_b,NULL,thread1,(void*)NULL);//Create thread printf(&quot;t_a:0x%x, t_b:0x%x:&quot;, t_a, t_b); pthread_join(t_b,NULL);//wait a_b thread end pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); exit(0);&#125; void *thread1(void *junk)&#123; for(i = 1;i&lt;= 9; i++)&#123; pthread_mutex_lock(&amp;mutex); //互斥锁 printf(&quot;call thread1 \\n&quot;); if(i%3 == 0) &#123; pthread_cond_signal(&amp;cond); //send sianal to t_b printf(&quot;thread1:******i=%d\\n&quot;, i); &#125; else printf(&quot;thread1: %d\\n&quot;,i); pthread_mutex_unlock(&amp;mutex); printf(&quot;thread1: sleep i=%d\\n&quot;, i); sleep(1); printf(&quot;thread1: sleep i=%d******end\\n&quot;, i); &#125;&#125; void *thread2(void*junk)&#123; while(i &lt; 9) &#123; pthread_mutex_lock(&amp;mutex); printf(&quot;call thread2 \\n&quot;); if(i%3 != 0) pthread_cond_wait(&amp;cond,&amp;mutex); //wait printf(&quot;thread2: %d\\n&quot;,i); pthread_mutex_unlock(&amp;mutex); printf(&quot;thread2: sleep i=%d\\n&quot;, i); sleep(1); printf(&quot;thread2: sleep i=%d******end\\n&quot;, i); &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"pthread简单使用","slug":"pthread简单使用","date":"2021-12-17T04:30:12.000Z","updated":"2021-12-17T01:12:27.955Z","comments":true,"path":"2021/12/17/pthread简单使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/17/pthread%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:pthread 线程基本函数_chenwh_cn的博客-CSDN博客_pthread函数 Pthread线程基础学习_我的梦-CSDN博客_pthread教程 创建线程12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thread_fun(void* arg)&#123; int num = *((int*)arg); printf(&quot;int the new thread: num = %d\\n&quot;, num);&#125;int main(int argc, char *argv[])&#123; pthread_t tid; int test = 100; pthread_create(&amp;tid, NULL, thread_fun, (void *)&amp;test); while(1); return 0;&#125; 线程等待1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; static int ret = 5; // thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr] sleep(1); pthread_exit((void*)&amp;ret); //return (void*)&amp;ret;&#125;// 等待线程结束并回收线程资源，此函数会阻塞，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回int main(int argc, char *argv[])&#123; pthread_t tid; void *ret = NULL; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_join(tid, &amp;ret); printf(&quot;ret = %d\\n&quot;, *((int*)ret)); return 0;&#125; 分离线程1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; for(int i=0; i&lt;3; i++) &#123; printf(&quot;thread is runing\\n&quot;); sleep(1); &#125; return NULL;&#125;int main(int argc, char *argv[])&#123; pthread_t tid; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_detach(tid); if (pthread_join(tid, NULL)) // 立即返回，调用失败 &#123; printf(&quot;join not working\\n&quot;); &#125; printf(&quot;after join\\n&quot;); sleep(5); printf(&quot;master is leaving\\n&quot;); return 0;&#125; 退出线程1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *thead_fun(void *arg)&#123; static int ret = 5; // thread_join.cpp:7:13: warning: address of local variable ‘ret’ returned [-Wreturn-local-addr] sleep(1); pthread_exit((void*)&amp;ret); //return (void*)&amp;ret;&#125;int main(int argc, char *argv[])&#123; pthread_t tid; void *ret = NULL; pthread_create(&amp;tid, NULL, thead_fun, NULL); pthread_join(tid, &amp;ret); printf(&quot;ret = %d\\n&quot;, *((int*)ret)); return 0;&#125; 取消线程123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *thread_fun(void *arg)&#123; int i=1; printf(&quot;thread start \\n&quot;); while(1) &#123; i++; // 调用pthread_testcancel，让内核去检测是否需要取消当前线程。 pthread_testcancel(); &#125; return (void *)0;&#125;int main()&#123; void *ret=NULL; int iret=0; pthread_t tid; pthread_create(&amp;tid,NULL,thread_fun,NULL); sleep(1); pthread_cancel(tid);//取消线程 pthread_join(tid, &amp;ret); printf(&quot;thread 3 exit code %d\\n&quot;, (int)ret); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"简单pid控制","slug":"pid控制","date":"2021-12-16T04:30:12.000Z","updated":"2021-12-16T05:03:07.454Z","comments":true,"path":"2021/12/16/pid控制/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/16/pid%E6%8E%A7%E5%88%B6/","excerpt":"","text":"参考网址:[P、I、D参数分析及倒立摆心得_一念之间、-CSDN博客_pid 倒立摆](https://blog.csdn.net/tqs_1220/article/details/75249145?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=p表示 i表示 d表示&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-8-75249145.pc_search_em_sort&amp;spm=1018.2226.3001.4187) PID控制算法的C语言实现_我的博客-CSDN博客_pid算法c程序 PID作用12345P-------作用是提高系统响应速度,过大会出现震荡---------------------------快速性I-------作用是消除静差----------------------------------------------准确性D-------作用是抑制震荡----------------------------------------------稳定性/预测性 例程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// pid控制测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// P:响应 I:稳差 D:预判struct PID_CTRL&#123; float kp; float ki; float kd;&#125;;float pos_pid_control(float target, float current, struct PID_CTRL pid)&#123; static float err_last; float out,err_sum=0,err_d,err; err = target - current; err_sum += err; err_d = err - err_last; out = pid.kp * err + pid.ki * err_sum + pid.kd * err_d; err_last = err; return out;&#125;float gain_pid_control(float target, float current, struct PID_CTRL pid)&#123; static float err_last; float out=0; float err = target - current; out += pid.kp * (err-err_last) + pid.ki * err; err_last = err; return out;&#125;void test_pos_pid_control()&#123; struct PID_CTRL pid&#123;0.5,0.1,0.1&#125;; pid.kp = 0.5; pid.ki = 0.2; pid.kd = 0.1; float target = 10.0; float current = 0.0; for(int i = 0; i &lt; 100; i++) &#123; current += 0.1; printf(&quot;target: %f, current: %f, out: %f\\n&quot;, target, current, pos_pid_control(target, current, pid)); &#125;&#125;void test_gain_pid_control()&#123; struct PID_CTRL pid&#123;0.5,0.1,0.1&#125;; pid.kp = 0.5; pid.ki = 0.2; pid.kd = 0.1; float target = 10.0; float current = 0.0; for(int i = 0; i &lt; 100; i++) &#123; current += 0.1; printf(&quot;target: %f, current: %f, out: %f\\n&quot;, target, current, gain_pid_control(target, current, pid)); &#125;&#125;int main()&#123; test_pos_pid_control(); printf(&quot;********************************************\\n&quot;); test_gain_pid_control(); return 0;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"修改和校正树莓派时间","slug":"树莓派更新与校正时间","date":"2021-12-16T04:30:12.000Z","updated":"2021-12-16T03:32:36.086Z","comments":true,"path":"2021/12/16/树莓派更新与校正时间/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%A0%A1%E6%AD%A3%E6%97%B6%E9%97%B4/","excerpt":"","text":"参考网址:修改和校正树莓派时间_胡嘿嘿-CSDN博客_树莓派修改时间 步骤1234567891011# 修改时区sudo dpkg-reconfigure tzdata# 选择亚洲时区 Asia# 选择上海时间 Shanghai# 检查是否设置成功date# 校正时间sudo ntpd -s -d# 强制设置时间sudo date --s=&quot;2017-07-25 10:43:00&quot;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"c语言的三种传参方式","slug":"c语言的三种传参方式","date":"2021-12-15T04:30:12.000Z","updated":"2021-12-15T08:45:10.864Z","comments":true,"path":"2021/12/15/c语言的三种传参方式/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/15/c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include &lt;stdint.h&gt;using namespace std; int fun1(int a)&#123; return a*a;&#125; void man(int &amp;a)&#123; a=a*a;&#125; void cubeByReference(int *a)&#123; *a=*a * *a;&#125;void fun2(uint8_t* *buffer)&#123; uint8_t buf[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; *buffer = buf;&#125;int main()&#123; int a=5,b=5,number=5; cout&lt;&lt;fun1(a)&lt;&lt;endl; man(b); cout&lt;&lt;b&lt;&lt;endl; cubeByReference(&amp;number); cout&lt;&lt;number&lt;&lt;endl; uint8_t *buf; fun2(&amp;buf); printf(&quot;%d\\n&quot;, buf[0]); // for (int i = 0; i &lt; 10; ++i) // &#123; // printf(&quot;%d\\n&quot;, buf[i]); // &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"镜像源","slug":"镜像源","date":"2021-12-12T04:30:12.000Z","updated":"2021-12-12T13:05:28.462Z","comments":true,"path":"2021/12/12/镜像源/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/12/%E9%95%9C%E5%83%8F%E6%BA%90/","excerpt":"","text":"参考网址:华为镜像源: https://mirrors.huaweicloud.com/home 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"0ohm电阻作用","slug":"0ohm电阻目的","date":"2021-12-11T04:30:12.000Z","updated":"2021-12-11T03:55:31.183Z","comments":true,"path":"2021/12/11/0ohm电阻目的/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/11/0ohm%E7%94%B5%E9%98%BB%E7%9B%AE%E7%9A%84/","excerpt":"","text":"零欧姆电阻的主要作用有如下： 1,在电路中没有任何功能，只是在PCB上为了调试方便或兼容设计等原因。2,可以做跳线用，如果某段线路不用，直接不贴该电阻即可（不影响外观）。3,在匹配电路参数不确定的时候，以0欧姆代替，实际调试的时候，确定参数，再以具体数值的元件代替。4,想测某部分电路的耗电流的时候，可以去掉0ohm电阻，接上电流表，这样方便测耗电流。5,在布线时,如果实在布不过去了,也可以加一个0欧的电阻。6,在高频信号下，充当电感或电容。（与外部电路特性有关）电感用，主要是解决EMC问题。如地与地，电源和IC Pin间。7,单点接地（指保护接地、工作接地、直流接地在设备上相互分开,各自成为独立系统。）8,熔丝作用；9，单点接地，只要是地，最终都要接到一起，然后入大地。如果不接在一起就是”浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上有四种方法解决此问题：1、用磁珠连接；2、用电容连接；3、用电感连接；4、用0欧姆电阻连接。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。电容隔直通交，造成浮地。电感体积大，杂散参数多，不稳定。0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。10，跨接时用于电流回路，当分割电地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。11，配置电路，一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子。空置跳线在高频时相当于天线，用贴片电阻效果好。12，其他用途，布线时跨线；调试/测试用；临时取代其他贴片器件；作为温度补偿器件；更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔）。","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"}]},{"title":"pip","slug":"pip","date":"2021-12-11T04:30:12.000Z","updated":"2021-12-11T03:58:55.879Z","comments":true,"path":"2021/12/11/pip/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/11/pip/","excerpt":"","text":"参考网址:(8条消息) pip安装镜像_转载_qq_2711624322-CSDN博客_pip安装镜像 设pip默认镜像源_SimpleLikeMe的博客-CSDN博客 配置1234#临时使用pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple package#配置成固定镜像pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"linux定时器","slug":"linux内核定时器","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-11T01:59:23.774Z","comments":true,"path":"2021/12/10/linux内核定时器/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"参考网址:LInux下几种定时器的比较和使用_weixin_34358365的博客-CSDN博客 1、sleep，usleep和nanosleep123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;sched.h&gt;#define COUNT 1000#define MILLION 1000000Lint main(void)&#123; int i; struct timespec slptm; long tdif; struct timeval tend, tstart; slptm.tv_sec = 0; slptm.tv_nsec = 1000; //1000 ns = 1 us //struct sched_param param; //param.sched_priority = 0; //sched_setscheduler(getpid(), SCHED_FIFO, &amp;param); if (gettimeofday(&amp;tstart, NULL) == -1) &#123; fprintf(stderr, &quot;Failed to get start time\\n&quot;); return 1; &#125; for (i = 0; i &lt; COUNT; i++) &#123; if (nanosleep(&amp;slptm, NULL) == -1) &#123; perror(&quot;Failed to nanosleep&quot;); return 1; &#125; &#125; if (gettimeofday(&amp;tend, NULL) == -1) &#123; fprintf(stderr, &quot;Failed to get end time\\n&quot;); return 1; &#125; tdif = MILLION * (tend.tv_sec - tstart.tv_sec) + (tend.tv_usec - tstart.tv_usec); printf(&quot;nanosleep() time is %ld us\\n&quot;, tdif/COUNT); return 0;&#125; 2、使用信号量SIGALRM + alarm(),只能秒级123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;signal.h&gt;void timer(int sig)&#123; if(SIGALRM == sig) &#123; printf(&quot;timer\\n&quot;); alarm(1); //重新继续定时1s &#125; return ;&#125;int main()&#123; signal(SIGALRM, timer); //注册安装信号 alarm(1); //触发定时器 getchar(); return 0;&#125; 3、使用RTC(系统硬件提供的RTC，精度可调)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;linux/rtc.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[])&#123; unsigned long i = 0; unsigned long data = 0; int retval = 0; int fd = open (&quot;/dev/rtc&quot;, O_RDONLY); if(fd &lt; 0) &#123; perror(&quot;open&quot;); exit(errno); &#125; /*Set the freq as 4Hz*/ if(ioctl(fd, RTC_IRQP_SET, 1) &lt; 0) &#123; perror(&quot;ioctl(RTC_IRQP_SET)&quot;); close(fd); exit(errno); &#125; /* Enable periodic interrupts */ if(ioctl(fd, RTC_PIE_ON, 0) &lt; 0) &#123; perror(&quot;ioctl(RTC_PIE_ON)&quot;); close(fd); exit(errno); &#125; for(i = 0; i &lt; 100; i++) &#123; if(read(fd, &amp;data, sizeof(unsigned long)) &lt; 0) &#123; perror(&quot;read&quot;); close(fd); exit(errno); &#125; printf(&quot;timer\\n&quot;); &#125; /* Disable periodic interrupts */ ioctl(fd, RTC_PIE_OFF, 0); close(fd); return 0;&#125; 4、使用select()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/select.h&gt;#include &lt;time.h&gt;int Callback_1(int x) // Callback Function 1&#123; printf(&quot;Hello, this is Callback_1: x = %d \\n&quot;, x); return 0;&#125;//设置模板template&lt;typename T&gt;void setTimer(int seconds, int mseconds,T arg,int (*callback)(T)) // Set Timer&#123; struct timeval temp; temp.tv_sec = seconds; temp.tv_usec = mseconds; select(0, NULL, NULL, NULL, &amp;temp); callback(arg); return ;&#125;float last_time;float get_diff_time(void)&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); float time = tv.tv_sec%10 + tv.tv_usec / 1000000.0; if (time &lt; last_time) time += 10; float time_diff = time - last_time; last_time = time; return time_diff;&#125;int main()&#123; int a = 2; for (size_t i = 0; i &lt; 5; i++) &#123; float time_diff = get_diff_time(); printf(&quot;time_diff = %f \\n&quot;, time_diff); setTimer(1, 0, a, Callback_1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"ros2安装","slug":"ros2安装","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-13T14:04:24.498Z","comments":true,"path":"2021/12/10/ros2安装/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/ros2%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考网址:Ubuntu18.04 安装ROS Melodic &amp;&amp; Ros2 Dashing踩坑笔记_LukeyAlvin的博客-CSDN博客_ubuntu18安装ros2 鱼香ROS (fishros.com) 简介由于ros2很多并不完善,所以采用ros1+ros2的方式实现,这里采用常规+fishros的方式实现安装.最后采用在初始化使用shell脚本选择使用ros版本 Ros1安装ros安装 | 某飞行员的随笔 (peitianyu.github.io) Ros2安装12345678910111213141516171819# 设置UTF-8编码sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8# 更新软件源sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27;# 安装wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros# 通过如下命令添加到.bashrc(注意这里如果需要使用两个版本,这一步不需要设置)echo &quot;source /opt/ros/dashing/setup.bash&quot; &gt;&gt; ~/.bashrc# RWM功能sudo apt updatesudo apt install ros-dashing-rmw-opensplice-cpp # for OpenSplicesudo apt install ros-dashing-rmw-connext-cpp # for RTI Connext (requires license agreement)# ros1与ros2通信sudo apt updatesudo apt install ros-dashing-ros1-bridge 12345678910111213141516171819202122232425262728293031323334# 安装编译工具sudo apt update &amp;&amp; sudo apt install -y \\build-essential \\cmake \\git \\python3-colcon-common-extensions \\python3-pip \\python-rosdep \\python3-vcstool \\wget# install some pip packages needed for testingsudo -H python3 -m pip install -U \\argcomplete \\flake8 \\flake8-blind-except \\flake8-builtins \\flake8-class-newline \\flake8-comprehensions \\flake8-deprecated \\flake8-docstrings \\flake8-import-order \\flake8-quotes \\pytest-repeat \\pytest-rerunfailures# [Ubuntu 16.04] install extra packages not available or recent enough on Xenialpython3 -m pip install -U \\pytest \\pytest-cov \\pytest-runner \\setuptools# install Fast-RTPS dependenciessudo apt install --no-install-recommends -y \\libasio-dev \\libtinyxml2-dev 12345678910111213# 测试mkdir ~/ros2_wscd /ros2_wsgit clone https://ghproxy.com/https://github.com/zhangrelay/ros2_tutorialscd ros2_tutorialscolcon build# 设置环境变量(也可以将之放入.bashrc中)source /install/setup.sh # 第一个终端cd /ros_ws/ros2_tutorials/installros2 run demo_nodes_cpp listener# 第二个终端ros2 run demo_nodes_cpp talker 使用多个ros版本保存一个脚本文件,使用前运行1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi !注意:由于使用不通ros,因此安装时注意将之前保存在.bashrc中的# source /opt/ros/melodic/setup.bash# source /opt/ros/dashing/setup.bash注释掉","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"树莓派CAN","slug":"树莓派CAN","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-11T02:01:35.946Z","comments":true,"path":"2021/12/10/树莓派CAN/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/%E6%A0%91%E8%8E%93%E6%B4%BECAN/","excerpt":"","text":"参考网址:树莓派CAN通讯教程 - MCP2515_j353838430的博客-CSDN博客_树莓派can通信 (86条消息) SPI协议、MCP2515裸机驱动详解—-主流SPI总线接口原理_csshuke的专栏-CSDN博客_mcp2515 spi极性 mcp2515模块资料:http://pan.baidu.com/s/1hsi3I4k 简介使用mcp2515实现的spi转can通信 原理图 需要注意的是这里的片选,也就是说可以通过片选CS信号实现一个spi转多个can通信,INT引脚用于中断缓存数据,当接收到数据时会将数据先放入缓冲区 环境准备12345678910111213# 安装cantoolssudo apt install can-utilspip3 install cantools# 检测挂载ifconfig# 查看是否进入read状态sudo ip -s -d link show can0# 使能树莓派SPI并加载MCP2515内核驱动dtparam=spi=ondtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25dtoverlay=spi1-1cs# 重启sudo reboot -h now 1234567891011121314# 关闭can0sudo ip link set can0 down# 设置波特率sudo ip link set can0 type can bitrate 1000000# 开启can0sudo ip link set can0 up# 查看sudo ip -s -d link show can0# 接收报文candump any,0:0,#FFFFFFFF# 发送报文cansend can0 123#1122334455667788# 设置回环 波特率 250K ,用于测试can通路,在没有其它硬件连接测试的情况下，可以设定成回环，自发自收sudo ip link set can0 type can bitrate 500000 loopback on C语言使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180// test.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/can.h&gt;#include &lt;linux/can/raw.h&gt;#define command &quot;ip link set can0 type can bitrate 1000000&quot;//将CAN0波特率设置为500K#define up &quot;ifconfig can0 up&quot;//打开CAN0#define down &quot;ifconfig can0 down&quot;//关闭CAN0int can_init()&#123; //关闭CAN设备，设置波特率后，重新打开CAN设备 system(down); system(command); system(up); return 0;&#125;int can_send(can_frame frame)&#123; int s, nbytes; struct sockaddr_can addr; struct ifreq ifr; //创建套接字 s = socket(PF_CAN, SOCK_RAW, CAN_RAW); strcpy(ifr.ifr_name, &quot;can0&quot; ); //指定 can0 设备 ioctl(s, SIOCGIFINDEX, &amp;ifr); addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; //将套接字与 can0 绑定 bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)); //发送 frame[0] nbytes = write(s, &amp;frame, sizeof(frame)); if(nbytes != sizeof(frame)) &#123; printf(&quot;Send Error frame[0]\\n!&quot;); &#125; close(s); return 0;&#125;int can_receive(struct can_frame * r_frame,unsigned int filter_id)&#123; int s, nbytes = 0; struct sockaddr_can addr; struct ifreq ifr; struct can_frame frame; struct can_filter rfilter; // Initial fram memset(&amp;frame,0,sizeof(can_frame)); //创建套接字 s = socket(PF_CAN, SOCK_RAW, CAN_RAW); strcpy(ifr.ifr_name, &quot;can0&quot; ); //指定 can0 设备 ioctl(s, SIOCGIFINDEX, &amp;ifr); addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; //将套接字与 can0 绑定 bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)); //设置过滤规则，取消当前注释为禁用过滤规则，即不接收所有报文， // 不设置此项（即如当前代码被注释）为接收所有ID的报文。 if (filter_id != 0) &#123; rfilter.can_id = 0x123; // CAN_EFF_MASK | CAN_SFF_MASK rfilter.can_mask = CAN_SFF_MASK; setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, sizeof(rfilter)); &#125; while (nbytes == 0) &#123; //接收总线上的报文保存在frame中 nbytes = read(s, &amp;frame, sizeof(frame)); &#125; *r_frame = frame;#ifdef MSG_DEBUG printf(&quot;the nbytes:%d\\n&quot;, nbytes); printf(&quot;length:%d&quot;, sizeof(frame)); printf(&quot;ID=0x%X DLC=%d\\n&quot;, frame.can_id, frame.can_dlc); printf(&quot;data0=0x%02x\\n&quot;,frame.data[0]); printf(&quot;data1=0x%02x\\n&quot;,frame.data[1]); printf(&quot;data2=0x%02x\\n&quot;,frame.data[2]); printf(&quot;data3=0x%02x\\n&quot;,frame.data[3]); printf(&quot;data4=0x%02x\\n&quot;,frame.data[4]); printf(&quot;data5=0x%02x\\n&quot;,frame.data[5]); printf(&quot;data6=0x%02x\\n&quot;,frame.data[6]); printf(&quot;data7=0x%02x\\n&quot;,frame.data[7]);#endif return 0;&#125;int led_ctl_on(void)&#123; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); frame.can_id = 0x101; frame.can_dlc = 8; frame.data[0] = 1; can_send(frame); return 0;&#125;int led_ctl_off(void)&#123; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); frame.can_id = 0x101; frame.can_dlc = 8; frame.data[0] = 2; can_send(frame); return 0;&#125;float can_get_vol(void)&#123; float vol_vle = 0; struct can_frame frame; memset(&amp;frame, 0, sizeof(can_frame)); // wait until can frame 100 received can_receive(&amp;frame,0); printf(&quot;###############################\\n&quot;); printf(&quot;length:%d&quot;, sizeof(frame)); printf(&quot;ID=0x%X DLC=%d\\n&quot;, frame.can_id, frame.can_dlc); printf(&quot;data0=0x%02x\\n&quot;,frame.data[0]); printf(&quot;data1=0x%02x\\n&quot;,frame.data[1]); printf(&quot;data2=0x%02x\\n&quot;,frame.data[2]); printf(&quot;data3=0x%02x\\n&quot;,frame.data[3]); printf(&quot;data4=0x%02x\\n&quot;,frame.data[4]); printf(&quot;data5=0x%02x\\n&quot;,frame.data[5]); printf(&quot;data6=0x%02x\\n&quot;,frame.data[6]); printf(&quot;data7=0x%02x\\n&quot;,frame.data[7]); vol_vle = (float)frame.data[0]/50; return vol_vle;&#125;int main(int argc, char* argv[])&#123; char control_str[15]; float vol_val = 0; if (argc &lt; 2) &#123; printf(&quot;can_control service_type\\n&quot; &quot; example: ./can_control led_off/led_on/get_vol\\n&quot; ); return 0; &#125; strcpy(control_str,argv[1]); // debug printf(&quot;Argc : %d\\n&quot;,argc); printf(&quot;Argv : %s\\n , %s\\n&quot;,argv[0], argv[1]); // can_init(); if (strcmp(control_str,&quot;led_off&quot;)==0) &#123; led_ctl_off(); &#125; else if (strcmp(control_str,&quot;led_on&quot;)==0) &#123; led_ctl_on(); &#125; else if (strcmp(control_str,&quot;get_vol&quot;)==0) &#123; vol_val = can_get_vol(); printf(&quot;Voltage is : %5.2f V\\n&quot;, vol_val); &#125; else &#123; /* Do nothing */ &#125; return 0;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"k60_can_bootloader","slug":"k60_can_bootloader","date":"2021-12-10T04:30:12.000Z","updated":"2021-12-10T12:58:35.323Z","comments":true,"path":"2021/12/10/k60_can_bootloader/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/10/k60_can_bootloader/","excerpt":"","text":"参考demo:peitianyu/k60_bootloader (github.com) main.c文件配置进入mian.c文件加入头文件并引用bootloader_entry()函数 使用ID=0x10发送06 00 00 00 00 00 00 00，表示已经进入app 判断bootflag是否制一，若是，进入boot模式 canbus.c文件配置在canbus.c文件中引用头文件，并判断是否0x25发来数据，若有且data._data[0]==1,则bootflag=1 keil配置将hex烧录地址改为从0x6000开始 树莓派使用./bootloader can0 xx.hex 挂载win101sudo mount -t cifs //192.168.2.101/2021.04/CH-K-Lib/Project/1/bootloader/MDK/mk60d10/flash /k60 -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"linux_shell","slug":"linux_shell","date":"2021-12-09T04:30:12.000Z","updated":"2021-12-09T09:56:42.091Z","comments":true,"path":"2021/12/09/linux_shell/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/09/linux_shell/","excerpt":"","text":"删除除某文件以外其他文件参考网址:linux删除指定文件夹中某个文件除外的其他文件 - He元素 - 博客园 (cnblogs.com) 1234shopt -s extglobrm -fr !(file1)# 如果是多个要排除的，可以这样：rm -rf !(file1|file2) 挂载参考网址ubuntu 挂载windows共享目录的方法 - Supper阿欣 - 博客园 (cnblogs.com) linux挂载文件报错mount error(13): Permission denied - 风中追风h - 博客园 (cnblogs.com) win10 家庭版 cmd运行gpedit.msc找不到文件？ - 知乎 (zhihu.com) (2条消息) ubuntu挂载Windows共享文件夹_深藏功与名-CSDN博客_ubuntu挂载windows共享目录 pi挂载Ubuntu1sudo mount 192.168.2.111:/home/pty/nfs/ /mnt pi挂载win1sudo mount -t cifs //192.168.10.1/d /mnt -o username=&quot;pty&quot;,password=&quot;pty123&quot;,sec=ntlmssp,rw,dir_mode=0777,file_mode=0777","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"树莓派GPIO","slug":"树莓派GPIO","date":"2021-12-06T04:30:12.000Z","updated":"2021-12-10T08:59:49.090Z","comments":true,"path":"2021/12/06/树莓派GPIO/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/06/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO/","excerpt":"","text":"参考网址:树莓派GPIO控制–C语言篇_hu7850的博客-CSDN博客_树莓派c语言控制gpio IO表示 123456789101112131415161718192021222324252627ubuntu@ubuntu:~/Cmake/build$ gpio readall +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | | | 3.3v | | | 1 || 2 | | | 5v | | | | 2 | 8 | SDA.1 | ALT0 | 1 | 3 || 4 | | | 5v | | | | 3 | 9 | SCL.1 | ALT0 | 1 | 5 || 6 | | | 0v | | | | 4 | 7 | GPIO. 7 | IN | 1 | 7 || 8 | 1 | ALT5 | TxD | 15 | 14 | | | | 0v | | | 9 || 10 | 1 | ALT5 | RxD | 16 | 15 | | 17 | 0 | GPIO. 0 | IN | 1 | 11 || 12 | 0 | IN | GPIO. 1 | 1 | 18 | | 27 | 2 | GPIO. 2 | IN | 0 | 13 || 14 | | | 0v | | | | 22 | 3 | GPIO. 3 | IN | 0 | 15 || 16 | 0 | IN | GPIO. 4 | 4 | 23 | | | | 3.3v | | | 17 || 18 | 0 | IN | GPIO. 5 | 5 | 24 | | 10 | 12 | MOSI | ALT0 | 0 | 19 || 20 | | | 0v | | | | 9 | 13 | MISO | ALT0 | 0 | 21 || 22 | 0 | IN | GPIO. 6 | 6 | 25 | | 11 | 14 | SCLK | ALT0 | 0 | 23 || 24 | 1 | OUT | CE0 | 10 | 8 | | | | 0v | | | 25 || 26 | 1 | OUT | CE1 | 11 | 7 | | 0 | 30 | SDA.0 | IN | 1 | 27 || 28 | 1 | IN | SCL.0 | 31 | 1 | | 5 | 21 | GPIO.21 | IN | 1 | 29 || 30 | | | 0v | | | | 6 | 22 | GPIO.22 | IN | 1 | 31 || 32 | 0 | IN | GPIO.26 | 26 | 12 | | 13 | 23 | GPIO.23 | IN | 0 | 33 || 34 | | | 0v | | | | 19 | 24 | GPIO.24 | IN | 1 | 35 || 36 | 0 | IN | GPIO.27 | 27 | 16 | | 26 | 25 | GPIO.25 | IN | 0 | 37 || 38 | 0 | IN | GPIO.28 | 28 | 20 | | | | 0v | | | 39 || 40 | 0 | IN | GPIO.29 | 29 | 21 | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+ wiringpi安装wiring直接安装1234git clone git://git.drogon.net/wiringPicd wiringPi./buildbuild脚本会帮助你编译和安装wiringPi 或者通过此[下载](WiringPi/WiringPi: Gordon’s Arduino wiring-like WiringPi Library for the Raspberry Pi (Unofficial Mirror for WiringPi bindings) (github.com))安装 raspbian上安装1sudo apt-get install wiringpi 测试github上有examples可以测试 cmake使用wiringpi库12345678cmake_minimum_required(VERSION 2.8)project(display)find_library(WIRINGPI_LIBRARIES NAMES wiringPi)add_executable(display display.cpp)target_link_libraries(display $&#123;WIRINGPI_LIBRARIES&#125;) PYTHON1https://code.google.com/p/raspberry-gpio-python/ BCM2835 C Library安装123456wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.35.tar.gztar xvzf bcm2835-1.35.tar.gzcd bcm2835-1.35./configure makesudo make checksudo make install 测试可以使用examples测试","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"cmake实现多文件编译","slug":"cmake实现多文件编译","date":"2021-12-03T04:30:12.000Z","updated":"2021-12-06T06:18:58.802Z","comments":true,"path":"2021/12/03/cmake实现多文件编译/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/03/cmake%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/","excerpt":"","text":"Cmake文件结构123456789101112131415161718192021root@LAPTOP-49LFJ4NT:/root/cmake# tree.├── build└── src ├── CMakeLists.txt ├── Queue │ ├── CMakeLists.txt │ └── src │ ├── QUE.cpp │ ├── QUE.h │ └── main.cpp └── canalyst_test ├── CMakeLists.txt ├── lib │ └── libcontrolcan.so └── src ├── Tongyi_Driver.cpp ├── Tongyi_Driver.h ├── controlcan.cpp ├── controlcan.h └── main.cpp shell.sh12# 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译cd .. &amp;&amp; cd build &amp;&amp; cmake ../src &amp;&amp; make -j CmakeLists.txt12345678# 指定cmake版本cmake_minimum_required(VERSION 3.0)# 工程名project(Cmake)# 添加下层cmakeadd_subdirectory(canalyst_test)add_subdirectory(Queue) 执行文件1cd build &amp;&amp; bin/./queue","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"wsl使用串口","slug":"wsl使用串口","date":"2021-12-01T04:30:12.000Z","updated":"2021-12-01T13:06:01.257Z","comments":true,"path":"2021/12/01/wsl使用串口/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/01/wsl%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3/","excerpt":"","text":"参考网址:Win10的Linux子系统Ubuntu使用串口_晨之清风-CSDN博客 WSL | 上的 USB 到串行适配器科学计算|科学视讯 (scivision.dev) 由于本人技术原因usb转串行没成功 Linux下串口收发通信_颜言研的博客-CSDN博客_linux串口通信 minicom使用安装配置12345678# 安装minicomsudo apt-get install minicom# 设置串口,主要该串口号ttyS1,以及将硬件流改为nosudo minicom -s# 保存Save setup as df1# 运行sudo minicom 命令12345Ctrl+A E:回显Ctrl+A W：当显示的内容超过一行之后自动换行Ctrl+A C：清屏Ctrl+A O：打开配置选项Ctrl+A X：退出minicom c语言123456789101112131415161718192021222324252627// usart.h#ifndef _USART_H#define _USART_H //串口相关的头文件 #include&lt;stdio.h&gt; /*标准输入输出定义*/ #include&lt;stdlib.h&gt; /*标准函数库定义*/ #include&lt;unistd.h&gt; /*Unix 标准函数定义*/ #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; /*文件控制定义*/ #include&lt;termios.h&gt; /*PPSIX 终端控制定义*/ #include&lt;errno.h&gt; /*错误号定义*/ #include&lt;string.h&gt; //宏定义 #define FALSE -1 #define TRUE 0int UART0_Open(int fd,char*port);void UART0_Close(int fd) ; int UART0_Set(int fd,int speed,int flow_ctrl,int databits,int stopbits,int parity);int UART0_Init(int fd, int speed,int flow_ctrl,int databits,int stopbits,int parity) ;int UART0_Recv(int fd, char *rcv_buf,int data_len);int UART0_Send(int fd, char *send_buf,int data_len); #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280// usart.c#include&quot;usart.h&quot;/******************************************************************* *名称： UART0_Open *功能： 打开串口并返回串口设备文件描述 *入口参数： fd 文件描述符 port 串口号(ttyS0,ttyS1,ttyS2) *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Open(int fd,char*port)&#123; fd = open( port, O_RDWR|O_NOCTTY|O_NDELAY); if (fd&lt;0) &#123; perror(&quot;Can&#x27;t Open Serial Port&quot;); return(FALSE); &#125; //恢复串口为阻塞状态 if(fcntl(fd, F_SETFL, 0) &lt; 0) &#123; printf(&quot;fcntl failed!\\n&quot;); return(FALSE); &#125; else &#123; printf(&quot;fcntl=%d\\n&quot;,fcntl(fd, F_SETFL,0)); &#125; //测试是否为终端设备 if(0 == isatty(STDIN_FILENO)) &#123; printf(&quot;standard input is not a terminal device\\n&quot;); return(FALSE); &#125; else &#123; printf(&quot;isatty success!\\n&quot;); &#125; printf(&quot;fd-&gt;open=%d\\n&quot;,fd); return fd; &#125; /******************************************************************* *名称： UART0_Close *功能： 关闭串口并返回串口设备文件描述 *入口参数： fd 文件描述符 port 串口号(ttyS0,ttyS1,ttyS2) *出口参数：void *******************************************************************/ void UART0_Close(int fd) &#123; close(fd); &#125; /******************************************************************* *名称： UART0_Set *功能： 设置串口数据位，停止位和效验位 *入口参数： fd 串口文件描述符* speed 串口速度 * flow_ctrl 数据流控制 * databits 数据位 取值为 7 或者8 * stopbits 停止位 取值为 1 或者2 * parity 效验类型 取值为N,E,O,,S *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Set(int fd,int speed,int flow_ctrl,int databits,int stopbits,int parity) &#123; int i; int status; int speed_arr[] = &#123; B115200, B19200, B9600, B4800, B2400, B1200, B300&#125;; int name_arr[] = &#123;115200, 19200, 9600, 4800, 2400, 1200, 300&#125;; struct termios options; /* tcgetattr(fd,&amp;options)得到与fd指向对象的相关参数，并将它们保存于options,该函数还可以测试配置是否正确， 该串口是否可用等。若调用成功，函数返回值为0，若调用失败，函数返回值为1. */ if( tcgetattr( fd,&amp;options) != 0) &#123; perror(&quot;SetupSerial 1&quot;); return(FALSE); &#125; //设置串口输入波特率和输出波特率 for ( i= 0; i &lt; sizeof(speed_arr) / sizeof(int); i++) &#123; if (speed == name_arr[i]) &#123; cfsetispeed(&amp;options, speed_arr[i]); cfsetospeed(&amp;options, speed_arr[i]); &#125; &#125; //修改控制模式，保证程序不会占用串口 options.c_cflag |= CLOCAL; //修改控制模式，使得能够从串口中读取输入数据 options.c_cflag |= CREAD; //设置数据流控制 switch(flow_ctrl) &#123; case 0 ://不使用流控制 options.c_cflag &amp;= ~CRTSCTS; break; case 1 ://使用硬件流控制 options.c_cflag |= CRTSCTS; break; case 2 ://使用软件流控制 options.c_cflag |= IXON | IXOFF | IXANY; break; &#125; //设置数据位 //屏蔽其他标志位 options.c_cflag &amp;= ~CSIZE; switch (databits) &#123; case 5 : options.c_cflag |= CS5; break; case 6 : options.c_cflag |= CS6; break; case 7 : options.c_cflag |= CS7; break; case 8: options.c_cflag |= CS8; break; default: fprintf(stderr,&quot;Unsupported data size\\n&quot;); return (FALSE); &#125; //设置校验位 switch (parity) &#123; case &#x27;n&#x27;: case &#x27;N&#x27;: //无奇偶校验位。 options.c_cflag &amp;= ~PARENB; options.c_iflag &amp;= ~INPCK; break; case &#x27;o&#x27;: case &#x27;O&#x27;://设置为奇校验 options.c_cflag |= (PARODD | PARENB); options.c_iflag |= INPCK; break; case &#x27;e&#x27;: case &#x27;E&#x27;://设置为偶校验 options.c_cflag |= PARENB; options.c_cflag &amp;= ~PARODD; options.c_iflag |= INPCK; break; case &#x27;s&#x27;: case &#x27;S&#x27;: //设置为空格 options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; break; default: fprintf(stderr,&quot;Unsupported parity\\n&quot;); return (FALSE); &#125; // 设置停止位 switch (stopbits) &#123; case 1: options.c_cflag &amp;= ~CSTOPB; break; case 2: options.c_cflag |= CSTOPB; break; default: fprintf(stderr,&quot;Unsupported stop bits\\n&quot;); return (FALSE); &#125; //修改输出模式，原始数据输出 options.c_oflag &amp;= ~OPOST; options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); //options.c_lflag &amp;= ~(ISIG | ICANON); //设置等待时间和最小接收字符 options.c_cc[VTIME] = 1; /* 读取一个字符等待1*(1/10)s */ options.c_cc[VMIN] = 1; /* 读取字符的最少个数为1 */ //如果发生数据溢出，接收数据，但是不再读取 刷新收到的数据但是不读 tcflush(fd,TCIFLUSH); //激活配置 (将修改后的termios数据设置到串口中） if (tcsetattr(fd,TCSANOW,&amp;options) != 0) &#123; perror(&quot;com set error!\\n&quot;); return (FALSE); &#125; return (TRUE); &#125; /******************************************************************* *名称： UART0_Init() *功能： 串口初始化 *入口参数： fd 文件描述符 * speed 串口速度 * flow_ctrl 数据流控制 * databits 数据位 取值为 7 或者8 * stopbits 停止位 取值为 1 或者2 * parity 效验类型 取值为N,E,O,,S * *出口参数：正确返回为1，错误返回为0 *******************************************************************/ int UART0_Init(int fd, int speed,int flow_ctrl,int databits,int stopbits,int parity) &#123; int err; //设置串口数据帧格式 if (UART0_Set(fd,115200,0,8,1,&#x27;N&#x27;) == FALSE) &#123; return FALSE; &#125; else &#123; return TRUE; &#125; &#125; /******************************************************************* * 名称： UART0_Recv * 功能： 接收串口数据 * 入口参数： fd 文件描述符 * rcv_buf 接收串口中数据存入rcv_buf缓冲区中 * data_len 一帧数据的长度 * 出口参数： 正确返回为1，错误返回为0 *******************************************************************/ int UART0_Recv(int fd, char *rcv_buf,int data_len) &#123; int len,fs_sel; fd_set fs_read; struct timeval time; FD_ZERO(&amp;fs_read); FD_SET(fd,&amp;fs_read); time.tv_sec = 10; time.tv_usec = 0; //使用select实现串口的多路通信 fs_sel = select(fd+1,&amp;fs_read,NULL,NULL,&amp;time); printf(&quot;fs_sel = %d\\n&quot;,fs_sel); if(fs_sel) &#123; len = read(fd,rcv_buf,data_len); return len; &#125; else &#123; return FALSE; &#125; &#125; /******************************************************************** * 名称： UART0_Send * 功能： 发送数据 * 入口参数： fd 文件描述符 * send_buf 存放串口发送数据 * data_len 一帧数据的个数 * 出口参数： 正确返回为1，错误返回为0 *******************************************************************/ int UART0_Send(int fd, char *send_buf,int data_len) &#123; int len = 0; len = write(fd,send_buf,data_len); if (len == data_len ) &#123; printf(&quot;send data is %s\\n&quot;,send_buf); return len; &#125; else &#123; tcflush(fd,TCOFLUSH); return FALSE; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// main.c#include &quot;usart.h&quot;#include&lt;stdio.h&gt; /*标准输入输出定义*/ #include&lt;stdlib.h&gt; /*标准函数库定义*/ #include&lt;unistd.h&gt; /*Unix 标准函数定义*/ #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; /*文件控制定义*/ #include&lt;termios.h&gt; /*PPSIX 终端控制定义*/ #include&lt;errno.h&gt; /*错误号定义*/ #include&lt;string.h&gt;int main(int argc, char **argv) &#123; int fd = -1; //文件描述符，先定义一个与程序无关的值，防止fd为任意值导致程序出bug int err; //返回调用函数的状态 int len; int i; char rcv_buf[256]; char send_buf[256]; fd = UART0_Open(fd,&quot;ttyS1&quot;); //打开串口，返回文件描述符 do &#123; err = UART0_Init(fd,115200,0,8,1,&#x27;N&#x27;); printf(&quot;Set Port Exactly!\\n&quot;); sleep(1); &#125;while(FALSE == err || FALSE == fd); if(0) //开发板向pc发送数据的模式 &#123; send_buf = (char*) &quot;hello world!&quot;; while(1) &#123; len = UART0_Send(fd,send_buf,40); if(len &gt; 0) printf(&quot;send data successful\\n&quot;); sleep(1); &#125; UART0_Close(fd); &#125; else //开发板收到pc发送的数据的模式 &#123; while (1) //循环读取数据 &#123; len = UART0_Recv(fd, rcv_buf,sizeof(rcv_buf)); if(len &gt; 0) &#123; rcv_buf[len] = &#x27;\\0&#x27;; printf(&quot;receive data is %s\\n&quot;,rcv_buf); &#125; else &#123; printf(&quot;cannot receive data\\n&quot;); &#125; sleep(1); &#125; UART0_Close(fd); &#125; &#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"查看程序使用情况","slug":"查看程序使用","date":"2021-12-01T04:30:12.000Z","updated":"2021-12-01T12:37:33.447Z","comments":true,"path":"2021/12/01/查看程序使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/12/01/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址Linux下查看某个进程所占用的资源_mayue_web的博客-CSDN博客_查看进程占用资源 shell例程12345678910111213141516#!/bin/bash# 更改这里的./Tungray运行程序,用于查看pidps -aux | grep ./Tungray &gt; pid# 读取第一行,并解析pidpid=`awk &#x27;NR==1&#123;print $2&#125;&#x27; pid`cat /proc/$pid/status &gt; pid# 读取第一行,并解析pidstate=`awk &#x27;NR==2&#123;print $2&#125;&#x27; pid`echo &quot;state:&quot;$state`awk &#x27;NR==2&#123;print $3&#125;&#x27; pid`VmSize=`awk &#x27;NR==12&#123;print $2&#125;&#x27; pid`echo &quot;VmSize:&quot;$VmSize`awk &#x27;NR==12&#123;print $3&#125;&#x27; pid`VmRSS=`awk &#x27;NR==15&#123;print $2&#125;&#x27; pid`echo &quot;VmRSS:&quot;$VmRSS`awk &#x27;NR==15&#123;print $3&#125;&#x27; pid`Threads=`awk &#x27;NR==21&#123;print $2&#125;&#x27; pid`echo &quot;Threads:&quot;$Threads 1234567891011121314151617181920212223242526272829Name 应用程序或命令的名字 State 任务的状态，运行/睡眠/僵死/ SleepAVG 任务的平均等待时间(以nanosecond为单位)，交互式任务因为休眠次数多、时间长，它们的 sleep_avg 也会相应地更大一些，所以计算出来的优先级也会相应高一些。 Tgid 线程组号 Pid 任务ID Ppid 父进程ID TracerPid 接收跟踪该进程信息的进程的ID号 Uid Uid euid suid fsuid Gid Gid egid sgid fsgid FDSize 文件描述符的最大个数，file-&gt;fds Groups VmSize(KB) 任务虚拟地址空间的大小 (total_vm-reserved_vm)，其中total_vm为进程的地址空间的大小，reserved_vm：进程在预留或特殊的内存间的物理页 VmLck(KB) 任务已经锁住的物理内存的大小。锁住的物理内存不能交换到硬盘 (locked_vm) VmRSS(KB) 应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss) VmData(KB) 程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据； (total_vm-shared_vm-stack_vm) VmStk(KB) 任务在用户态的栈的大小 (stack_vm) VmExe(KB) 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库 (end_code-start_code) VmLib(KB) 被映像到任务的虚拟内存空间的库的大小 (exec_lib) VmPTE 该进程的所有页表的大小，单位：kb Threads 共享使用该信号描述符的任务的个数，在POSIX多线程序应用程序中，线程组中的所有线程使用同一个信号描述符。 SigQ 待处理信号的个数 SigPnd 屏蔽位，存储了该线程的待处理信号 ShdPnd 屏蔽位，存储了该线程组的待处理信号 SigBlk 存放被阻塞的信号 SigIgn 存放被忽略的信号 SigCgt 存放被俘获到的信号 CapInh Inheritable，能被当前进程执行的程序的继承的能力 CapPrm Permitted，进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的，CapEff是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性 CapEff Effective，进程的有效能力","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"easy_logger","slug":"easy_log","date":"2021-11-26T04:30:12.000Z","updated":"2021-11-28T03:38:08.768Z","comments":true,"path":"2021/11/26/easy_log/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/26/easy_log/","excerpt":"","text":"参考网址:一款超轻量级(ROM&lt;1.6K, RAM&lt;0.3k)、高性能的 C/C++ 日志库 移植到linuxpeitianyu/easy_log (github.com) 注意修改log文件保存路径,在easy_log/include/elog_file_cfg.h中 一款更加轻量化的log工具,可以自行更改函数,实现功能 peitianyu/light_log (github.com)","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"Mk60+shell_letter","slug":"shell_letter","date":"2021-11-26T04:30:12.000Z","updated":"2021-11-26T06:12:11.961Z","comments":true,"path":"2021/11/26/shell_letter/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/26/shell_letter/","excerpt":"","text":"参考网址:letter-shell | 一个功能强大的嵌入式shell_Mculover666的博客（嵌入式）-CSDN博客_letter shell 实例12345678910111213141516171819202122232425262728293031323334353637383940414243//shell_port.c/** * @brief shell移植到STM32L431时的接口实现 * @author mculover666 * @date 2020/03/27 */#include &quot;shell.h&quot;#include &quot;uart.h&quot;#include &quot;shell_port.h&quot;/* 1. 创建shell对象，开辟shell缓冲区 */Shell shell;char shell_buffer[512];/* 2. 自己实现shell写函数 *///shell写函数原型：typedef void (*shellWrite)(const char);/** * @brief 用户shell写 * * @param data 数据 * @param len 数据长度 * * @return short 实际写入的数据长度 */short userShellWrite(char *data, unsigned short len)&#123; for(int i = 0;i&lt;len;i++) &#123; UART_WriteByte(HW_UART0, data[i]); &#125; return len;&#125;/* 3. 编写初始化函数 */void User_Shell_Init(void)&#123; //注册自己实现的写函数 shell.write = userShellWrite; //调用shell初始化函数 shellInit(&amp;shell, shell_buffer, 512);&#125; 12345678910111213// shell_port.h#ifndef _SHELL_PORT_H_#define _SHELL_PORT_H_#include &quot;shell.h&quot;/* 将shell定义为外部变量，在串口中断回调函数中还要使用 */extern Shell shell;/* 声明自己编写的初始化函数 */void User_Shell_Init(void);#endif /* _SHELL_PORT_H_ */ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;gpio.h&quot;#include &quot;common.h&quot;#include &quot;uart.h&quot;#include &quot;cpuidy.h&quot;#include &quot;shell_port.h&quot;uint16_t recv_buf = 0;/* USER CODE BEGIN 0 */int test(int i, char ch, char *str)&#123; printf(&quot;input int: %d, char: %c, string: %s\\r\\n&quot;, i, ch, str); return 0;&#125;static void UART_RX_ISR(uint16_t byteReceived)&#123; //调用shell处理数据的接口 recv_buf = byteReceived; shellHandler(&amp;shell, recv_buf);&#125;int main(void)&#123; DelayInit(); uint32_t instance = GPIO_QuickInit(HW_GPIOE, 0, kGPIO_Mode_OPP); UART_QuickInit(UART0_RX_PA01_TX_PA02, 115200); /* 配置UART 中断配置 打开接收中断 安装中断回调函数 */ UART_CallbackRxInstall(HW_UART0, UART_RX_ISR); /* 打开串口接收中断功能 IT 就是中断的意思*/ UART_ITDMAConfig(HW_UART0, kUART_IT_Rx, true); User_Shell_Init(); while(1) &#123; /* 闪烁小灯 */ GPIO_ToggleBit(HW_GPIOE, 0); DelayMs(500); &#125;&#125;//导出到命令列表里SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), test, test, test);","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"amcl原理分析","slug":"amcl原理分析","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T09:33:29.720Z","comments":true,"path":"2021/11/25/amcl原理分析/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/amcl%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"参考网址:slam 学习之 AMCL 概念与原理分析_学之知之的博客-CSDN博客_amcl定位原理 机器人定位技术：AMCL的参数你真的会调了吗？(一） - 知乎 (zhihu.com) 改写amcl ROS导航包源码学习2 — 定位 - 知乎 (zhihu.com) 概念算法 运动模型(里程计模型) 测量模型(波束模型与似然域模型) 采样算法(KLD采样) 蒙特卡洛算法 自适应蒙特卡洛算法 运动模型关于速度模型与里程计模型 ,主要采取采样模型 概率机器人 这里主要使用里程计模型 测量模型波束模型主要调整六个参数: ， ， ， ， （ 的方差）和λ（动态障碍物的影响力度) 似然域模型主要调整两个参数 。 KLD采样目的:将估计的概率分布转化为真实的概率分布。 蒙特卡洛算法","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"boost_thread","slug":"boost_thread","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T08:34:45.643Z","comments":true,"path":"2021/11/25/boost_thread/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/boost_thread/","excerpt":"","text":"参考网址:了解boost C++ Boost库分类总结（个人收藏） - 知乎 (zhihu.com) boost教程 Highscore - Boost C++ 库 - 多线程 boost多线程同步简单使用12345678910111213141516171819202122232425262728#include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) &#123; boost::this_thread::sleep(boost::posix_time::seconds(seconds)); &#125; boost::mutex mutex; void thread() &#123; for (int i = 0; i &lt; 5; ++i) &#123; wait(1); mutex.lock(); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; mutex.unlock(); &#125; &#125; int main() &#123; boost::thread t1(thread); boost::thread t2(thread); t1.join(); t2.join(); &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"amcl简单使用","slug":"amcl简单使用","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T08:55:51.979Z","comments":true,"path":"2021/11/25/amcl简单使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/amcl%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:AMCL介绍及参数说明_走过_冬天的博客-CSDN博客_amcl参数配置 深入AMCL(三):AMCL手动初始化后如何自动定位_yuanguobin01的博客-CSDN博客 配置amcl_demo.launch 1234567891011121314151617181920212223242526&lt;launch&gt; &lt;!-- r2000驱动 --&gt; &lt;include file=&quot;$(find pepperl_fuchs_r2000)/launch/gui_example.launch&quot;/&gt; &lt;!-- Map server --&gt; &lt;!-- 发布map.yaml,其中包含了pgm文件位置--&gt; &lt;arg name=&quot;map_file&quot; default=&quot;$(find run)/map/mymap.yaml&quot;/&gt; &lt;node name=&quot;map_server&quot; pkg=&quot;map_server&quot; type=&quot;map_server&quot; args=&quot;$(arg map_file)&quot; /&gt; &lt;!-- Localization --&gt; &lt;include file=&quot;$(find run)/launch/amcl.launch&quot;/&gt; &lt;!-- 获取odom数据 --&gt; &lt;!-- 由于采用的是里程计模型,注意里程计的位置输出尤为关键 --&gt; &lt;!-- &lt;node name=&quot;tcp_server&quot; pkg=&quot;tcp_server&quot; type=&quot;tcp_server&quot; /&gt; --&gt; &lt;!-- 注意坐标转换:map-&gt;odom-&gt;base_link-&gt;laser_link --&gt; &lt;!-- 如果转换多了,会报错,多转换可能会报laserscan超时,少了,rviz会报没有上级坐标系 --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;map_to_odom_broadcaster&quot; args=&quot;0 0 0 0 0 0 /map /odom 100&quot;/&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0 0 0 0 /base_link /laser_link 100&quot;/&gt; &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find run)/rviz/hector_map.rviz&quot;/&gt;&lt;/launch&gt; amcl.launch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;launch&gt; &lt;arg name=&quot;use_map_topic&quot; default=&quot;false&quot;/&gt; &lt;arg name=&quot;scan_topic&quot; default=&quot;scan&quot;/&gt; &lt;arg name=&quot;initial_pose_x&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;initial_pose_y&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;initial_pose_a&quot; default=&quot;0.0&quot;/&gt; &lt;arg name=&quot;odom_frame_id&quot; default=&quot;odom&quot;/&gt; &lt;arg name=&quot;base_frame_id&quot; default=&quot;base_link&quot;/&gt; &lt;arg name=&quot;global_frame_id&quot; default=&quot;map&quot;/&gt; &lt;node pkg=&quot;amcl&quot; type=&quot;amcl&quot; name=&quot;amcl&quot;&gt; &lt;param name=&quot;use_map_topic&quot; value=&quot;$(arg use_map_topic)&quot;/&gt; &lt;!-- Publish scans from best pose at a max of 10 Hz --&gt; &lt;!-- 差分模型 --&gt; &lt;param name=&quot;odom_model_type&quot; value=&quot;diff&quot;/&gt; &lt;!-- 速度模型参数 --&gt; &lt;param name=&quot;odom_alpha5&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;gui_publish_rate&quot; value=&quot;10.0&quot;/&gt; &lt;param name=&quot;laser_max_beams&quot; value=&quot;810&quot;/&gt; &lt;param name=&quot;laser_max_range&quot; value=&quot;-1&quot;/&gt; &lt;param name=&quot;min_particles&quot; value=&quot;500&quot;/&gt; &lt;param name=&quot;max_particles&quot; value=&quot;5000&quot;/&gt; &lt;param name=&quot;kld_err&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;kld_z&quot; value=&quot;0.99&quot;/&gt; &lt;!-- 里程计模型调节超参 --&gt; &lt;param name=&quot;odom_alpha1&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha2&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha3&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha4&quot; value=&quot;0.2&quot;/&gt; &lt;!-- 一般情况而言,高斯误差会比较大,可以设置大一些 --&gt; &lt;param name=&quot;laser_z_hit&quot; value=&quot;0.95&quot;/&gt; &lt;param name=&quot;laser_z_short&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_max&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_rand&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_sigma_hit&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_lambda_short&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;laser_model_type&quot; value=&quot;likelihood_field&quot;/&gt; &lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt; &lt;param name=&quot;laser_likelihood_max_dist&quot; value=&quot;2.0&quot;/&gt; &lt;param name=&quot;update_min_d&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;update_min_a&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_frame_id&quot; value=&quot;$(arg odom_frame_id)&quot;/&gt; &lt;param name=&quot;base_frame_id&quot; value=&quot;$(arg base_frame_id)&quot;/&gt; &lt;param name=&quot;global_frame_id&quot; value=&quot;$(arg global_frame_id)&quot;/&gt; &lt;param name=&quot;resample_interval&quot; value=&quot;1&quot;/&gt; &lt;!-- Increase tolerance because the computer can get quite busy --&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;1.0&quot;/&gt; &lt;!-- 快慢指针,一般slow会小一些,良好的值可能为0.001,fast可能为0.01 --&gt; &lt;param name=&quot;recovery_alpha_slow&quot; value=&quot;0.0&quot;/&gt; &lt;param name=&quot;recovery_alpha_fast&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 初始位姿 --&gt; &lt;param name=&quot;initial_pose_x&quot; value=&quot;$(arg initial_pose_x)&quot;/&gt; &lt;param name=&quot;initial_pose_y&quot; value=&quot;$(arg initial_pose_y)&quot;/&gt; &lt;param name=&quot;initial_pose_a&quot; value=&quot;$(arg initial_pose_a)&quot;/&gt; &lt;remap from=&quot;scan&quot; to=&quot;$(arg scan_topic)&quot;/&gt; &lt;/node&gt;&lt;/launch&gt;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"boost安装与测试","slug":"boost安装与测试","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T08:36:56.676Z","comments":true,"path":"2021/11/25/boost安装与测试/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/boost%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/","excerpt":"","text":"参考网址:Ubuntu下安装boost库_上善若水-CSDN博客 在Ubuntu上安装boost库_一点一滴-CSDN博客 Ubuntu20.04安装boost库_vanyongqi-CSDN博客_ubuntu 安装boost 安装apt安装1sudo apt-get install libboost-dev build安装 下载boost库:Boost C++ Libraries 解压: tar -xzvf boost_1_xx_xx.tar.gz 进入解压目录,执行脚本,sudo ./bootstrap.sh 安装, sudo ./b2 install 测试环境变量 123456sudo gedit /etc/profile #在文件末尾添加export CPLUS_INCLUDE_PATH=/usr/local/include/boost:$CPLUS_INCLUDE_PATHexport LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATHexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 测试1sudo nano test.cpp 12345678910#include&lt;iostream&gt;#include&lt;boost/bind.hpp&gt;using namespace std;using namespace boost;int fun(int x,int y)&#123;return x+y;&#125;int main()&#123; int m=1;int n=2; cout&lt;&lt;boost::bind(fun,_1,_2)(m,n)&lt;&lt;endl; return 0;&#125; 1g++ test.cpp -o test cmake使用boost库1234567// CMakeLists.txtcmake_minimum_required(VERSION 2.8.3)project(boost_test)find_package(Boost REQUIRED COMPONENTS system thread)include_directories($&#123;Boost_INCLUDE_DIRS&#125;)add_executable(boost_test boost_test.cpp)target_link_libraries(boost_test $&#123;Boost_LIBRARIES&#125;) 1234567891011// boost_test.cpp#include&lt;iostream&gt;#include&lt;boost/bind.hpp&gt;using namespace std;using namespace boost;int fun(int x,int y)&#123;return x+y;&#125;int main()&#123; int m=1;int n=2; cout&lt;&lt;boost::bind(fun,_1,_2)(m,n)&lt;&lt;endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"strcpy重写","slug":"strcpy重写","date":"2021-11-25T04:30:12.000Z","updated":"2021-11-25T05:41:55.590Z","comments":true,"path":"2021/11/25/strcpy重写/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/25/strcpy%E9%87%8D%E5%86%99/","excerpt":"","text":"参考网址:什么？面试官让我写strcpy()函数_m0_57304511的博客-CSDN博客 strpy1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;assert.h&gt;char * my_strcpy(char* dest, const char* src)//const可以防止源字符串被改变&#123; // 使用断言避免传入空指针 assert( dest &amp;&amp; src ); char* ret = dest; // 按地址复制,直到为空 while(*dest++ = *src++) &#123; ; &#125; return ret;&#125;int main()&#123; char arr1[20] = &#123; 0 &#125;; char arr2[] = &quot;hello&quot;; printf(&quot;%s\\n&quot;, my_strcpy(arr1, arr2)); return 0;&#125; mempy12345678910void * memcpy(void *dest, const void *src, unsigned int count); &#123; if ((src == NULL) || (dest == NULL)) return; while (count--) *dest++ = *src++; return dest; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"cjson精度丢失","slug":"cjson精度丢失","date":"2021-11-24T04:30:12.000Z","updated":"2021-11-24T05:45:10.708Z","comments":true,"path":"2021/11/24/cjson精度丢失/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/24/cjson%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/","excerpt":"","text":"参考网址:(80条消息) cJSON精度丢失问题_weixin_33858485的博客-CSDN博客 在cJSON.c中的print_number函数中的sprintf((char*)number_buffer, &quot;%1.17g&quot;, d);更改为 sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* Render the number nicely from the given item into a string. */static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)&#123; unsigned char *output_pointer = NULL; double d = item-&gt;valuedouble; int length = 0; size_t i = 0; unsigned char number_buffer[26] = &#123;0&#125;; /* temporary buffer to print the number into */ unsigned char decimal_point = get_decimal_point(); double test = 0.0; if (output_buffer == NULL) &#123; return false; &#125; /* This checks for NaN and Infinity */ if (isnan(d) || isinf(d)) &#123; length = sprintf((char*)number_buffer, &quot;null&quot;); &#125; else &#123; /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */ // 更改这里的1.4,这里指的是保留4位小数 length = sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); /* Check whether the original double can be recovered */ if ((sscanf((char*)number_buffer, &quot;%lg&quot;, &amp;test) != 1) || !compare_double((double)test, d)) &#123; /* If not, print with 17 decimal places of precision */ // 更改这里的1.4,这里指的是保留4位小数 length = sprintf((char*)number_buffer, &quot;%1.4g&quot;, d); &#125; &#125; /* sprintf failed or buffer overrun occurred */ if ((length &lt; 0) || (length &gt; (int)(sizeof(number_buffer) - 1))) &#123; return false; &#125; /* reserve appropriate space in the output */ output_pointer = ensure(output_buffer, (size_t)length + sizeof(&quot;&quot;)); if (output_pointer == NULL) &#123; return false; &#125; /* copy the printed number to the output and replace locale * dependent decimal point with &#x27;.&#x27; */ for (i = 0; i &lt; ((size_t)length); i++) &#123; if (number_buffer[i] == decimal_point) &#123; output_pointer[i] = &#x27;.&#x27;; continue; &#125; output_pointer[i] = number_buffer[i]; &#125; output_pointer[i] = &#x27;\\0&#x27;; output_buffer-&gt;offset += (size_t)length; return true;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"FTP服务","slug":"FTP","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T13:34:07.537Z","comments":true,"path":"2021/11/23/FTP/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/FTP/","excerpt":"","text":"参考网址:在虚拟机的Ubuntu上部署FTP服务器_ncut_wxj的博客-CSDN博客 安装1sudo apt-get install vsftpd 配置1sudo nano /etc/vsftpd.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# Example config file /etc/vsftpd.conf## The default compiled in settings are fairly paranoid. This sample file# loosens things up a bit, to make the ftp daemon more usable.# Please see vsftpd.conf.5 for all compiled in defaults.## READ THIS: This example file is NOT an exhaustive list of vsftpd options.#Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd&#x27;s# capabilities.### Run standalone? vsftpd can run either from an inetd or as a standalone# daemon started from an initscript.listen=NO## This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.listen_ipv6=YES## Allow anonymous FTP? (Disabled by default).#这个是设置是否允许匿名登录ftp服务器，不允许。anonymous_enable=NO## Uncomment this to allow local users to log in.#是否允许本机用户登录local_enable=YES## Uncomment this to enable any form of FTP write command.#允许上传文件到ftp服务器write_enable=YES## Default umask for local users is 077. You may wish to change this to 022,# if your users expect that (022 is used by most other ftpd&#x27;s)#local_umask=022## Uncomment this to allow the anonymous FTP user to upload files. This only# has an effect if the above global write enable is activated. Also, you will# obviously need to create a directory writable by the FTP user.#anon_upload_enable=YES## Uncomment this if you want the anonymous FTP user to be able to create# new directories.#anon_mkdir_write_enable=YES## Activate directory messages - messages given to remote users when they# go into a certain directory.dirmessage_enable=YES## If enabled, vsftpd will display directory listings with the time# in your local time zone. The default is to display GMT. The# times returned by the MDTM FTP command are also affected by this# option.use_localtime=YES## Activate logging of uploads/downloads.xferlog_enable=YES## Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES## If you want, you can arrange for uploaded anonymous files to be owned by# a different user. Note! Using &quot;root&quot; for uploaded files is not# recommended!#chown_uploads=YES#chown_username=whoever## You may override where the log file goes if you like. The default is shown# below.#xferlog_file=/var/log/vsftpd.log## If you want, you can have your log file in standard ftpd xferlog format.# Note that the default log file location is /var/log/xferlog in this case.#xferlog_std_format=YES## You may change the default value for timing out an idle session.#idle_session_timeout=600## You may change the default value for timing out a data connection.#data_connection_timeout=120## It is recommended that you define on your system a unique user which the# ftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure## Enable this and the server will recognise asynchronous ABOR requests. Not# recommended for security (the code is non-trivial). Not enabling it,# however, may confuse older FTP clients.#async_abor_enable=YES## By default the server will pretend to allow ASCII mode but in fact ignore# the request. Turn on the below options to have the server actually do ASCII# mangling on files when in ASCII mode.# Beware that on some FTP servers, ASCII support allows a denial of service# attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd# predicted this attack and has always been safe, reporting the size of the# raw file.# ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES## You may fully customise the login banner string:#ftpd_banner=Welcome to blah FTP service.## You may specify a file of disallowed anonymous e-mail addresses. Apparently# useful for combatting certain DoS attacks.#deny_email_enable=YES# (default follows)#banned_email_file=/etc/vsftpd.banned_emails## You may restrict local users to their home directories. See the FAQ for# the possible risks in this before using chroot_local_user or# chroot_list_enable below.#chroot_local_user=YES## You may specify an explicit list of local users to chroot() to their home# directory. If chroot_local_user is YES, then this list becomes a list of# users to NOT chroot().# (Warning! chroot&#x27;ing can be very dangerous. If using chroot, make sure that# the user does not have write access to the top level directory within the# chroot)chroot_local_user=YESchroot_list_enable=YES# (default follows) 允许chroot_list文件中配置的用户登录此ftp服务器。chroot_list_file=/etc/vsftpd.chroot_list# You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by# default to avoid remote users being able to cause excessive I/O on large# sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume# the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.#ls_recurse_enable=YES## Customization## Some of vsftpd&#x27;s settings don&#x27;t fit the filesystem layout by# default.## This option should be the name of a directory which is empty. Also, the# directory should not be writable by the ftp user. This directory is used# as a secure chroot() jail at times vsftpd does not require filesystem# access.secure_chroot_dir=/var/run/vsftpd/empty## This string is the name of the PAM service vsftpd will use.pam_service_name=vsftpd## This option specifies the location of the RSA certificate to use for SSL# encrypted connections.rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyallow_writeable_chroot=YESssl_enable=NO## Uncomment this to indicate that vsftpd use a utf8 filesystem.#utf8_filesystem=YES#配置ftp服务器的上传下载文件所在的目录。#这个地址中的 “/home/python” 是这个Ubuntu系统的用户主目录#它的用户名叫 “python”，文件夹 “ftpfile” 是后来创建的local_root=/home/python/ftpfile 给ftp服务器配置使用用户等信息1sudo nano /etc/vsftpd.chroot_list 12rootftp_user 使用文件夹内输入1ftp:/192.168.xx.xx","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"shm","slug":"shm","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T14:17:34.247Z","comments":true,"path":"2021/11/23/shm/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/shm/","excerpt":"","text":"参考网址:进程间通信——共享内存（Shared Memory）_ypt-CSDN博客_共享内存 例程12345678910111213141516//comm.h#ifndef _COMM_H__#define _COMM_H__ #include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt; #define PATHNAME &quot;.&quot;#define PROJ_ID 0x6666 int CreateShm(int size);int DestroyShm(int shmid);int GetShm(int size);#endif 123456789101112131415161718192021222324252627282930313233343536//comm.c#include&quot;comm.h&quot; static int CommShm(int size,int flags)&#123; key_t key = ftok(PATHNAME,PROJ_ID); if(key &lt; 0) &#123; perror(&quot;ftok&quot;); return -1; &#125; int shmid = 0; if((shmid = shmget(key,size,flags)) &lt; 0) &#123; perror(&quot;shmget&quot;); return -2; &#125; return shmid;&#125;int DestroyShm(int shmid)&#123; if(shmctl(shmid,IPC_RMID,NULL) &lt; 0) &#123; perror(&quot;shmctl&quot;); return -1; &#125; return 0;&#125;int CreateShm(int size)&#123; return CommShm(size,IPC_CREAT | IPC_EXCL | 0666);&#125;int GetShm(int size)&#123; return CommShm(size,IPC_CREAT);&#125; 123456789101112131415161718192021222324//client.c#include&quot;comm.h&quot; int main()&#123; // 获得共享内存的id int shmid = GetShm(4096); sleep(1); // 将共享内存映射到本进程的地址空间 char *addr = shmat(shmid,NULL,0); sleep(2); int i = 0; while(i &lt; 26) &#123; addr[i] = &#x27;A&#x27; + i; i++; addr[i] = 0; sleep(1); &#125; // 将共享内存从本进程的地址空间中卸载 shmdt(addr); sleep(2); return 0;&#125; 1234567891011121314151617181920212223//server.c#include&quot;comm.h&quot; int main()&#123; // 创建并获得共享内存的id int shmid = CreateShm(4096); // 将共享内存映射到本进程的地址空间 char *addr = shmat(shmid,NULL,0); sleep(2); int i = 0; while(i++ &lt; 26) &#123; printf(&quot;client# %s\\n&quot;,addr); sleep(1); &#125; // 将共享内存从本进程的地址空间中卸载 shmdt(addr); sleep(2); // 删除共享内存 DestroyShm(shmid); return 0;&#125; 123456789101112//Makefile.PHONY:allall:server client client:client.c comm.c gcc -o $@ $^server:server.c comm.c gcc -o $@ $^ .PHONY:cleanclean: rm -f client server","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"ubuntu14","slug":"ubuntu14","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T12:30:28.295Z","comments":true,"path":"2021/11/23/ubuntu14/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/ubuntu14/","excerpt":"","text":"安装ssh12345678910111213141516171819202122# 安装服务sudo apt-get install openssh-server# 查看ssh服务是否启动sudo ps -e |grep ssh# 启动ssh服务sudo service ssh start# 配置服务sudo gedit /etc/ssh/sshd_config#找到下面相关配置：# Authentication:LoginGraceTime 120PermitRootLogin prohibit-passwordStrictModes yes#更改为：# Authentication:LoginGraceTime 120#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes# 重启sshsudo service ssh restart 换源12cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo nano /etc/apt/sources.list 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse # 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse 12sudo apt updatesudo apt upgrade 右键没有terminal12sudo apt-get install nautilus-open-terminal sudo reboot","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"linux_gpio","slug":"linux_gpio","date":"2021-11-23T04:30:12.000Z","updated":"2021-12-09T12:35:13.862Z","comments":true,"path":"2021/11/23/linux_gpio/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/linux_gpio/","excerpt":"","text":"参考网址:Linux操作GPIO（文件IO方式）_Leon-CSDN博客 在Linux 中的应用层操作gpio的方法_仗劍走天涯-CSDN博客 位置控制GPIO的目录位于/sys/class/gpio 例子1234567891011121. 导出/sys/class/gpio# echo 44 &gt; export2. 设置方向/sys/class/gpio/gpio44# echo out &gt; direction3. 查看方向/sys/class/gpio/gpio44# cat direction4. 设置输出/sys/class/gpio/gpio44# echo 1 &gt; value5. 查看输出值/sys/class/gpio/gpio44# cat value6. 取消导出/sys/class/gpio# echo 44 &gt; unexport 以echo的形式调用system函数进行操作，这种形式编程比较简单，结构比较清晰，如下 123456void set_gpio64_low(void) &#123; system(&quot;echo 64 &gt; /sys/class/gpio/export&quot;); system(&quot;echo out &gt; /sys/class/gpio/gpio64/direction&quot;); system(&quot;echo 0 &gt; /sys/class/gpio/gpio64/value&quot;); &#125; 通过文件的形式来调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; //define O_WRONLY and O_RDONLY void initGpio(int n)&#123; FILE * fp =fopen(&quot;/sys/class/gpio/export&quot;,&quot;w&quot;); if (fp == NULL) perror(&quot;export open filed&quot;); else fprintf(fp,&quot;%d&quot;,n); fclose(fp);&#125; //create gpio file void setGpioDirection(int n,char *direction)&#123; char path[100] = &#123;0&#125;; sprintf(path,&quot;/sys/class/gpio/gpio%d/direction&quot;,n); FILE * fp =fopen(path,&quot;w&quot;); if (fp == NULL) perror(&quot;direction open filed&quot;); else fprintf(fp,&quot;%s&quot;,direction); fclose(fp);&#125; //set gpio &quot;in&quot; or &quot;out&quot; int getGpioValue(int n)&#123; char path[64]; char value_str[3]; int fd; snprintf(path, sizeof(path), &quot;/sys/class/gpio/gpio%d/value&quot;, n); fd = open(path, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;Failed to open gpio value for reading!&quot;); return -1; &#125; if (read(fd, value_str, 3) &lt; 0) &#123; perror(&quot;Failed to read value!&quot;); return -1; &#125; close(fd); return (atoi(value_str));&#125; //get gpio(n)&#x27;s valuevoid setGpioValue(int n,int value)&#123; char path[64]; char value_str[3]; int fd; snprintf(path, sizeof(path), &quot;/sys/class/gpio/gpio%d/value&quot;, n); fd = open(path, O_WRONLY); if (fd &lt; 0) &#123; perror(&quot;Failed to open gpio value for writing!&quot;); return; &#125; if (value) strcpy(value_str,&quot;1&quot;); else strcpy(value_str,&quot;0&quot;); if (write(fd, value_str, 1) != 1) &#123; perror(&quot;Failed to write value!&quot;); return; &#125; close(fd);&#125; //set gpio(n)&#x27;s value int main() &#123; initGpio(18); setGpioDirection(18,(char*)&quot;out&quot;); while(1) &#123; setGpioValue(18,0); printf(&quot;%d\\n&quot;,getGpioValue(18));//每隔1s输出一次gpio18的值 sleep(1); setGpioValue(18,1); printf(&quot;%d\\n&quot;,getGpioValue(18));//每隔1s输出一次gpio18的值 sleep(1); &#125; return 0; &#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"状态机","slug":"状态机","date":"2021-11-23T04:30:12.000Z","updated":"2021-11-23T14:54:12.528Z","comments":true,"path":"2021/11/23/状态机/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/23/%E7%8A%B6%E6%80%81%E6%9C%BA/","excerpt":"","text":"参考网址:什么是状态机？用C语言实现进程5状态模型_一口Linux的专栏-CSDN博客 例程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// stateMachine.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;typedef enum &#123; sta_origin=0, sta_running, sta_owencpu, sta_sleep_int, sta_sleep_unint&#125;State;static const char *statename[]=&#123; &quot;origin&quot;, &quot;running&quot;, &quot;owencpu&quot;, &quot;sleep_int&quot;, &quot;sleep_unint&quot;, &#125;;typedef enum&#123; evt_fork=0, evt_sched, evt_wait, evt_wait_unint, evt_wake_up, evt_wake, &#125;EventID;typedef void (*CallBack)(void *) ;typedef struct &#123; State curState;//当前状态 EventID eventId;//事件ID State nextState;//下个状态 CallBack action;//回调函数&#125;StateTransform ; State globalState = sta_origin;pthread_t pid;void action_callback(void *arg)&#123; StateTransform *statTran = (StateTransform *)arg; if(statename[statTran-&gt;curState] == statename[statTran-&gt;nextState]) &#123; printf(&quot;invalid event,state not change\\n&quot;); &#125;else&#123; printf(&quot;call back state from %s --&gt; %s\\n&quot;, statename[statTran-&gt;curState], statename[statTran-&gt;nextState]); &#125;&#125; /*origin*/StateTransform stateTran_0[]=&#123; &#123;sta_origin,evt_fork, sta_running,action_callback&#125;, &#123;sta_origin,evt_sched, sta_origin,NULL&#125;, &#123;sta_origin,evt_wait, sta_origin,NULL&#125;, &#123;sta_origin,evt_wait_unint,sta_origin,NULL&#125;, &#123;sta_origin,evt_wake_up, sta_origin,NULL&#125;, &#123;sta_origin,evt_wake, sta_origin,NULL&#125;,&#125;; /*running*/StateTransform stateTran_1[]=&#123; &#123;sta_running,evt_fork, sta_running,NULL&#125;, &#123;sta_running,evt_sched, sta_owencpu,action_callback&#125;, &#123;sta_running,evt_wait, sta_running,NULL&#125;, &#123;sta_running,evt_wait_unint,sta_running,NULL&#125;, &#123;sta_running,evt_wake_up, sta_running,NULL&#125;, &#123;sta_running,evt_wake, sta_running,NULL&#125;,&#125;; /*owencpu*/StateTransform stateTran_2[]=&#123; &#123;sta_owencpu,evt_fork, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_sched, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_wait, sta_sleep_int,action_callback&#125;, &#123;sta_owencpu,evt_wait_unint,sta_sleep_unint,action_callback&#125;, &#123;sta_owencpu,evt_wake_up, sta_owencpu,NULL&#125;, &#123;sta_owencpu,evt_wake, sta_owencpu,NULL&#125;,&#125;; /*sleep_int*/StateTransform stateTran_3[]=&#123; &#123;sta_sleep_int,evt_fork, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_sched, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wait, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wait_unint,sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wake_up, sta_sleep_int,NULL&#125;, &#123;sta_sleep_int,evt_wake, sta_running,action_callback&#125;,&#125;; /*sleep_unint*/StateTransform stateTran_4[]=&#123; &#123;sta_sleep_unint,evt_fork, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_sched, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wait, sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wait_unint,sta_sleep_unint,NULL&#125;, &#123;sta_sleep_unint,evt_wake_up, sta_running,action_callback&#125;, &#123;sta_sleep_unint,evt_wake, sta_sleep_unint,NULL&#125;,&#125;; void init_machine(void)&#123; globalState = sta_origin;&#125;/*显示当前状态*/void *show_stat(void *arg)&#123; int len; char buf[64]=&#123;0&#125;; while(1) &#123; sleep(1); printf(&quot;cur stat:%s\\n&quot;,statename[globalState]); &#125; &#125;#define STATETRANS(n) (stateTran_##n)/*change state &amp; call callback()*/void do_action(StateTransform *statTran)&#123; if(NULL == statTran) &#123; perror(&quot;statTran is NULL\\n&quot;); return; &#125; globalState = statTran-&gt;nextState; if(statTran-&gt;action != NULL) &#123; statTran-&gt;action((void*)statTran); &#125;else&#123; printf(&quot;invalid event,state not change\\n&quot;); &#125;&#125;void event_happen(unsigned int event)&#123; switch(globalState) &#123; case sta_origin: do_action(&amp;STATETRANS(0)[event]); break; case sta_running: do_action(&amp;STATETRANS(1)[event]); break; case sta_owencpu: do_action(&amp;STATETRANS(2)[event]); break; case sta_sleep_int: do_action(&amp;STATETRANS(3)[event]); break; case sta_sleep_unint: do_action(&amp;STATETRANS(4)[event]); break; default: printf(&quot;state is invalid\\n&quot;); break; &#125; &#125;void main(void)&#123; init_machine(); pthread_create(&amp;pid, NULL,show_stat, NULL); sleep(5); event_happen(evt_fork); sleep(5); event_happen(evt_sched); sleep(5); event_happen(evt_sched); sleep(5); event_happen(evt_wait); sleep(5); event_happen(evt_wake); &#125; 1gcc -o main stateMachine.c -pthread -g","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"ros教程","slug":"ros教程","date":"2021-11-13T04:30:12.000Z","updated":"2021-11-13T03:15:23.044Z","comments":true,"path":"2021/11/13/ros教程/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/13/ros%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考网址:古月居21讲 博客 - 古月居 (guyuehome.com) 创客智造 ROS入门教程-目录 - 创客智造 (ncnynl.com) (70条消息) ros机器人_wuzhishiwo的博客-CSDN博客 ROS资源整理-学习ROS用得到的一些资料（持续更新）_Jiali Zhang的博客-CSDN博客 国外教程(需要科学上网),可在线模拟,有开源代码 Learn Robotics from Zero - Robotics &amp; ROS Online Courses (theconstructsim.com) 很现成的模拟舒爽 智能机器人系统_国防科技大学_中国大学MOOC(慕课) (icourse163.org) 外文教程 Webots: tutorial- (cyberbotics.com) 环境通过WSL+melodic+vscode+xlaunch实现ros环境模拟 wsl安装:wsl安装与使用 | 某飞行员的随笔 (peitianyu.github.io) melodic安装:ros安装 | 某飞行员的随笔 (peitianyu.github.io) vscode安装:vscode | 某飞行员的随笔 (peitianyu.github.io) vscode配置ros:安装C/C++，CMake，CMake Tools，Code Runner，ROS，Chinese 这些插件 使用VScode搭建ROS开发环境_白鸟无言的博客-CSDN博客 xlaunch安装:(https://windows.podnova.com/software/3151375.htm) 下载好之后,配置~/.bashrc 12345sudo nano ~/.bashrc# 进入编辑文件,在最后添加上export DISPLAY=localhost:0# CTRL+S + CTRL+X保存退出source ~/.bashrc 学习路径古月居二十一讲这一步需要每一个实验都过一遍,编译一遍,不必要太过详尽,重在了解ros流程,之后回来重新复习 古月居二十一讲视频 古月居二十一讲笔记 古月居二十一讲讲义与代码 密码:4n76 ROS探索总结 - 古月居 ROS-Academy-for-Beginners 中国大学MOOC《机器人操作系统入门》讲义 中国大学MOOC《机器人操作系统入门》课程代码示例 注意下载自己需要的版本,别下错了,然后有显示的问题,可以试试 rosdep install --from-paths src --ignore-src --rosdistro=melodic -y navigation ros navigation stack源码学习 - 知乎 (zhihu.com) ROS Navigation stack源码 激光slam根据以下的几种尝试看源码 对比几种在ROS中常用的几种SLAM算法 激光SLAM学习 移动机器人_少磊的博客 路径参考记得收藏丨ROS开发工程师学习指南 (qq.com) 几款适合copy的源码ros_tutorials ros_tutorials: ROS Tutorials for beginner ros_basic_tutorials ROS进阶攻略系列视频课程 Tutorials about using the ROS Navigation stack Agvs robot simulation packages for ROS","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"vscode","slug":"vscode","date":"2021-11-13T04:30:12.000Z","updated":"2021-11-13T01:22:17.748Z","comments":true,"path":"2021/11/13/vscode/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/13/vscode/","excerpt":"","text":"参考网址:VsCode安装和配置c/c++环境（超完整，小白专用）_黄化的多多-CSDN博客_vscode配置c++环境 vscode 与 WSL 进行linux开发_从零开始-CSDN博客_vscode wsl 在WSL中安装并配置VSCode_reeeeein的博客-CSDN博客_wsl安装vscode WIN10安装WSL并使用VScode连接WSL_作业君的博客-CSDN博客_vscode wsl 简介vscode配置wsl 流程下载安装vscode:Download Visual Studio Code - Mac, Linux, Windows 安装win版,一直下一步,注意改一下安装位置 连接wslctrl + shift + x打开应用商店,输入Remote - WSL安装由于事先安装好wsl了 打开左侧小电脑图标,点击进入即可进入wsl终端,可以通过点击左下角⚪,▲进入终端命令行","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"USBCAN/CANalyst-II","slug":"USBCAN","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-13T01:04:27.331Z","comments":true,"path":"2021/11/11/USBCAN/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/USBCAN/","excerpt":"","text":"参考网址:(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动 Ubuntu16.04 （ROS）下通过CAN分析仪（USBCAN/CANalyst-II）调试无人车助力转向电机（1）_秋名山的过客-CSDN博客 USBCAN在Linux系统下使用说明 (gcgd.net) ubuntu下研华工控机CAN卡驱动的安装与测试_星辰和大海都需要门票的博客-CSDN博客 简介介绍两款使用过的usb转can的使用方法 一款是广成科技的USBCAN-I PRO资料下载 (gcgd.net) 一款是创芯科技的CANalyst珠海创芯科技有限公司 - 珠海创芯科技 (zhcxgd.com) 软件安装与使用USBCAN:沈阳广成科技USBCAN系列产品驱动安装及ECANTools软件使用方法 (gcgd.net) GC-USBCAN—–点击进入文件夹选择需要下载的文件_免费高速下载|百度网盘-分享无限制 (baidu.com) CANalyst:(完整版)Python读取CANalyst-II分析仪(创芯科技)接口函数_蜡笔小新历险记的博客-CSDN博客_创芯科技can分析仪驱动 编程!建议采用官方例程至少不会出错这里推荐两个例程可以验证学习VincentCheungM/ESR_canalyst_ros: A warped ROS driver for CANalyst-II and ESR Radar (github.com) Andy-jg/RaspberryCanalyst-2: linux use the canalyst-2 (github.com) !注意由于can驱动使用时每次都需要sudo,可以加配置,这样就不需要每次都sudo了 方法1sudo nano /etc/udev/rules.d/99-myusb.rules 输入 12ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;,GROUP=&quot;users&quot;, MODE=&quot;0777&quot;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"io扩展","slug":"io扩展","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-11T13:15:31.977Z","comments":true,"path":"2021/11/11/io扩展/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/io%E6%89%A9%E5%B1%95/","excerpt":"","text":"参考网址:IO口不够了？基于I2C的 IO扩展芯片驱动和开发_arenascat的博客-CSDN博客_io扩展芯片 单片机扩展IO口_我的博客-CSDN博客 74HC164(三八译码器),矩阵键盘这种方式可以实现简单的io扩展,但不可以保持,也就是说,治理只是三位二进制转为八个数,虽然也可以通过加快频率的方式实现.仅用于对时序要求不高的电路,比如led流水灯,而尤其是通讯不太适用的. 采用可编程I/O接口扩展芯片这种方式可以实现io扩展,不过需要一定的编程经验. 采用芯片有 8255a 与 MCP23016 i/o扩展芯片_i/o扩展芯片采购信息-立创电子元器件商城 (szlcsc.com) 采用A/D获取按键的位置通过不同电压对应不通按键,挺不错的思路","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"linux解压","slug":"linux解压","date":"2021-11-11T04:30:12.000Z","updated":"2021-11-11T11:25:51.951Z","comments":true,"path":"2021/11/11/linux解压/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/11/linux%E8%A7%A3%E5%8E%8B/","excerpt":"","text":"参考网址:Linux解压.tgz，.tar.gz文件（tar详细参数使用介绍）_echo-CSDN博客_linux解压.tar.gz文件 压缩1234567tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg //rar格式的压缩，需要先下载 rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载 zip for linux 解压1234567tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Ztar -Jxvf file.tar.xzunrar e file.rar //解压rarunzip file.zip //解压zip 总结123456789*.tar 用 tar -xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar -xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar -xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar -xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"cJSON","slug":"cJSON","date":"2021-11-10T04:30:12.000Z","updated":"2021-11-11T12:45:27.407Z","comments":true,"path":"2021/11/10/cJSON/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/10/cJSON/","excerpt":"","text":"参考网址:(65条消息) cJSON使用详细教程 | 一个轻量级C语言JSON解析器_Mculover666的博客（嵌入式_) cJSON-github 生成12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot;int main(void)&#123; cJSON* cjson_test = NULL; cJSON* cjson_address = NULL; cJSON* cjson_skill = NULL; char* str = NULL; /* 创建一个JSON数据对象(链表头结点) */ cjson_test = cJSON_CreateObject(); /* 添加一条字符串类型的JSON数据(添加一个链表节点) */ cJSON_AddStringToObject(cjson_test, &quot;name&quot;, &quot;mculover666&quot;); /* 添加一条整数类型的JSON数据(添加一个链表节点) */ cJSON_AddNumberToObject(cjson_test, &quot;age&quot;, 22); /* 添加一条浮点类型的JSON数据(添加一个链表节点) */ cJSON_AddNumberToObject(cjson_test, &quot;weight&quot;, 55.5); /* 添加一个嵌套的JSON数据（添加一个链表节点） */ cjson_address = cJSON_CreateObject(); cJSON_AddStringToObject(cjson_address, &quot;country&quot;, &quot;China&quot;); cJSON_AddNumberToObject(cjson_address, &quot;zip-code&quot;, 111111); cJSON_AddItemToObject(cjson_test, &quot;address&quot;, cjson_address); /* 添加一个数组类型的JSON数据(添加一个链表节点) */ cjson_skill = cJSON_CreateArray(); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;C&quot; )); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;Java&quot; )); cJSON_AddItemToArray(cjson_skill, cJSON_CreateString( &quot;Python&quot; )); cJSON_AddItemToObject(cjson_test, &quot;skill&quot;, cjson_skill); /* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */ cJSON_AddFalseToObject(cjson_test, &quot;student&quot;); /* 打印JSON对象(整条链表)的所有数据 */ str = cJSON_Print(cjson_test); printf(&quot;%s\\n&quot;, str); return 0;&#125; 解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot;char *message = &quot;&#123; \\ \\&quot;name\\&quot;:\\&quot;mculover666\\&quot;, \\ \\&quot;age\\&quot;: 22, \\ \\&quot;weight\\&quot;: 55.5, \\ \\&quot;address\\&quot;: \\ &#123; \\ \\&quot;country\\&quot;: \\&quot;China\\&quot;,\\ \\&quot;zip-code\\&quot;: 111111\\ &#125;, \\ \\&quot;skill\\&quot;: [\\&quot;c\\&quot;, \\&quot;Java\\&quot;, \\&quot;Python\\&quot;],\\ \\&quot;student\\&quot;: false \\&#125;&quot;;int main(void)&#123; cJSON* cjson_test = NULL; cJSON* cjson_name = NULL; cJSON* cjson_age = NULL; cJSON* cjson_weight = NULL; cJSON* cjson_address = NULL; cJSON* cjson_address_country = NULL; cJSON* cjson_address_zipcode = NULL; cJSON* cjson_skill = NULL; cJSON* cjson_student = NULL; int skill_array_size = 0, i = 0; cJSON* cjson_skill_item = NULL; /* 解析整段JSO数据 */ cjson_test = cJSON_Parse(message); if(cjson_test == NULL) &#123; printf(&quot;parse fail.\\n&quot;); return -1; &#125; /* 依次根据名称提取JSON数据（键值对） */ cjson_name = cJSON_GetObjectItem(cjson_test, &quot;name&quot;); cjson_age = cJSON_GetObjectItem(cjson_test, &quot;age&quot;); cjson_weight = cJSON_GetObjectItem(cjson_test, &quot;weight&quot;); printf(&quot;name: %s\\n&quot;, cjson_name-&gt;valuestring); printf(&quot;age:%d\\n&quot;, cjson_age-&gt;valueint); printf(&quot;weight:%.1f\\n&quot;, cjson_weight-&gt;valuedouble); /* 解析嵌套json数据 */ cjson_address = cJSON_GetObjectItem(cjson_test, &quot;address&quot;); cjson_address_country = cJSON_GetObjectItem(cjson_address, &quot;country&quot;); cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, &quot;zip-code&quot;); printf(&quot;address-country:%s\\naddress-zipcode:%d\\n&quot;, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint); /* 解析数组 */ cjson_skill = cJSON_GetObjectItem(cjson_test, &quot;skill&quot;); skill_array_size = cJSON_GetArraySize(cjson_skill); printf(&quot;skill:[&quot;); for(i = 0; i &lt; skill_array_size; i++) &#123; cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i); printf(&quot;%s,&quot;, cjson_skill_item-&gt;valuestring); &#125; printf(&quot;\\b]\\n&quot;); /* 解析布尔型数据 */ cjson_student = cJSON_GetObjectItem(cjson_test, &quot;student&quot;); if(cjson_student-&gt;valueint == 0) &#123; printf(&quot;student: false\\n&quot;); &#125; else &#123; printf(&quot;student:error\\n&quot;); &#125; return 0;&#125; 相关 - JSMN(仅解析)JSMN介绍和使用_心飞的博客-CSDN博客 The most simple JSON parser in C for small systems (zserge.com) zserge/jsmn: Jsmn is a world fastest JSON parser/tokenizer. This is the official repo replacing the old one at Bitbucket (github.com)","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_常见电路","slug":"电路设计_常见电路","date":"2021-11-08T04:30:12.000Z","updated":"2021-11-09T10:17:19.739Z","comments":true,"path":"2021/11/08/电路设计_常见电路/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/","excerpt":"","text":"驱动输出电路 这里需要注意的是,uln2803是一种npn输出,输出低电平,因此在其输出端会有上拉电阻.在uln2803左侧接gnd右侧接24v. 这里的74hct245为三态输出八路收发器作用是增加单片机的驱动能力. 将同样用74hct245此电路改为pnp型输出,需要将uln2803换为tbd62783,需要注意输出端需要接下拉电阻. **!注意:**由于改驱动芯片uln2803输出最大电流为500ma可能出现烧芯片的情况,可以加一个500ma熔断 放大电路(opa2333) 这里通过R64,R65阻值的变化来实现放大,具体详细可参考:(61条消息) 基本运算放大器原理_小神兵之技术篇-CSDN博客_运算放大器 值得注意的是,由于是轨到轨的放大电路,输入24v,最大放大电压同样也可以达到24v 模拟量采样电路 这里两个二极管用以防过压,电压大于3.3v小于26.7v时直接通过+3.3v,输出,而大于26.7v击穿二极管,直接导地. 模拟量采集,还需要注意一点就是,对于电源要进行滤波处理,使电源信号更干净 普通光耦(TLP290-4)与单向高速光耦(PC4D10) TLP290-4为一种普通光耦,可以实现双向导通,这里原理图左边部分有些出入需要注意一下,输出为npn型输出,注意上拉电阻 pc4d10为告诉光耦,实现的npn型输出,所以注意需要有上拉电阻. 防反接电路参考网址:(62条消息) 直流电源输入防反接保护电路总结_cgy8919的博客-CSDN博客","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_稚晖君机械臂","slug":"电路设计_稚晖君机械臂学习","date":"2021-11-08T04:30:12.000Z","updated":"2021-11-11T11:13:57.930Z","comments":true,"path":"2021/11/08/电路设计_稚晖君机械臂学习/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E7%A8%9A%E6%99%96%E5%90%9B%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"参考网址:peng-zhihui/Dummy-Robot: 我的超迷你机械臂机器人项目。 (github.com) 电源部分:采用TPS61040DBV芯片实现的5v转9v电路,该芯片支持1.8v到6v输入,高达28v输出,同时还支持400ma的电流输出,具体可参考: TPS6104x Low-Power DC-DC Boost Converter in SOT-23 and WSON Packages datasheet (Rev. J) (ti.com) LP2992线性稳压器,输入2.2v到16v输出1.5v到5v,指定250毫安输出电流 LP2992 Micropower 250-mA Low-Noise Ultra-Low-Dropout Regulator in SOT-23 and WSON Packages Designed for Use With Very Low-ESR Output Capacitors datasheet (Rev. J) (ti.com) ME3116 是一款内部集成了 MOSFET 的异步整流降压型 稳压器。它在很宽的输入电压范围内（4.75V-40V）能够提供 高达 1A 的负载能力。 ME6206:降压稳压器,高精度输出电压：±2% 输出电压：1.5V~5.0V(步长 0.1V) 最大工作电压：6V 带载能力强：当 Vin=4.3V 且 Vout=3.3V 时 Iout=300mA 极低的输入输出电压差： 0.2V at 90mA and 0.40V at 200mA 这里使用了ss54实现防反接,sy8303降压型dc-dc芯片 自动下载电路采用cp2101usb转串口芯片,通过三极管,实现串口自动下载","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派串口通信","slug":"树莓派串口通信","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-06T07:46:11.413Z","comments":true,"path":"2021/11/06/树莓派串口通信/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","excerpt":"","text":"参考网址:树莓派4b ubuntu系统开启串口_benchuspx的博客-CSDN博客 树莓派4B如何使用串口与外部进行通信 - 程序员大本营 (pianshen.com) 介绍树莓派原本的抽是用于串口控制台的,即/ttyAMA0,且此硬件串口也与蓝牙连接到一块,因此需要将控制台与蓝牙关闭才能使用 方法 /boot/firmware/nobtcmd.txt里删除console = /ttyAMA 921600从而禁用串口控制台.这个txt文件也可以用读卡器把sd卡插到windows系统里在system-boot里找到 /boot/firmware/config.txt 里设置enable_uart=1（默认就是）.如果=0表示启用minicom串口，而不是这个硬件串口. /boot/firmware/config.txt 里加入一行dtoverlay=disable-bt从而禁用蓝牙. sudo systemctl disable bluetooth…… 禁用掉和蓝牙有关的开机启动项.直到桌面不再显示蓝牙标志，但是还有/ttyAMA0存在.","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派备份","slug":"树莓派备份","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-06T13:10:22.879Z","comments":true,"path":"2021/11/06/树莓派备份/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/","excerpt":"","text":"参考网址:收藏！最简单的树莓派系统备份方法！ - 知乎 (zhihu.com) 树莓派学习笔记 篇四：树莓派4B 的系统备份方法大全（全卡+压缩备份）_其他智能设备_什么值得买 (smzdm.com) 烧写之前备份过的树莓派镜像到SD卡，证明这样备份恢复是可行的！！！！！！！_TYINY的博客-CSDN博客 最简单的方式win10下新建一个.img格式文件,通过Win32DiskImager,read插入卡的系统,read完就备份好了 脚本方式(推荐) 在Linux系统中一键备份树莓派系统SD卡的脚本 (github.com) 下载下来脚本rpi-backup.sh放入到Linux系统 插入需备份的树莓派系统,用df -h命令查询SD卡设备名 运行sudo chmod +x rpi-backup.sh后,运行./rpi-backup.sh /dev/sdb1 /dev/sdb2 注意第一个参数是树莓派SD卡/boot分区的设备名：/dev/sdb1，第二个参数是/分区的设备名：/dev/sdb2，视情况修改） 终 img 文件会生成在~/backupimg/文件夹下","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"树莓派安装Ubuntu18_server","slug":"树莓派安装ubuntu18_server","date":"2021-11-06T04:30:12.000Z","updated":"2021-12-24T06:03:51.525Z","comments":true,"path":"2021/11/06/树莓派安装ubuntu18_server/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/","excerpt":"","text":"参考网址:树莓派raspberry 安装ubuntu18.04 server + desktop + ros1_越来越胖了_mengleijin的博客-CSDN博客 树莓派4b安装带桌面的ubuntu18.04 server和ROS melodic系统 - 灰信网（软件开发博客聚合） (freesion.com) 树莓派4B安装Ubuntu18.04 + vnc远程桌面_我是大一菜鸡-CSDN博客 img镜像下载树莓派操作系统镜像下载地址 ubuntu18_server https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04.5/release/ 将系统烧入SD卡使用win32diskimager或者balenaetcher烧录进去 启动树莓派将SD卡插入树莓派，并为树莓派连接好电源，显示器，鼠标，键盘，网线。启动树莓派，默认用户名密码都是ubuntu，之后需要马上修改密码，按提示操作即可。 SSH打开 system-boot 磁盘下根目录的 network-config 文件1234567891011121314151617181920# This file contains a netplan-compatible configuration which cloud-init# will apply on first-boot. Please refer to the cloud-init documentation and# the netplan reference for full details:## https://cloudinit.readthedocs.io/# https://netplan.io/reference## Some additional examples are commented out belowversion: 2ethernets: eth0: dhcp4: false addresses: [192.168.30.110/24]wifis: wlan0: access-points: HUAWEI_PTY: password: pty123456787 dhcp4: true 修改在相同目录下的 user-data 文件，expire：后改成false。 启动树莓派如果是刷完固件后第一次启动，因为第一次需要进行系统配置，所以第一次不会自动连接。第一次上电过两分钟后重新上电稍等片刻就会自动连接wifi了。 连网可以参考: Ubuntu Server 18.04 连接 WIFI_zyr920425的博客-CSDN博客 编辑 1sudo nano /etc/netplan/xxxxxxx.yaml 12345678910111213141516171819# This file is generated from information provided by the datasource. Changes# to it will not persist across an instance reboot. To disable cloud-init&#x27;s# network configuration capabilities, write a file# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:# network: &#123;config: disabled&#125;network: version: 2 ethernets: eth0: dhcp4: false addresses: [192.168.8.110/24] wifis: wlan0: access-points: HUAWEI_PTY: password: pty123456787 dhcp4: true optional: true 1sudo netplan apply 换源1sudo nano /etc/apt/sources.list 参考:树莓派4安装 18.04ubuntu server（2020.11.2）_lovely_yoshino的博客-CSDN博客_树莓派ubuntu18.04 123456789101112131415161718192021deb http://mirrors.aliyun.com/ubuntu-ports bionic main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic universedeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates universedeb http://mirrors.aliyun.com/ubuntu-ports bionic multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricteddeb http://mirrors.aliyun.com/ubuntu-ports bionic-security universedeb http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports bionic main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-updates multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security universedeb-src http://mirrors.aliyun.com/ubuntu-ports bionic-security multiverse 1sudo apt-get update SSH连接网线连接好,通过ip a查看是否配置好,然后在物理机上尝试ping通后连接 1ssh.exe ubuntu@192.168.xx.xx 安装gcc与g++1234 # gcc安装 sudo apt-get install build-essential # g++安装sudo apt-get install g++","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_最小系统设计","slug":"电路设计_最小系统设计","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-08T06:22:13.129Z","comments":true,"path":"2021/11/06/电路设计_最小系统设计/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"参考网址:(60条消息) STM32最小系统设计_little_ox的博客-CSDN博客 最小系统组成:主芯片,复位电路,时钟电路,电源电路,下载电路 主芯片根据自己需要的io数量,功能选择好主芯片 复位电路,时钟电路,下载电路由于低电平复位,因此可以通过上拉电阻实现,由于复位电路与时钟电路一般芯片都会提供参考电路或者查查资料都很容易找到,就不再赘述,下载电路的话直接clk,dio给他,通过SWD,或者JTAG下载,这里使用的时SWD下载 **!注意:**一般芯片都会有电源滤波,因此在布线的过程中注意将电容尽量放的里芯片近些. 晶振的选择有源晶振:自供电,有内部电路,精度会高些,当然价格也贵些 无源晶振:内部不供电,与芯片直接相连,精度差些,在对时钟要求没那么高的情况下一般够用 电源电路比较麻烦的是电源电路,或者降压,或者稳压,根据需要实现. 这里提供一种从24v转3.3v的思路电源思路.这里使用TPS5430芯片实现的一种电源降压的方式,这里D2指的是瞬态抑制起到当电压超过24v(比如打火花)进来时,D2导通,24v直接接地,同事使用了F1保险丝做保护","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"电路设计_通讯设计","slug":"电路设计_通讯设计","date":"2021-11-06T04:30:12.000Z","updated":"2021-11-08T06:21:47.065Z","comments":true,"path":"2021/11/06/电路设计_通讯设计/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"CAN: 两张图用的都是TJA1050,速度1Mbps,不过后期的处理略有些不同,上图can信号分两路输出,而下图,为保护电路,加入了fuse(熔断器),SMAJ30CA(瞬态抑制二极管) 这张图用的是max30513.3v供电,高速运行1Mbps,这里使用了ACT45B共模电感起EMI滤波的作用，用于抑制高速信号线产生的电磁波向外辐射发射. RS485 由于采用3.3v供电,使用芯片为sp3485,参考图二,5v供电可更换为max485,电路设计上也还是同样,图一,采用熔断器与瞬态一直二极管保护电路 这张图就是max485实现的RS485电路,同样对于电路保护也采用熔断器与瞬态一直二极管,同时采用电容进行进一步滤波.这里发送接收通过EN控制,三极管做开关功能,EN为0时接收,为1时发送. 232 数据手册: 具有 ±15kV ESD 保护功能的 MAX3232 3V 至 5.5V 多通道 RS-232 线路驱动器和接收器 datasheet 布板参考: USB转串口 这张图是type_c转串口的图,图中使用CH340N实现板子最小化,非常nice 下面是他的开源链接:TYPE C usb转串口 - 立创EDA开源硬件平台 (oshwhub.com) 当然为了保护电路,我们也可以在上边加上熔断与瞬时抑制二极管 以太网参考渡鸦卡发版设计 大佬的串口转以太网设计: 串口转以太网模块-CH9121 - 立创EDA开源硬件平台 (oshwhub.com)","categories":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"}],"tags":[{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"}]},{"title":"hector源码理解","slug":"hector源码阅读","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-06T07:29:40.188Z","comments":true,"path":"2021/11/05/hector源码阅读/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"参考网址:大佬的分析,包含代码注释解析与源码重写,论文翻译 Hector_slam源码框架分析_翎风的博客-CSDN博客 Hector SLAM解读（1）原文翻译 - cyberniklee - 博客园 (cnblogs.com) HectorSLAM论文解析・代码重写（2） - scomup - 博客园 (cnblogs.com) zhangwenxiao/HectorSlamWithoutROS: 脱离ROS的hector slam算法 (github.com) 代码框架该开源系统的主要代码在hector_mapping文件夹中，文件夹里有src文件夹和include文件夹，包含了算法所有的核心代码。通过对源码的梳理，整理出了如下流程图： 大佬的图非常清晰的可以看到,整个代码分为地图匹配与地图更新 地图匹配主要采用非线性优化—-高斯牛顿法,实际上就是通过激光数据与现有地图的差距(双线性插补),通过最小二乘法,计算概率,从而更新位移增量,计算出机器人最可能存在位置 双线性插值计算栅格概率一篇文章为你讲透双线性插值 - 知乎 (zhihu.com) 通过双线性插补得到一个位置,然后通过最小二乘法,更新位移增量 高斯牛顿法高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客 【泡泡机器人公开课】第三十课：非线性优化与g2o-高翔_哔哩哔哩_bilibili 地图更新用bresenham划线算法计算激光途经栅格 (60条消息) Bresenham 算法原理_yzh1994414的博客-CSDN博客_bresenham 画线算法-Bresenham算法_天才樱木-CSDN博客_bresenham画线算法 优缺点1.优点（1）不需要使用里程计，可以用于地面不平坦区域及空中飞行器。（2）使用多分辨率地图能避免局部最小值。 2.缺点（1）要求雷达更新频率较高，测量噪声小；或者机器人运动速度低。（2）无法利用精确的里程计信息。","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"hector基础使用","slug":"hector基础使用","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T06:14:45.991Z","comments":true,"path":"2021/11/05/hector基础使用/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"","text":"参考网址:思岚A1激光雷达hector_mapping建图与定位_欧俊岑的博客-CSDN博客 tx2+r2000激光雷达 hector建图_大家安静啊的博客-CSDN博客 hectorslam之EAI雷达(ydlidar_x2l)配置过程_sunshine-CSDN博客 NickL77/RPLidar_Hector_SLAM: Hector SLAM without odometry data on ROS with the RPLidar A1 (github.com) 简介hector是纯粹基于laserscan数据的算法,只需要提供scan数据即可,这里使用r2000做实验.因此第一步应该发布scan数据. Scan激光数据发布r2000提供了ros发布的驱动文件,因此只需要修改些配置即可. 驱动网址: dillenberger/pepperl_fuchs: Pepperl+Fuchs R2000 Driver (github.com) 修改一下配置: 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;node pkg=&quot;pepperl_fuchs_r2000&quot; type=&quot;r2000_node&quot; name=&quot;r2000_driver_node&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;scanner_ip&quot; value=&quot;192.168.1.19&quot;/&gt; &lt;param name=&quot;frame_id&quot; value=&quot;laser_link&quot;/&gt; &lt;param name=&quot;scan_frequency&quot; value=&quot;35&quot;/&gt; &lt;param name=&quot;samples_per_scan&quot; value=&quot;3600&quot;/&gt; &lt;!-- &lt;remap from=&quot;/r2000_driver_node/scan&quot; to=&quot;scan&quot;/&gt; --&gt; &lt;/node&gt; &lt;!--&lt;node pkg=&quot;dummy_slam_broadcaster&quot; type=&quot;dummy_slam_broadcaster_node&quot; name=&quot;dummy_slam_broadcaster&quot;/&gt; &lt;node name=&quot;rvizLocal&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; respawn=&quot;false&quot; output=&quot;screen&quot; args=&quot;-d $(find pepperl_fuchs_r2000)/rviz/test.rviz&quot; required=&quot;true&quot;/&gt;--&gt;&lt;/launch&gt; 1234567scanner_ip r2000的配置激光ip地址frame_id 发布出去的框架id(用于tf转换)scan_frequency 扫描频率samples_per_scan 每圈的扫描数# 值得注意的是这里r2000发不出去的scan节点为/r2000_driver_node/scan# 可以通过remap重定义为/scan最后通过rviz显示 ros执行命令: 1roslaunch pepperl_fuchs_r2000 gui_example.launch 使用hector_mapping建图并定位这里可以直接在系统中安装hector,并新建hector_mapping.launch文件,指令如下: 12345sudo apt-get install ros-melodic-hector-slamcd catkin_ws/srccatkin_create_pkg run_launch # 因为内部都是launch文件并不需要依赖包cd run_launch &amp;&amp; sudo mkdir launch &amp;&amp; cd launchsudo nano hector_mapping.launch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;launch&gt;&lt;node pkg=&quot;hector_mapping&quot; type=&quot;hector_mapping&quot; name=&quot;hector_mapping&quot; output=&quot;screen&quot;&gt; &lt;!-- Frame names --&gt; &lt;!-- 确定map-&gt; odom转换是否应该由系统发布 --&gt; &lt;param name=&quot;pub_map_odom_transform&quot; value=&quot;true&quot;/&gt; &lt;!-- 坐标系id,hector会将map与车体做tf连接到一块,而车体与激光之间的连接需要我们自己做 --&gt; &lt;param name=&quot;map_frame&quot; value=&quot;map&quot; /&gt; &lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot; /&gt; &lt;!-- 由于没有使用里程计,改为base_link即可 --&gt; &lt;param name=&quot;odom_frame&quot; value=&quot;base_link&quot; /&gt; &lt;!-- Tf use --&gt; &lt;param name=&quot;use_tf_scan_transformation&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;use_tf_pose_start_estimate&quot; value=&quot;false&quot;/&gt; &lt;!-- Map size / start point --&gt; &lt;param name=&quot;map_resolution&quot; value=&quot;0.05&quot;/&gt; &lt;!-- 地图尺寸需要注意一下,如果地图太小,可能导致激光范围过大,超出地图,这样匹配坐标会很挫 --&gt; &lt;param name=&quot;map_size&quot; value=&quot;512&quot;/&gt; &lt;param name=&quot;map_start_x&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;map_start_y&quot; value=&quot;0.5&quot; /&gt; &lt;param name=&quot;laser_z_min_value&quot; value = &quot;-1.0&quot; /&gt; &lt;param name=&quot;laser_z_max_value&quot; value = &quot;1.0&quot; /&gt; &lt;param name=&quot;map_multi_res_levels&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;map_pub_period&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;laser_min_dist&quot; value=&quot;0.4&quot; /&gt; &lt;!-- 激光扫描距离要适中,如果太小也会出现建图建的很挫的现象 --&gt; &lt;param name=&quot;laser_max_dist&quot; value=&quot;5.5&quot; /&gt; &lt;param name=&quot;output_timing&quot; value=&quot;false&quot; /&gt; &lt;!-- 确定scanmatcher到map的转换是否发布到TF --&gt; &lt;param name=&quot;pub_map_scanmatch_transform&quot; value=&quot;true&quot; /&gt; &lt;!-- 发布的坐标名 --&gt; &lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt; &lt;!-- Map update parameters --&gt; &lt;param name=&quot;update_factor_free&quot; value=&quot;0.4&quot;/&gt; &lt;param name=&quot;update_factor_occupied&quot; value=&quot;0.7&quot; /&gt; &lt;param name=&quot;map_update_distance_thresh&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;map_update_angle_thresh&quot; value=&quot;0.06&quot; /&gt; &lt;!-- Advertising config --&gt; &lt;param name=&quot;advertise_map_service&quot; value=&quot;true&quot;/&gt; &lt;!-- 扫描订阅器的队列大小 --&gt; &lt;param name=&quot;scan_subscriber_queue_size&quot; value=&quot;5&quot;/&gt; &lt;!-- 这里更改一下scan_topic 如果我们做了重定向,需要改为/scan--&gt; &lt;param name=&quot;scan_topic&quot; value=&quot;/r2000_driver_node/scan&quot;/&gt;&lt;/node&gt;&lt;!-- !注意:这一步需要将车体坐标系与激光坐标系进行tf转换连接起来 --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0.105 0 0 0 /base_link /laser_link 100&quot;/&gt;_ &lt;!-- 这里使用的是hector自带的rviz配置,我们也可以在他的基础上增减功能,另存到我们自己的文件src/run_launch/rviz/map/hector_map.rviz --&gt; &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;/&gt; &lt;/launch&gt; 执行步骤: 1234# 发布scan数据roslaunch pepperl_fuchs_r2000 gui_example.launch# 启动hector_mappingroslaunch run_launch hector_mapping.launch 一些图片 总结1.订阅/scan不要出错 2.tf转换尤为需要注意,map-&gt;base_link-&gt;laser_link 3.激光距离与地图大小需要注意一下,这里设不好容易崩","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"map_server","slug":"map_server","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T07:26:41.799Z","comments":true,"path":"2021/11/05/map_server/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/map_server/","excerpt":"","text":"参考网址:(60条消息) map server 功能和作用_天才樱木-CSDN博客_map_server 保存1rosrun map_server map_saver -f mymap 我们会得到两个文件,mymap.pgm,mymap.yaml mymap.pgm为0到1的灰度图 mymap.yaml为配置文件 123456789101112# 文件名image: testmap.png# 分辨率resolution: 0.1# 初始点origin: [0.0, 0.0, 0.0]# 占用阈值occupied_thresh: 0.65# 为自由阈值free_thresh: 0.196# 是否应该颠倒白/黑 自由/被占用的语义(阈值的解释不受影响)negate: 0 发布节点1rosrun map_server map_server mymap.yaml 主题map_metadata (nav_msgs/MapMetaData) 123456789101112# 这包含了关于占领网格特征的基本信息# 地图加载的时间time map_load_time# 地图的分辨率 [m/cell]float32 resolution# Map width [cells]uint32 width# Map height [cells]uint32 height# 地图的原点[m, m, rad]。这是地图中单元格(0,0)的真实姿态。geometry_msgs/Pose origin map (nav_msgs/OccupancyGrid) 123456789101112# 这代表了一个二维网格地图，其中每个单元格代表占用概率。Header header # uint32 seq# time stamp# string frame_id#地图的元数据MapMetaData info# 映射数据，按行主顺序，从(0,0)开始。占用概率在[0,100]范围内。未知是1。int8[] data static_map (nav_msgs/GetMap) 123# Get the map as a nav_msgs/OccupancyGrid---nav_msgs/OccupancyGrid map","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"梯度下降法","slug":"梯度下降法","date":"2021-11-05T04:30:12.000Z","updated":"2021-11-05T12:21:42.907Z","comments":true,"path":"2021/11/05/梯度下降法/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/","excerpt":"","text":"参考网址:(60条消息) 高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客 信赖域狗腿（dogleg）方法_LSEC小陆的博客-CSDN博客 高斯牛顿(Gauss Newton)、列文伯格-马夸尔特(Levenberg-Marquardt)最优化算法与VSLAM_weixin_30463341的博客-CSDN博客 LM算法——列文伯格-马夸尔特算法（最速下降法，牛顿法，高斯牛顿法）（完美解释负梯度方向）_三眼二郎-CSDN博客_lm算法 从上倒下为梯度下降法的前世今生已经未来的演化：最速下降法（一阶梯度法）牛顿法（二阶梯度法）高斯牛顿法列文伯格法马夸尔特法 梯度下降主要用于slam中的非线性优化,实际上就是对一个最小二乘问题的求解,这也是上述几种方法的用途. 问题 最速下降(一阶梯度法)最速下降法（一阶梯度法）就是保留泰勒展开的一阶项用来近似非线性函数**F ( x )**，即：$$F(xk​+Δxk​)≈F(xk​)+J(xk​)TΔxk$$ $$Δxk​=−J(xk)$$ **缺点:**由于仅保留一阶的雅可比矩阵,该方法过于贪心，容易走出锯齿线，反而增加迭代次数。 牛顿法和阻尼牛顿法（二阶梯度法）$$H(xk​ )Δxk​ =−J(xk​ )$$ **牛顿法的缺点:**海塞矩阵H计算量太大 阻尼牛顿法(可以看成是牛顿法与最速法的结合) 阻尼牛顿法就是在使用牛顿法获得增量方向后，进一步对最优步长进行搜索： 高斯牛顿法(仅用于最小二乘)原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)增量方程:$$H(xk​ )Δxk​ =g(xk​ )$$算法流程: 12341.给定初始值X02.对于第k次迭代,求出当前雅可比矩阵J与误差f(x)3.求解增量方程:H*deltaxk=g4.若的了他xk足够小,则停止,否则,xk+1 = xk + deltaxk 缺点: 由于是通过雅各比矩阵做的JH(海瑟矩阵)的近似,因此会遇见奇异矩阵与病态矩阵,可能出现算法不收敛. L-M方法，阻尼牛顿法列文伯格-马夸尔特方法的思想针对高斯牛顿法的不足，L-M方法做了两点改进： 在求解增量Δ xk 时，对其设置了信赖区域 在求得增量Δ xk对其近似效果进行了量化，并根据量化结果对信赖区域进行调整， 再从新计算增量Δ x k，直到近似效果量化结果达到阈值。 增量方程$$(H+λDT D)Δxk​ =g(xk​ )$$近似程度的量化$$ρ=(f(xk​+Δx k​)−f(x k​ ))/(J(x k​)TΔxk​)​$$ 当ρ接近1时，近似效果好； 当ρ太小时，实际减小的值远小于近似函数减小的值，近似效果差，需要缩小近似范围μ 当ρ较大时，实际减小的值大于近似函数减小的值，近似效果差，需要增大近似范围μ 算法流程:","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"罗技遥控","slug":"Logitechcontrol","date":"2021-11-03T04:30:12.000Z","updated":"2021-12-06T01:15:18.572Z","comments":true,"path":"2021/11/03/Logitechcontrol/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/Logitechcontrol/","excerpt":"","text":"参考网址:罗技F310与F710游戏手柄驱动（附C++源码）_冬瓜-CSDN博客 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Logitech_controller.h/* define ----------------------------------------------------------------*/#ifndef Logitech_DRIVER#define Logitech_DRIVER/* Includes ---------------------------------------------------------------*/#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;linux/input.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;#define JSKEY_A 0x001#define JSKEY_B 0x101#define JSKEY_X 0x201#define JSKEY_Y 0x301#define JSKEY_LB 0x401#define JSKEY_RB 0x501#define JSKEY_BACK 0x601#define JSKEY_START 0x701#define JSKEY_HOME 0x801#define JSKEY_LT 0x202#define JSKEY_RT 0x502#define JSKEY_CROSS_X 0x602#define JSKEY_CROSS_Y 0x702#define JSKEY_LEFTSTICK_X 0x002#define JSKEY_LEFTSTICK_Y 0x102#define JSKEY_RIGHTSTICK_X 0x302#define JSKEY_RIGHTSTICK_Y 0x402#define JSKEY_PRESS 0x001 #define JSKEY_RELEASE 0x0 #define JSKEY_CROSS_LOW_VALUE 0xffff8001 #define JSKEY_CROSS_HIGH_VALUE 0x7fff using namespace std;class Logitech&#123;private: char *dev; ssize_t n; int fd; int buf[2];public: Logitech(char* device); map&lt;int, int&gt; Keystate_map; int init(); void listen_input(); void print_key_state();&#125;;#endif //Logitech_DRIVER 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// Logitech_controller.c #include &quot;Logitech_controller.h&quot;using namespace std;Logitech::Logitech(char* device)&#123; dev = device; memset(buf, 0, sizeof buf);&#125;int Logitech::init()&#123; fd = open(dev, O_RDONLY); if (fd == -1) &#123; fprintf(stderr, &quot;Cannot open %s: %s.\\n&quot;, dev, strerror(errno)); return EXIT_FAILURE; &#125; /*Key Status*/ /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_A] =0; Keystate_map[JSKEY_B] =0; Keystate_map[JSKEY_X] =0; Keystate_map[JSKEY_Y] =0; /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_LB] =0; Keystate_map[JSKEY_RB] =0; /* 0 is released */ /* 1 is press */ Keystate_map[JSKEY_BACK] =0; Keystate_map[JSKEY_START] =0; Keystate_map[JSKEY_HOME] =0; /* 0 is released */ /* -1 is the left or up button is pressed */ /* 1 is the right or down button is pressed*/ Keystate_map[JSKEY_CROSS_X] =0; Keystate_map[JSKEY_CROSS_Y] =0; /* the result is the value of the key(0~99)*/ Keystate_map[JSKEY_LT] =0; Keystate_map[JSKEY_RT] =0; /* the result is the value of the key(-100~100)*/ Keystate_map[JSKEY_LEFTSTICK_X] =0; Keystate_map[JSKEY_LEFTSTICK_Y] =0; Keystate_map[JSKEY_RIGHTSTICK_X] =0; Keystate_map[JSKEY_RIGHTSTICK_Y] =0; return 0;&#125;void Logitech::listen_input()&#123; while (1) &#123; memset(buf, 0, sizeof buf); n = read(fd, &amp;buf, sizeof buf); n = n / sizeof(int); if (n == (ssize_t)-1) &#123; if (errno == EINTR) continue; else break; &#125; unsigned short btn = buf[1] &gt;&gt; 16; short val = (short)(buf[1] &amp; 0xffff); /*Test for button ID*/ //cout&lt;&lt;&quot;0x&quot;&lt;&lt;hex&lt;&lt;btn&lt;&lt;endl; if (btn == JSKEY_LT || btn == JSKEY_RT) &#123; unsigned short prs_val = val + 32768; val = (unsigned short) (((long)prs_val)*100/65536); Keystate_map[btn]= val; &#125; else if (btn == JSKEY_LEFTSTICK_X || btn == JSKEY_LEFTSTICK_Y || btn == JSKEY_RIGHTSTICK_X || btn == JSKEY_RIGHTSTICK_Y) &#123; /* y-axis reverse */ if(btn==JSKEY_LEFTSTICK_Y||btn == JSKEY_RIGHTSTICK_Y) &#123;val=(-1)*val;&#125; val = val*100/32767; Keystate_map[btn]= val; &#125; else &#123; switch (val) &#123; case JSKEY_PRESS: Keystate_map[btn]=1; break; case JSKEY_RELEASE: Keystate_map[btn]=0; break; case JSKEY_CROSS_LOW_VALUE: Keystate_map[btn]=-1; break; case JSKEY_CROSS_HIGH_VALUE: Keystate_map[btn]=1; break; default: break; &#125; /* y-axis reverse */ if(btn==JSKEY_CROSS_Y) &#123;Keystate_map[btn]=(-1)*Keystate_map[btn];&#125; &#125; print_key_state(); &#125;&#125;void Logitech::print_key_state()&#123; cout&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_A = &quot;&lt;&lt;Keystate_map[JSKEY_A]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_B = &quot;&lt;&lt;Keystate_map[JSKEY_B]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_X = &quot;&lt;&lt;Keystate_map[JSKEY_X]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_Y = &quot;&lt;&lt;Keystate_map[JSKEY_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LB = &quot;&lt;&lt;Keystate_map[JSKEY_LB]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RB = &quot;&lt;&lt;Keystate_map[JSKEY_RB]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_BACK = &quot;&lt;&lt;Keystate_map[JSKEY_BACK]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_START = &quot;&lt;&lt;Keystate_map[JSKEY_START]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_HOME = &quot;&lt;&lt;Keystate_map[JSKEY_HOME]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LT = &quot;&lt;&lt;Keystate_map[JSKEY_LT]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RT = &quot;&lt;&lt;Keystate_map[JSKEY_RT]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_CROSS_X = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_X]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_CROSS_Y = &quot;&lt;&lt;Keystate_map[JSKEY_CROSS_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_LEFTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_X] &lt;&lt;&quot; JSKEY_LEFTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_LEFTSTICK_Y]&lt;&lt;endl; cout&lt;&lt;&quot;JSKEY_RIGHTSTICK_X = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_X]&lt;&lt;&quot; JSKEY_RIGHTSTICK_Y = &quot;&lt;&lt;Keystate_map[JSKEY_RIGHTSTICK_Y]&lt;&lt;endl;&#125; 123456789101112131415// main.cpp#include &quot;Logitech_controller.h&quot;using namespace std;int main()&#123; char path[] = &quot;/dev/input/js0&quot;; Logitech gamepad(path); gamepad.init(); gamepad.listen_input(); return 0;&#125; !注意:由于不同遥控对于io定义不同,所以需要改动一下**Logitech_controller.h中的#define**","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Jupyter Notebooks","slug":"Jupyter","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-23T13:10:25.284Z","comments":true,"path":"2021/11/03/Jupyter/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/Jupyter/","excerpt":"","text":"安装Jupyter1conda install jupyter # 或 pip install jupyter Ubuntu下使用jupyterUbuntu 下 Jupyter 的使用_yaoyz105-CSDN博客 Vscode使用jupyter在VS Code中编写Jupyter Notebook_云水木石-CSDN博客 win10Jupyter Notebooks的安装和使用介绍_LarsCheng’s Blog-CSDN博客","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"树莓派入门","slug":"树莓派入门","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-03T13:51:08.689Z","comments":true,"path":"2021/11/03/树莓派入门/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/","excerpt":"","text":"树莓派入门1、树莓派安装12345678教程网站：https://blog.csdn.net/bhniunan/article/details/104783321 https://blog.csdn.net/W17330937835/article/details/105351273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603417716780255273810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161603417716780255273810&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-105351273.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b https://ubuntu-mate.org/noobs安装系统：https://blog.csdn.net/diandianxiyu_geek/article/details/78949393https://shumeipai.nxez.com/downloadhttps://make.quwj.com/member/2/bookmarks?category=36 2、汉化Raspbian操作系统12https://blog.csdn.net/bhniunan/article/details/104842773中文输入法：https://blog.csdn.net/qq_33475105/article/details/113488707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161605416616780261948746%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161605416616780261948746&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-113488707.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95 3、树莓派gpio控制1https://wiki.jikexueyuan.com/project/raspberry-pi/gpio.html 4、树莓派命令行连接wifihttps://blog.csdn.net/u010875635/article/details/70170145 5、树莓派用rc.local设置开机启动12进入etc/rc.local编辑需要打开的设置，直接编辑命令","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"hexo模板","slug":"模板","date":"2021-11-03T04:30:12.000Z","updated":"2021-11-03T13:51:18.385Z","comments":true,"path":"2021/11/03/模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考网址:","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ros_rosbag","slug":"rosbag","date":"2021-11-02T04:30:12.000Z","updated":"2021-11-02T05:47:29.407Z","comments":true,"path":"2021/11/02/rosbag/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/02/rosbag/","excerpt":"","text":"参考网址:(59条消息) Rosbag详细操作_Sun的博客-CSDN博客 rosbag –clock_newbeixue的博客-CSDN博客 Rosbag基础使用保存12345678# 保存所有topicrosbag record -a# 只记录某些感兴趣的 topicrosbag record /topic_name1 /topic_name2 /topic_name3# 指定生成数据包的名字，则用-O /-o 参数rosbag record -O filename.bag /topic_name1# launch 文件中使用 rosbag record 命令&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; 显示信息123456789101112131415161718192021rosbag info filename.bagrosbag info -y filename.bag# 示例xiaohu@xiaohu:~/bagfiles$ rosbag info -y 1.bagpath: 1.bagversion: 2.0duration: 3.295966start: 1566653873.351150end: 1566653876.647117size: 8103messages: 20indexed: Truecompression: nonetypes: - type: geometry_msgs/Twist md5: 9f195f881246fdfa2798d1d3eebca84atopics: - topic: /turtle1/cmd_vel type: geometry_msgs/Twist messages: 20 rosbag play1234567891011# 简单播放rosbag play &lt;bagfile&gt;# -r 2 表示2倍速播放rosbag play -r 2 &lt;bagfile&gt;# 循环播放rosbag play -l &lt;bagfile&gt; # -l== --loop# 只播放一部分topicrosbag play &lt;bagfile&gt; --topic /topic1# 开始播放立刻暂停，按空格继续rosbag play --pause record.bag rosbag –clock123456rosbag play --clock recorded1.bag# -k， --keep-aliverosbag play -k --clock recorded1.bag# -r FACTOR, --rate=FACTOR# 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。rosbag play -r 0.1 --clock recorded1.bag 常用命令12rosparam set /use_sim_time truerosbag play --pause --clock -k scan_odom.bag --topic /topic1","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"三维空间内旋转","slug":"三维空间内旋转","date":"2021-11-02T04:30:12.000Z","updated":"2021-11-02T13:07:47.696Z","comments":true,"path":"2021/11/02/三维空间内旋转/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/","excerpt":"","text":"参考网址:旋转矩阵_ahelloyou的博客-CSDN博客_旋转矩阵 机器人运动学基础——旋转矩阵_太初有泪的博客-CSDN博客 三维重建学习(1)：基础知识：旋转矩阵与旋转向量_hongbin_xu的博客-CSDN博客_旋转向量 简记","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"RTOS多任务访问同一个UART的操作方法","slug":"RTOS多任务访问同一个UART的操作方法","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-04T00:46:00.546Z","comments":true,"path":"2021/11/01/RTOS多任务访问同一个UART的操作方法/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"参考网址:RTOS多任务访问同一个UART的操作方法 在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。 处理“混乱”局面的方法比较多，下面基于FreeRTOS，以UART为例讲讲常见的互斥、队列这两种方法。 互斥访问方法123456789101112131415161718//创建互斥量资源SemaphoreHandle_t xSemaphore = NULL;xSemaphore = xSemaphoreCreateMutex();void TaskA(void *pvParameters)&#123; for(;;) &#123; //占用资源 if(xSemaphoreTake(xSemaphore, 10 ) == pdTRUE) &#123; //使用资源(发送数据) USART_SendNByte(); //释放资源 xSemaphoreGive(xSemaphore); &#125; &#125;&#125; 信号量与互斥量区别： 信号量：多个任务同步使用某个资源； 一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作； 互斥量：多任务互斥使用某个资源； 一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源； 队列操作方法队列操作方法就是FIFO，先入先出的原理。比如：任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据。 1234567891011121314151617181920212223242526272829303132333435363738QueueHandle_t xQueue;xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);xTaskCreate(UART_Send_Task, &quot;UART_Send&quot;, STACK_SIZE, NULL, TASK_PRIORITY, NULL);void TaskA(void *pvParameters)&#123; for(;;) &#123; //任务相关操作 //加入队列 xQueueSend(xQueue, &amp;TaskA_Buf, 10) &#125;&#125;void TaskB(void *pvParameters)&#123; for(;;) &#123; //任务相关操作 //加入队列 xQueueSend(xQueue, &amp;TaskB_Buf, 10) &#125;&#125;void UART_Send_Task(void *pvParameters)&#123; for(;;) &#123; //循环读取队列BUF if(xQueueReceive(xQueue, &amp;Buf, 10) == pdTRUE) &#123; USART_SendNByte(&amp;Buf); &#125; &#125;&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"C程序注意点","slug":"c语言编写注意","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:08:52.756Z","comments":true,"path":"2021/11/01/c语言编写注意/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/","excerpt":"","text":"参考网址:https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A 意想不到的八进制12// b为八进制int a=34, b=034; 指针加减运算123456int a=1; int *p=(int *)0x00001000; a=a+1; p=p+1; // 这里的p是指针,// p+1实际上是按照公式p+1*sizeof(int)来计算的。 比如RAM初始化零操作,如下,只有4字节空间被初始化为零 1234567unsigned int *pRAMaddr; //定义地址指针变量 // pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节for(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=4) &#123; *pRAMaddr=0x00000000; //指定RAM地址清零 // 这里清除了四个字节&#125; 关键字sizeofsizeof是一个关键字,需要注意的是,使用sizeof获取数组长度时，不要对指针应用sizeof操作符. 123456789101112131415void ClearRAM(char array[]) &#123; int i ; for(i=0;i&lt;sizeof(array)/sizeof(array[0]);i++) //这里用法错误，array实际上是指针 &#123; array[i]=0x00; &#125; &#125; int main(void) &#123; char Fle[20]; ClearRAM(Fle); //只能清除数组Fle中的前四个元素 &#125; 结构体填充结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体： 第一个结构体： 12345struct &#123; char c； short s； int x； &#125;str_test1; 第二个结构体： 12345struct &#123; char c； int x； short s； &#125;str_test2; 这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？ 其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下第一个结构体变量占用8个字节，第二个结构体占用12个字节，差别很大。第一个结构体变量在内存中的存储格式如图所示： 121~4字节 cc填充SSSS5~8字节 XXXXXXXX 第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。 1231~4字节 cc填充5~8字节 XXXXXXXX9~12字节 ssss填充","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"软件开发中各种开发模型的优缺点","slug":"几种软件开发模型","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:06:25.100Z","comments":true,"path":"2021/11/01/几种软件开发模型/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"参考网址:软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com) 可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。 但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。 瀑布模型该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示： 在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。 优点 该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。 比较适用于前期的软件开发与小型软件系统的开发中。 缺点 无法评估项目进度。因为不知道哪个阶段会造成项目的延期 无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果 快速原型模型快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示： 优点 解决需求不明确带来的风险，适用于不能提前确定项目需求的项目 缺点 不利于开发人员对产品进行扩展 迭代模型迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示： 优点 第一个可交付版本的软件所需的成本与时间较小 能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。 缺点 如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。 最终集成各个组件时，可能会出现集成失败的风险。 喷泉模型该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示： 优点 支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。 缺点 由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。 大量开发人员不利于项目的管理。 该模型需要严格管理文档，会增加审核的难度增大。 螺旋模型螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示： 该模型共有四个象限，每个象限的含义如下： 制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。 风险分析:评价所制订的实施方案，识别风险并消除风险。 实施工程:开发产品并进行验证。 客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。 优点 螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。 缺点 过多的迭代次数会增加开发成本，延迟提交时间。 敏捷模型在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。 敏捷开发模型的价值与原则 个体和交互重于过程和工具 可用软件重于完备文档 客户协作重于合同谈判 响应变化重于遵循计划 优点 用户很快可以看到一个基线架构版的产品 敏捷注重市场快速反应能力，客户前期满意度高。 缺点 注重人员的沟通 忽略文档的重要性 如果项目人员流动大太，会增加项目维护难度 软件之前版本的可重现性、可回溯性较低 对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"变量初始化多种操作","slug":"变量初始化多种操作","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-29T05:07:51.246Z","comments":true,"path":"2021/11/01/变量初始化多种操作/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/","excerpt":"","text":"参考网址:嵌入式C语言编程时，变量、数组、指针初始化的多种操作 数值初始化123int inum = 0;float fnum = 0.00f;double dnum = 0.00; 字符初始化1char ch = &#x27;\\0&#x27;; 字符串初始化实际上就是将字符数组中的字符都初始化为&#39;\\0&#39; 1234567891011// 使用&quot;&quot;实现char str[10] = &quot;&quot;;// 使用memsetchar str[10];memset(str, 0, sizeof(str));//使用循环char str[10];for(int i = 0; i &lt; 10; i++)&#123; str[i] = &#x27;\\0&#x27;;&#125; 一般使用memset最合适,一般采用+1的方式参考: 123char year[4+1];memset(year, 0, sizeof(year));strcpy(year,&quot;2018&quot;); 指针初始化需要使用malloc申请动态内存 123456789101112char *p = NULL; p=(char *)malloc(100); if(NULL == p)&#123; printf(&quot;Memory Allocated at: %x\\n&quot;,p); &#125;else&#123; printf(&quot;Not Enough Memory!\\n&quot;); &#125; free(p); p = NULL; //这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题 结构体初始化1234567891011121314typedef struct student&#123; int id; char name[20]; char sex;&#125;STU;STU stu1;memset((char *)&amp;stu1, 0, sizeof(stu1));// struct tm * tmp_time;// memset(tmp_time, 0, sizeof(struct tm));// task_send_data task_data;// task_rcv_data rcv_data;// memset(&amp;task_data, 0, sizeof(task_data));// memset(&amp;rcv_data, 0, sizeof(rcv_data)); 注意初始化结构体数组时 12345STU stus[10];memset((char *)&amp;stus, 0, sizeof(stus)); //正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度memset((char *)&amp;stus, 0, sizeof(STU)); //错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化memset((char *)&amp;stus, 0, sizeof(STU)*10); //正确，效果与第一个是一样的memset((char *)&amp;stu1, 0x00, sizeof(stu1)); //正确,效果与第一个是一样的","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"时间触发嵌入式系统设计模式","slug":"时间片调度","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:13:36.281Z","comments":true,"path":"2021/11/01/时间片调度/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/","excerpt":"","text":"参考网址:时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式 SimpleTimer [Linux下C实现的自定义定时器](voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)) [CppTimer](berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)) [simple-timer-for-c-language](ielife/simple-timer-for-c-language: high performance timer for linux (github.com)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// main.c// GPIO_LED : GPIO output to control an on-board red LED// // EVB : Nu-LB-NUC140// MCU : NUC140VE3CN// low-active output control by GPC12#include &lt;stdio.h&gt;#include &quot;NUC100Series.h&quot;#include &quot;MCU_init.h&quot;#include &quot;SYS_init.h&quot;#include &quot;scheduler.h&quot;extern void SCH_Init(void) ; extern void SCH_Update(void) ;void SysTick_Handler(void)&#123; SCH_Update(); &#125;void InitSysTickClk()&#123; SCH_Init(); SysTick-&gt;LOAD = 1000 *CyclesPerUs -1; SysTick-&gt;VAL = (0x00); NVIC_EnableIRQ(SysTick_IRQn); SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk; &#125;void LED_Flash_Update(void)&#123; GPIO_TOGGLE(PC14); &#125;void LED_Flash_UpdateD(void)&#123; GPIO_TOGGLE(PC12); &#125;int main(void)&#123; SYS_Init(); UART_Open(UART0, 115200); printf(&quot;Hello World \\r\\n&quot;); GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT); GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT); GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT); InitSysTickClk(); SCH_Add_Task(LED_Flash_Update, 0, 1000); SCH_Add_Task(LED_Flash_UpdateD, 0, 2000); while(1) &#123; SCH_Dispatch_Tasks(); &#125; &#125; 12345678910111213141516171819202122// scheduler.h#ifndef _SCHEDULER_H#define _SCHEDULER_H// ------ 公用的函数原型 -------------------------------// 调度器内核函数void SCH_Dispatch_Tasks(void);unsigned char SCH_Add_Task(void (*) (void), const unsigned int, const unsigned int); unsigned char SCH_Delete_Task(const unsigned char);void SCH_Report_Status(void);// ------ 公用的常数 -----------------------------------------// 在程序的运行期间任一时刻请求的任务最大数目// 在程序的运行期间// 每个新建项目都必须调整#define SCH_MAX_TASKS (3) #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389// scheduler.c/*------------------------------------------------------------------*- SCH51.C (v1.00) ------------------------------------------------------------------ /// 这里是调度器内核函数 /// *** 这里是调度器内核函数 *** --- 这些函数可以用于所有 8051 芯片 --- *** hSCH_MAX_TASKS 必须由用户设置 *** --- 参见 &quot;Sch51.h&quot; --- *** 包括省电模式*** --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----） --- 诸如 c515c, c509,等等才需要 ----*------------------------------------------------------------------*/#include &quot;scheduler.h&quot;typedef unsigned char tByte;typedef unsigned int tWord;typedef unsigned long tLong;#define ERROR_SCH_TOO_MANY_TASKS (1)#define ERROR_SCH_CANNOT_DELETE_TASK (2)#define ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)#define ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)#define ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)#define ERROR_SCH_LOST_SLAVE (5)#define ERROR_SCH_CAN_BUS_ERROR (6)#define ERROR_I2C_WRITE_BYTE (10)#define ERROR_I2C_READ_BYTE (11)#define ERROR_I2C_WRITE_BYTE_AT24C64 (12)#define ERROR_I2C_READ_BYTE_AT24C64 (13)#define ERROR_I2C_DS1621 (14)#define ERROR_USART_TI (21)#define ERROR_USART_WRITE_CHAR (22)#define ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)#define ERROR_SPI_X25_TIMEOUT (32)#define ERROR_SPI_MAX1110_TIMEOUT (33)#define ERROR_ADC_MAX150_TIMEOUT (44)#define RETURN_NORMAL 0#define RETURN_ERROR 1// ------ 公用变量定义 ------------------------------// ------ 公用数据类型声明 ----------------------------// 如果可能的话，存储在 DATA 区, 以供快速存取 // 每个任务的存储器总和是 7个字节typedef struct &#123; // 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数) void (* pTask)(void); //延迟 (时标) 直到函数将 (下一次) 运行 // - 详细说明参见 SCH_Add_Task() unsigned int Delay; // 在连续的运行之间的间隔 (时标) // - 详细说明参见 SCH_Add_Task() unsigned int Period; // 当任务需要运行时 (由调度器) 加1 unsigned char RunMe; &#125; sTask; // 任务队列sTask SCH_tasks_G[SCH_MAX_TASKS];// 用来显示错误代码// 错误代码的详细资料参见 Main.H // 关于错误端口的详细资料参见 Port.H unsigned char Error_code_G = 0;// ------ 私有函数原型 ------------------------------static void SCH_Go_To_Sleep(void);// ------ 私有变量 ----------------------------------------// 跟踪自从上一次记录错误以来的时间 (见下文)static unsigned int Error_tick_count_G;// 上次的错误代码 (在1分钟之后复位)static unsigned char Last_error_code_G;/*------------------------------------------------------------------*- SCH_Dispatch_Tasks() 这是“调度”函数. 当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它. 这个函数必须被主循环 (重复)调用.-*------------------------------------------------------------------*/void SCH_Dispatch_Tasks(void) &#123; unsigned char Index; // 调度 (运行) 下一个任务 (如果有任务就绪) for (Index = 0; Index &lt; SCH_MAX_TASKS; Index++) &#123; if (SCH_tasks_G[Index].RunMe &gt; 0) &#123; (*SCH_tasks_G[Index].pTask)(); // 运行任务 SCH_tasks_G[Index].RunMe -= 1; // RunMe 标志复位/减1 // 周期性的任务将自动的再次运行 // - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除 if (SCH_tasks_G[Index].Period == 0) &#123; SCH_Delete_Task(Index); &#125; &#125; &#125; // 报告系统状况 SCH_Report_Status(); // 这里调度器进行空闲模式 SCH_Go_To_Sleep(); &#125;/*------------------------------------------------------------------*- SCH_Add_Task() 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行 Fn_P - 将被调度的函数的名称. 注意: 所有被调度的函数必须是 &#x27;void, void&#x27; - 即函数没有参数, 并且返回类型为 void DELAY - 在任务第一次被运行之前的间隔（时标） PERIOD - &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次. &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些） //PERIOD 返回值 : 返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中 (空间不够). 如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。 注意: 如果以后要删除任务, 将需要这个返回值，参见 SCH_Delete_Task(). 例子: Task_ID = SCH_Add_Task(Do_X,1000,0,0); 使函数 Do_X() 在1000 个调度器时标之后运行一次 Task_ID = SCH_Add_Task(Do_X,0,1000,1); 使函数 Do_X() 每隔1000 个调度器时标运行一次 Task_ID = SCH_Add_Task(Do_X,300,1000,0); 使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标， 2300个时标 ，等等 -*------------------------------------------------------------------*/unsigned char SCH_Add_Task(void (* pFunction)(), const unsigned int DELAY, const unsigned int PERIOD) &#123; unsigned char Index = 0; // 首先在队列中找到一个空隙(如果有的话) while ((SCH_tasks_G[Index].pTask != 0) &amp;&amp; (Index &lt; SCH_MAX_TASKS)) &#123; Index++; &#125; // 是否已经到达队列的结尾 ？？ if (Index == SCH_MAX_TASKS) &#123; // 任务队列已满 // // 设置全局错误变量 Error_code_G = ERROR_SCH_TOO_MANY_TASKS; // 同时返回错误代码 return SCH_MAX_TASKS; &#125; // 如果能运行到这里，说明任务队列中有空间 SCH_tasks_G[Index].pTask = pFunction; SCH_tasks_G[Index].Delay = DELAY; SCH_tasks_G[Index].Period = PERIOD; SCH_tasks_G[Index].RunMe = 0; return Index; // 返回任务的位置 (以便以后删除) &#125;/*------------------------------------------------------------------*- SCH_Delete_Task() 从调度器删除任务. 注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 参数: TASK_INDEX - 任务索引. 由 SCH_Add_Task()提供. 返回值: RETURN_ERROR or RETURN_NORMAL-*------------------------------------------------------------------*/unsigned char SCH_Delete_Task(const tByte TASK_INDEX) &#123; unsigned char Return_code; if (SCH_tasks_G[TASK_INDEX].pTask == 0) &#123; // 这里没有任务 // // 设置全局错误变量 Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK; // ...同时返回错误代码 Return_code = RETURN_ERROR; &#125; else &#123; Return_code = RETURN_NORMAL; &#125; SCH_tasks_G[TASK_INDEX].pTask = 0x0000; SCH_tasks_G[TASK_INDEX].Delay = 0; SCH_tasks_G[TASK_INDEX].Period = 0; SCH_tasks_G[TASK_INDEX].RunMe = 0; return Return_code; // 返回状态 &#125;/*------------------------------------------------------------------*- SCH_Report_Status() 用来显示错误代码的简单的函数. 这个版本将在连接到端口的LED上显示错误代码， 如果需要的话，可以修改为通过串行连接等方式报告错误。 错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。). 此后错误代码被复位为0. 这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。 更加详尽的资料参见第10章。-*------------------------------------------------------------------*/void SCH_Report_Status(void) &#123;#ifdef SCH_REPORT_ERRORS // 只在需要报告错误时适用 // 检查新的错误代码 if (Error_code_G != Last_error_code_G) &#123; // 假定LED采用负逻辑 Error_port = 255 - Error_code_G; Last_error_code_G = Error_code_G; if (Error_code_G != 0) &#123; Error_tick_count_G = 60000; &#125; else &#123; Error_tick_count_G = 0; &#125; &#125; else &#123; if (Error_tick_count_G != 0) &#123; if (--Error_tick_count_G == 0) &#123; Error_code_G = 0; // 复位错误代码 &#125; &#125; &#125;#endif &#125;/*------------------------------------------------------------------*- SCH_Go_To_Sleep() 本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。 注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。 然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计 调度器的性能。这方面的例子参见第14章。 *** 如果使用看门狗的话，可能需要禁止这个功能 *** *** 根据硬件的需要修改 ***-*------------------------------------------------------------------*/void SCH_Go_To_Sleep() &#123; &#125; /*------------------------------------------------------------------*- SCH_Update 中断调用 这是调度器的中断服务程序. 初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。 这个版本由定时器1中断触发 -*------------------------------------------------------------------*/void SCH_Update(void) &#123; tByte Index; // 重装定时器 // 注意：计算单位为“时标”（不是毫秒） for (Index = 0; Index &lt; SCH_MAX_TASKS; Index++) &#123; // 检测这里是否有任务 if (SCH_tasks_G[Index].pTask) &#123; if (SCH_tasks_G[Index].Delay == 0) &#123; // 任务需要运行 SCH_tasks_G[Index].RunMe += 1; // &#x27;RunMe&#x27; 标志加1 if (SCH_tasks_G[Index].Period) &#123; // 调度定期的任务再次运行 SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period; &#125; &#125; else &#123; //还没有准备好运行，延迟减 1 SCH_tasks_G[Index].Delay -= 1; &#125; &#125; &#125; &#125; void SCH_Init(void) &#123; unsigned char i; for (i = 0; i &lt; SCH_MAX_TASKS; i++) &#123; SCH_Delete_Task(i); &#125; // 复位全局错误变量 // - SCH_Delete_Task() 将产生一个错误代码 // (因为任务队列是空的) Error_code_G = 0; &#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"嵌入式相关的开源项目","slug":"嵌入式相关开源项目","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T08:22:56.607Z","comments":true,"path":"2021/11/01/嵌入式相关开源项目/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"参考网址:https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw 1.Avem这是一个轻量级无人机飞控项目。 2.Awesome-Embedded这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源： 3.soft-and-hard这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。 4.FreeModbusFreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要收费的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。 5. EmbedSummary精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"注释软件","slug":"注释软件","date":"2021-11-01T04:30:12.000Z","updated":"2021-11-01T09:07:34.012Z","comments":true,"path":"2021/11/01/注释软件/","link":"","permalink":"https://peitianyu.github.io/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"参考网址:几款注释软件推荐 javEhttp://www.jave.de/ 里边的字体,图片生成挺有意思,不过需要装java 原理图https://josoansi.de/download.php 流程图ascii-art 有很多有意思的注释,可知看一下直接复制粘贴,很舒爽 CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject 类似于”Visio”的一款工具","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"回调函数","slug":"回调函数","date":"2021-10-29T04:30:12.000Z","updated":"2021-10-29T10:23:09.856Z","comments":true,"path":"2021/10/29/回调函数/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"参考网站c语言回调函数 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/**************************************** * 函数指针结构体 ***************************************/typedef struct _OP &#123; float (*p_add)(float, float); float (*p_sub)(float, float); float (*p_mul)(float, float); float (*p_div)(float, float); &#125; OP; /**************************************** * 加减乘除函数 ***************************************/float ADD(float a, float b) &#123; return a + b;&#125;float SUB(float a, float b) &#123; return a - b;&#125;float MUL(float a, float b) &#123; return a * b;&#125;float DIV(float a, float b) &#123; return a / b;&#125;/**************************************** * 初始化函数指针 ***************************************/void init_op(OP *op)&#123; op-&gt;p_add = ADD; op-&gt;p_sub = SUB; op-&gt;p_mul = &amp;MUL; op-&gt;p_div = &amp;DIV;&#125;/**************************************** * 库函数 ***************************************/float add_sub_mul_div(float a, float b, float (*op_func)(float, float))&#123; return (*op_func)(a, b);&#125;int main(int argc, char *argv[]) &#123; OP *op = (OP *)malloc(sizeof(OP)); init_op(op); /* 直接使用函数指针调用函数 */ printf(&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\\n&quot;, (op-&gt;p_add)(1.3, 2.2), (*op-&gt;p_sub)(1.3, 2.2), (op-&gt;p_mul)(1.3, 2.2), (*op-&gt;p_div)(1.3, 2.2)); /* 调用回调函数 */ printf(&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\\n&quot;, add_sub_mul_div(1.3, 2.2, ADD), add_sub_mul_div(1.3, 2.2, SUB), add_sub_mul_div(1.3, 2.2, MUL), add_sub_mul_div(1.3, 2.2, DIV)); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"局部全局坐标转换","slug":"局部全局坐标转换","date":"2021-10-29T04:30:12.000Z","updated":"2021-10-29T10:24:19.049Z","comments":true,"path":"2021/10/29/局部全局坐标转换/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"局部全局坐标转换模型 公式: ROS 中里程计的计算代码理解12345678double dt = (current_time - last_time).toSec();double delta_x = (vx * cos(th) - vy * sin(th)) * dt;double delta_y = (vx * sin(th) + vy * cos(th)) * dt;double delta_th = vth * dt;x += delta_x;y += delta_y;th += delta_th;","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"STL库","slug":"STL","date":"2021-10-28T04:30:12.000Z","updated":"2021-10-28T13:39:17.249Z","comments":true,"path":"2021/10/28/STL/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/28/STL/","excerpt":"","text":"参考网址:C++中STL用法超详细总结 MyTinySTL STL中六大组件：容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；仿函数（Functor）适配器（Adaptor）分配器（allocator） 2.1 容器STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list； Vector：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时； Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时； List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。 Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找； Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。 2.2 STL迭代器Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator. 2.3 算法STL中算法大致分为四类：非可变序列算法：指不直接修改其所操作的容器内容的算法。可变序列算法：指可以修改它们所操作的容器内容的算法。排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。数值算法：对容器内容进行数值计算。以下对所有算法进行细致分类并标明功能： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的 一个InputIterator。find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一 个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代 替等于操作。find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使 用了用户自定义操作符。find_if: 使用输入的函数代替等于操作符执行find。lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函 数使用自定义比较操作。upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志 一个大于value的值。重载函数使用自定义比较操作。search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位 置，查找失败指向last1。重载版本使用自定义的比较操作。search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重 载版本使用自定义的比较操作。partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。reverse: 将指定范围内元素重新反序排序。reverse_copy: 与reverse类似，不过将结果写入另一个容器。rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。rotate_copy: 与rotate类似，不过将结果写入另一个容器。sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个)copy: 复制序列copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。iter_swap: 交换两个ForwardIterator的值。remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和 remove_if函数。remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。remove_if: 删除指定范围内输入操作结果为true的所有元素。remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。replace: 将指定范围内所有等于vold的元素都用vnew代替。replace_copy: 与replace类似，不过将结果写入另一个容器。replace_if: 将指定范围内所有操作结果为true的元素用新值代替。replace_copy_if: 与replace_if，不过将结果写入另一个容器。swap: 交换存储在两个对象中的值。swap_range: 将指定范围内的元素与另一个序列元素值进行交换。unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。fill_n: 将输入值赋给first到first+n范围内的所有元素。for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。generate: 连续调用输入的函数来填充指定的范围。generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。max: 返回两个元素中较大一个。重载版本使用自定义比较操作。max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。min: 返回两个元素中较小一个。重载版本使用自定义比较操作。min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用 自定义的比较操作。set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 2.4 仿函数2.4.1 概述 仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。 有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。 1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。 2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。 2.4.2 仿函数(functor)在编程语言中的应用1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int sort_function( const void *a, const void *b);int sort_function( const void *a, const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; int list[5] = &#123; 54, 21, 11, 67, 22 &#125;; qsort((void *)list, 5, sizeof(list[0]), sort_function);//起始地址，个数，元素大小，回调函数 int x; for (x = 0; x &lt; 5; x++) printf(&quot;%i\\n&quot;, list[x]); return 0;&#125; 2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; for_each(ia, ia + 5, display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 2.4.3 仿函数在STL中的定义要使用STL内建的仿函数，必须包含头文件。而头文件中包含的仿函数分类包括 1）算术类仿函数 加：plus&lt;T&gt; 减：minus&lt;T&gt; 乘：multiplies&lt;T&gt; 除：divides&lt;T&gt; 模取：modulus&lt;T&gt; 否定：negate&lt;T&gt; 例子： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;vector&gt; #include &lt;functional&gt; using namespace std;int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; vector&lt;int&gt; iv(ia, ia + 5); //120 cout &lt;&lt; accumulate(iv.begin(), iv.end(), 1, multiplies&lt;int&gt;()) &lt;&lt; endl; //15 cout &lt;&lt; multiplies&lt;int&gt;()(3, 5) &lt;&lt; endl; modulus&lt;int&gt; modulusObj; cout &lt;&lt; modulusObj(3, 5) &lt;&lt; endl; // 3 system(&quot;pause&quot;); return 0;&#125; 2）关系运算类仿函数 等于：equal_to&lt;T&gt; 不等于：not_equal_to&lt;T&gt; 大于：greater&lt;T&gt; 大于等于：greater_equal&lt;T&gt; 小于：less&lt;T&gt; 小于等于：less_equal&lt;T&gt; 从大到小排序： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;functional&gt;#include &lt;vector&gt; using namespace std;template &lt;class T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,5,4,3,2 &#125;; vector&lt;int&gt; iv(ia, ia + 5); sort(iv.begin(), iv.end(), greater&lt;int&gt;()); for_each(iv.begin(), iv.end(), display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 3）逻辑运算仿函数 逻辑与：logical_and&lt;T&gt; 逻辑或：logical_or&lt;T&gt; 逻辑否：logical_no&lt;T&gt; 除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结 2.5 容器适配器标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈) 什么是容器适配器 ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack&lt;int, vector &gt;实现了栈的功能，但其内部使用顺序容器vector来存储数据。（相当于是vector表现出 了栈的行为）。 容器适配器 要使用适配器，需要加入一下头文件： #include &lt;stack&gt; //stack #include&lt;queue&gt; //queue、priority_queue 种类 默认顺序容器 可用顺序容器 说明stack deque vector、list、dequequeue deque list、deque 基础容器必须提供push_front()运算priority_queue vector vector、deque 基础容器必须提供随机访问功能定义适配器 1、初始化 stack&lt;int&gt; stk(dep); 2、覆盖默认容器类型 stack&lt;int,vector&lt;int&gt; &gt; stk; 使用适配器 2.5.1 stackstack s;stack&lt; int, vector &gt; stk; //覆盖基础容器类型，使用vector实现stks.empty(); //判断stack是否为空，为空返回true，否则返回falses.size(); //返回stack中元素的个数s.pop(); //删除栈顶元素，但不返回其值s.top(); //返回栈顶元素的值，但不删除此元素s.push(item); //在栈顶压入新元素item实例：括号匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;int main()&#123; string s; stack&lt;char&gt; ss; while (cin &gt;&gt; s) &#123; bool flag = true; for (char c : s) //C++11新标准，即遍历一次字符串s &#123; if (c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27;) &#123; ss.push(c); continue; &#125; if (c == &#x27;&#125;&#x27;) &#123; if (!ss.empty() &amp;&amp; ss.top() == &#x27;&#123;&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;]&#x27;) &#123; if (ss.top() == &#x27;[&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;)&#x27;) &#123; if (ss.top() == &#x27;(&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; &#125; if (flag) cout &lt;&lt; &quot;Match!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Not Match!&quot; &lt;&lt; endl; &#125;&#125; 2.5.2 queue &amp; priority_queuequeue q; //priority_queue q;q.empty(); //判断队列是否为空q.size(); //返回队列长度q.push(item); //对于queue，在队尾压入一个新元素 //对于priority_queue，在基于优先级的适当位置插入新元素 //queue only:q.front(); //返回队首元素的值，但不删除该元素q.back(); //返回队尾元素的值，但不删除该元素 //priority_queue only:q.top(); //返回具有最高优先级的元素值，但不删除该元素 常用容器用法介绍vector基本函数实现1.构造函数vector():创建一个空vectorvector(int nSize):创建一个vector,元素个数为nSizevector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为tvector(const vector&amp;):复制构造函数vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数void push_back(const T&amp; x):向量尾部增加一个元素Xiterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素xiterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素xiterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数iterator erase(iterator it):删除向量中迭代器指向元素iterator erase(iterator first,iterator last):删除向量中[first,last)中元素void pop_back():删除向量中最后一个元素void clear():清空向量中所有元素 4.遍历函数reference at(int pos):返回pos位置元素的引用reference front():返回首元素的引用reference back():返回尾元素的引用iterator begin():返回向量头指针，指向第一个元素iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置reverse_iterator rbegin():反向迭代器，指向最后一个元素reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数int size() const:返回向量中元素的个数int capacity() const:返回当前向量张红所能容纳的最大元素值int max_size() const:返回最大可允许的vector元素数量值 7.其他函数void swap(vector&amp;):交换两个同类型向量的数据void assign(int n,const T&amp; x):设置向量中第n个元素的值为xvoid assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 8.看着清楚1.push_back 在数组的最后添加一个数据 2.pop_back 去掉数组的最后一个数据 3.at 得到编号位置的数据 4.begin 得到数组头的指针 5.end 得到数组的最后一个单元+1的指针 6．front 得到数组头的引用 7.back 得到数组的最后一个单元的引用 8.max_size 得到vector最大可以是多大 9.capacity 当前vector分配的大小 10.size 当前使用数据的大小 11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 12.reserve 改变当前vecotr所分配空间的大小 13.erase 删除指针指向的数据项 14.clear 清空当前的vector 15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) 16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1) 17.empty 判断vector是否为空 18.swap 与另一个vector交换数据 基本用法#include &lt; vector&gt;using namespace std; 简单介绍Vector&lt;类型&gt;标识符Vector&lt;类型&gt;标识符(最大容量)Vector&lt;类型&gt;标识符(最大容量,初始所有值)Int i[5]={1,2,3,4,5}Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过 实例3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据1234567891011121314151617181920212223242526272829#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj;//创建一个向量存储容器 int for(int i=0;i&lt;10;i++) // push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; for(int i=0;i&lt;5;i++)//去掉数组最后一个数据 &#123; obj.pop_back(); &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++)//size()容器中实际数据个数 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 1230,1,2,3,4,5,6,7,8,9,0,1,2,3,4, clear()清除容器中所有数据1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++)//push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; obj.clear();//清除容器中所以数据 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;endl; &#125; return 0;&#125; 输出结果为： 10,1,2,3,4,5,6,7,8,9, 排序123456789101112131415161718192021222324252627282930313233#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; obj.push_back(1); obj.push_back(3); obj.push_back(0); sort(obj.begin(),obj.end());//从小到大 cout&lt;&lt;&quot;从小到大:&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; cout&lt;&lt;&quot;从大到小:&quot;&lt;&lt;endl; reverse(obj.begin(),obj.end());//从大到小 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 12345从小到大:0,1,3,从大到小:3,1,0, 1.注意 sort 需要头文件 #include 2.如果想 sort 来降序，可重写 sort bool compare(int a,int b){ return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序}int a[20]={2,4,1,23,5,76,0,43,24,65},i;for(i=0;i&lt;20;i++) cout&lt;&lt; a[i]&lt;&lt; endl;sort(a,a+20,compare); 访问（直接数组访问&amp;迭代器访问）1234567891011121314151617181920212223242526272829303132#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; //顺序访问 vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++) &#123; obj.push_back(i); &#125; cout&lt;&lt;&quot;直接利用数组：&quot;; for(int i=0;i&lt;10;i++)//方法一 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;利用迭代器：&quot; ; //方法二，使用迭代器将容器中数据输出 vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for(it=obj.begin();it!=obj.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 输出结果为： 12直接利用数组：0 1 2 3 4 5 6 7 8 9 利用迭代器：0 1 2 3 4 5 6 7 8 9 二维数组两种定义方法（结果一样）方法一 123456789101112131415161718192021222324252627#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N); //定义二维动态数组大小5行 for(int i =0; i&lt; obj.size(); i++)//动态二维数组为5行6列，值全为0 &#123; obj[i].resize(M); &#125; for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 方法二 1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 输出结果为： 1234560 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3.2 deque 所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。 deque#include // 头文件deque deq; // 声明一个元素类型为type的双端队列quedeque deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque deq(mydeque); // deq是mydeque的一个副本deque deq(first, last); // 使用迭代器first、last范围内的元素初始化deq deque的常用成员函数deque deq;deq[ ]：用来访问双向队列中单个的元素。deq.front()：返回第一个元素的引用。deq.back()：返回最后一个元素的引用。deq.push_front(x)：把元素x插入到双向队列的头部。deq.pop_front()：弹出双向队列的第一个元素。deq.push_back(x)：把元素x插入到双向队列的尾部。deq.pop_back()：弹出双向队列的最后一个元素。 deque的一些特点支持随机访问，即支持[ ]以及at()，但是性能没有vector好。可以在内部进行插入和删除操作，但性能不及list。deque两端都能够快速插入和删除元素，而vector只能在尾端进行。deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。deque不支持对容量和内存分配时机的控制。在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。deque不提供容量操作：capacity()和reverse()，但是vector可以。 实例12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;deque&gt;using namespace std;int main(void)&#123; int i; int a[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; deque&lt;int&gt; q; for (i = 0; i &lt;= 9; i++) &#123; if (i % 2 == 0) q.push_front(a[i]); else q.push_back(a[i]); &#125; /*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/ q.pop_front(); printf(&quot;%d\\n&quot;, q.front()); /*清除第一个元素后输出第一个(6)*/ q.pop_back(); printf(&quot;%d\\n&quot;, q.back()); /*清除最后一个元素后输出最后一个(7)*/ deque&lt;int&gt;::iterator it; for (it = q.begin(); it != q.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &#x27;\\t&#x27;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 输出结果： listlist定义List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件 #include list定义和初始化123456789list&lt;int&gt;lst1; //创建空listlist&lt;int&gt; lst2(5); //创建含有5个元素的listlist&lt;int&gt;lst3(3,2); //创建含有3个元素的listlist&lt;int&gt;lst4(lst2); //使用lst2初始化lst4list&lt;int&gt;lst5(lst2.begin(),lst2.end()); //同lst4 list常用操作函数Lst1.assign() 给list赋值Lst1.back() 返回最后一个元素Lst1.begin() 返回指向第一个元素的迭代器Lst1.clear() 删除所有元素Lst1.empty() 如果list是空的则返回trueLst1.end() 返回末尾的迭代器Lst1.erase() 删除一个元素Lst1.front() 返回第一个元素Lst1.get_allocator() 返回list的配置器Lst1.insert() 插入一个元素到list中Lst1.max_size() 返回list能容纳的最大元素数量Lst1.merge() 合并两个listLst1.pop_back() 删除最后一个元素Lst1.pop_front() 删除第一个元素Lst1.push_back() 在list的末尾添加一个元素Lst1.push_front() 在list的头部添加一个元素Lst1.rbegin() 返回指向第一个元素的逆向迭代器Lst1.remove() 从list删除元素Lst1.remove_if() 按指定条件删除元素Lst1.rend() 指向list末尾的逆向迭代器Lst1.resize() 改变list的大小Lst1.reverse() 把list的元素倒转Lst1.size() 返回list中的元素个数Lst1.sort() 给list排序Lst1.splice() 合并两个listLst1.swap() 交换两个listLst1.unique() 删除list中相邻重复的元素 List使用实例迭代器遍历list12345for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++) &#123; cout&lt;&lt;*iter; &#125; cout&lt;&lt;endl; 综合实例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;using namespace std;typedef list&lt;int&gt; LISTINT;typedef list&lt;int&gt; LISTCHAR;void main()&#123; //用LISTINT创建一个list对象 LISTINT listOne; //声明i为迭代器 LISTINT::iterator i; listOne.push_front(3); listOne.push_front(2); listOne.push_front(1); listOne.push_back(4); listOne.push_back(5); listOne.push_back(6); cout &lt;&lt; &quot;listOne.begin()--- listOne.end():&quot; &lt;&lt; endl; for (i = listOne.begin(); i != listOne.end(); ++i) cout &lt;&lt; *i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; LISTINT::reverse_iterator ir; cout &lt;&lt; &quot;listOne.rbegin()---listOne.rend():&quot; &lt;&lt; endl; for (ir = listOne.rbegin(); ir != listOne.rend(); ir++) &#123; cout &lt;&lt; *ir &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; int result = accumulate(listOne.begin(), listOne.end(), 0); cout &lt;&lt; &quot;Sum=&quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl; //用LISTCHAR创建一个list对象 LISTCHAR listTwo; //声明i为迭代器 LISTCHAR::iterator j; listTwo.push_front(&#x27;C&#x27;); listTwo.push_front(&#x27;B&#x27;); listTwo.push_front(&#x27;A&#x27;); listTwo.push_back(&#x27;D&#x27;); listTwo.push_back(&#x27;E&#x27;); listTwo.push_back(&#x27;F&#x27;); cout &lt;&lt; &quot;listTwo.begin()---listTwo.end():&quot; &lt;&lt; endl; for (j = listTwo.begin(); j != listTwo.end(); ++j) cout &lt;&lt; char(*j) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; j = max_element(listTwo.begin(), listTwo.end()); cout &lt;&lt; &quot;The maximum element in listTwo is: &quot; &lt;&lt; char(*j) &lt;&lt; endl; system(&quot;pause&quot;);&#125; 输出结果 综合实例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt; #include &lt;list&gt; using namespace std;typedef list&lt;int&gt; INTLIST;//从前向后显示list队列的全部元素 void put_list(INTLIST list, char *name)&#123; INTLIST::iterator plist; cout &lt;&lt; &quot;The contents of &quot; &lt;&lt; name &lt;&lt; &quot; : &quot;; for (plist = list.begin(); plist != list.end(); plist++) cout &lt;&lt; *plist &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;//测试list容器的功能 void main(void)&#123; //list1对象初始为空 INTLIST list1; INTLIST list2(5, 1); INTLIST list3(list2.begin(), --list2.end()); //声明一个名为i的双向迭代器 INTLIST::iterator i; put_list(list1, &quot;list1&quot;); put_list(list2, &quot;list2&quot;); put_list(list3, &quot;list3&quot;); list1.push_back(7); list1.push_back(8); cout &lt;&lt; &quot;list1.push_back(7) and list1.push_back(8):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.push_front(6); list1.push_front(5); cout &lt;&lt; &quot;list1.push_front(6) and list1.push_front(5):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.insert(++list1.begin(), 3, 9); cout &lt;&lt; &quot;list1.insert(list1.begin()+1,3,9):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); //测试引用类函数 cout &lt;&lt; &quot;list1.front()=&quot; &lt;&lt; list1.front() &lt;&lt; endl; cout &lt;&lt; &quot;list1.back()=&quot; &lt;&lt; list1.back() &lt;&lt; endl; list1.pop_front(); list1.pop_back(); cout &lt;&lt; &quot;list1.pop_front() and list1.pop_back():&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.erase(++list1.begin()); cout &lt;&lt; &quot;list1.erase(++list1.begin()):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list2.assign(8, 1); cout &lt;&lt; &quot;list2.assign(8,1):&quot; &lt;&lt; endl; put_list(list2, &quot;list2&quot;); cout &lt;&lt; &quot;list1.max_size(): &quot; &lt;&lt; list1.max_size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.size(): &quot; &lt;&lt; list1.size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.empty(): &quot; &lt;&lt; list1.empty() &lt;&lt; endl; put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); cout &lt;&lt; &quot;list1&gt;list3: &quot; &lt;&lt; (list1 &gt; list3) &lt;&lt; endl; cout &lt;&lt; &quot;list1&lt;list3: &quot; &lt;&lt; (list1 &lt; list3) &lt;&lt; endl; list1.sort(); put_list(list1, &quot;list1&quot;); list1.splice(++list1.begin(), list3); put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); system(&quot;pause&quot;);&#125; 输出结果： map/multimapmap和multimap都需要#include，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。 C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。 Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 基本操作函数12345678910111213141516171819202122232425262728293031323334353637begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数 声明1234//头文件#include&lt;map&gt;map&lt;int, string&gt; ID_Name; // 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012 1234map&lt;int, string&gt; ID_Name = &#123; &#123; 2015, &quot;Jim&quot; &#125;, &#123; 2016, &quot;Tom&quot; &#125;, &#123; 2017, &quot;Bob&quot; &#125; &#125;; 迭代器共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。 二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示： 123456789map&lt;int,int&gt;::iterator it;map&lt;int,int&gt; mmap;const map&lt;int,int&gt; const_mmap;it = mmap.begin(); //iteratormmap.cbegin(); //const_iteratorconst_mmap.begin(); //const_iteratorconst_mmap.cbegin(); //const_iterator 返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。 插入操作用insert插入pair数据//数据的插入–第一种：用insert函数插入pair数据 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 用insert函数插入value_type数据//第二种：用insert函数插入value_type数据，下面举例说明 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125; 用insert函数进行多个插入insert共有4个重载函数： // 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败pair&lt;iterator,bool&gt; insert (const value_type&amp; val); //在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排iterator insert (const_iterator position, const value_type&amp; val); // 插入多个void insert (InputIterator first, InputIterator last); //c++11开始支持，使用列表插入多个void insert (initializer_list il);下面是具体使用示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;map&gt;int main()&#123; std::map&lt;char, int&gt; mymap; // 插入单个值 mymap.insert(std::pair&lt;char, int&gt;(&#x27;a&#x27;, 100)); mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 200)); //返回插入位置以及是否插入成功 std::pair&lt;std::map&lt;char, int&gt;::iterator, bool&gt; ret; ret = mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 500)); if (ret.second == false) &#123; std::cout &lt;&lt; &quot;element &#x27;z&#x27; already existed&quot;; std::cout &lt;&lt; &quot; with a value of &quot; &lt;&lt; ret.first-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; //指定位置插入 std::map&lt;char, int&gt;::iterator it = mymap.begin(); mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;b&#x27;, 300)); //效率更高 mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;c&#x27;, 400)); //效率非最高 //范围多值插入 std::map&lt;char, int&gt; anothermap; anothermap.insert(mymap.begin(), mymap.find(&#x27;c&#x27;)); // 列表形式插入 anothermap.insert(&#123; &#123; &#x27;d&#x27;, 100 &#125;, &#123;&#x27;e&#x27;, 200&#125; &#125;); return 0;&#125; 用数组方式插入数据//第三种：用数组方式插入数据，下面举例说明 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[2] = &quot;student_two&quot;; mapStudent[3] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明 123mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;)); 上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下 123pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); 我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。 下面给出完成代码，演示插入成功与否问题 //验证插入函数的作用效果 1234567891011121314151617181920212223#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_two&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 大家可以用如下程序，看下用数组插入在数据覆盖上的效果 //验证数组形式插入数据的效果 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[1] = &quot;student_two&quot;; mapStudent[2] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 查找、删除、交换查找 // 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器// 根据map的类型，返回的迭代器为 iterator 或者 const_iteratoriterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; 删除 // 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器iterator erase( iterator pos ) // 删除一定范围内的元素，并返回一个指向下一元素的迭代器iterator erase( const_iterator first, const_iterator last ); // 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1size_t erase( const key_type&amp; key ); // 清空map，清空后的size为0void clear();交换 // 就是两个map的内容互换void swap( map&amp; other ); 容量// 查询map是否为空bool empty(); // 查询map中键值对的数量size_t size(); // 查询map所能包含的最大键值对数量，和系统和应用库有关。// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了size_t max_size(); // 查询关键字为key的元素的个数，在map里结果非0即1size_t count( const Key&amp; key ) const; // 排序map中的元素是自动按Key升序排序，所以不能对map用sort函数； 这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。 小于号 &lt; 重载12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std;typedef struct tagStudentinfo&#123; int niD; string strName; bool operator &lt; (tagStudentinfo const&amp; _A) const &#123; //这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序 if (niD &lt; _A.niD) return true; if (niD == _A.niD) return strName.compare(_A.strName) &lt; 0; return false; &#125;&#125;Studentinfo, *PStudentinfo; //学生信息 int main()&#123; int nSize; //用学生信息映射分数 map&lt;Studentinfo, int&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;&#125; 仿函数的应用，这个时候结构体中没有直接的小于号重载//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std;typedef struct tagStudentinfo&#123; int niD; string strName;&#125;Studentinfo, *PStudentinfo; //学生信息 class sort&#123;public: bool operator() (Studentinfo const &amp;_A, Studentinfo const &amp;_B) const &#123; if (_A.niD &lt; _B.niD) return true; if (_A.niD == _B.niD) return _A.strName.compare(_B.strName) &lt; 0; return false; &#125;&#125;;int main()&#123; //用学生信息映射分数 map&lt;Studentinfo, int, sort&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; system(&quot;pause&quot;);&#125; unordered_map在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？ map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。 unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。 还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。 最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。 至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。 set/multisetstd::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。 set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。 由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。 multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。 set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。 set常用成员函数 begin()–返回指向第一个元素的迭代器 clear()–清除所有元素 count()–返回某个值元素的个数 empty()–如果集合为空，返回true end()–返回指向最后一个元素的迭代器 equal_range()–返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 代码示例 以下代码涉及的内容：1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？ 2、set容器中，如何让元素类型为自定义类型？ 3、set容器的insert函数的返回值为什么类型？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;/* 仿函数CompareSet，在test02使用 */class CompareSet&#123;public: //从大到小排序 bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125; //从小到大排序 //bool operator()(int v1, int v2) //&#123; // return v1 &lt; v2; //&#125;&#125;;/* Person类，用于test03 */class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person);public: Person(string name, int age) &#123; mName = name; mAge = age; &#125;public: string mName; int mAge;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person)&#123; out &lt;&lt; &quot;name:&quot; &lt;&lt; person.mName &lt;&lt; &quot; age:&quot; &lt;&lt; person.mAge &lt;&lt; endl; return out;&#125;/* 仿函数ComparePerson,用于test03 */class ComparePerson&#123;public: //名字大的在前面，如果名字相同，年龄大的排前面 bool operator()(const Person &amp;p1, const Person &amp;p2) &#123; if (p1.mName == p2.mName) &#123; return p1.mAge &gt; p2.mAge; &#125; return p1.mName &gt; p2.mName; &#125;&#125;;/* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;void test01()&#123; //set容器默认从小到大排序 set&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //输出set PrintSet(s); //结果为:10 20 30 /* set的insert函数返回值为一个对组(pair)。 对组的第一个值first为set类型的迭代器： 1、若插入成功，迭代器指向该元素。 2、若插入失败，迭代器指向之前已经存在的元素 对组的第二个值seconde为bool类型： 1、若插入成功，bool值为true 2、若插入失败，bool值为false */ pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(40); if (true == ret.second) cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入成功&quot; &lt;&lt; endl; else cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入失败&quot; &lt;&lt; endl;&#125;void test02()&#123; /* 如果想让set容器从大到小排序，需要给set容 器提供一个仿函数,本例的仿函数为CompareSet */ set&lt;int, CompareSet&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印set PrintSet(s); //结果为:30,20,10&#125;void test03()&#123; /* set元素类型为Person，当set元素类型为自定义类型的时候 必须给set提供一个仿函数，用于比较自定义类型的大小， 否则无法通过编译 */ set&lt;Person,ComparePerson&gt; s; s.insert(Person(&quot;John&quot;, 22)); s.insert(Person(&quot;Peter&quot;, 25)); s.insert(Person(&quot;Marry&quot;, 18)); s.insert(Person(&quot;Peter&quot;, 36)); //打印set PrintSet(s);&#125;int main(void)&#123; //test01(); //test02(); //test03(); return 0;&#125; multiset容器的insert函数返回值为什么？ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;/* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;void test(void)&#123; multiset&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印multiset PrintSet(s); /* multiset的insert函数返回值为multiset类型的迭代器， 指向新插入的元素。multiset允许插入相同的值，因此 插入一定成功，因此不需要返回bool类型。 */ multiset&lt;int&gt;::iterator iter = s.insert(10); cout &lt;&lt; *iter &lt;&lt; endl; &#125;int main(void)&#123; test(); return 0;&#125; unordered_setC++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。 unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用: 使用unordered_set需要包含#include头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。 除此之外unordered_multiset也是一种可选的容器。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"概率机器人","slug":"概率机器人","date":"2021-10-28T04:30:12.000Z","updated":"2021-10-28T12:14:44.215Z","comments":true,"path":"2021/10/28/概率机器人/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"参考网址:概率机器人 5.机器人运动模型速度模型(概率运动规划)闭式算法 采样算法 数学推导精确运动 真实运动加入扰动,模型表达为 加入噪声,求得概率公式为: 里程计模型(估计)模型为: 闭式算法 采样算法 数学推导三次转换: 加入噪声: 求出坐标: 求得最终概率:","categories":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"}]},{"title":"cpp学习","slug":"cpp学习","date":"2021-10-24T04:30:12.000Z","updated":"2021-10-27T12:02:39.994Z","comments":true,"path":"2021/10/24/cpp学习/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"参考网址:C++ 教程 (github.com) C++ 教程 | 菜鸟教程 (runoob.com) c++基础const关键字声明指定类型的常量,此类型不会发生变化. 比如常用的字符串const char* str,例如 1const char* str = &quot;hello world!&quot;; 当然也会有常数,常指针等.只需要记住它修饰的是它后边的那个.例如 123const char* str #值不能改char const *str #值不能改char* const str #修饰的是常数指针,该指针不能修改 static修饰静态变量,在程序的生命周期内保持局部变量的存在,用于保存上一次运行数据,比如计数等 1static int i = 5; #define预处理器,例如 1#define PORT 7070 extern储存类extern 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.例如 12345678910// main.cpp#include &lt;iostream&gt;int count ;extern void write_extern(); int main()&#123; count = 5; write_extern();&#125; 12345678// support.cpp#include &lt;iostream&gt;extern int count; void write_extern(void)&#123; std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 两个文件之间传递参数. register 存储类寄存器局部变量,用于快速访问.因此也意味着最大尺寸只有寄存器尺寸. 1register int a; thread_local 存储类量在创建线程时创建，并在销毁线程时销毁。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。thread_local 说明符可以与 static 或 extern 合并。 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; 成员运算符1234struct Employee &#123; char first_name[16]; int age;&#125; emp; （.）点运算符下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员 1strcpy(emp.first_name, &quot;zara&quot;); （-&gt;）箭头运算符如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： 1strcpy(p_emp-&gt;first_name, &quot;zara&quot;); 条件运算符 ? :12345if(y &lt; 10)&#123; var = 30;&#125;else&#123; var = 40;&#125; 可写为: 1var = (y &lt; 10) ? 30 : 40; sizeof 运算符sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。 1sizeof (data type) 指针运算符（&amp; 和 *）取地址运算符 &amp; 间接寻址运算符 *顾名思义,挺形象的. 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std; int main ()&#123; int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = &amp;var; // 获取 ptr 的值 val = *ptr; cout &lt;&lt; &quot;Value of var :&quot; &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; &quot;Value of ptr :&quot; &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; &quot;Value of val :&quot; &lt;&lt; val &lt;&lt; endl; return 0;&#125; 传参三种方式传值、传址、传引用123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include &lt;stdint.h&gt;using namespace std;int fun1(int a) return a*a;void man(int &amp;a) a=a*a;void cubeByReference(int *a) *a=*a * *a;void fun2(uint8_t* *buffer)&#123; uint8_t buf[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; *buffer = buf;&#125;int main()&#123; int a=5,b=5,number=5; cout&lt;&lt;fun1(a)&lt;&lt;endl; man(b); cout&lt;&lt;b&lt;&lt;endl; cubeByReference(&amp;number); cout&lt;&lt;number&lt;&lt;endl; return 0;&#125; Lambda 函数与表达式1[capture](parameters)-&gt;return-type&#123;body&#125; 例如: 1[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125; 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 值得注意的是this指针 1[this]() &#123; this-&gt;someFunc(); &#125;(); 数学运算 #include &lt;cmath12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; int main ()&#123; // 数字定义 short s = 10; int i = -1000; long l = 100000; float f = 230.47; double d = 200.374; // 数学运算 cout &lt;&lt; &quot;sin(d) :&quot; &lt;&lt; sin(d) &lt;&lt; endl; cout &lt;&lt; &quot;abs(i) :&quot; &lt;&lt; abs(i) &lt;&lt; endl; cout &lt;&lt; &quot;floor(d) :&quot; &lt;&lt; floor(d) &lt;&lt; endl; cout &lt;&lt; &quot;sqrt(f) :&quot; &lt;&lt; sqrt(f) &lt;&lt; endl; cout &lt;&lt; &quot;pow( d, 2) :&quot; &lt;&lt; pow(d, 2) &lt;&lt; endl; return 0;&#125; 通过time实现的伪随机数123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt; using namespace std; int main ()&#123; int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ) &#123; // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; &#125; return 0;&#125; setw() 函数12345678910111213141516#include &lt;iomanip&gt;using std::setw;cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;# 结果Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 字符串操作 #include &lt;string123456789101112strcpy(s1, s2); // s2复制到s1strcat(s1, s2); // s2拼接到s1后边,类似于:string str = str1 + str2;strlen(s1); // 字符串长度strcmp(s1, s2); // 比较两字符串,相同回0,s1&lt;s2返回小于0,反之,大于0strchr(s1, ch); // 返回字符ch第一次在s1中出现得位置指针strstr(s1, s2); // 返回字符串s2在s1中出现的位姿指针// 复制 str1 到 str3 str3 = str1;// 连接 str1 和 str2 str3 = str1 + str2;// 连接后，str3 的总长度 len = str3.size(); 时间 #include &lt;ctime123456789time_t time(time_t *time); // 返回当前时间char *ctime(const time_t *time); // 返回 day month year hours:minutes:seconds year\\n\\0struct tm *localtime(const time_t *time); // 返回tm时间结构体clock_t clock(void); // 该函数返回程序执行起,处理器时钟所使用的时间char * asctime ( const struct tm * time ); // 返回 day month date hours:minutes:seconds year\\n\\0struct tm *gmtime(const time_t *time); // 用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示time_t mktime(struct tm *time); // 该函数返回日历时间double difftime ( time_t time2, time_t time1 ); // 该函数返回 time1 和 time2 之间相差的秒数size_t strftime(); // 该函数可用于格式化日期和时间为指定的格式 12345678910111213141516#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; &quot;本地日期和时间：&quot; &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; &quot;UTC 日期和时间：&quot;&lt;&lt; dt &lt;&lt; endl;&#125; cin、cout、cerr 和 clog 标准输入输出1234cin :一个istream对象,用来从标准输入读取数据。cout:一个ostream对象，经过缓冲区而直接输出.cerr:一个ostream对象,写到cerr数据是不缓冲clog:一个ostream对象,被缓冲的 结构体12345678910111213141516171819202122// 模板// 使用 Books Book;struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;// 使用 books Book;typedef struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;books;// 取别名 pin32typedef long int pint32;pint32 x, y, z; 结构体指针 12345struct Books *struct_pointer;// 取地址struct_pointer = &amp;Book1;// 访问成员struct_pointer-&gt;title; 面向对象c++对象123456789101112131415161718192021222324252627282930313233343536373839class Line&#123; // 访问修饰符 public: // 类成员函数 double getLength( void ); Line(); // 构造函数声明 friend void printWidth( Box box ); // 友元函数 Line( const Line &amp;obj); //拷贝构造函数 ~Line(); // 析构函数声明 private: double length;&#125;; // 成员函数定义，包括构造函数Line::Line(void)&#123; cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;&#125;Line::~Line(void)&#123; cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;&#125;Line::Line(const Line &amp;obj)&#123; cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值&#125;double Line::getLength( void )&#123; return length;&#125;// 请注意：printWidth() 不是任何类的成员函数void printWidth( Box box )&#123; /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;&#125; 内联函数inline引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神: 1.在内联函数内不允许使用循环语句和开关语句； 2.内联函数的定义必须出现在内联函数第一次调用之前； 3.类结构中所在的类说明内部定义的函数是内联函数。 结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用! 123456789101112131415#include &lt;iostream&gt;using namespace std;inline int Max(int x, int y)&#123; return (x &gt; y)? x : y;&#125;// 程序的主函数int main( )&#123; cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl; cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl; cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl; return 0;&#125; this指针友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 this 指针的类型可理解为 Box* 12# 实际上就是指针引用结构体成员this-&gt;Volume(); 继承12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; // 基类class Shape &#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;; // 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;; int main(void)&#123; Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0;&#125; 多继承另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如： 1234class D&#123;......&#125;;class B: public D&#123;......&#125;;class A: public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 重载运算符类内重调用 12345678Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; 算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，**-&gt;(成员访问)，,(逗号)，[]**(下标) 多态123456789101112131415161718192021222324252627class Shape &#123; protected: int width, height; public: Shape( int a=0, int b=0) &#123; width = a; height = b; &#125; // 虚函数 virtual int area() &#123; cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl; return 0; &#125; // 纯虚数 virtual int area1() = 0;&#125;;class Rectangle: public Shape&#123; public: Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl; return (width * height); &#125;&#125;; 文件和流头文件:iostream 和 fstream 读写文件模板123456789101112131415161718192021222324252627282930313233343536#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std; int main ()&#123; char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Enter your name: &quot;; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;Enter your age: &quot;; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;&#125; 文件位置指针123456// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end ); 异常处理123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;double division(int a, int b)&#123; if( b == 0 ) &#123; throw &quot;Division by zero condition!&quot;; &#125; return (a/b);&#125;int main ()&#123; int x = 50; int y = 0; double z = 0; try &#123; z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; &#125;catch (const char* msg) &#123; cerr &lt;&lt; msg &lt;&lt; endl; &#125; return 0;&#125; 动态内存变量动态内存123double* pvalue = NULL; // 初始化为 null 的指针pvalue = new double; // 为变量请求内存delete pvalue; // 释放 pvalue 所指向的内存 数组动态内存1234567char* pvalue = NULL; // 初始化为 null 的指针pvalue = new char[20]; // 为变量请求内存for(int i = 0; i &lt; COL; i++) &#123; delete[] pvalue[i];&#125;delete [] pvalue; 对象的动态内存分配12Box* myBoxArray = new Box[4];delete [] myBoxArray; // Delete array 模板123456789101112131415#include &lt;iostream&gt;using namespace std;int main ()&#123; double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl; delete pvalue; // 释放内存 return 0;&#125; 命名空间12345namespace namespace_name &#123; func(); // 代码声明&#125;name::func(); // code 可以是变量或函数 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;template&lt;typename T1,typename T2&gt;class Test&#123;public: Test(T1 i,T2 j):a(i),b(j)&#123;cout&lt;&lt;&quot;模板类&quot;&lt;&lt;endl;&#125;private: T1 a; T2 b;&#125;;template&lt;&gt; //全特化，由于是全特化，参数都指定了，参数列表故为空。class Test&lt;int ,char&gt;&#123;public: Test(int i,char j):a(i),b(j)&#123;cout&lt;&lt;&quot;全特化&quot;&lt;&lt;endl;&#125;private: int a; int b;&#125;;template&lt;typename T2&gt; //由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。class Test&lt;char,T2&gt;&#123;public: Test(char i,T2 j):a(j),b(j)&#123;cout&lt;&lt;&quot;个数偏特化&quot;&lt;&lt;endl;&#125;private: char a; T2 b;&#125;;template&lt;typename T1,typename T2&gt; //这是范围上的偏特化class Test&lt;T1*,T2*&gt;&#123;public: Test(T1* i,T2* j):a(i),b(j)&#123;cout&lt;&lt;&quot;指针偏特化&quot;&lt;&lt;endl;&#125;private: T1* a; T2* b;&#125;;template&lt;typename T1,typename T2&gt;//同理这也是范围上的偏特化class Test&lt;T1 const,T2 const&gt;&#123;public: Test(T1 i,T2 j):a(i),b(j)&#123;cout&lt;&lt;&quot;const偏特化&quot;&lt;&lt;endl;&#125;private: T1 a; T2 b;&#125;;int main()&#123; int a; Test&lt;double,double&gt; t1(0.1,0.2); Test&lt;int,char&gt; t2(1,&#x27;A&#x27;); Test&lt;char,bool&gt; t3(&#x27;A&#x27;,true); Test&lt;int*,int*&gt; t4(&amp;a,&amp;a); Test&lt;const int,const int&gt; t5(1,2); return 0;&#125; 预处理器12#define PI 3.14159#define MIN(a,b) (((a)&lt;(b)) ? a : b) 条件编译1234#define DEBUG#ifdef DEBUG cerr &lt;&lt;&quot;Trace: Coming out of main function&quot; &lt;&lt; endl;#endif # 和 ## 运算符1234567# 将x转换为字符串#define MKSTR( x ) #xcout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;## 将x,y连接#define CONCAT( x, y ) x ## yint xy = 100;cout &lt;&lt; concat(x, y); 预定义宏1234cout &lt;&lt; &quot;Value of __LINE__ : &quot; &lt;&lt; __LINE__ &lt;&lt; endl; //当前行号cout &lt;&lt; &quot;Value of __FILE__ : &quot; &lt;&lt; __FILE__ &lt;&lt; endl; //当前文件名cout &lt;&lt; &quot;Value of __DATE__ : &quot; &lt;&lt; __DATE__ &lt;&lt; endl; //当前年月日cout &lt;&lt; &quot;Value of __TIME__ : &quot; &lt;&lt; __TIME__ &lt;&lt; endl; //当前时分秒 信号处理信号类型1SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;csignal&gt;using namespace std;void signalHandler( int signum )&#123; cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\\n&quot;; // 清理并关闭 // 终止程序 exit(signum); &#125;int main ()&#123; int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i)&#123; cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl; if( i == 3 )&#123; // 信号抬起 raise( SIGINT); &#125; sleep(1); &#125; return 0;&#125; 多线程12345#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) // 参数:线程指针,线程属性,线程函数,函数参数// 线程显性退出pthread_exit (NULL); 向线程传递参数123456struct thread_data&#123; int thread_id; char *message;&#125;;struct thread_data td[NUM_THREADS];rc = pthread_create(threadid, NULL,PrintHello, (void *)&amp;td[i]); 连接和分离线程12pthread_join (threadid, status) pthread_detach (threadid) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM_THREADS 5void *wait(void *t)&#123; int i; long tid; tid = (long)t; sleep(1); cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot; ...exiting &quot; &lt;&lt; endl; pthread_exit(NULL);&#125;int main ()&#123; int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)i ); if (rc)&#123; cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; // 删除属性，并等待其他线程 pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ )&#123; rc = pthread_join(threads[i], &amp;status); if (rc)&#123; cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ; cout &lt;&lt; &quot; exiting with status :&quot; &lt;&lt; status &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl; pthread_exit(NULL);&#125; vector与iterator1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123; // 创建一个向量存储 int vector&lt;int&gt; vec; int i; // 显示 vec 的原始大小 cout &lt;&lt; &quot;vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl; // 推入 5 个值到向量中 for(i = 0; i &lt; 5; i++)&#123; vec.push_back(i); &#125; // 显示 vec 扩展后的大小 cout &lt;&lt; &quot;extended vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl; // 访问向量中的 5 个值 for(i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; &quot;value of vec [&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; vec[i] &lt;&lt; endl; &#125; // 使用迭代器 iterator 访问值 vector&lt;int&gt;::iterator v = vec.begin(); while( v != vec.end()) &#123; cout &lt;&lt; &quot;value of v = &quot; &lt;&lt; *v &lt;&lt; endl; v++; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"Socket编程","slug":"socket","date":"2021-10-20T04:30:12.000Z","updated":"2021-10-26T06:14:17.420Z","comments":true,"path":"2021/10/20/socket/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/20/socket/","excerpt":"","text":"参考网址：peitianyu/TcpIpBook: TCP/IP网络编程 (github.com) TCP/IP网络通信之Socket编程入门_哔哩哔哩_bilibili 套接字操作12345678910111213141516#include&lt;sys/socket.h&gt;# 创建套接字int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1# 分配地址信息int bind(int sockfd, struct sockaddr* pSockAddr, socklen_t addrLen);//成功时返回0， 失败时返回-1# 设置监听int listen(int sockfd, int backlog);//成功时返回0， 失败时返回-1# 受理连接int accept(int sockfd, struct sockaddr* pSockAddr, socklen_t* pAddrLen);//成功时返回文件描述符，失败时返回-1# 请求连接int connect(in sockfd, struct sockaddr* pSockAddr, socklen_t sockLen);//成功时返回0， 失败时返回-1 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 打开文件#include&lt;fcntl.h&gt;int open(const char* path, int flag);//成功时返回文件描述符， 失败时返回-1# 关闭文件#include&lt;unistd.h&gt;int close(int fd);//成功时返回0， 失败时返回-1# 写入文件#include&lt;unistd.h&gt;ssize_t write(int sockfd, const void* buf, size_t nBytes);//成功时返回写入的字节数，失败时返回-1# 读取文件ssize_t read(int sockfd, void* buf, size_t nBytes);//成功时返回读到的字节数（若遇到文件结尾则返回0），失败时返回-1#include&lt;sys/uio.h&gt;# 写文件ssize_t writev(int sockfd, const struct iovec* iov, int iovcnt);//成功时返回发送的字节数，失败时返回-1# 读文件ssize_t readv(int sockfd, const struct iovec* iov, int iovcnt);//成功时返回发送的字节数，失败时返回-1// TCP// 发送文件ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);//成功时返回发送的字节数，失败时返回-1// 接收文件ssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1// UDP接收发送ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen);//成功时返回发送的字节数，失败时返回-1,参数flags 一般设0ssize_t recvfrom(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen);//成功时返回接收的字节数，失败时返回-1,参数flags 一般设0struct iovec&#123; void* iov_base; //缓冲地址 size_t iov_len; //缓冲大小&#125;# 断开连接int shutdown(int sock, int howto);//成功时返回0，失败时返回-1 套接字的可选项和IO缓冲大小12345#include&lt;sys/socket.h&gt;int getsockopt(int sock, int level, int optname,void* optval,socklen_t* optlen);//成功时返回0，失败时返回-1int setsockopt(int sock, int level, int optname, void* optval,socklen_t optlen);//成功时返回0，失败时返回-1 12345678int sock = socket(PF_INET,SOCK_STREAM,0);int optval;socklen_t optlen;int state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,(void*)&amp;optval, &amp;optlen);optval = 1024*3;optlen = sizeof(optval);state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,(void*)&amp;optval,optlen); IO复用 FD_ZERO(fd_set* fdset): 将fdset变量的所有位初始化位0 FD_SET(int fd, fd_set* fdset): 向fdset变量中注册文件描述符fd FD_CLR(int fd, fd_set* fdset): 清除fdset变量中的文件描述符fd FD_ISSET(int fd, fd_set* fdset): fdset变量中是否存在fd文件描述符 123456789101112131415# 设置监视范围及超时#include&lt;sys/select.h&gt;#include&lt;sys/time.h&gt;int select(int maxfd, fd_set* readset, fd_set* writeset,fd_set* exceptset, const struct timeval* timeout );//失败时返回-1，超时返回0，成功时返回发生事件的文件描述符数量struct timeval&#123; long tv_sec; long tv_usec;&#125; maxfd: 监视的文件描述符数量（最大的文件描述符+1） readset: 将关注“是否存在待读取数据”的文件描述符存放在readset变量中 writeset: 将关注”是否可写“的文件描述符存放在writeset变量中 exceptset: 将关注”是否有异常“的文件描述符放在exceptset变量中 -timeout: 为了防止调用select函数后陷入无限阻塞状态，可以传递超时信息","categories":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"}]},{"title":"cmake配置模板","slug":"cmake模板","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-03T08:27:39.384Z","comments":true,"path":"2021/10/19/cmake模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"Cmake教程参考网址:CMake 入门实战 | HaHack Cmake文件结构1234567891011root@LAPTOP-49LFJ4NT:/root/cmake# tree.├── CMakeLists.txt├── bin├── build├── include│ └── func.h└── src ├── func.cpp ├── main.cpp └── shell.sh shell.sh12# 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译cd .. &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j &amp;&amp; ./main CmakeLists.txt123456789101112131415161718192021222324252627282930313233# 指定cmake版本cmake_minimum_required(VERSION 3.0)# 工程名project(canalyst)#cmake的c++设置# 告知當前使用的是交叉編譯方式，必須配置SET(CMAKE_SYSTEM_NAME Linux)SET(CMAKE_C_COMPILER &quot;gcc&quot;)SET(CMAKE_CXX_COMPILER &quot;g++&quot;)# 执行路径设置SET(EXECUTABLE_OUTPUT_PATH ../bin)# 设置编译选项set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -Wall -pthread -std=c++11 -fPIC &quot;)# 添加.h文件include_directories(src)# 添加.cpp文件aux_source_directory(src SRC_LIST)# 链接库link_directories(lib)set(LIB_LIST libcontrolcan.so)# 输出调试信息# message(&quot;src :$&#123;SRC_LIST&#125; &quot;)# 执行文件add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC_LIST&#125; )target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIB_LIST&#125;) 运行12# 在src文件夹下运行shell.sh./shell","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"git使用","slug":"git","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-13T13:28:18.968Z","comments":true,"path":"2021/10/19/git/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/git/","excerpt":"","text":"推送新创建git1234567891011121314151617# 进入本地文件夹cd tool# 添加需要上传文件echo &quot;# tool&quot; &gt;&gt; README.md# 初始化gitgit init# 添加需要上传文件# git add -A 上传全部git add README.md# 注释git commit -m &quot;first commit&quot;# 添加分支git branch -M main# 添加默认远程库git remote add origin git@github.com:peitianyu/tool.git# 推送git push -u origin main 推送已存在的库123git remote add origin git@github.com:peitianyu/tool.gitgit branch -M maingit push -u origin main git删除远程库文件123456git --help # 帮助命令git pull origin master # 将远程仓库里面的项目拉下来dir # 查看有哪些文件夹git rm -r --cached yun_app # 删除yun_app文件夹git commit -m ‘删除了yun_app’ # 提交,添加操作说明git push -u origin master # 将本次更改更新到github项目上去 git删除远程分支123456789# 快速创建分支并切换分支 (dev 分支)git checkout -b dev# 删除分支 ： 如分支名为devgit branch -d dev 会在删除前检查merge状态（其与上游分支或者与head）。git branch -D dev 它会直接删除,不检查# 删除远程分支git push origin --delete dev# 清理本地不存在的远程分支，如别人删除了dev,但是你本地查看还有，就可以执行该条命令git remote prune origin git 分支1234567891011* 查看分支：git branch* 创建分支：git branch &lt;name&gt;* 切换分支：git checkout &lt;name&gt;* 创建+切换分支：git checkout -b &lt;name&gt;* 合并某分支到当前分支：git merge &lt;name&gt;* 删除分支：git branch -d &lt;name&gt; git clone文件代理12345678git clonegit clone https://ghproxy.com/https://github.com/stilleshan/ServerStatuswget &amp; curlwget https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zipwget https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfilecurl -O https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zipcurl -O https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"hugo配置","slug":"hugo","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:08:31.508Z","comments":true,"path":"2021/10/19/hugo/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/hugo/","excerpt":"","text":"git安装与配置12345678# git安装sudo apt updatesudo apt install git #git配置git config --global user.name &quot;zoey&quot;git config --global user.email &quot;zoey686@163.com&quot;#查看设置用户名与密码git config --list hugo安装12345678# 安装sudo apt install hugo# 手动安装wget https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.debsudo dpkg -i hugo_0.54.0_Linux-64bit.deb# 查看hugo --helphugo version 建立博客新建git文件夹用以git模板等，并在文件夹下新建myblog，用来存放博客页面 12345# 新建git文件夹并git初始化mkdir gitFile git init# 新建myblog文件夹用来存放博客页面hugo new site myblog myblog下面就会有以下几个文件夹自动生成 文件夹名 作用 archetypes 文章开头形式 content 内容 data 自定义模板 layouts 网页模板文件 static 存储图片一些其他的资源 themes 主题 config.toml 配置文件 设置主题在（https://themes.gohugo.io/）中挑选主题,这里选择的是diary主题（[Diary | Hugo Themes (gohugo.io)](https://themes.gohugo.io/themes/hugo-theme-diary/)） 例子：（浅蓝色 (gitee.io)） 1234# 下载diary主题到themes文件夹下并重命名为diarygit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary# 配置config.toml文件nano config.toml 12345678910111213141516171819202122232425262728293031323334353637baseURL = &quot;https://peitianyu.github.io/pty_blog.github.io&quot;DefaultContentLanguage = &quot;zh&quot; # Theme&#x27;s display language, supports: en, fr, zh, zh-hantlanguageCode = &quot;zh-hant&quot;title = &quot;武装带你&quot;copyright = &quot;This is a customized copyright.&quot;theme = &quot;diary&quot;[markup] [markup.highlight] codeFences = true guessSyntax = false hl_Lines = &quot;&quot; lineNoStart = 1 lineNos = false lineNumbersInTable = true noClasses = true style = &quot;perldoc&quot; tabWidth = 4enableOpenGraph = trueenableTwitterCards = truetitle = &quot;My Blog&quot; description = &quot;My HomePage Description&quot; [taxonomies] ros = &quot;Ros&quot; blog = &quot;Blog&quot;[[menu.main]]url = &quot;/blog&quot;name = &quot;Blog&quot;weight = 1[[menu.main]]url = &quot;/ros&quot;name = &quot;Ros&quot;weight = 2 创建文章默认主目录文章在content/post下 1234567# 创建文章hugo new post/my_first_blog.md#创建文章在需要目录(Archive)下hugo new posts/my_first_blog.mdcd content/postnano my_first_blog.md# 注意将draft参数改为false，否则跳过草稿文件，无法预览 123456---title: &quot;my_first_blog&quot;date: 2021-10-12T10:49:31+08:00draft : false---文本内容 本地调试 1hugo server --theme=blackburn --buildDrafts 其中 –theme 选项可以指定主题，–buildDrafts 包括标记为草稿然后在浏览器里打开： http://localhost:1313 即可访问到你的博客 部署到github如果你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：pty_blog.github.io （pty_blog替换为你的github用户名的小写） 进入仓库，点击Settings进入，找到GitHub Pages并点击Check it out here!，配置Source并save，会发现绿色框中显现 Your site is published at https://peitianyu.github.io/pty_blog.github.io/ 此处https://peitianyu.github.io/pty_blog.github.io/就是我们的网址，也是config.toml文件中设置的网址，设置hugo登陆网址 1hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot; 注意：这里的 –baseUrl 一定是https://（Hugo中文文档里为http://），不然你部署后的博客会没有样式！ 可看到根目录下多出 /public文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。然后继续在你的站点根目录执行git 命令，添加远程仓库。 123456cd publicgit initgit remote add origin git@github.com:peitianyu/pty_blog.github.io.gitgit add -Agit commit -m &quot;first commit&quot;git push -u origin master 然后浏览器里访问：https://peitianyu.github.io/pty_blog.github.io/即可看到刚刚搭建的博客。 发布博客并更新： 123456789# 新建博客markdown文件，并编辑博客内容(文件名为 **.md )hugo new post/newBlog.md# 生成静态页面hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;# 发布cd publicgit add .git commit -m &quot;new blog added&quot;git push origin master","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"jetson_nano 踩坑","slug":"jetson_nano","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:03.171Z","comments":true,"path":"2021/10/19/jetson_nano/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/jetson_nano/","excerpt":"","text":"参考网址:玩转智能硬件之Jetson Nano(一)安装篇 - 知乎 (zhihu.com) Jetson Nano-配置环境_Ay_yzx的博客-CSDN博客 预先下载:balenaEtcher balenaEtcher - Flash OS images to SD cards &amp; USB drives 系统下载 官方默认系统: https://developer.download.nvidia.cn/embedded/L4T/r32_Release_v6.1/Jeston_Nano/jetson-nano-jp46-sd-card-image.zip?xtLGc386JIwQlfgPPGITNMMx3dC47xG6lIybgH0z9HUPzZaP7ZO2h3U3UFhcpzo7QJsYr-1cCnspcgl929SsucJH043bqSzwC_jUQGxqQuJvmNyIMcrmp8IJopYJUgh41KDf32qZNNeEUEquBj5vkUSAUH_46_UJ1VEv5d1IbYE_36EcSGByIJ1Anw Ubuntu18.04: https://pan.baidu.com/share/init?surl=QXd34V5FfLcFk2XDgphoig 密码 : tun3 sd卡格式化工具 SD Memory Card Formatter for Windows Download | SD Association (sdcard.org) 安装步骤:1231.格式化sd卡2.使用balenaEtcher烧录下载好的系统3.插上卡后做初始化设置 jetson三种供电方式:参考网址:Jetson nano 的三种供电方式_Dunkle.T的博客-CSDN博客_jetson nano供电 分别为: USB供电(默认5v2a 仅低功率),使用时拔去条线帽 使用 DC 供电(默认5v 4A),使用时插上跳线帽 使用引脚供电(5v3a 无所谓跳线帽) 查看cuda配置12sudo pip3 install jetson-statssudo jtop 关于ros安装参考网址:ROS_安装 (peitianyu.github.io) 其他部分按ros安装教程来即可比较实用的方案是先按照我的步骤安装ros,之后再通过fishros一行代码解决rosdep问题 远程连接nanossh.exe usrname@192.168.xxx.xxx jetson nano初始化配置网络配置静态ip设置:Ubuntu 18.04配置静态IP地址) root免密登录参考网址:ubuntu设置root免密登陆 vscode连接jetson nano参考网址:vscode设置ssh进行远程编辑_Quan的博客-CSDN博客","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"make配置模板","slug":"make模板","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:25.577Z","comments":true,"path":"2021/10/19/make模板/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"make文件目录123456root@LAPTOP-49LFJ4NT:/root/make# tree.├── Makefile├── conf.sh├── main.cpp└── shell.sh 这里使用了shell脚本来实现对于make的编译，由于使用的是wsl在windows下操作导致编码格式含有\\r\\n，以此有两个shell脚本。 conf.sh12345678# 实现对于make的编译与运行#!/bin/bashif [[ $1 == clean ]]; then make cleanelif [[ $1 == all ]]; then make clean &amp;&amp; make -j8 &amp;&amp; ./mainelse make -j8 &amp;&amp; ./main shell.sh123# 实现将conf.sh的dos编码转化为unix编码，并执行#!/bin/bashdos2unix conf.sh &amp;&amp; ./conf.sh Makefile123456789101112131415161718192021222324252627282930313233343536373839# 自动捕捉符合c/c++编译#指定编译工具CC = gccCPP = g++LINK = g++LIBS = -lsqlite3 -lpthread#编译.so 必须添加 -fPIC 和 -shared 选项CCFLAGS = -c -g -fPICCPPFLAGS = -c -g -fPIC#期望得到的执行文件或动态库.so#TARGET=libxx.soTARGET=mainINCLUDES = -I. #-I../../CPPFILES = $(wildcard *.cpp )#遍历得到当前目录及上层目录中的所有.cpp文件CFILES = $(wildcard *.c )#遍历得到当前目录及上层目录中的所有.c文件OBJFILE = $(CFILES:.c=.o) $(CPPFILES:.cpp=.o)all:$(TARGET)$(TARGET):$(OBJFILE)# 编译得到 .so 文件用下面的代码# $(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@# 编译得到可执行文件用下面的代码 $(LINK) $^ $(LIBS) -Wall -O2 -o $@%.o:%.c $(CC) -o $@ $(CCFLAGS) $&lt; $(INCLUDES)%.o:%.cpp $(CPP) -o $@ $(CPPFLAGS) $&lt; $(INCLUDES)clean: rm -rf $(TARGET) rm -rf $(OBJFILE) main.c12345678#include &lt;stdio.h&gt; int main()&#123; printf(&quot;Hello, World! \\n&quot;); return 0;&#125; 运行1./shell","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"mpg处理","slug":"mpg处理","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:53:53.801Z","comments":true,"path":"2021/10/19/mpg处理/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/mpg%E5%A4%84%E7%90%86/","excerpt":"","text":"参考网址:(47条消息) ROS开发实践（十三）——ROS中SLAM地图（.pgm格式）编辑软件的安装与使用_Ehang_Maker的博客-CSDN博客 安装:参考网址:Gimp中文网 (baisheng999.com) windows安装流程:1注意选择安装路径,其他下一步即可 流程:12341.选择使用笔刷工具2.设置笔刷大小,硬度为100,力度为100,线型为直线3.按住Ctrl选择颜色4.释放后刷刷刷","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"nano操作","slug":"nano操作","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:46.628Z","comments":true,"path":"2021/10/19/nano操作/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/nano%E6%93%8D%E4%BD%9C/","excerpt":"","text":"参考网址 nano使用技巧大全_Xav Pun的博客-CSDN博客_nano使用教程 便捷快捷键注意前缀键Ctrl+b按完后松开，再按下其他键。 快捷键 含义 Alt+x 切换帮助栏 ALT-# 显示行号 CTRL-K 剪切到行末 ALT+6 复制 SHIFT+方向 选择 CTRL+u 粘贴 Alt + u 撤销 Alt + e 重复 ALT+&lt; 切换到上一个文件 ALT+&gt; / alt + 切换到下一个文件 CTRL+X 关闭 CTRL+R CTRL+T 文件浏览器 CTRL+C 退出文件选择界面 CTRL+S 保存","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"ros_cmake配置模板","slug":"ros_cmake","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:56.706Z","comments":true,"path":"2021/10/19/ros_cmake/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros_cmake/","excerpt":"","text":"简易CmakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243cmake_minimum_required(VERSION 2.8.3)# 工程名project(hmi)# 支持编译add_compile_options(-std=c++11)# 查找包find_package(catkin REQUIRED COMPONENTS roscpp sensor_msgs pcl_ros perception_msgs)# catkin库catkin_package( INCLUDE_DIRS include CATKIN_DEPENDS roscpp sensor_msgs pcl_ros)# 头文件库include_directories( include $&#123;catkin_INCLUDE_DIRS&#125;)# 链接库文件夹link_directories($&#123;PCL_LIBRARY_DIRS&#125;)# 生成执行文件add_executable($&#123;PROJECT_NAME&#125;_node src/hmi_node.cpp src/hmi_core.cpp)# 依赖包add_dependencies($&#123;PROJECT_NAME&#125;_node perception_msgs_generate_messages_cpp)# 链接库target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125; $&#123;PCL_LIBRARIES&#125;) 详细CmakeLists.txt1234567891011121314151617181920212223242526272829cmake_minimum_required() #CMake的版本号project() #项目名称find_package() #找到编译需要的其他CMake/Catkin package catkin_python_setup() #catkin新加宏，打开catkin的Python Module的支持add_message_files() #catkin新加宏，添加自定义Message文件 add_service_files() #catkin新加宏，添加自定义Service文件 add_action_files() #catkin新加宏，添加自定义Action文件 generate_message() #catkin新加宏，生成不同语言版本的msg/srv/action接口 catkin_package() #catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 add_library() #生成库 add_executable() #生成可执行二进制文件add_dependencies() #定义目标文件依赖于其他目标文件，确保其他目标已被构建 target_link_libraries() #链接catkin_add_gtest() #catkin新加宏，生成测试install() #安装至本机 对照实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242cmake_minimum_required(VERSION 3.0.2) # catkin至少需要3.0.2版本以上的Cmake#通过project()这个函数指定包的名字，在CMake中指定后，你可在其他地方通过使用变量$&#123;PROJECT_NAME&#125;来引用它project(ultrasonic_data) ## Compile as C++11, supported in ROS Kinetic and newer# add_compile_options(-std=c++11)## 查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package(） ##find_package(catkin REQUIRED COMPONENTS xyz) 被用于找其他依赖的功能包##这里指明构建这个package需要依赖的package，我们使用catkin_make的编译方式，至少需要catkin这个包。find_package(catkin REQUIRED COMPONENTS message_generation roscpp sensor_msgs std_msgs visualization_msgs can_msgs)## 系统依赖关系是通过CMake的约定找到的# find_package(Boost REQUIRED COMPONENTS system)##启动Python模块支持：catkin_python_package()##如果功能包中提供了一些Python模块.这个宏定义可以确保包中声明的模块和全局脚本被安装## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html# catkin_python_setup()############################## 声明ROS消息、服务和动作 ################################ 消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()##当我们需要使用.msg.srv.action形式的文件时，我们需要特殊的预处理器把他们转化为系统可以识别特定编程语言（.h.cpp）。##注意：这些宏必须在catkin_package() 宏前面##请执行以下步骤：## * 在package.xml中:## *1.添加&quot;message_generation&quot;在build_depend标记中## *2.添加&quot;message_runtime&quot;在exec_depend标记中## * 在CMakeLists.txt中:## *1、在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;message_generation&quot; ## *2、在catkin_package(CATKIN_DEPENDS ...)添加&quot;message_runtime&quot;## 根据需要取消下面“add_######_files”部分的注释## * 取消下面的generate_messages(DEPENDENCIES...注释## * add every package to generate_messages(DEPENDENCIES ...)## 在&#x27;msg&#x27; 文件夹生成消息 add_message_files( FILES Ultrasonic.msg# Message2.msg )##在 &#x27;srv&#x27; 文件夹生成服务# add_service_files(# FILES# Service1.srv# Service2.srv# )## 在 &#x27;action&#x27; 文件夹生成动作# add_action_files(# FILES# Action1.action# Action2.action# )## 在此处列出的任何添加的消息和服务生成的依赖项##调用消息/服务/操作生成：generate_messages() generate_messages( DEPENDENCIES# sensor_msgs std_msgs# visualization_msgs )##################################################声明ROS动态配置参数 #################################################### 声明和生成动态重新配置参数包:遵循以下步骤## * 在package.xml中:## *添加&quot;dynamic_reconfigure&quot;在build_depend和exec_depend标记中## * 在CMakeLists.txt中:## *在find_package(catkin REQUIRED COMPONENTS ...)添加&quot;dynamic_reconfigure&quot; ## * 取消下面 &quot;generate_dynamic_reconfigure_options&quot; 的注释## 列出要处理的每个.cfg文件## Generate dynamic reconfigure parameters in the &#x27;cfg&#x27; folder# generate_dynamic_reconfigure_options(# cfg/DynReconf1.cfg# cfg/DynReconf2.cfg# )##################################### catkin 特定的配置 ####################################### catkin_package为包生成cmake配置文件 这是一个catkin提供的cmake宏，当我们要给构建系统指定catkin的特定的信息时就需要了## 或者反过来利用他产生pkg-config和CMake文件。##指定包编译信息导出：catkin_package()## 该函数必须在使用 add_library()或add_executable()声明任何targets之前调用。## INCLUDE_DIRS: 如果包包含头文件，请取消对INCLUDE_DIRS的注释## LIBRARIES: 此项目中创建的依赖项目需要的库LIBRARIES## CATKIN_DEPENDS: catkin_packages依赖的项目## DEPENDS: 依赖项目需要的系统依赖项catkin_package( INCLUDE_DIRS include# LIBRARIES ultrasonic_data CATKIN_DEPENDS message_runtime# DEPENDS system_lib)############# Build ############### include_directories用来设置头文件的相对路径##include_directories的参数是通过find_package产生的*_INCLUDE_DIRS变量和其他所有额外的头文件路径##这里&quot;include&quot;表示你的pacakge里面的include这个路径也包含在里面include_directories( include $&#123;catkin_INCLUDE_DIRS&#125;)############################################################################添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()############################################################################## add_library()用来指定编译产生的库。默认的catkin编译产生共享库：# add_library($&#123;PROJECT_NAME&#125;# src/$&#123;PROJECT_NAME&#125;/ultrasonic_data.cpp# )## add_dependencies用于设置依赖##如果你有一个包编译.msg .srv，并且可执行文件要使用他们，那么你就需要创建一个显式的依赖项，## 我们定义的语言无关的消息类型，消息类型会在编译过程中产生相应的语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要## 使用add_dependencies($&#123;PROJECT_NAME&#125;_generate_messages_cpp)## add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)## add_executable用于设置需要编译的代码和生成的可执行文件##第一个参数为期望生成的可执行文件名称；后面的参数为参与编译的源文件（cpp),如果需要多个代码文件，用空格区分开## 推荐的前缀可以确保跨包的目标名称不会冲突# add_executable($&#123;PROJECT_NAME&#125;_node src/ultrasonic_data_node.cpp)## 重命名C++无前缀可执行文件## 利用set_target_properties()函数将这个target进行重命名，在catkin中target的名字必须是唯一的# set_target_properties($&#123;PROJECT_NAME&#125;_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)## 添加可执行文件的cmake目标依赖项## same as for the library above与上面的库相同# add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)##target_link_libraries用于设置链接库# target_link_libraries($&#123;PROJECT_NAME&#125;_node# $&#123;catkin_LIBRARIES&#125;# )add_executable(ultrasonic_activate_node src/ultrasonic_activate_node.cpp)add_dependencies(ultrasonic_activate_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries(ultrasonic_activate_node $&#123;catkin_LIBRARIES&#125;)add_executable(ultrasonic_node src/ultrasonic_node.cpp src/ultrasonic_filter.cpp)add_dependencies(ultrasonic_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries(ultrasonic_node $&#123;catkin_LIBRARIES&#125;)################安装至本机 ################ 所有安装目标都应该使用catkin目标变量# See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html##安装Python可执行脚本# catkin_install_python(PROGRAMS# scripts/my_python_script# DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## 安装的可执行文件## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html# install(TARGETS $&#123;PROJECT_NAME&#125;_node# RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## 要安装的库##编译完成后，目标被放入catkin工作空间下的devel目录。一般希望将目标安装到系统上，以使其他用户使用，##或者安装到本地目录来测试系统级别的安装。也就是说，如果希望能够对代码进行make install，就需要明确目标结束的位置。##上述过程可以使用CMake的 install()函数实现。##该函数的参数有##TARGETS：要安装的目标##ARCHIVE DESTINATION：静态库和动态链接库DLL(Windows).lib存根##LIBRARY DESTINATION：非DLL共享库和模块##RUNTIME DESTINATION：可执行目标和DLL(Windows)模式共享库## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html# install(TARGETS $&#123;PROJECT_NAME&#125;# ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;# LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;# RUNTIME DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;# )## 安装头文件##头文件必须安装到include目录下，这通常通过安装整个文件夹的文件来完成（可以根据文件名模式进行过滤，并排除SVN子文件夹）##可以通过以下安装规则实现：# install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/# DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;# FILES_MATCHING PATTERN &quot;*.h&quot;# PATTERN &quot;.svn&quot; EXCLUDE# )## 安装roslaunch文件或其他源##其他像launchfiles的资源可以安装到 $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;# install(FILES# # myfile1# # myfile2# DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;# )############################### 测试编译：catkin_add_gtest()################################# 基于gtest测试目标和链接库# catkin_add_gtest($&#123;PROJECT_NAME&#125;-test test/test_ultrasonic_data.cpp)# if(TARGET $&#123;PROJECT_NAME&#125;-test)# target_link_libraries($&#123;PROJECT_NAME&#125;-test $&#123;PROJECT_NAME&#125;)# endif()## 添加要由python osetests运行的文件夹# catkin_add_nosetests(test) 具体可参考网址ROS中的CMake List详解_yangtao420902的博客-CSDN博客 ROS下CmakeLists.txt模板_CipherPolzz的博客-CSDN博客 ROS新建程序包CmakeLists和package详解_JayLee719的博客-CSDN博客 (46条消息) ROS中CMakeLists.txt文件 使用 讲解与总结_月照银海似蛟龙的博客-CSDN博客","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ros安装","slug":"ros安装","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-13T03:03:53.549Z","comments":true,"path":"2021/10/19/ros安装/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装环境12Ubuntu18.04ros-melodic-desktop-full 安装1234567891011vim /etc/apt/sources.list.d/ros-latest.listdeb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic mainsudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt updatesudo apt-get install ros-melodic-desktop-full# 初始化sudo rosdep initrosdep updatesudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essentialsudo echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 一行代码安装ros（包含问题处理）1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros 参考视频： 玩着游戏听着歌，就把ROS装好了！一行代码搞定系列！ (qq.com) 安装问题rosdep init不成功 1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros 卸载12345sudo apt-get autoremove --purge ros-melodic# 先卸载包sudo apt-get purge ros-*# 然后删除依赖，配置sudo apt-get autoremove 测试12345mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_makesource devel/setup.bashroscore 打开新窗口执行 1rosrun turtlesim turtlesim_node 出现小乌龟则安装完成。","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ros错误集锦","slug":"ros错误集锦","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-13T03:24:32.797Z","comments":true,"path":"2021/10/19/ros错误集锦/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ros%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/","excerpt":"","text":"“cv_bridge“解决办法出现问题:123456CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package):Could not find a package configuration file provided by “cv_bridge” withany of the following names:cv_bridgeConfig.cmakecv_bridge-config.cmake 解决办法:CMake Error ：Could not find a package configuration file provided by “cv_bridge“解决办法 WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决1234567891011121314# 卸载gazebo与rossudo apt-get remove gazebo11 gazebo11-*sudo apt-get purge ros-*sudo apt-get install ros-melodic-desktop-full# 卸载gazebo9sudo apt-get remove gazebo9 gazebo9-common gazebo9-plugin-base libgazebo9:amd64 libgazebo9-dev:amd64 ros-melodic-gazebo-* # 查看dpkg -l | grep gazebo# 清楚残余包sudo dpkg --purge gazebo9# 安装gazebo11sudo apt-get install gazebo11 -ysudo apt-get install libgazebo11-devgazebo 通过重新安装的方式绕过 WSL折腾记录之三：WSL+Ubuntu18.03环境下gazebo9视图黑屏问题的解决与升级安装gazebo11 rosdep init不成功命令行输入 1wget http://fishros.com/install -O fishros &amp;&amp; sudo bash fishros Could not find a package configuration file provided by “xxxx”1sudo apt-get install ros-melodic-xxxx","categories":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"}],"tags":[{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"}]},{"title":"ssh","slug":"ssh","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:55:33.815Z","comments":true,"path":"2021/10/19/ssh/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ssh/","excerpt":"","text":"参考网址 SSH简介及两种远程登录的方法_德prince-CSDN博客_ssh 安装:12345678sudo apt-get install openssh-client sudo apt-get install openssh-server # 查看启动情况ps -e | grep ssh# 启动 停止 重启sudo /etc/init.d/ssh start sudo /etc/init.d/ssh stop #server停止ssh服务 sudo /etc/init.d/ssh restart #server重启ssh服务 登录口令登录12345678# 基础登录ssh ldz@192.168.0.1# 调用图形界面ssh -X ldz@192.168.0.1# 如果客户机的用户名和服务器的用户名相同，登录时可以省略用户名。ssh 192.168.0.1# -p修改端口,默认22端口ssh -p 1234 ldz@192.168.0.1 第一次连时需要确认连接,选yes,即可成功 遇到问题: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOT bug解决: ssh-keygen -R 192.168.0.1 退出Ctrl+d或者exit 公钥登录在本机生成密钥对1ssh-keygen -t rsa #-t表示类型选项，这里采用rsa加密算法 将公钥复制到远程主机1ssh-copy-id ldz@192.168.0.1","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"几款terminal","slug":"terminal","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:55:58.329Z","comments":true,"path":"2021/10/19/terminal/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/terminal/","excerpt":"","text":"终端Powershell,Windows terminal,wsl-terminal,fluent terminal,xshell,Mobaxterm,putty Powershell最基础的远程终端,只需要通过ssh指令连接远程终端即可.如,ssh.exe pty@192.168.30.100 Windows terminal同样可以用指令打开,同时也可以配置,打开wsl,ssh都比较方便,点击即用.但有些丑.当然也可以配置网上教程挺多,再次不做过多介绍. 安装:1234# powershell输入winget install --id=Microsoft.WindowsTerminal -e# 通过Chocolateychoco upgrade microsoft-windows-terminal 右键打开windows terimnal(未测试)保存为install.bat文件打开 1234567891011121314151617Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Windows Terminal]; 右键菜单中显示的名称@=&quot;Windows Terminal&quot;; 右键菜单中显示的图标&quot;Icon&quot;=&quot;C:\\\\Toolkits\\\\Icons\\\\App\\\\WindowsTerminal.ico&quot;; 仅支持在按住Shift+右键的时候才显示&quot;Extended&quot;=&quot;&quot;; &quot;NoWorkingDirectory&quot;=&quot;&quot;; 在菜单中显示或隐藏&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Windows Terminal\\Command]@=&quot;C:\\\\Users\\\\xyz\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe -d \\&quot;%V\\&quot;&quot; fluent terminal好看但没有windows terminal那么方便,不过可以设置快捷键,也还行. 安装1choco install fluent-terminal 12# 下载zip文件解压安装https://github.com/felixse/FluentTerminal/releases 下载完毕后解压，选择 Install.ps1 文件，右键使用 powershell 运行。 右键打开保存为install.bat文件打开 12345reg add &quot;HKCU\\Software\\Classes\\Directory\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%1\\&quot;&quot; /freg add &quot;HKCU\\Software\\Classes\\Directory\\Background\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%V\\&quot;&quot; /freg add &quot;HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\Open Fluent Terminal here\\command&quot; /d &quot;\\&quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\flute.exe\\&quot; new \\&quot;%%V\\&quot;&quot; /f 右键关闭保存为Uninstall.bat文件打开 1234reg delete &quot;HKCU\\Software\\Classes\\Directory\\shell\\Open Fluent Terminal here&quot; /freg delete &quot;HKCU\\Software\\Classes\\Directory\\Background\\shell\\Open Fluent Terminal here&quot; /freg delete &quot;HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\Open Fluent Terminal here&quot; /f wsl-terminal加u个人使用而言,如果多个wsl,则没那么舒爽.当然也可以像powershell那样wsl -d Ubuntu这样切换版本 参考网址:使用 wsl-terminal 更好地体验 Win 10 WSL 终端环境 写的比较详细就不具体赘述了 putty是一款集合ssh,串口的远程软件,但每次都需要开启后配置参数,对于懒人不友好. 参考网址:putty使用教程(总结) xshell具有putty相似的功能,同时还有stfp文件传输,只需点击即可使用.但对于需要调试gui程序而言,需要购买正式版,嗯…………大佬随意. 参考网址:Xshell使用基础教程_ Mobaxterm集百家之长于一身,因此使用起来没那么方便,但使用后非常舒爽.值得一提的是,远程文件是可以根据终端实时更新的,同时支持拖拽文件,新建文件,文件夹,本地编辑文件,这就很爽了. 参考网址:全能终端神器mobaxterm入坑指南","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"tmux使用","slug":"tmux","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:56:24.420Z","comments":true,"path":"2021/10/19/tmux/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/tmux/","excerpt":"","text":"参考网址 Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com) A Quick and Easy Guide to tmux Tactical tmux: The 10 Most Important Commands Getting started with Tmux 便捷快捷键注意前缀键Ctrl+b按完后松开，再按下其他键。 快捷键 含义 Ctrl+d 退出 Ctrl+b s 列出所有会话 Ctrl+b % 划分左右两个窗格 Ctrl+b “ 划分上下两个窗格 Ctrl+b o 切换到下一个窗格 Ctrl+b x 关闭当前窗格 Ctrl+b c 创建一个新窗口 Ctrl+b n 切换到下一个窗口","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"ubuntu18源","slug":"ubuntu更新源","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:56:51.336Z","comments":true,"path":"2021/10/19/ubuntu更新源/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90/","excerpt":"","text":"更新软件源参考网址：Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源 阿里源 （Ubuntu 18.04）1sudo vim /etc/apt/sources.list 1234567891011121314deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 123sudo apt-get updatesudo apt-get -f installsudo apt-get upgrade 西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）1234567891011121314deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse 清华源12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 网易源12345678910deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse 中科大12345678910111213##中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 树莓派更换国内源123# 备份sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak 1sudo nano /etc/apt/sources.list 12# 添加入,Ctrl+s保存,Ctrl+X退出.deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 12# 修改系统更新源sudo nano /etc/apt/sources.list.d/raspi.list 12# 加入deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 12sudo apt-get updatesud apt upgrade Ubuntu18换回原来源1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic universedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team, and may not be under a free licence. Please satisfy yourself as to## your rights to use the software. Also, please note that software in## multiverse WILL NOT receive any review or updates from the Ubuntu## security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic multiversedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse## N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.## Also, please note that software in backports WILL NOT receive any review## or updates from the Ubuntu security team.deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse## Uncomment the following two lines to add software from Canonical&#x27;s## &#x27;partner&#x27; repository.## This software is not part of Ubuntu, but is offered by Canonical and the## respective vendors as a service to Ubuntu users.# deb http://archive.canonical.com/ubuntu bionic partner# deb-src http://archive.canonical.com/ubuntu bionic partnerdeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricteddeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security universedeb http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse# deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse","categories":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"}]},{"title":"win自启动程序","slug":"win自启动","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:08:05.700Z","comments":true,"path":"2021/10/19/win自启动/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/win%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"","text":"记事本写入脚本12345time /t &gt;&gt;c:\\test\\log1.logecho %username% &gt;&gt;c:\\test\\log1.logecho %computername% &gt;&gt;c:\\test\\log1.log 另存为start.bat，无人见类型为所有类型 配置系统点击运行，输入gpedit.msc,具体操作如下： 重启电脑可以发现，脚本运行了","categories":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/categories/win/"}],"tags":[{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/tags/win/"}]},{"title":"wsl安装与使用","slug":"wsl","date":"2021-10-19T04:30:12.000Z","updated":"2021-12-08T11:31:57.700Z","comments":true,"path":"2021/10/19/wsl/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/wsl/","excerpt":"","text":"wsl安装参考网址： Windows 终端安装 | Microsoft Docs 玩转Linux(1)——安装Windows亲儿子Linux系统之WSL之最全攻略之最佳体验之究极无敌舒服_衡与墨的博客-CSDN博客 管理员身份运行Powershell 12Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux wsl --install -d Ubuntu wsl使用 进入linux系统 命令行输入wsl或者bash，进入linux系统 linux初始配置 添加sudo，这样就不用输密码了 修改 123%sudo ALL=(ALL:ALL) ALL# 改为%sudo ALL=(ALL:ALL) NOPASSWD:ALL 图形界面 参考网址： WSL2运行图像应用或图形界面_Alisebeast的博客-CSDN博客_wsl2 图形界面 在WSL中打开与显示图片的简单方法_neetneves的博客-CSDN博客 12echo &quot;export DISPLAY=localhost:0&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 测试查看 123echo $DISPLAY# 或者xclock 更新软件源 参考网址：Ubuntu 更换国内源_quanwei的博客-CSDN博客_ubuntu换源 wsl命令详解 命令 含义 wsl或bash 打开默认子系统 wsl -d Ubuntu18 打开Ubuntu18子系统 wsl -l -o 可安装的有效分发的列表 wsl –install -d Ubuntu 安装默认Ubuntu wsl –shutdown 关闭子系统 wsl –import Ubuntu-20.04 e:\\ubuntu d:\\ubuntu20.04.tar –version 2 导入已存的操作系统 wsl –export Ubuntu-20.04 e:\\ubuntu20.04.tar 导出操作子系统 wsl -l -v 显示所有子系统 wsl -s Ubuntu-20.04 将分发版设置为默认值 bash -c “ls” windows命令提示符 wsl –unregister Ubuntu-20.04 注销分发版 wslconfig /s Ubuntu-18.04 修改默认子系统 wsl-terminal 参考网址： mskyaxl/wsl-terminal: Terminal emulator for Windows Subsystem for Linux (WSL) (github.com) 最常用的依旧是Windows Terminal参考网址 [Windows Terminal配置_人间世-CSDN博客](https://blog.csdn.net/rjszz1314/article/details/111354738?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows terminal&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-4-111354738.pc_search_ecpm_flag&amp;spm=1018.2226.3001.4187) Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载 Windows Terminal安装方式一： 微软商店安装 购买 Windows Terminal - Microsoft Store zh-CN 方式二： Windows Terminal 新终端下载安装_Archon-CSDN博客_terminal 下载 方式三： https://github.com/microsoft/Terminal 使用Visual Studio打开构建运行","categories":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"}]},{"title":"嵌入式业务逻辑","slug":"嵌入式业务逻辑","date":"2021-10-19T04:30:12.000Z","updated":"2021-11-23T14:40:36.386Z","comments":true,"path":"2021/10/19/嵌入式业务逻辑/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/","excerpt":"","text":"参考网址:嵌入式架构到底有多重要？看完惊呆了_连志安-CSDN博客 史上最详细！嵌入式系统知识和接口技术总结_连志安-CSDN博客 嵌入式开发中为什么很少用设计模式？_strongerHuang-CSDN博客 嵌入式架构_分享嵌入式,移动端,智能应用,数据库等专业板块,记录知识碎片！！！-CSDN博客 应用架构、业务架构、技术架构和业务流程图详解_代码帮-CSDN博客_业务架构 提高RTOS应用程序稳定可靠的几点技巧-面包板社区 (eet-china.com) RTOS 是如何进行任务划分的？_wenzi嵌入式软件的博客-CSDN博客 UCOS 等 RTOS的任务划分原则（转载整理）_Dr树树的博客-CSDN博客","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"项目模板","slug":"模板案例","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T05:51:25.222Z","comments":true,"path":"2021/10/19/模板案例/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B/","excerpt":"","text":"天穹飞控项目将模块细分非常细致值得嵌入式借鉴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161SRC# tree.├── CONTROL│ ├── flightControl.c│ ├── flightControl.h│ ├── missionControl.c│ ├── missionControl.h│ ├── motor.c│ ├── motor.h│ ├── rc.c│ ├── rc.h│ ├── safeControl.c│ ├── safeControl.h│ ├── userControl.c│ ├── userControl.h│ ├── waypointControl.c│ └── waypointControl.h├── DRIVER│ ├── board.c│ ├── board.h│ ├── boardConfigBlueSkyV3.h│ ├── drv_adc.c│ ├── drv_adc.h│ ├── drv_can.c│ ├── drv_can.h│ ├── drv_flash.c│ ├── drv_flash.h│ ├── drv_i2c_soft.c│ ├── drv_i2c_soft.h│ ├── drv_ppm.c│ ├── drv_ppm.h│ ├── drv_pwm.c│ ├── drv_pwm.h│ ├── drv_sbus.c│ ├── drv_sbus.h│ ├── drv_spi.c│ ├── drv_spi.h│ ├── drv_usart.c│ ├── drv_usart.h│ ├── drv_usb.c│ └── drv_usb.h├── LOG│ ├── logger.c│ ├── logger.h│ ├── ulog.c│ ├── ulog.h│ ├── ulog_data.c│ └── ulog_data.h├── MATH│ ├── LevenbergMarquardt.c│ ├── LevenbergMarquardt.h│ ├── declination.c│ ├── declination.h│ ├── kalman3.c│ ├── kalman3.h│ ├── kalmanVel.c│ ├── kalmanVel.h│ ├── lowPassFilter.c│ ├── lowPassFilter.h│ ├── mathTool.c│ ├── mathTool.h│ ├── matrix3.c│ ├── matrix3.h│ ├── matrix6.c│ ├── matrix6.h│ ├── pid.c│ ├── pid.h│ ├── quaternion.c│ ├── quaternion.h│ ├── rotation.c│ ├── rotation.h│ ├── vector3.c│ └── vector3.h├── MESSAGE│ ├── bsklink.c│ ├── bsklink.h│ ├── bsklinkDecode.c│ ├── bsklinkDecode.h│ ├── bsklinkSend.c│ ├── bsklinkSend.h│ ├── mavlinkDecode.c│ ├── mavlinkDecode.h│ ├── mavlinkNotice.c│ ├── mavlinkNotice.h│ ├── mavlinkParam.c│ ├── mavlinkParam.h│ ├── mavlinkSend.c│ ├── mavlinkSend.h│ ├── message.c│ └── message.h├── MODULE│ ├── 2smpb.c│ ├── 2smpb.h│ ├── battery.c│ ├── battery.h│ ├── icm20602.c│ ├── icm20602.h│ ├── icm20689.c│ ├── icm20689.h│ ├── ist8310.c│ ├── ist8310.h│ ├── mmc3630.c│ ├── mmc3630.h│ ├── module.c│ ├── module.h│ ├── mpu6000.c│ ├── mpu6000.h│ ├── mpu6500.c│ ├── mpu6500.h│ ├── ms5611.c│ ├── ms5611.h│ ├── qmc5883.c│ ├── qmc5883.h│ ├── rgb.c│ ├── rgb.h│ ├── ublox.c│ └── ublox.h├── NAVIGATION│ ├── ahrs.c│ ├── ahrs.h│ ├── ahrsAux.c│ ├── ahrsAux.h│ ├── navigation.c│ └── navigation.h├── SENSOR│ ├── accelerometer.c│ ├── accelerometer.h│ ├── barometer.c│ ├── barometer.h│ ├── gps.c│ ├── gps.h│ ├── gyroscope.c│ ├── gyroscope.h│ ├── magnetometer.c│ ├── magnetometer.h│ ├── sensor.c│ └── sensor.h├── SYSTEM│ ├── faultDetect.c│ ├── faultDetect.h│ ├── flightStatus.c│ ├── flightStatus.h│ ├── parameter.c│ └── parameter.h├── TASK│ ├── TaskConfig.h│ ├── control_task.c│ ├── control_task.h│ ├── log_task.c│ ├── log_task.h│ ├── messageQueue.c│ ├── messageQueue.h│ ├── message_task.c│ ├── message_task.h│ ├── module_task.c│ ├── module_task.h│ ├── navigation_task.c│ ├── navigation_task.h│ ├── sensor_task.c│ └── sensor_task.h└── main.c 待添加……","categories":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"编程规范","slug":"编程规范","date":"2021-10-19T04:30:12.000Z","updated":"2021-10-24T06:07:29.530Z","comments":true,"path":"2021/10/19/编程规范/","link":"","permalink":"https://peitianyu.github.io/blog/2021/10/19/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","excerpt":"","text":"编程规范规范1. 原则 简洁明了，提高代码可读性，读的是代码而不是注释，注释永远都是辅助的。 零告警，严谨的语法才能保障代码表达和编译器理解的是一至的。 2. 排版 程序块之间、变量声明之间，用空行分隔 突出语法关键字 一行不要太长，换行增加可读性 Tab键排版 3. 注释 注释的目的是阐明意图目的，而不是翻译某行代码的动作 注释的原则是尽量代码自注释，代码越清晰，可读性越高 统一格式 **/* 注释内容 */**， *号与注释内容之间有一个空格 1234567891011/*************************************************Copyright //版权File name: // 文件名Author： //作者Version: //版本号Description: // 用于详细说明此程序文件完成的主要功能，与其他模块 // 或函数的接口，输出值、取值范围、含义及参数间的控 // 制、顺序、独立或依赖等关系Others: // 其它内容的说明Log: // 修改日志，包括修改内容，日期，修改人等*************************************************/ 123456/**@ Description: 函数描述，描述本函数的基本功能* @param 1 – 参数 1.* @param 2 – 参数 2* @return – 返回值*/ 4. 定义 命名风格 模块名+文件名+功能描述，之间采用短下划线分隔 功能描述部分，采用驼峰风格 例如， 1void SAFE_LASER_setLaserShield(uint8_t _EN); 宏定义 define 必须大写 typedef 可以小写 例如， 12#define OS_TASK_R200RXID1 0x198 /* HEX格式 */typedef uint32_t StackSize_t； /* 仅用于堆栈 */ 类型定义 使用linux自带类型定义规则 123456789101112#define uint8_t unsigned char#define int8_t char#define uint16_t unsigned short#define int16_t short#define uint32_t unsigned int#define int32_t int#define uint64_t unsigned long long#define int64_t long long#define TRUE 1#define FALSE 0#define NULL 0 5. 变量 变量通用规则 采用驼峰风格,首字母大写 在函数开始是全部定义，不允许在函数中间定义 变量命名必须可以表示其含义 必须初始化 局部变量 本地局部变量必须用static关键字修饰 全局变量 全局变量必须以g开头 函数变量 变量必须以_开头 123static uint8_t SafeLaserSet = 0;uint8_t gSafeLaserSet = 0;static uint8_t _SafeLaserSet = 0; 6. 函数 函数名必须能够自注释，必要是需要增加注释写明意图 内部函数必须使用static定义，命名可以不加模块名 外部函数 必须在头文件中声明， 命名时必须带模块名， 必须给出带注释，并写明函数意图，参数说明，返回值 12static uint_t SAFE_LASER_setLaseShield(uint8_t _EN);void SAFE_LASER_setLaseShield(uint8_t _EN); 7. 文件 头文件 命名规则模块名+功能，小写，例如os_task.h 格式如下 12345678#ifndef __OS_TASK_H__#define __OS_TASK_H__..../* 开放的宏定义 */..../* 开放的全局变量声明 */..../* 开放的函数声明 */#endif 源文件 命名规则模块名+功能，小写，例如os_task.c 格式如下，举例只为说明源文件中，各元素的顺序 123456789101112131415161718192021222324252627&lt;- 1 - 引用头文件 -&gt;#include &quot;os_task.h&quot;&lt;- 2 - 定义本文件用到的宏 -&gt;#define OS_TASK_SWITCH_INTERVAL 10 /* 单位ms */typedef uint32_t StackSize_t ； /* 仅用于堆栈 */typedef enum&#123;&#125;;typedef union&#123;&#125;;typedef struct&#123;&#125;;&lt;- 3 - 本地变量 -&gt;static StackSize_t *TopStack = NULL；&lt;- 4 - 开放的全局变量 -&gt;uint32_t gOsTaskEventBitMap = 0; &lt;- 5 - 本地函数，仅在本文件使用 -&gt;static void TASK_TaskSwitch(void)&#123; return；&#125;&lt;- 6 - 开放的函数 -&gt;void OS_TASK_TaskDelay(uint16_t _ms)&#123; return； &#125; 8.约定俗成简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354addition add 加subtraction sub 减multiplication mul 乘法division div 除法answer ans 响应、回答array arr 数组、集合average avg 平均buffer buf或buff 缓冲区capture cap或capt 捕获check chk 检查count cnt 计数器column col 列control ctrl 控制decode dec 解码、译码define def 定义delete del 删除destination dst或dest 目的display disp 显示encode enc 编码environment env 环境error err 错误float flt 浮动、浮点frequency freq 频率header hdr 开始、开头index idx 索引、指示、image img 影像、镜像increment inc 增加、增量initalize init 初始化iteration itr 循环、迭代length len 长度memory mem 内存middle mid 中值make mk 制造、形成message msg 消息number num 数量、编号operand opnd 操作数optimization opt 最优operator optr 操作packet pkt 消息包positon pos 位置previous pre或prev 以前的pointer ptr 指针record rcd 记录receive recv 收到、接收result res 结果return ret 返回source src 源头stack stk 栈string str 字符串table tab 表temporary tmp或temp 临时total tot 全部的time stamp ts 时间戳value val 值 有互斥意义的变量或者动作相反的函数应该是用互斥词组命名 12345add/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/deletelock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down 9. 模块 模块必须具有封装性，且对外提供尽量少的必要接口，接口必须提供详细的注释描述 模块的组织形式可以是文件夹形式，也可以是文件形式 文件都以小写命名 例如： 123456789101112. ├── src /* 应用层代码 */ │ ├── main.c /* 应用入口 */ │ ├── test.c │ ├── test1.c ├── include /* 设备驱动代码 */ │ ├── test.h │ ├── test1.h ├── debug /* 芯片厂家提供的库代码 */ │ ├── MakeFile │ ├── CMake │ └── main","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/categories/cpp/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/categories/linux/"},{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/categories/sch/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/categories/ros/"},{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/categories/slam/"},{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/categories/tool/"},{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/categories/win/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"cpp","slug":"cpp","permalink":"https://peitianyu.github.io/blog/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"https://peitianyu.github.io/blog/tags/linux/"},{"name":"sch","slug":"sch","permalink":"https://peitianyu.github.io/blog/tags/sch/"},{"name":"ros","slug":"ros","permalink":"https://peitianyu.github.io/blog/tags/ros/"},{"name":"tool","slug":"tool","permalink":"https://peitianyu.github.io/blog/tags/tool/"},{"name":"slam","slug":"slam","permalink":"https://peitianyu.github.io/blog/tags/slam/"},{"name":"模板","slug":"模板","permalink":"https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"win","slug":"win","permalink":"https://peitianyu.github.io/blog/tags/win/"}]}