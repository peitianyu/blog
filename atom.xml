<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>某飞行员的随笔</title>
  
  
  <link href="https://peitianyu.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://peitianyu.github.io/blog/"/>
  <updated>2021-11-08T11:35:29.572Z</updated>
  <id>https://peitianyu.github.io/blog/</id>
  
  <author>
    <name>某飞行员</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电路设计_常见</title>
    <link href="https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/"/>
    <id>https://peitianyu.github.io/blog/2021/11/08/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/</id>
    <published>2021-11-08T04:30:12.000Z</published>
    <updated>2021-11-08T11:35:29.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="驱动输出电路"><a href="#驱动输出电路" class="headerlink" title="驱动输出电路"></a>驱动输出电路</h1><p><img src="https://i.loli.net/2021/11/08/IcfBqFezTlgAm9b.png" alt="image-20211108152310283.png"></p><p>这里需要注意的是,<code>uln2803</code>是一种<code>npn</code>输出,输出低电平,因此在其输出端会有上拉电阻.在<code>uln2803</code>左侧接<code>gnd</code>右侧接<code>24v</code>.</p><p>这里的<code>74hct245</code>为<code>三态输出八路收发器</code>作用是增加单片机的驱动能力.</p><p>将同样用<code>74hct245</code>此电路改为<code>pnp</code>型输出,需要将<code>uln2803</code>换为<code>tbd62783</code>,需要注意输出端需要接<code>下拉电阻</code>.</p><p>**!注意:**由于改驱动芯片<code>uln2803</code>输出最大电流为<code>500ma</code>可能出现烧芯片的情况,可以加一个<code>500ma</code>熔断</p><h1 id="放大电路-opa2333"><a href="#放大电路-opa2333" class="headerlink" title="放大电路(opa2333)"></a>放大电路(opa2333)</h1><p><img src="https://i.loli.net/2021/11/08/cdPVFXozHa5hrxR.png" alt="image-20211108185457678.png"></p><p>这里通过<code>R64</code>,<code>R65</code>阻值的变化来实现放大,具体详细可参考:<a href="https://blog.csdn.net/cyousui/article/details/82936155">(61条消息) 基本运算放大器原理_小神兵之技术篇-CSDN博客_运算放大器</a></p><p>值得注意的是,由于是轨到轨的放大电路,输入<code>24v</code>,最大放大电压同样也可以达到<code>24v</code></p><h1 id="模拟量采样电路"><a href="#模拟量采样电路" class="headerlink" title="模拟量采样电路"></a>模拟量采样电路</h1><p><img src="https://i.loli.net/2021/11/08/PRZG7qv6kX3yQA9.png" alt="image-20211108191319100.png"></p><p>这里两个二极管用以防过压,电压大于<code>3.3v</code>小于<code>26.7v</code>时直接通过<code>+3.3v</code>,输出,而大于<code>26.7v</code>击穿二极管,直接导地.</p><p><img src="https://i.loli.net/2021/11/08/F1qsv4pESJwMUbN.png" alt="image-20211108191642356.png"></p><p>模拟量采集,还需要注意一点就是,对于电源要进行滤波处理,使电源信号更干净</p><h1 id="普通光耦-TLP290-4-与单向高速光耦-PC4D10"><a href="#普通光耦-TLP290-4-与单向高速光耦-PC4D10" class="headerlink" title="普通光耦(TLP290-4)与单向高速光耦(PC4D10)"></a>普通光耦(TLP290-4)与单向高速光耦(PC4D10)</h1><p><img src="https://i.loli.net/2021/11/08/Z6cxwFV4NLpevJK.png" alt="image-20211108192255515.png"></p><p><code>TLP290-4</code>为一种普通光耦,可以实现双向导通,这里原理图<code>左边部分有些出入</code>需要注意一下,输出为<code>npn</code>型输出,注意上拉电阻</p><p><img src="https://i.loli.net/2021/11/08/lESfhw24NsPrKpc.png" alt="image-20211108191804168.png"></p><p><code>pc4d10</code>为告诉光耦,实现的<code>npn</code>型输出,所以注意需要有上拉电阻.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;驱动输出电路&quot;&gt;&lt;a href=&quot;#驱动输出电路&quot; class=&quot;headerlink&quot; title=&quot;驱动输出电路&quot;&gt;&lt;/a&gt;驱动输出电路&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/11/08/IcfBqFezTlgAm9</summary>
      
    
    
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/categories/sch/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/tags/sch/"/>
    
  </entry>
  
  <entry>
    <title>树莓派备份</title>
    <link href="https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/"/>
    <id>https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%87%E4%BB%BD/</id>
    <published>2021-11-06T04:30:12.000Z</published>
    <updated>2021-11-06T13:10:22.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://zhuanlan.zhihu.com/p/299844978?utm_source=wechat_session">收藏！最简单的树莓派系统备份方法！ - 知乎 (zhihu.com)</a></p><p><a href="https://post.smzdm.com/p/apzkgne7/">树莓派学习笔记 篇四：树莓派4B 的系统备份方法大全（全卡+压缩备份）_其他智能设备_什么值得买 (smzdm.com)</a></p><p><a href="https://blog.csdn.net/sinat_16643223/article/details/109006150">烧写之前备份过的树莓派镜像到SD卡，证明这样备份恢复是可行的！！！！！！！_TYINY的博客-CSDN博客</a></p><h1 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h1><p><code>win10</code>下新建一个<code>.img</code>格式文件,通过<code>Win32DiskImager</code>,<code>read</code>插入卡的系统,<code>read</code>完就备份好了</p><p><img src="https://qnam.smzdm.com/201912/08/5ded02bcc031f2090.jpg_e1080.jpg" alt="树莓派4B 的系统备份方法大全（全卡+压缩备份）"></p><h1 id="脚本方式-推荐"><a href="#脚本方式-推荐" class="headerlink" title="脚本方式(推荐)"></a>脚本方式(推荐)</h1><p><a href="https://github.com/BigBubbleGum/RaspberryBackup"> 在Linux系统中一键备份树莓派系统SD卡的脚本 (github.com)</a></p><ul><li>下载下来脚本<code>rpi-backup.sh</code>放入到<code>Linux</code>系统</li><li>插入需备份的树莓派系统,用<code>df -h</code>命令查询SD卡设备名</li><li>运行<code>sudo chmod +x rpi-backup.sh</code>后,运行<code>./rpi-backup.sh /dev/sdb1 /dev/sdb2</code></li><li>注意第一个参数是树莓派SD卡<code>/boot</code>分区的设备名：/dev/sdb1，第二个参数是<code>/</code>分区的设备名：/dev/sdb2，视情况修改）</li><li>终 img 文件会生成在<code>~/backupimg/</code>文件夹下</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/299844978?utm_source=w</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>树莓派串口通信</title>
    <link href="https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</id>
    <published>2021-11-06T04:30:12.000Z</published>
    <updated>2021-11-06T07:46:11.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/benchuspx/article/details/112571880?ops_request_misc=%7B%22request_id%22:%22163054521616780274150518%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163054521616780274150518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-112571880.pc_search_insert_download&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEubuntu+20%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF%E8%B0%83%E8%AF%95&spm=1018.2226.3001.4187">树莓派4b ubuntu系统开启串口_benchuspx的博客-CSDN博客</a></p><p><a href="https://www.pianshen.com/article/3825828971/">树莓派4B如何使用串口与外部进行通信 - 程序员大本营 (pianshen.com)</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>树莓派原本的抽是用于<strong>串口控制台</strong>的,即<code>/ttyAMA0</code>,且此硬件串口也与蓝牙连接到一块,因此需要将<strong>控制台</strong>与<strong>蓝牙</strong>关闭才能使用</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><code>/boot/firmware/nobtcmd.tx</code>t里删除<code>console = /ttyAMA 921600</code>从而禁用串口控制台.这个<code>txt文件</code>也可以用读卡器把sd卡插到windows系统里在<code>system-boot</code>里找到</p></li><li><p><code>/boot/firmware/config.txt</code> 里设置<code>enable_uart=1</code>（默认就是）.如果=0表示启用minicom串口，而不是这个硬件串口.</p></li><li><p><code>/boot/firmware/config.txt</code> 里加入一行<code>dtoverlay=disable-bt</code>从而禁用蓝牙.</p></li><li><p><code>sudo systemctl disable bluetooth</code>…… 禁用掉和蓝牙有关的开机启动项.直到桌面不再显示蓝牙标志，但是还有<code>/ttyAMA0</code>存在.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benchuspx/article/details/112</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装Ubuntu18_server</title>
    <link href="https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/"/>
    <id>https://peitianyu.github.io/blog/2021/11/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubuntu18_server/</id>
    <published>2021-11-06T04:30:12.000Z</published>
    <updated>2021-11-07T03:49:11.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_36628778/article/details/105056549?ops_request_misc=%7B%22request_id%22:%22163048418216780264057617%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163048418216780264057617&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-105056549.pc_search_insert_download&utm_term=ubuntu18.04+server+wlan0&spm=1018.2226.3001.4187">树莓派raspberry 安装ubuntu18.04 server + desktop + ros1_越来越胖了_mengleijin的博客-CSDN博客</a></p><p><a href="https://www.freesion.com/article/3758800537/">树莓派4b安装带桌面的ubuntu18.04 server和ROS melodic系统 - 灰信网（软件开发博客聚合） (freesion.com)</a></p><h1 id="img镜像下载"><a href="#img镜像下载" class="headerlink" title="img镜像下载"></a>img镜像下载</h1><p><a href="https://www.lxx1.com/3779">树莓派操作系统镜像下载地址</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/releases/bionic/release/ubuntu-18.04.5-preinstalled-server-arm64%2Braspi4.img.xz">ubuntu18_server</a></p><h1 id="将系统烧入SD卡"><a href="#将系统烧入SD卡" class="headerlink" title="将系统烧入SD卡"></a>将系统烧入SD卡</h1><p>使用<strong>win32diskimager</strong>或者<strong>balenaetcher</strong>烧录进去</p><p><img src="https://img-blog.csdnimg.cn/20210507104309422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTcwMDI1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200603191826555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDU4NDYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="启动树莓派"><a href="#启动树莓派" class="headerlink" title="启动树莓派"></a>启动树莓派</h1><p>将SD卡插入树莓派，并为树莓派连接好电源，显示器，鼠标，键盘，网线。启动树莓派，默认用户名密码都是<code>ubuntu</code>，之后需要马上修改密码，按提示操作即可。</p><h1 id="连网"><a href="#连网" class="headerlink" title="连网"></a>连网</h1><p>可以参考:</p><p><a href="https://blog.csdn.net/zyr920425/article/details/93351457">Ubuntu Server 18.04 连接 WIFI_zyr920425的博客-CSDN博客</a></p><p>编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/netplan/xxxxxxx.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: false</span><br><span class="line">            addresses: [192.168.10.135/24]</span><br><span class="line">    wifis:</span><br><span class="line">        wlan0:</span><br><span class="line">            access-points:</span><br><span class="line">                &quot;10X&quot;:</span><br><span class="line">                    password: 123456787</span><br><span class="line">            dhcp4: true</span><br></pre></td></tr></table></figure><h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano  /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/Meteor_s/article/details/81301252">Ubuntu–更换软件源_星迹-CSDN博客_乌班图软件源</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h1 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h1><p>网线连接好,通过<code>ip a</code>查看是否配置好,然后在物理机上尝试<code>ping</code>通后连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh.exe ubuntu@192.168.xx.xx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_36628778/article/detai</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>电路设计_最小系统设计</title>
    <link href="https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-06T04:30:12.000Z</published>
    <updated>2021-11-08T06:22:13.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/little_ox/article/details/105056030">(60条消息) STM32最小系统设计_little_ox的博客-CSDN博客</a></p><h1 id="最小系统"><a href="#最小系统" class="headerlink" title="最小系统"></a>最小系统</h1><p>组成:<strong>主芯片</strong>,<strong>复位电路</strong>,<strong>时钟电路</strong>,<strong>电源电路</strong>,<strong>下载电路</strong></p><h2 id="主芯片"><a href="#主芯片" class="headerlink" title="主芯片"></a>主芯片</h2><p>根据自己需要的io数量,功能选择好主芯片</p><h2 id="复位电路-时钟电路-下载电路"><a href="#复位电路-时钟电路-下载电路" class="headerlink" title="复位电路,时钟电路,下载电路"></a>复位电路,时钟电路,下载电路</h2><p>由于低电平复位,因此可以通过上拉电阻实现,由于<strong>复位电路</strong>与<strong>时钟电路</strong>一般芯片都会提供参考电路或者查查资料都很容易找到,就不再赘述,<strong>下载电路</strong>的话直接<code>clk</code>,<code>dio</code>给他,通过<code>SWD</code>,或者<code>JTAG</code>下载,这里使用的时<code>SWD</code>下载</p><p><img src="https://i.loli.net/2021/11/06/uVUHSfX4Lt2Reiq.png" alt="image-20211106195658724.png"></p><p>**!注意:**一般芯片都会有电源滤波,因此在布线的过程中注意将电容尽量放的里芯片近些.</p><h2 id="晶振的选择"><a href="#晶振的选择" class="headerlink" title="晶振的选择"></a>晶振的选择</h2><p>有源晶振:自供电,有内部电路,精度会高些,当然价格也贵些</p><p>无源晶振:内部不供电,与芯片直接相连,精度差些,在对时钟要求没那么高的情况下一般够用</p><h2 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h2><p>比较麻烦的是电源电路,或者降压,或者稳压,根据需要实现.</p><p>这里提供一种从24v转3.3v的思路电源思路.这里使用<code>TPS5430</code>芯片实现的一种电源降压的方式,这里<code>D2</code>指的是<code>瞬态抑制</code>起到当电压超过24v(比如打火花)进来时,<code>D2</code>导通,24v直接接地,同事使用了F1保险丝做保护        </p><p><img src="https://i.loli.net/2021/11/06/OokdWnJcprP4uZV.png" alt="image-20211106200343212.png"></p><p><img src="https://i.loli.net/2021/11/06/SXDMrFs3iagZGBq.png" alt="image-20211106200412912.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/little_ox/article/details/105</summary>
      
    
    
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/categories/sch/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/tags/sch/"/>
    
  </entry>
  
  <entry>
    <title>电路设计_通讯设计</title>
    <link href="https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/"/>
    <id>https://peitianyu.github.io/blog/2021/11/06/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1_%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-06T04:30:12.000Z</published>
    <updated>2021-11-08T06:21:47.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAN"><a href="#CAN" class="headerlink" title="CAN:"></a>CAN:</h1><p><img src="https://i.loli.net/2021/11/06/Cs8JxWr3kPG7efT.png" alt="image-20211106130338091-16361750226251.png"></p><p><img src="https://i.loli.net/2021/11/06/6BkYVPWyMIU5g1Z.png" alt="image-20211106133256690.png"></p><p>两张图用的都是<code>TJA1050</code>,速度<code>1Mbps</code>,不过后期的处理略有些不同,上图can信号分两路输出,而下图,为保护电路,加入了<code>fuse</code>(熔断器),<code>SMAJ30CA</code>(瞬态抑制二极管)</p><p><img src="https://i.loli.net/2021/11/06/tcjs9VvHAG8ENQX.png" alt="image-20211106140618661.png"></p><p>这张图用的是<code>max3051</code>3.3v供电,高速运行<code>1Mbps</code>,这里使用了<code>ACT45B</code>共模电感起<code>EMI</code>滤波的作用，用于抑制高速信号线产生的电磁波向外辐射发射.</p><h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><p><img src="https://i.loli.net/2021/11/06/NuSOBZ4Yldot6wp.png" alt="image-20211106141453916.png"></p><p><img src="https://i.loli.net/2021/11/06/T8zrX3fUBA4Slc2.png" alt="image-20211106141550298.png"></p><p>由于采用<code>3.3v</code>供电,使用芯片为<code>sp3485</code>,参考图二,<code>5v</code>供电可更换为<code>max485</code>,电路设计上也还是同样,图一,采用<code>熔断器</code>与<code>瞬态一直二极管</code>保护电路</p><p><img src="https://i.loli.net/2021/11/06/QHouRcwMjXm7fFh.png" alt="image-20211106142404847"></p><p>这张图就是<code>max485</code>实现的<code>RS485</code>电路,同样对于电路保护也采用熔断器与瞬态一直二极管,同时采用电容进行进一步滤波.这里发送接收通过<code>EN</code>控制,三极管做开关功能,<code>EN</code>为0时接收,为1时发送.</p><h1 id="232"><a href="#232" class="headerlink" title="232"></a>232</h1><p><img src="https://i.loli.net/2021/11/06/J8CwfLA7H1uErT4.png" alt="image-20211106143625304"></p><p>数据手册:</p><p><a href="https://www.ti.com/cn/lit/ds/symlink/max3232.pdf?ts=1636166679814">具有 ±15kV ESD 保护功能的 MAX3232 3V 至 5.5V 多通道 RS-232 线路驱动器和接收器 datasheet </a></p><p>布板参考:</p><p><img src="https://i.loli.net/2021/11/06/wghYLF1WtiadvNS.png" alt="image-20211106143955599.png"></p><h1 id="USB转串口"><a href="#USB转串口" class="headerlink" title="USB转串口"></a>USB转串口</h1><p><img src="https://i.loli.net/2021/11/06/oKLkuhrp9EUb43w.png" alt="image-20211106145617779.png"></p><p>这张图是type_c转串口的图,图中使用<code>CH340N</code>实现板子最小化,非常<strong>nice</strong></p><p>下面是他的开源链接:<a href="https://oshwhub.com/vcijj/TYPE-C-usbzhuai-chuan-kou">TYPE C usb转串口 - 立创EDA开源硬件平台 (oshwhub.com)</a></p><p>当然为了保护电路,我们也可以在上边加上<code>熔断</code>与<code>瞬时抑制二极管</code></p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p><strong>参考渡鸦卡发版设计</strong></p><p><img src="https://i.loli.net/2021/11/06/u3pGfIP86yELD4F.png" alt="image-20211106150109596.png"></p><p><strong>大佬的串口转以太网设计:</strong></p><p><a href="https://oshwhub.com/jixin/CH9121-4c2c4f99e2494eee8421dd23768820a1">串口转以太网模块-CH9121 - 立创EDA开源硬件平台 (oshwhub.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAN&quot;&gt;&lt;a href=&quot;#CAN&quot; class=&quot;headerlink&quot; title=&quot;CAN:&quot;&gt;&lt;/a&gt;CAN:&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/11/06/Cs8JxWr3kPG7efT.png&quot; alt</summary>
      
    
    
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/categories/sch/"/>
    
    
    <category term="sch" scheme="https://peitianyu.github.io/blog/tags/sch/"/>
    
  </entry>
  
  <entry>
    <title>hector基础使用</title>
    <link href="https://peitianyu.github.io/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://peitianyu.github.io/blog/2021/11/05/hector%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2021-11-05T04:30:12.000Z</published>
    <updated>2021-11-05T06:14:45.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/weixin_41459903/article/details/102795148">思岚A1激光雷达hector_mapping建图与定位_欧俊岑的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44785456/article/details/116789296?ops_request_misc=%7B%22request_id%22:%22163453792216780255277807%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163453792216780255277807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116789296.pc_search_ecpm_flag&utm_term=r2000+hector&spm=1018.2226.3001.4187">tx2+r2000激光雷达 hector建图_大家安静啊的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_36170626/article/details/98316545?ops_request_misc=%7B%22request_id%22:%22163454144916780262550313%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163454144916780262550313&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-98316545.pc_search_ecpm_flag&utm_term=hector_slam%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187">hectorslam之EAI雷达(ydlidar_x2l)配置过程_sunshine-CSDN博客</a></p><p><a href="https://github.com/NickL77/RPLidar_Hector_SLAM">NickL77/RPLidar_Hector_SLAM: Hector SLAM without odometry data on ROS with the RPLidar A1 (github.com)</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hector是纯粹基于laserscan数据的算法,只需要提供scan数据即可,这里使用r2000做实验.因此第一步应该发布scan数据.</p><h1 id="Scan激光数据发布"><a href="#Scan激光数据发布" class="headerlink" title="Scan激光数据发布"></a>Scan激光数据发布</h1><p>r2000提供了ros发布的驱动文件,因此只需要修改些配置即可.</p><p>驱动网址:</p><p><a href="https://github.com/dillenberger/pepperl_fuchs">dillenberger/pepperl_fuchs: Pepperl+Fuchs R2000 Driver (github.com)</a></p><p>修改一下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pepperl_fuchs_r2000&quot;</span> <span class="attr">type</span>=<span class="string">&quot;r2000_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;r2000_driver_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scanner_ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.1.19&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;frame_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;laser_link&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_frequency&quot;</span> <span class="attr">value</span>=<span class="string">&quot;35&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;samples_per_scan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;remap from=&quot;/r2000_driver_node/scan&quot; to=&quot;scan&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;node pkg=&quot;dummy_slam_broadcaster&quot; type=&quot;dummy_slam_broadcaster_node&quot; name=&quot;dummy_slam_broadcaster&quot;/&gt;</span></span><br><span class="line"><span class="comment">  &lt;node name=&quot;rvizLocal&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; respawn=&quot;false&quot; output=&quot;screen&quot; args=&quot;-d $(find pepperl_fuchs_r2000)/rviz/test.rviz&quot; required=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scanner_ip       r2000的配置激光ip地址</span><br><span class="line">frame_id         发布出去的框架id(用于tf转换)</span><br><span class="line">scan_frequency   扫描频率</span><br><span class="line">samples_per_scan 每圈的扫描数</span><br><span class="line"># 值得注意的是这里r2000发不出去的scan节点为/r2000_driver_node/scan</span><br><span class="line"># 可以通过remap重定义为/scan</span><br><span class="line">最后通过rviz显示</span><br></pre></td></tr></table></figure><p>ros执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br></pre></td></tr></table></figure><h1 id="使用hector-mapping建图并定位"><a href="#使用hector-mapping建图并定位" class="headerlink" title="使用hector_mapping建图并定位"></a>使用hector_mapping建图并定位</h1><p>这里可以直接在系统中安装hector,并新建<code>hector_mapping.launch</code>文件,指令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-hector-slam</span><br><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_create_pkg run_launch # 因为内部都是launch文件并不需要依赖包</span><br><span class="line">cd run_launch &amp;&amp; sudo mkdir launch &amp;&amp; cd launch</span><br><span class="line">sudo nano hector_mapping.launch</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Frame names --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定map-&gt; odom转换是否应该由系统发布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_odom_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坐标系id,hector会将map与车体做tf连接到一块,而车体与激光之间的连接需要我们自己做 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;map&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于没有使用里程计,改为base_link即可 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Tf use --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_scan_transformation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_tf_pose_start_estimate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map size / start point --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_resolution&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 地图尺寸需要注意一下,如果地图太小,可能导致激光范围过大,超出地图,这样匹配坐标会很挫 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;512&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_start_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_min_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;-1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max_value&quot;</span> <span class="attr">value</span> = <span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_multi_res_levels&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_pub_period&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_min_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 激光扫描距离要适中,如果太小也会出现建图建的很挫的现象 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_timing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定scanmatcher到map的转换是否发布到TF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;pub_map_scanmatch_transform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布的坐标名 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map update parameters --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_free&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_factor_occupied&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.7&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_distance_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_angle_thresh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.06&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Advertising config --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;advertise_map_service&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描订阅器的队列大小 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_subscriber_queue_size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里更改一下scan_topic 如果我们做了重定向,需要改为/scan--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scan_topic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/r2000_driver_node/scan&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- !注意:这一步需要将车体坐标系与激光坐标系进行tf转换连接起来 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_to_laser_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0.105 0 0 0 /base_link /laser_link 100&quot;</span>/&gt;</span>_</span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是hector自带的rviz配置,我们也可以在他的基础上增减功能,另存到我们自己的文件src/run_launch/rviz/map/hector_map.rviz --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行步骤:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发布scan数据</span></span><br><span class="line">roslaunch pepperl_fuchs_r2000 gui_example.launch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动hector_mapping</span></span><br><span class="line">roslaunch run_launch hector_mapping.launch</span><br></pre></td></tr></table></figure><h1 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h1><p><img src="https://img-blog.csdnimg.cn/20210514140914724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210514140924770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4NTQ1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.订阅/scan不要出错</p><p>2.tf转换尤为需要注意,map-&gt;base_link-&gt;laser_link</p><p>3.激光距离与地图大小需要注意一下,这里设不好容易崩</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41459903/article/detai</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>hector源码理解</title>
    <link href="https://peitianyu.github.io/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://peitianyu.github.io/blog/2021/11/05/hector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2021-11-05T04:30:12.000Z</published>
    <updated>2021-11-06T07:29:40.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p>大佬的分析,包含代码注释解析与源码重写,论文翻译</p><p><a href="https://blog.csdn.net/qq_36355662/article/details/90349302">Hector_slam源码框架分析_翎风的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cyberniklee/p/8484104.html">Hector SLAM解读（1）原文翻译 - cyberniklee - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/scomup/p/7075296.html">HectorSLAM论文解析・代码重写（2） - scomup - 博客园 (cnblogs.com)</a></p><p><a href="https://github.com/zhangwenxiao/HectorSlamWithoutROS">zhangwenxiao/HectorSlamWithoutROS: 脱离ROS的hector slam算法 (github.com)</a></p><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>该开源系统的主要代码在hector_mapping文件夹中，文件夹里有src文件夹和include文件夹，包含了算法所有的核心代码。<br>通过对源码的梳理，整理出了如下流程图：</p><p><img src="https://img-blog.csdnimg.cn/20190520100840536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU1NjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>大佬的图非常清晰的可以看到,整个代码分为<code>地图匹配</code>与<code>地图更新</code></p><h1 id="地图匹配"><a href="#地图匹配" class="headerlink" title="地图匹配"></a>地图匹配</h1><p>主要采用<strong>非线性优化</strong>—-<strong>高斯牛顿法</strong>,实际上就是通过激光数据与现有地图的差距(双线性插补),通过最小二乘法,计算概率,从而更新位移增量,计算出机器人最可能存在位置</p><h2 id="双线性插值计算栅格概率"><a href="#双线性插值计算栅格概率" class="headerlink" title="双线性插值计算栅格概率"></a>双线性插值计算栅格概率</h2><p><a href="https://zhuanlan.zhihu.com/p/110754637">一篇文章为你讲透双线性插值 - 知乎 (zhihu.com)</a></p><p>通过双线性插补得到一个位置,然后通过最小二乘法,更新位移增量</p><h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1b441177kr?from=search&seid=5703864891923353812&spm_id_from=333.337.0.0">【泡泡机器人公开课】第三十课：非线性优化与g2o-高翔_哔哩哔哩_bilibili</a></p><h1 id="地图更新"><a href="#地图更新" class="headerlink" title="地图更新"></a>地图更新</h1><p>用bresenham<code>划线</code>算法计算激光途经栅格</p><p><a href="https://blog.csdn.net/yzh1994414/article/details/82860187">(60条消息) Bresenham 算法原理_yzh1994414的博客-CSDN博客_bresenham</a></p><p><a href="https://blog.csdn.net/datase/article/details/83620338">画线算法-Bresenham算法_天才樱木-CSDN博客_bresenham画线算法</a></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><p>（1）不需要使用里程计，可以用于地面不平坦区域及空中飞行器。<br>（2）使用多分辨率地图能避免局部最小值。</p><h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h4><p>（1）要求雷达更新频率较高，测量噪声小；或者机器人运动速度低。<br>（2）无法利用精确的里程计信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;大佬的分析,包含代码注释解析与源码重写,论文翻译&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.n</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>map_server</title>
    <link href="https://peitianyu.github.io/blog/2021/11/05/map_server/"/>
    <id>https://peitianyu.github.io/blog/2021/11/05/map_server/</id>
    <published>2021-11-05T04:30:12.000Z</published>
    <updated>2021-11-05T07:26:41.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/datase/article/details/82495600">(60条消息) map server 功能和作用_天才樱木-CSDN博客_map_server</a></p><h1 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_saver -f mymap</span><br></pre></td></tr></table></figure><p>我们会得到两个文件,<code>mymap.pgm</code>,<code>mymap.yaml</code></p><p><code>mymap.pgm</code>为0到1的灰度图</p><p><code>mymap.yaml</code>为配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">image: testmap.png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分辨率</span></span><br><span class="line">resolution: 0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始点</span></span><br><span class="line">origin: [0.0, 0.0, 0.0]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 占用阈值</span></span><br><span class="line">occupied_thresh: 0.65</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为自由阈值</span></span><br><span class="line">free_thresh: 0.196</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否应该颠倒白/黑 自由/被占用的语义(阈值的解释不受影响)</span></span><br><span class="line">negate: 0</span><br></pre></td></tr></table></figure><h1 id="发布节点"><a href="#发布节点" class="headerlink" title="发布节点"></a>发布节点</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_server mymap.yaml</span><br></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><strong>map_metadata</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html">nav_msgs/MapMetaData</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这包含了关于占领网格特征的基本信息</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图加载的时间</span></span><br><span class="line">time map_load_time</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的分辨率 [m/cell]</span></span><br><span class="line">float32 resolution</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map width [cells]</span></span><br><span class="line">uint32 width</span><br><span class="line"><span class="meta">#</span><span class="bash"> Map height [cells]</span></span><br><span class="line">uint32 height</span><br><span class="line"><span class="meta">#</span><span class="bash"> 地图的原点[m, m, rad]。这是地图中单元格(0,0)的真实姿态。</span></span><br><span class="line">geometry_msgs/Pose origin</span><br></pre></td></tr></table></figure><p><strong>map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html">nav_msgs/OccupancyGrid</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这代表了一个二维网格地图，其中每个单元格代表占用概率。</span></span><br><span class="line"></span><br><span class="line">Header header </span><br><span class="line"><span class="meta">#</span><span class="bash"> uint32 seq</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> time stamp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> string frame_id</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">地图的元数据</span></span><br><span class="line">MapMetaData info</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射数据，按行主顺序，从(0,0)开始。占用概率在[0,100]范围内。未知是1。</span></span><br><span class="line">int8[] data</span><br></pre></td></tr></table></figure><p><strong>static_map</strong> (<a href="http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html">nav_msgs/GetMap</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Get the map as a nav_msgs/OccupancyGrid</span></span><br><span class="line">---</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/datase/article/details/824956</summary>
      
    
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/categories/ros/"/>
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降法</title>
    <link href="https://peitianyu.github.io/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
    <id>https://peitianyu.github.io/blog/2021/11/05/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</id>
    <published>2021-11-05T04:30:12.000Z</published>
    <updated>2021-11-05T12:21:42.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/qq_42138662/article/details/109289129">(60条消息) 高斯牛顿法详解_我只是一只自动小青蛙的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lusongno1/article/details/80558684">信赖域狗腿（dogleg）方法_LSEC小陆的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_30463341/article/details/94809554?ops_request_misc=%7B%22request_id%22:%22163611474316780357221244%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163611474316780357221244&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-94809554.pc_search_mgc_flag&utm_term=%E5%88%97%E6%96%87%E4%BC%AF%E6%A0%BC-%E9%A9%AC%E5%A4%B8%E5%B0%94%E7%89%B9%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B&spm=1018.2226.3001.4187">高斯牛顿(Gauss Newton)、列文伯格-马夸尔特(Levenberg-Marquardt)最优化算法与VSLAM_weixin_30463341的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/a6333230/article/details/83304098">LM算法——列文伯格-马夸尔特算法（最速下降法，牛顿法，高斯牛顿法）（完美解释负梯度方向）_三眼二郎-CSDN博客_lm算法</a></p><h1 id="从上倒下为梯度下降法的前世今生已经未来的演化："><a href="#从上倒下为梯度下降法的前世今生已经未来的演化：" class="headerlink" title="从上倒下为梯度下降法的前世今生已经未来的演化："></a>从上倒下为梯度下降法的前世今生已经未来的演化：</h1><p><strong>最速下降法（一阶梯度法）</strong><br><strong>牛顿法（二阶梯度法）</strong><br><strong>高斯牛顿法</strong><br><strong>列文伯格法</strong><br><strong>马夸尔特法</strong></p><p>梯度下降主要用于slam中的非线性优化,实际上就是对一个最小二乘问题的求解,这也是上述几种方法的用途.</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://img-blog.csdnimg.cn/202010261811320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM4NjYy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="最速下降-一阶梯度法"><a href="#最速下降-一阶梯度法" class="headerlink" title="最速下降(一阶梯度法)"></a>最速下降(一阶梯度法)</h1><p><strong>最速下降法</strong>（一阶梯度法）就是保留泰勒展开的一阶项用来近似非线性函数**F ( x )**，即：<br>$$<br>F(xk​+Δxk​)≈F(xk​)+J(xk​)TΔxk<br>$$</p><p>$$<br>Δxk​=−J(xk)<br>$$</p><p>**缺点:**由于仅保留一阶的雅可比矩阵,该方法过于贪心，容易走出锯齿线，反而增加迭代次数。</p><h1 id="牛顿法和阻尼牛顿法（二阶梯度法）"><a href="#牛顿法和阻尼牛顿法（二阶梯度法）" class="headerlink" title="牛顿法和阻尼牛顿法（二阶梯度法）"></a>牛顿法和阻尼牛顿法（二阶梯度法）</h1><p>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =−J(x<br>k<br>​<br> )<br>$$</p><p>**牛顿法的缺点:**海塞矩阵H计算量太大</p><p><strong>阻尼牛顿法</strong>(可以看成是牛顿法与最速法的结合)</p><p>阻尼牛顿法就是在使用牛顿法获得增量方向后，进一步对最优步长进行搜索：</p><h1 id="高斯牛顿法-仅用于最小二乘"><a href="#高斯牛顿法-仅用于最小二乘" class="headerlink" title="高斯牛顿法(仅用于最小二乘)"></a>高斯牛顿法(仅用于最小二乘)</h1><h3 id="原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开"><a href="#原理-不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f-x-进行一阶泰勒展开" class="headerlink" title="原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)"></a>原理(不对优化目标函数进行泰勒展开，我们对优化目标函数中的一部分，即f(x)进行一阶泰勒展开)</h3><p><strong>增量方程:</strong><br>$$<br>H(x<br>k<br>​<br> )Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>算法流程:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.给定初始值X0</span><br><span class="line">2.对于第k次迭代,求出当前雅可比矩阵J与误差f(x)</span><br><span class="line">3.求解增量方程:H*deltaxk=g</span><br><span class="line">4.若的了他xk足够小,则停止,否则,xk+1 = xk + deltaxk</span><br></pre></td></tr></table></figure><p><strong>缺点:</strong></p><p>由于是通过雅各比矩阵做的JH(海瑟矩阵)的近似,因此会遇见奇异矩阵与病态矩阵,可能出现算法不收敛.</p><h1 id="L-M方法，阻尼牛顿法"><a href="#L-M方法，阻尼牛顿法" class="headerlink" title="L-M方法，阻尼牛顿法"></a>L-M方法，阻尼牛顿法</h1><p><strong>列文伯格-马夸尔特方法的思想</strong><br>针对高斯牛顿法的不足，L-M方法做了两点改进：</p><ul><li><p>在求解增量Δ xk 时，对其设置了信赖区域</p></li><li><p>在求得增量Δ xk对其近似效果进行了量化，并根据量化结果对信赖区域进行调整，</p><p>再从新计算增量Δ x k，直到近似效果量化结果达到阈值。</p></li></ul><p><strong>增量方程</strong><br>$$<br>(H+λD<br>T<br> D)Δx<br>k<br>​<br> =g(x<br>k<br>​<br> )<br>$$<br><strong>近似程度的量化</strong><br>$$<br>ρ=<br>(f(xk​+Δx k​)−f(x k​ ))/(J(x k​)TΔxk​)​<br>$$</p><ul><li>当ρ接近1时，近似效果好；</li><li>当ρ太小时，实际减小的值远小于近似函数减小的值，近似效果差，需要缩小近似范围μ</li><li>当ρ较大时，实际减小的值大于近似函数减小的值，近似效果差，需要增大近似范围μ </li></ul><p><strong>算法流程:</strong></p><p><img src="https://img-blog.csdn.net/20170712180312420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YmFvaHVhX2J1cHQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_42138662/article/details/1</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>树莓派入门</title>
    <link href="https://peitianyu.github.io/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"/>
    <id>https://peitianyu.github.io/blog/2021/11/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/</id>
    <published>2021-11-03T04:30:12.000Z</published>
    <updated>2021-11-03T13:51:08.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树莓派入门"><a href="#树莓派入门" class="headerlink" title="树莓派入门"></a>树莓派入门</h2><h3 id="1、树莓派安装"><a href="#1、树莓派安装" class="headerlink" title="1、树莓派安装"></a>1、树莓派安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">教程网站：https://blog.csdn.net/bhniunan/article/details/104783321</span><br><span class="line">    https://blog.csdn.net/W17330937835/article/details/105351273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603417716780255273810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161603417716780255273810&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-105351273.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b</span><br><span class="line"></span><br><span class="line">https://ubuntu-mate.org/</span><br><span class="line">noobs安装系统：https://blog.csdn.net/diandianxiyu_geek/article/details/78949393</span><br><span class="line"></span><br><span class="line">https://shumeipai.nxez.com/download</span><br><span class="line">https://make.quwj.com/member/2/bookmarks?category=36</span><br></pre></td></tr></table></figure><h3 id="2、汉化Raspbian操作系统"><a href="#2、汉化Raspbian操作系统" class="headerlink" title="2、汉化Raspbian操作系统"></a>2、汉化Raspbian操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/bhniunan/article/details/104842773</span><br><span class="line">中文输入法：https://blog.csdn.net/qq_33475105/article/details/113488707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161605416616780261948746%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161605416616780261948746&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-113488707.pc_search_result_no_baidu_js&amp;utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE4b%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95</span><br></pre></td></tr></table></figure><h3 id="3、树莓派gpio控制"><a href="#3、树莓派gpio控制" class="headerlink" title="3、树莓派gpio控制"></a>3、树莓派gpio控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wiki.jikexueyuan.com/project/raspberry-pi/gpio.html</span><br></pre></td></tr></table></figure><h3 id="4、树莓派命令行连接wifi"><a href="#4、树莓派命令行连接wifi" class="headerlink" title="4、树莓派命令行连接wifi"></a>4、树莓派命令行连接wifi</h3><p><a href="https://blog.csdn.net/u010875635/article/details/70170145">https://blog.csdn.net/u010875635/article/details/70170145</a></p><h3 id="5、树莓派用rc-local设置开机启动"><a href="#5、树莓派用rc-local设置开机启动" class="headerlink" title="5、树莓派用rc.local设置开机启动"></a>5、树莓派用rc.local设置开机启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入etc/rc.local</span><br><span class="line">编辑需要打开的设置，直接编辑命令</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;树莓派入门&quot;&gt;&lt;a href=&quot;#树莓派入门&quot; class=&quot;headerlink&quot; title=&quot;树莓派入门&quot;&gt;&lt;/a&gt;树莓派入门&lt;/h2&gt;&lt;h3 id=&quot;1、树莓派安装&quot;&gt;&lt;a href=&quot;#1、树莓派安装&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo模板</title>
    <link href="https://peitianyu.github.io/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://peitianyu.github.io/blog/2021/11/03/%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-11-03T04:30:12.000Z</published>
    <updated>2021-11-03T13:51:18.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;</summary>
      
    
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>ros_rosbag</title>
    <link href="https://peitianyu.github.io/blog/2021/11/02/rosbag/"/>
    <id>https://peitianyu.github.io/blog/2021/11/02/rosbag/</id>
    <published>2021-11-02T04:30:12.000Z</published>
    <updated>2021-11-02T05:47:29.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://blog.csdn.net/qiqiqiqi0000/article/details/114767249?ops_request_misc=%7B%22request_id%22:%22163582490616780261970410%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582490616780261970410&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-114767249.pc_search_ecpm_flag&utm_term=rosbag&spm=1018.2226.3001.4187">(59条消息) Rosbag详细操作_Sun的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/newbeixue/article/details/110082489?ops_request_misc=%7B%22request_id%22:%22163582694116780271519523%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582694116780271519523&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-110082489.pc_search_ecpm_flag&utm_term=rosbag+play+--clock&spm=1018.2226.3001.4187">rosbag –clock_newbeixue的博客-CSDN博客</a></p><h2 id="Rosbag基础使用"><a href="#Rosbag基础使用" class="headerlink" title="Rosbag基础使用"></a>Rosbag基础使用</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存所有topic</span></span><br><span class="line">rosbag record -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只记录某些感兴趣的 topic</span></span><br><span class="line">rosbag record /topic_name1 /topic_name2 /topic_name3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定生成数据包的名字，则用-O /-o 参数</span></span><br><span class="line">rosbag record -O filename.bag /topic_name1</span><br><span class="line"><span class="meta">#</span><span class="bash"> launch 文件中使用 rosbag record 命令</span></span><br><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rosbag info filename.bag</span><br><span class="line">rosbag info -y filename.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">xiaohu@xiaohu:~/bagfiles$  rosbag info -y 1.bag</span><br><span class="line">path: 1.bag</span><br><span class="line">version: 2.0</span><br><span class="line">duration: 3.295966</span><br><span class="line">start: 1566653873.351150</span><br><span class="line">end: 1566653876.647117</span><br><span class="line">size: 8103</span><br><span class="line">messages: 20</span><br><span class="line">indexed: True</span><br><span class="line">compression: none</span><br><span class="line">types:</span><br><span class="line">    - type: geometry_msgs/Twist</span><br><span class="line">      md5: 9f195f881246fdfa2798d1d3eebca84a</span><br><span class="line">topics:</span><br><span class="line">    - topic: /turtle1/cmd_vel</span><br><span class="line">      type: geometry_msgs/Twist</span><br><span class="line">      messages: 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rosbag-play"><a href="#rosbag-play" class="headerlink" title="rosbag play"></a>rosbag play</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 简单播放</span></span><br><span class="line">rosbag play &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 2 表示2倍速播放</span></span><br><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环播放</span></span><br><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只播放一部分topic</span></span><br><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始播放立刻暂停，按空格继续</span></span><br><span class="line">rosbag play --pause record.bag</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rosbag-–clock"><a href="#rosbag-–clock" class="headerlink" title="rosbag –clock"></a>rosbag –clock</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rosbag play --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -k， --keep-alive</span></span><br><span class="line">rosbag play -k  --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r FACTOR, --rate=FACTOR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。</span></span><br><span class="line">rosbag play -r 0.1 --clock recorded1.bag</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosparam set /use_sim_time true</span><br><span class="line">rosbag play --pause  --clock -k scan_odom.bag --topic /topic1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qiqiqiqi0000/article/details/</summary>
      
    
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/categories/ros/"/>
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>三维空间内旋转</title>
    <link href="https://peitianyu.github.io/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/"/>
    <id>https://peitianyu.github.io/blog/2021/11/02/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E6%97%8B%E8%BD%AC/</id>
    <published>2021-11-02T04:30:12.000Z</published>
    <updated>2021-11-02T13:07:47.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/ahelloyou/article/details/108903506?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108903506.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">旋转矩阵_ahelloyou的博客-CSDN博客_旋转矩阵</a></p><p><a href="https://blog.csdn.net/u012424737/article/details/106269229?ops_request_misc=%7B%22request_id%22:%22163585328716780271555754%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585328716780271555754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-106269229.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5&spm=1018.2226.3001.4187">机器人运动学基础——旋转矩阵_太初有泪的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/hongbin_xu/article/details/78929006?ops_request_misc=%7B%22request_id%22:%22163585334816780366567178%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163585334816780366567178&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78929006.pc_search_mgc_flag&utm_term=%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F&spm=1018.2226.3001.4187">三维重建学习(1)：基础知识：旋转矩阵与旋转向量_hongbin_xu的博客-CSDN博客_旋转向量</a></p><h1 id="简记"><a href="#简记" class="headerlink" title="简记"></a>简记</h1><p><img src="https://i.loli.net/2021/11/02/dxrQGvqahi5YN2I.jpg" alt="三位空间内的旋转"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ahelloyou/article/details/108</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>RTOS多任务访问同一个UART的操作方法</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-04T00:46:00.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q">RTOS多任务访问同一个UART的操作方法</a></p><p>在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。</p><p>处理“混乱”局面的方法比较多，下面基于<strong>FreeRTOS</strong>，以UART为例讲讲常见的<em><strong>互斥</strong></em>、<em><strong>队列</strong></em>这两种方法。</p><h3 id="互斥访问方法"><a href="#互斥访问方法" class="headerlink" title="互斥访问方法"></a><strong>互斥访问方法</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建互斥量资源</span></span><br><span class="line">SemaphoreHandle_t xSemaphore = <span class="literal">NULL</span>;</span><br><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//占用资源</span></span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xSemaphore, <span class="number">10</span> ) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//使用资源(发送数据)</span></span><br><span class="line">      USART_SendNByte();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      xSemaphoreGive(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量与互斥量区别</strong>：</p><p><strong>信号量</strong>：多个任务同步使用某个资源；</p><p>一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作；</p><p><strong>互斥量</strong>：多任务互斥使用某个资源；</p><p>一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源；</p><h3 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a><strong>队列操作方法</strong></h3><p>队列操作方法就是FIFO，先入先出的原理。比如：<strong>任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t xQueue;</span><br><span class="line">xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);</span><br><span class="line"></span><br><span class="line">xTaskCreate(UART_Send_Task, <span class="string">&quot;UART_Send&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, TASK_PRIORITY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskA_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskB_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_Send_Task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//循环读取队列BUF</span></span><br><span class="line">    <span class="keyword">if</span>(xQueueReceive(xQueue, &amp;Buf, <span class="number">10</span>) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      USART_SendNByte(&amp;Buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q&quot;&gt;</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C程序注意点</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:08:52.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A">https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A</a></p><h3 id="意想不到的八进制"><a href="#意想不到的八进制" class="headerlink" title="意想不到的八进制"></a>意想不到的八进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b为八进制</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">34</span>, b=<span class="number">034</span>; </span><br></pre></td></tr></table></figure><h3 id="指针加减运算"><a href="#指针加减运算" class="headerlink" title="指针加减运算"></a>指针加减运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="number">0x00001000</span>;  </span><br><span class="line">a=a+<span class="number">1</span>;  </span><br><span class="line">p=p+<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 这里的p是指针,</span></span><br><span class="line"><span class="comment">// p+1实际上是按照公式p+1*sizeof(int)来计算的。</span></span><br></pre></td></tr></table></figure><p>比如RAM初始化零操作,如下,只有4字节空间被初始化为零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *pRAMaddr;         <span class="comment">//定义地址指针变量  </span></span><br><span class="line"><span class="comment">// pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节</span></span><br><span class="line"><span class="keyword">for</span>(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=<span class="number">4</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">     *pRAMaddr=<span class="number">0x00000000</span>;   <span class="comment">//指定RAM地址清零  </span></span><br><span class="line">    <span class="comment">// 这里清除了四个字节</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="关键字sizeof"><a href="#关键字sizeof" class="headerlink" title="关键字sizeof"></a>关键字sizeof</h3><p><strong>sizeof</strong>是一个关键字,需要注意的是,<strong>使用sizeof获取数组长度时，不要对指针应用sizeof操作符</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearRAM</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);i++) <span class="comment">//这里用法错误，array实际上是指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">array</span>[i]=<span class="number">0x00</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> Fle[<span class="number">20</span>];  </span><br><span class="line">      </span><br><span class="line">    ClearRAM(Fle);          <span class="comment">//只能清除数组Fle中的前四个元素  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="结构体填充"><a href="#结构体填充" class="headerlink" title="结构体填充"></a>结构体填充</h3><p>结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体：</p><p>第一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">short</span> s；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">&#125;str_test1; </span><br></pre></td></tr></table></figure><p>第二个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">    <span class="keyword">short</span> s；      </span><br><span class="line">&#125;str_test2;</span><br></pre></td></tr></table></figure><p>这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？</p><p>其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下<strong>第一个结构体变量占用8个字节</strong>，<strong>第二个结构体占用12个字节</strong>，差别很大。第一个结构体变量在内存中的存储格式如图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1~4字节  cc填充SSSS</span><br><span class="line">5~8字节  XXXXXXXX</span><br></pre></td></tr></table></figure><p>第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1~4字节   cc填充</span><br><span class="line">5~8字节   XXXXXXXX</span><br><span class="line">9~12字节  ssss填充</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>软件开发中各种开发模型的优缺点</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:06:25.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/57187282">软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com)</a></p><p>可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。</p><p>但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20191209214003673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0MDY2Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。</li><li>比较适用于前期的软件开发与小型软件系统的开发中。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>无法评估项目进度。因为不知道哪个阶段会造成项目的延期</li><li>无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果</li></ul><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzNzQwMDAxNWZjYTAyNjgwMzU0LmpwZw?x-oss-process=image/format,png" alt="http://img2.mukewang.com/5d78b37400015fca02680354.jpg"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>解决需求不明确带来的风险，适用于不能提前确定项目需求的项目</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不利于开发人员对产品进行扩展</li></ul><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzN2MwMDAxZTFlMjAzOTEwMTcxLmpwZw?x-oss-process=image/format,png" alt="http://img4.mukewang.com/5d78b37c0001e1e203910171.jpg"></p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>第一个可交付版本的软件所需的成本与时间较小</li><li>能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。</li><li>最终集成各个组件时，可能会出现集成失败的风险。</li></ul><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzODUwMDAxOTYwOTAyNTcwMjI5LmpwZw?x-oss-process=image/format,png" alt="img"></p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。</li><li>大量开发人员不利于项目的管理。</li><li>该模型需要严格管理文档，会增加审核的难度增大。</li></ul><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。<br>螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示：</p><p><img src="http://hiphotos.baidu.com/wlclass/pic/item/aad0ca9597169740d0135e27.jpg" alt="img"></p><p>该模型共有四个象限，每个象限的含义如下：</p><ul><li>制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</li><li>风险分析:评价所制订的实施方案，识别风险并消除风险。</li><li>实施工程:开发产品并进行验证。</li><li>客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</li></ul><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul><li>螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。</li></ul><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul><h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。<br>敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。<br>软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。<br>该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。</p><h5 id="敏捷开发模型的价值与原则"><a href="#敏捷开发模型的价值与原则" class="headerlink" title="敏捷开发模型的价值与原则"></a>敏捷开发模型的价值与原则</h5><ul><li>个体和交互重于过程和工具</li><li>可用软件重于完备文档</li><li>客户协作重于合同谈判</li><li>响应变化重于遵循计划</li></ul><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul><li>用户很快可以看到一个基线架构版的产品</li><li>敏捷注重市场快速反应能力，客户前期满意度高。</li></ul><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul><li>注重人员的沟通</li><li>忽略文档的重要性</li><li>如果项目人员流动大太，会增加项目维护难度</li><li>软件之前版本的可重现性、可回溯性较低</li><li>对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/57187282&quot;&gt;软件开发的几种常见模型（</summary>
      
    
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>变量初始化多种操作</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T06:06:58.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ">嵌入式C语言编程时，变量、数组、指针初始化的多种操作</a></p><h1 id="数值初始化"><a href="#数值初始化" class="headerlink" title="数值初始化"></a>数值初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    inum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span>  fnum = <span class="number">0.00f</span>;</span><br><span class="line"><span class="keyword">double</span> dnum = <span class="number">0.00</span>;</span><br></pre></td></tr></table></figure><h1 id="字符初始化"><a href="#字符初始化" class="headerlink" title="字符初始化"></a>字符初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>; </span><br></pre></td></tr></table></figure><h1 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h1><p>实际上就是将字符数组中的字符都初始化为<code>&#39;\0&#39;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用&quot;&quot;实现</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 使用memset</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line"><span class="comment">//使用循环</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般使用<code>memset</code>最合适,一般采用<code>+1</code>的方式参考:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> year[<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(year, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(year));</span><br><span class="line"><span class="built_in">strcpy</span>(year,<span class="string">&quot;2018&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><p>需要使用<code>malloc</code>申请动态内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;  </span><br><span class="line">p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory Allocated at: %x\n&quot;</span>,p);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not Enough Memory!\n&quot;</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>;   <span class="comment">//这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题</span></span><br></pre></td></tr></table></figure><h1 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU stu1;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1));</span><br></pre></td></tr></table></figure><p>注意初始化结构体数组时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STU stus[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stus)); <span class="comment">//正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU));  <span class="comment">//错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU)*<span class="number">10</span>);  <span class="comment">//正确，效果与第一个是一样的</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0x00</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1)); <span class="comment">//正确,效果与第一个是一样的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>时间触发嵌入式系统设计模式</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:13:36.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/wowocpp/article/details/82887244">时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式</a></p><p><a href="https://github.com/yzhong52/SimpleTimer">SimpleTimer</a></p><p>[Linux下C实现的自定义定时器](<a href="https://github.com/voidAspire/Timer">voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)</a>)</p><p>[CppTimer](<a href="https://github.com/berndporr/cppTimer">berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)</a>)</p><p>[simple-timer-for-c-language](<a href="https://github.com/ielife/simple-timer-for-c-language">ielife/simple-timer-for-c-language: high performance timer for linux (github.com)</a>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// GPIO_LED : GPIO output to control an on-board red LED</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// EVB : Nu-LB-NUC140</span></span><br><span class="line"><span class="comment">// MCU : NUC140VE3CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// low-active output control by GPC12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NUC100Series.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MCU_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SYS_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">SCH_Update();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSysTickClk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">SCH_Init();</span><br><span class="line">    </span><br><span class="line">SysTick-&gt;LOAD = <span class="number">1000</span> *CyclesPerUs <span class="number">-1</span>;</span><br><span class="line">SysTick-&gt;VAL  = (<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">NVIC_EnableIRQ(SysTick_IRQn);</span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_Update</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">GPIO_TOGGLE(PC14);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_UpdateD</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">GPIO_TOGGLE(PC12);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYS_Init();  </span><br><span class="line">UART_Open(UART0, <span class="number">115200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);</span><br><span class="line">GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);</span><br><span class="line">GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">InitSysTickClk();</span><br><span class="line">        SCH_Add_Task(LED_Flash_Update, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">SCH_Add_Task(LED_Flash_UpdateD, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      SCH_Dispatch_Tasks();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SCHEDULER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SCHEDULER_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的函数原型 -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器内核函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (*) (<span class="keyword">void</span>), <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的常数 -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间任一时刻请求的任务最大数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间</span></span><br><span class="line"><span class="comment">// 每个新建项目都必须调整</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCH_MAX_TASKS   (3)   </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.c</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   SCH51.C (v1.00) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   /// 这里是调度器内核函数 ///</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 这里是调度器内核函数 ***</span></span><br><span class="line"><span class="comment">   --- 这些函数可以用于所有 8051 芯片 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** hSCH_MAX_TASKS 必须由用户设置 ***</span></span><br><span class="line"><span class="comment">   --- 参见 &quot;Sch51.h&quot; ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 包括省电模式***</span></span><br><span class="line"><span class="comment">   --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----）</span></span><br><span class="line"><span class="comment">   --- 诸如 c515c, c509,等等才需要 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> tByte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  tWord;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tLong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_TOO_MANY_TASKS (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CANNOT_DELETE_TASK (2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_LOST_SLAVE (5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CAN_BUS_ERROR (6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE (10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE (11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE_AT24C64 (12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE_AT24C64 (13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_DS1621 (14)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_TI (21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_WRITE_CHAR (22)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_X25_TIMEOUT (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_MAX1110_TIMEOUT (33)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_ADC_MAX150_TIMEOUT (44)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_NORMAL  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ERROR   1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用变量定义 ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用数据类型声明 ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果可能的话，存储在 DATA 区, 以供快速存取  </span></span><br><span class="line"><span class="comment">// 每个任务的存储器总和是 7个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数)</span></span><br><span class="line">   <span class="keyword">void</span> (* pTask)(<span class="keyword">void</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//延迟 (时标) 直到函数将 (下一次) 运行</span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task()</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  Delay;       </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在连续的运行之间的间隔 (时标) </span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task() </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> Period;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当任务需要运行时 (由调度器) 加1</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> RunMe;  </span><br><span class="line"></span><br><span class="line">&#125; sTask; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line">sTask SCH_tasks_G[SCH_MAX_TASKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来显示错误代码</span></span><br><span class="line"><span class="comment">// 错误代码的详细资料参见 Main.H </span></span><br><span class="line"><span class="comment">// 关于错误端口的详细资料参见 Port.H </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Error_code_G = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有函数原型  ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有变量 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟踪自从上一次记录错误以来的时间 (见下文)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  Error_tick_count_G;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上次的错误代码 (在1分钟之后复位)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Last_error_code_G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Dispatch_Tasks()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这是“调度”函数.  当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它.</span></span><br><span class="line"><span class="comment">  这个函数必须被主循环 (重复)调用.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调度 (运行) 下一个任务 (如果有任务就绪)</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">if</span> (SCH_tasks_G[Index].RunMe &gt; <span class="number">0</span>) </span><br><span class="line">      &#123;</span><br><span class="line">         (*SCH_tasks_G[Index].pTask)();  <span class="comment">// 运行任务</span></span><br><span class="line"></span><br><span class="line">         SCH_tasks_G[Index].RunMe -= <span class="number">1</span>;   <span class="comment">//  RunMe 标志复位/减1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性的任务将自动的再次运行</span></span><br><span class="line">         <span class="comment">// - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除</span></span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Period == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            SCH_Delete_Task(Index);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 报告系统状况</span></span><br><span class="line">   SCH_Report_Status();  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里调度器进行空闲模式  </span></span><br><span class="line">   SCH_Go_To_Sleep();          </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Add_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  Fn_P  - 将被调度的函数的名称.</span></span><br><span class="line"><span class="comment">          注意: 所有被调度的函数必须是 &#x27;void, void&#x27; -</span></span><br><span class="line"><span class="comment">          即函数没有参数, 并且返回类型为 void </span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">  DELAY   - 在任务第一次被运行之前的间隔（时标）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  PERIOD   -  &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次.</span></span><br><span class="line"><span class="comment">              &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些）</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  //PERIOD</span></span><br><span class="line"><span class="comment">  返回值 :   返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中</span></span><br><span class="line"><span class="comment">           (空间不够).  如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          注意: 如果以后要删除任务, 将需要这个返回值，参见  SCH_Delete_Task().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  例子:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,1000,0,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 在1000 个调度器时标之后运行一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,0,1000,1);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个调度器时标运行一次</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,300,1000,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标，</span></span><br><span class="line"><span class="comment">   2300个时标 ，等等            </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (* pFunction)(), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DELAY, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> PERIOD)</span>    </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 首先在队列中找到一个空隙(如果有的话)</span></span><br><span class="line">   <span class="keyword">while</span> ((SCH_tasks_G[Index].pTask != <span class="number">0</span>) &amp;&amp; (Index &lt; SCH_MAX_TASKS))</span><br><span class="line">      &#123;</span><br><span class="line">      Index++;</span><br><span class="line">      &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 是否已经到达队列的结尾 ？？   </span></span><br><span class="line">   <span class="keyword">if</span> (Index == SCH_MAX_TASKS)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 任务队列已满</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_TOO_MANY_TASKS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同时返回错误代码</span></span><br><span class="line">      <span class="keyword">return</span> SCH_MAX_TASKS;  </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 如果能运行到这里，说明任务队列中有空间</span></span><br><span class="line">   SCH_tasks_G[Index].pTask  = pFunction;</span><br><span class="line">     </span><br><span class="line">   SCH_tasks_G[Index].Delay  = DELAY;</span><br><span class="line">   SCH_tasks_G[Index].Period = PERIOD;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[Index].RunMe  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Index; <span class="comment">// 返回任务的位置 (以便以后删除)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Delete_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  从调度器删除任务.  注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 </span></span><br><span class="line"><span class="comment">  参数:   TASK_INDEX - 任务索引.  由 SCH_Add_Task()提供. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回值:  RETURN_ERROR or RETURN_NORMAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>  <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> tByte TASK_INDEX)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Return_code;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SCH_tasks_G[TASK_INDEX].pTask == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 这里没有任务</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ...同时返回错误代码</span></span><br><span class="line">      Return_code = RETURN_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      Return_code = RETURN_NORMAL;</span><br><span class="line">      &#125;      </span><br><span class="line">   </span><br><span class="line">   SCH_tasks_G[TASK_INDEX].pTask   = <span class="number">0x0000</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Delay   = <span class="number">0</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Period  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[TASK_INDEX].RunMe   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Return_code;       <span class="comment">// 返回状态</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Report_Status()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  用来显示错误代码的简单的函数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个版本将在连接到端口的LED上显示错误代码，</span></span><br><span class="line"><span class="comment">  如果需要的话，可以修改为通过串行连接等方式报告错误。</span></span><br><span class="line"><span class="comment">  错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。).</span></span><br><span class="line"><span class="comment">  此后错误代码被复位为0. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  更加详尽的资料参见第10章。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SCH_REPORT_ERRORS</span></span><br><span class="line">   <span class="comment">// 只在需要报告错误时适用</span></span><br><span class="line">   <span class="comment">// 检查新的错误代码</span></span><br><span class="line">   <span class="keyword">if</span> (Error_code_G != Last_error_code_G)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 假定LED采用负逻辑</span></span><br><span class="line">      Error_port = <span class="number">255</span> - Error_code_G;</span><br><span class="line">      </span><br><span class="line">      Last_error_code_G = Error_code_G;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Error_code_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">60000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> (Error_tick_count_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">if</span> (--Error_tick_count_G == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            Error_code_G = <span class="number">0</span>; <span class="comment">// 复位错误代码</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Go_To_Sleep()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。</span></span><br><span class="line"><span class="comment">  注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。</span></span><br><span class="line"><span class="comment">  然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计</span></span><br><span class="line"><span class="comment">  调度器的性能。这方面的例子参见第14章。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 如果使用看门狗的话，可能需要禁止这个功能 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 根据硬件的需要修改 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Update  中断调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   这是调度器的中断服务程序.  初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。</span></span><br><span class="line"><span class="comment">   这个版本由定时器1中断触发</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   tByte Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重装定时器</span></span><br><span class="line">   <span class="comment">// 注意：计算单位为“时标”（不是毫秒）</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 检测这里是否有任务</span></span><br><span class="line">      <span class="keyword">if</span> (SCH_tasks_G[Index].pTask)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Delay == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">// 任务需要运行</span></span><br><span class="line">            SCH_tasks_G[Index].RunMe += <span class="number">1</span>;  <span class="comment">//  &#x27;RunMe&#x27; 标志加1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SCH_tasks_G[Index].Period)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调度定期的任务再次运行</span></span><br><span class="line">               SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//还没有准备好运行，延迟减 1</span></span><br><span class="line">            SCH_tasks_G[Index].Delay -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;         </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span>  i;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SCH_MAX_TASKS; i++) </span><br><span class="line"> &#123;</span><br><span class="line">SCH_Delete_Task(i);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 复位全局错误变量</span></span><br><span class="line"> <span class="comment">// - SCH_Delete_Task() 将产生一个错误代码 </span></span><br><span class="line"> <span class="comment">//   (因为任务队列是空的)</span></span><br><span class="line"> Error_code_G = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wowocpp/article/details/82887</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式相关的开源项目</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T08:22:56.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw">https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw</a></p><h2 id="1-Avem"><a href="#1-Avem" class="headerlink" title="1.Avem"></a>1.<a href="https://github.com/avem-labs/Avem">Avem</a></h2><p>这是一个轻量级无人机飞控项目。</p><h1 id="2-Awesome-Embedded"><a href="#2-Awesome-Embedded" class="headerlink" title="2.Awesome-Embedded"></a>2.<a href="https://github.com/nhivp/Awesome-Embedded">Awesome-Embedded</a></h1><p>这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源：</p><h1 id="3-soft-and-hard"><a href="#3-soft-and-hard" class="headerlink" title="3.soft-and-hard"></a>3.<a href="https://github.com/alwxkxk/soft-and-hard">soft-and-hard</a></h1><p>这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。</p><h1 id="4-FreeModbus"><a href="#4-FreeModbus" class="headerlink" title="4.FreeModbus"></a>4.<a href="https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32">FreeModbus</a></h1><p>FreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要<strong>收费</strong>的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。</p><h1 id="5-EmbedSummary"><a href="#5-EmbedSummary" class="headerlink" title="5. EmbedSummary"></a>5.<strong><a href="https://github.com/zhengnianli/EmbedSummary"> EmbedSummary</a></strong></h1><p>精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw&quot;&gt;</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
