<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>某飞行员的随笔</title>
  
  
  <link href="https://peitianyu.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://peitianyu.github.io/blog/"/>
  <updated>2021-11-02T04:45:29.315Z</updated>
  <id>https://peitianyu.github.io/blog/</id>
  
  <author>
    <name>某飞行员</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ros_rosbag</title>
    <link href="https://peitianyu.github.io/blog/2021/11/02/rosbag/"/>
    <id>https://peitianyu.github.io/blog/2021/11/02/rosbag/</id>
    <published>2021-11-02T04:30:12.000Z</published>
    <updated>2021-11-02T04:45:29.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h2><p><a href="https://blog.csdn.net/qiqiqiqi0000/article/details/114767249?ops_request_misc=%7B%22request_id%22:%22163582490616780261970410%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582490616780261970410&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-114767249.pc_search_ecpm_flag&utm_term=rosbag&spm=1018.2226.3001.4187">(59条消息) Rosbag详细操作_Sun的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/newbeixue/article/details/110082489?ops_request_misc=%7B%22request_id%22:%22163582694116780271519523%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163582694116780271519523&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-110082489.pc_search_ecpm_flag&utm_term=rosbag+play+--clock&spm=1018.2226.3001.4187">rosbag –clock_newbeixue的博客-CSDN博客</a></p><h2 id="Rosbag基础使用"><a href="#Rosbag基础使用" class="headerlink" title="Rosbag基础使用"></a>Rosbag基础使用</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存所有topic</span></span><br><span class="line">rosbag record -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只记录某些感兴趣的 topic</span></span><br><span class="line">rosbag record /topic_name1 /topic_name2 /topic_name3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定生成数据包的名字，则用-O /-o 参数</span></span><br><span class="line">rosbag record -O filename.bag /topic_name1</span><br><span class="line"><span class="meta">#</span><span class="bash"> launch 文件中使用 rosbag record 命令</span></span><br><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rosbag info filename.bag</span><br><span class="line">rosbag info -y filename.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">xiaohu@xiaohu:~/bagfiles$  rosbag info -y 1.bag</span><br><span class="line">path: 1.bag</span><br><span class="line">version: 2.0</span><br><span class="line">duration: 3.295966</span><br><span class="line">start: 1566653873.351150</span><br><span class="line">end: 1566653876.647117</span><br><span class="line">size: 8103</span><br><span class="line">messages: 20</span><br><span class="line">indexed: True</span><br><span class="line">compression: none</span><br><span class="line">types:</span><br><span class="line">    - type: geometry_msgs/Twist</span><br><span class="line">      md5: 9f195f881246fdfa2798d1d3eebca84a</span><br><span class="line">topics:</span><br><span class="line">    - topic: /turtle1/cmd_vel</span><br><span class="line">      type: geometry_msgs/Twist</span><br><span class="line">      messages: 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rosbag-play"><a href="#rosbag-play" class="headerlink" title="rosbag play"></a>rosbag play</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 简单播放</span></span><br><span class="line">rosbag play &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 2 表示2倍速播放</span></span><br><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环播放</span></span><br><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只播放一部分topic</span></span><br><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始播放立刻暂停，按空格继续</span></span><br><span class="line">rosbag play --pause record.bag</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rosbag-–clock"><a href="#rosbag-–clock" class="headerlink" title="rosbag –clock"></a>rosbag –clock</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rosbag play --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -k， --keep-alive</span></span><br><span class="line">rosbag play -k  --clock recorded1.bag</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r FACTOR, --rate=FACTOR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将发布频率降低为原来的10%，留给滤波节点足够的时间进行处理。</span></span><br><span class="line">rosbag play -r 0.1 --clock recorded1.bag</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play --pause  --clock -k scan_odom.bag --topic /topic1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qiqiqiqi0000/article/details/</summary>
      
    
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/categories/ros/"/>
    
    
    <category term="ros" scheme="https://peitianyu.github.io/blog/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>RTOS多任务访问同一个UART的操作方法</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/RTOS%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AAUART%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T08:43:54.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q">RTOS多任务访问同一个UART的操作方法</a></p><p>在RTOS多任务编程的时候，同一个硬件（比如UART、I2C等）被多个任务访问的情况比较多，如果不合理处理，就会导致“混乱”的局面。</p><p>处理“混乱”局面的方法比较多，下面基于<strong>FreeRTOS</strong>，以UART为例讲讲常见的<em><strong>互斥</strong></em>、<em><strong>队列</strong></em>这两种方法。</p><h3 id="互斥访问方法"><a href="#互斥访问方法" class="headerlink" title="互斥访问方法"></a><strong>互斥访问方法</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建互斥量资源</span></span><br><span class="line">SemaphoreHandle_t xSemaphore = <span class="literal">NULL</span>;</span><br><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//占用资源</span></span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xSemaphore, <span class="number">10</span> ) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//使用资源(发送数据)</span></span><br><span class="line">      USART_SendNByte();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      xSemaphoreGive(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量与互斥量区别</strong>：</p><p><strong>信号量</strong>：多个任务同步使用某个资源；</p><p>一个任务完成某个动作后通过信号告诉别的任务，别的任务才可以执行某些动作；</p><p><strong>互斥量</strong>：多任务互斥使用某个资源；</p><p>一个任务占用某个资源，那么别的任务就无法访问，直到该任务离开，其他任务才可以访问该资源；</p><h3 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a><strong>队列操作方法</strong></h3><p>队列操作方法就是FIFO，先入先出的原理。比如：<strong>任务A要使用UART发送一串数据，将其加入队列； 接着任务B也要使用UART发送一串数据</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t xQueue;</span><br><span class="line">xQueue = xQueueCreate(QUEUE_LENGTH, QUEUE_ITEM_SIZE);</span><br><span class="line"></span><br><span class="line">xTaskCreate(UART_Send_Task, <span class="string">&quot;UART_Send&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, TASK_PRIORITY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskA_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//任务相关操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入队列</span></span><br><span class="line">    xQueueSend(xQueue, &amp;TaskB_Buf, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_Send_Task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//循环读取队列BUF</span></span><br><span class="line">    <span class="keyword">if</span>(xQueueReceive(xQueue, &amp;Buf, <span class="number">10</span>) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      USART_SendNByte(&amp;Buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4wWhF-Pm0vC8O0Qt5eiN-Q&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C程序注意点</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:08:52.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A">https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A</a></p><h3 id="意想不到的八进制"><a href="#意想不到的八进制" class="headerlink" title="意想不到的八进制"></a>意想不到的八进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b为八进制</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">34</span>, b=<span class="number">034</span>; </span><br></pre></td></tr></table></figure><h3 id="指针加减运算"><a href="#指针加减运算" class="headerlink" title="指针加减运算"></a>指针加减运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="number">0x00001000</span>;  </span><br><span class="line">a=a+<span class="number">1</span>;  </span><br><span class="line">p=p+<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 这里的p是指针,</span></span><br><span class="line"><span class="comment">// p+1实际上是按照公式p+1*sizeof(int)来计算的。</span></span><br></pre></td></tr></table></figure><p>比如RAM初始化零操作,如下,只有4字节空间被初始化为零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *pRAMaddr;         <span class="comment">//定义地址指针变量  </span></span><br><span class="line"><span class="comment">// pRAMaddr+=4代码其实使pRAMaddr偏移了4*sizeof(int)=16个字节</span></span><br><span class="line"><span class="keyword">for</span>(pRAMaddr=StartAddr;pRAMaddr&lt;EndAddr;pRAMaddr+=<span class="number">4</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">     *pRAMaddr=<span class="number">0x00000000</span>;   <span class="comment">//指定RAM地址清零  </span></span><br><span class="line">    <span class="comment">// 这里清除了四个字节</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="关键字sizeof"><a href="#关键字sizeof" class="headerlink" title="关键字sizeof"></a>关键字sizeof</h3><p><strong>sizeof</strong>是一个关键字,需要注意的是,<strong>使用sizeof获取数组长度时，不要对指针应用sizeof操作符</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearRAM</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);i++) <span class="comment">//这里用法错误，array实际上是指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">array</span>[i]=<span class="number">0x00</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> Fle[<span class="number">20</span>];  </span><br><span class="line">      </span><br><span class="line">    ClearRAM(Fle);          <span class="comment">//只能清除数组Fle中的前四个元素  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="结构体填充"><a href="#结构体填充" class="headerlink" title="结构体填充"></a>结构体填充</h3><p>结构体可能产生填充，因为对大多数处理器而言，访问按字或者半字对齐的数据速度更快，当定义结构体时，编译器为了性能优化，可能会将它们按照半字或字对齐，这样会带来填充问题。比如以下两个结构体：</p><p>第一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">short</span> s；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">&#125;str_test1; </span><br></pre></td></tr></table></figure><p>第二个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span>  c；  </span><br><span class="line">    <span class="keyword">int</span>   x；  </span><br><span class="line">    <span class="keyword">short</span> s；      </span><br><span class="line">&#125;str_test2;</span><br></pre></td></tr></table></figure><p>这两个结构体元素都是相同的变量，只是元素换了下位置，那么这两个结构体变量占用的内存大小相同吗？</p><p>其实这两个结构体变量占用的内存是不同的，对于Keil MDK编译器，默认情况下<strong>第一个结构体变量占用8个字节</strong>，<strong>第二个结构体占用12个字节</strong>，差别很大。第一个结构体变量在内存中的存储格式如图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1~4字节  cc填充SSSS</span><br><span class="line">5~8字节  XXXXXXXX</span><br></pre></td></tr></table></figure><p>第二个结构体变量在内存中的存储格式如图所示。对比两个图可以看出MDK编译器是是怎么将数据对齐的，这其中的填充内容是之前内存中的数据，是随机的，所以不能再结构之间逐字节比较；另外，合理的排布结构体内的元素位置，可以最大限度减少填充，节省RAM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1~4字节   cc填充</span><br><span class="line">5~8字节   XXXXXXXX</span><br><span class="line">9~12字节  ssss填充</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/sgWvpKMqetU6l6th4SRJ9A&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>软件开发中各种开发模型的优缺点</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:06:25.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h3><p><a href="https://zhuanlan.zhihu.com/p/57187282">软件开发的几种常见模型（转自于葵阳林四的博客） - 知乎 (zhihu.com)</a></p><p>可能新手或初级工程师不会在乎什么开发模型，管他三七二十一，直接开干。</p><p>但有经验的工程师都会考虑的比较周全，计划、需求、设计等各个环节考虑清楚才开始编码。下面就来说说软件开发中常见的开发模型。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>该模型是由上至下一次性完成整个项目的开发方式。该模型一共分为6个阶段，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20191209214003673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0MDY2Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在瀑布模型的开发过程中需要严格的按照这条线执行，只有完成当前阶段之后才能够进行下一阶段的开发任务。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>该模型划分出了每个阶段的检查点，当一个阶段开发完成之后，开发人员的精力可以全部的投入下个阶段，有利于提高开发效率，便于项目的管理。</li><li>比较适用于前期的软件开发与小型软件系统的开发中。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>无法评估项目进度。因为不知道哪个阶段会造成项目的延期</li><li>无法适应用户的需求变更，只能等到项目完成后，用户才能够看到项目结果</li></ul><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型模型与瀑布模型相反，项目初期根据用户的需求快速构建一个可以运行的系统原型，之后向用户展示，由用户进行审核，提出意见，然后逐步丰富项目需求。当需求真正确定后，才正式进行项目开发。模型如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzNzQwMDAxNWZjYTAyNjgwMzU0LmpwZw?x-oss-process=image/format,png" alt="http://img2.mukewang.com/5d78b37400015fca02680354.jpg"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>解决需求不明确带来的风险，适用于不能提前确定项目需求的项目</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不利于开发人员对产品进行扩展</li></ul><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型又被称作为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，之后对每个组件进行逐步的开发测试，每当完成一个组件就会向客户进行展示，让客户确认该组件功能与性能是否达到要求，最终确定无误，将组件集成到软件体系结构中。整个开发工作被分为为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析、软件设计、编码、测试这几项过程，其开发过程如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzN2MwMDAxZTFlMjAzOTEwMTcxLmpwZw?x-oss-process=image/format,png" alt="http://img4.mukewang.com/5d78b37c0001e1e203910171.jpg"></p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>第一个可交付版本的软件所需的成本与时间较小</li><li>能够适应客户的需求变更，当需求变化时，只需要修改某一个组件即可。</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>如果对用户需求的变更没有整体的规划，可能会变化为”边做边开发”的模式。</li><li>最终集成各个组件时，可能会出现集成失败的风险。</li></ul><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>该模型主要采用面向对象技术。当客户需求基本类似时，在开发过程中可以采用面向对象的开发方式，将相同的模块全部封装起来，以便于下次功能开发时使用。模型如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tdWtld2FuZy5jb20vNWQ3OGIzODUwMDAxOTYwOTAyNTcwMjI5LmpwZw?x-oss-process=image/format,png" alt="img"></p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>支持软件重用，并且开发过程无间隙性，分析、设计编码无明显边界，可交叉迭代进行。使软件在无法排除重大风险时有机会停止，以减小损失。</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>由于喷泉模型在各个阶段是重叠的，即每个对象都有分析、设计和编码阶段，所以需要大量开发人员。</li><li>大量开发人员不利于项目的管理。</li><li>该模型需要严格管理文档，会增加审核的难度增大。</li></ul><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型融合了瀑布模型，快速原型模型，该模型最大的特点就是引入了其他模型所没有的风险分析。<br>螺旋模型将开发过程都分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，在每个周期开始之前都会进行风险分析。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。模型如图所示：</p><p><img src="http://hiphotos.baidu.com/wlclass/pic/item/aad0ca9597169740d0135e27.jpg" alt="img"></p><p>该模型共有四个象限，每个象限的含义如下：</p><ul><li>制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</li><li>风险分析:评价所制订的实施方案，识别风险并消除风险。</li><li>实施工程:开发产品并进行验证。</li><li>客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</li></ul><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul><li>螺旋模型强调风险分析，对每个演化层出现的风险都所了解，继而做出应有反应。因此特别适合用于庞大、复杂并且具有高风险的系统。螺旋模型支持用户需求的动态变化有助于提高产品的适应能力。</li></ul><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul><h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>在现代社会的开发中，由于业务会经常快速的变化，因此会导致在软件开发之前经常是无法得到详细完整的开发需求，没有完整的开发需求，传统的软件开发模型也就无法适用。<br>敏捷开发模型的提出就是为了解决该问题。该模型以客户的需求为核心，采用迭代，循序渐进的方法进行开发。<br>软件项目在构建初期会被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目。开发过程中，各个子项目都要经过开发测试。当客户有需求变更时，敏捷模型能够迅速地对某个子项目做出修改以满足客户的需求。在这个过程中，软件一直处于可使用状态。<br>该模型更重视人在软件开发中的作用。软件开发过程中，各个部门需要紧密的合作沟通，为适应软件需求的频繁改变，客户可以全程参与到开发过程中。</p><h5 id="敏捷开发模型的价值与原则"><a href="#敏捷开发模型的价值与原则" class="headerlink" title="敏捷开发模型的价值与原则"></a>敏捷开发模型的价值与原则</h5><ul><li>个体和交互重于过程和工具</li><li>可用软件重于完备文档</li><li>客户协作重于合同谈判</li><li>响应变化重于遵循计划</li></ul><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul><li>用户很快可以看到一个基线架构版的产品</li><li>敏捷注重市场快速反应能力，客户前期满意度高。</li></ul><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul><li>注重人员的沟通</li><li>忽略文档的重要性</li><li>如果项目人员流动大太，会增加项目维护难度</li><li>软件之前版本的可重现性、可回溯性较低</li><li>对于较大的项目,人员越多,面对面的有效沟通越困难。因此，该模型适用于小型项目的开发。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/57187282&quot;&gt;软件开发的几种常见模型（</summary>
      
    
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>变量初始化多种操作</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T06:06:58.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ">嵌入式C语言编程时，变量、数组、指针初始化的多种操作</a></p><h1 id="数值初始化"><a href="#数值初始化" class="headerlink" title="数值初始化"></a>数值初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    inum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span>  fnum = <span class="number">0.00f</span>;</span><br><span class="line"><span class="keyword">double</span> dnum = <span class="number">0.00</span>;</span><br></pre></td></tr></table></figure><h1 id="字符初始化"><a href="#字符初始化" class="headerlink" title="字符初始化"></a>字符初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>; </span><br></pre></td></tr></table></figure><h1 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h1><p>实际上就是将字符数组中的字符都初始化为<code>&#39;\0&#39;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用&quot;&quot;实现</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 使用memset</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line"><span class="comment">//使用循环</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般使用<code>memset</code>最合适,一般采用<code>+1</code>的方式参考:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> year[<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(year, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(year));</span><br><span class="line"><span class="built_in">strcpy</span>(year,<span class="string">&quot;2018&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><p>需要使用<code>malloc</code>申请动态内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;  </span><br><span class="line">p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory Allocated at: %x\n&quot;</span>,p);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not Enough Memory!\n&quot;</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>;   <span class="comment">//这一行给指针置空必不可少，否则很可能后面操作了这个野指针而不自知，从而导致出现严重的问题</span></span><br></pre></td></tr></table></figure><h1 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU stu1;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1));</span><br></pre></td></tr></table></figure><p>注意初始化结构体数组时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STU stus[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stus)); <span class="comment">//正确，数组本身在内存里就是连续的，sizeof取出的就是数组的字节长度</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU));  <span class="comment">//错误，只会初始化第一个STU结构体，后面还有9个STU元素并未初始化</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stus, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(STU)*<span class="number">10</span>);  <span class="comment">//正确，效果与第一个是一样的</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;stu1, <span class="number">0x00</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stu1)); <span class="comment">//正确,效果与第一个是一样的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4lbQwc_O4VqXxteC2bS2gQ&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式相关的开源项目</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T08:22:56.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw">https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw</a></p><h2 id="1-Avem"><a href="#1-Avem" class="headerlink" title="1.Avem"></a>1.<a href="https://github.com/avem-labs/Avem">Avem</a></h2><p>这是一个轻量级无人机飞控项目。</p><h1 id="2-Awesome-Embedded"><a href="#2-Awesome-Embedded" class="headerlink" title="2.Awesome-Embedded"></a>2.<a href="https://github.com/nhivp/Awesome-Embedded">Awesome-Embedded</a></h1><p>这是一个很棒的嵌入式资源汇总的项目。汇聚了各种嵌入式相关的资源：</p><h1 id="3-soft-and-hard"><a href="#3-soft-and-hard" class="headerlink" title="3.soft-and-hard"></a>3.<a href="https://github.com/alwxkxk/soft-and-hard">soft-and-hard</a></h1><p>这是一个以物联网项目为主方向分享web开发教程，制作并演示一个物联网系统是怎么跑起来的，介绍如何学习相关知识。</p><h1 id="4-FreeModbus"><a href="#4-FreeModbus" class="headerlink" title="4.FreeModbus"></a>4.<a href="https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32">FreeModbus</a></h1><p>FreeModbus是一款开源的Modbus协议栈，但是只有从机开源，主机源码是需要<strong>收费</strong>的。同时网上也没有发现比较好的开源的Modbus主机协议栈，所以才开发这款支持主机模式的FreeModbus协议栈。</p><h1 id="5-EmbedSummary"><a href="#5-EmbedSummary" class="headerlink" title="5. EmbedSummary"></a>5.<strong><a href="https://github.com/zhengnianli/EmbedSummary"> EmbedSummary</a></strong></h1><p>精心汇总了一些嵌入式相关资源，包括但不限于编程语言、单片机、开源项目、物联网、操作系统、Linux等资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/UdJbDTWrnupMGYiwvKcIyw&quot;&gt;</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>时间触发嵌入式系统设计模式</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:13:36.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/wowocpp/article/details/82887244">时间触发嵌入式系统设计模式 第14章 笔记_abc-CSDN博客_时间触发嵌入式系统设计模式</a></p><p><a href="https://github.com/yzhong52/SimpleTimer">SimpleTimer</a></p><p>[Linux下C实现的自定义定时器](<a href="https://github.com/voidAspire/Timer">voidAspire/Timer: Linux下C实现的自定义定时器 (github.com)</a>)</p><p>[CppTimer](<a href="https://github.com/berndporr/cppTimer">berndporr/cppTimer: C++ timer: wrapper around the standard Linux C timer to make your life easier (github.com)</a>)</p><p>[simple-timer-for-c-language](<a href="https://github.com/ielife/simple-timer-for-c-language">ielife/simple-timer-for-c-language: high performance timer for linux (github.com)</a>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// GPIO_LED : GPIO output to control an on-board red LED</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// EVB : Nu-LB-NUC140</span></span><br><span class="line"><span class="comment">// MCU : NUC140VE3CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// low-active output control by GPC12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NUC100Series.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MCU_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SYS_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">SCH_Update();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSysTickClk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">SCH_Init();</span><br><span class="line">    </span><br><span class="line">SysTick-&gt;LOAD = <span class="number">1000</span> *CyclesPerUs <span class="number">-1</span>;</span><br><span class="line">SysTick-&gt;VAL  = (<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">NVIC_EnableIRQ(SysTick_IRQn);</span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk |SysTick_CTRL_TICKINT_Msk;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_Update</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">GPIO_TOGGLE(PC14);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Flash_UpdateD</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">GPIO_TOGGLE(PC12);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYS_Init();  </span><br><span class="line">UART_Open(UART0, <span class="number">115200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);</span><br><span class="line">GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);</span><br><span class="line">GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">InitSysTickClk();</span><br><span class="line">        SCH_Add_Task(LED_Flash_Update, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">SCH_Add_Task(LED_Flash_UpdateD, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      SCH_Dispatch_Tasks();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SCHEDULER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SCHEDULER_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的函数原型 -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器内核函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (*) (<span class="keyword">void</span>), <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用的常数 -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间任一时刻请求的任务最大数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的运行期间</span></span><br><span class="line"><span class="comment">// 每个新建项目都必须调整</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCH_MAX_TASKS   (3)   </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.c</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   SCH51.C (v1.00) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   /// 这里是调度器内核函数 ///</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 这里是调度器内核函数 ***</span></span><br><span class="line"><span class="comment">   --- 这些函数可以用于所有 8051 芯片 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** hSCH_MAX_TASKS 必须由用户设置 ***</span></span><br><span class="line"><span class="comment">   --- 参见 &quot;Sch51.h&quot; ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *** 包括省电模式***</span></span><br><span class="line"><span class="comment">   --- 必须确认省电模式被修改以适用于所选定的芯片（通常只有在使用扩展8051----）</span></span><br><span class="line"><span class="comment">   --- 诸如 c515c, c509,等等才需要 ---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> tByte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  tWord;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tLong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_TOO_MANY_TASKS (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CANNOT_DELETE_TASK (2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_SLAVE_TO_ACK (3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_WAITING_FOR_START_COMMAND_FROM_MASTER (3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_ONE_OR_MORE_SLAVES_DID_NOT_START (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_LOST_SLAVE (5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SCH_CAN_BUS_ERROR (6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE (10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE (11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_WRITE_BYTE_AT24C64 (12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_READ_BYTE_AT24C64 (13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_I2C_DS1621 (14)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_TI (21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_USART_WRITE_CHAR (22)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_EXCHANGE_BYTES_TIMEOUT (31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_X25_TIMEOUT (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_SPI_MAX1110_TIMEOUT (33)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_ADC_MAX150_TIMEOUT (44)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_NORMAL  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ERROR   1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用变量定义 ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 公用数据类型声明 ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果可能的话，存储在 DATA 区, 以供快速存取  </span></span><br><span class="line"><span class="comment">// 每个任务的存储器总和是 7个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 指向任务的指针 (必须是 &#x27;void (void)&#x27; 函数)</span></span><br><span class="line">   <span class="keyword">void</span> (* pTask)(<span class="keyword">void</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//延迟 (时标) 直到函数将 (下一次) 运行</span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task()</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  Delay;       </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在连续的运行之间的间隔 (时标) </span></span><br><span class="line">   <span class="comment">// - 详细说明参见 SCH_Add_Task() </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> Period;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当任务需要运行时 (由调度器) 加1</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> RunMe;  </span><br><span class="line"></span><br><span class="line">&#125; sTask; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line">sTask SCH_tasks_G[SCH_MAX_TASKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来显示错误代码</span></span><br><span class="line"><span class="comment">// 错误代码的详细资料参见 Main.H </span></span><br><span class="line"><span class="comment">// 关于错误端口的详细资料参见 Port.H </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Error_code_G = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有函数原型  ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 私有变量 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟踪自从上一次记录错误以来的时间 (见下文)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>  Error_tick_count_G;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上次的错误代码 (在1分钟之后复位)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Last_error_code_G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Dispatch_Tasks()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这是“调度”函数.  当一个任务 (函数)需要运行时， SCH_Dispatch_Tasks() 将运行它.</span></span><br><span class="line"><span class="comment">  这个函数必须被主循环 (重复)调用.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Dispatch_Tasks</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调度 (运行) 下一个任务 (如果有任务就绪)</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">if</span> (SCH_tasks_G[Index].RunMe &gt; <span class="number">0</span>) </span><br><span class="line">      &#123;</span><br><span class="line">         (*SCH_tasks_G[Index].pTask)();  <span class="comment">// 运行任务</span></span><br><span class="line"></span><br><span class="line">         SCH_tasks_G[Index].RunMe -= <span class="number">1</span>;   <span class="comment">//  RunMe 标志复位/减1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性的任务将自动的再次运行</span></span><br><span class="line">         <span class="comment">// - 如果这是个&#x27;单次&#x27; 任务, 将它从队列中删除</span></span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Period == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            SCH_Delete_Task(Index);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 报告系统状况</span></span><br><span class="line">   SCH_Report_Status();  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里调度器进行空闲模式  </span></span><br><span class="line">   SCH_Go_To_Sleep();          </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Add_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 使用任务 (函数) 每隔一定时隔或在用户定义的延迟之后 运行</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  Fn_P  - 将被调度的函数的名称.</span></span><br><span class="line"><span class="comment">          注意: 所有被调度的函数必须是 &#x27;void, void&#x27; -</span></span><br><span class="line"><span class="comment">          即函数没有参数, 并且返回类型为 void </span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">  DELAY   - 在任务第一次被运行之前的间隔（时标）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  PERIOD   -  &#x27;PERIOD&#x27; 如果为 0, 则该函数u将在由“DELAY”g确定的时间被调用一次.</span></span><br><span class="line"><span class="comment">              &#x27;PERIOD&#x27; 如果非 0, 那么该函数将按PERIOD的值所确定的间隔被重复调用（下面的例子将有助于理解这些）</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  //PERIOD</span></span><br><span class="line"><span class="comment">  返回值 :   返回被添加任务在任务队列中的位置.如果返回值是SCH_MAX_TASKS ，那么该任务不能被加到队列中</span></span><br><span class="line"><span class="comment">           (空间不够).  如果返回值 &lt; SCH_MAX_TASKS, 那么该任务被成功添加。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          注意: 如果以后要删除任务, 将需要这个返回值，参见  SCH_Delete_Task().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  例子:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,1000,0,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 在1000 个调度器时标之后运行一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,0,1000,1);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个调度器时标运行一次</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Task_ID = SCH_Add_Task(Do_X,300,1000,0);</span></span><br><span class="line"><span class="comment">   使函数 Do_X() 每隔1000 个时标定时运行一次。任务将首先在T=300个时标时被执行，然后是1300个时标，</span></span><br><span class="line"><span class="comment">   2300个时标 ，等等            </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">SCH_Add_Task</span><span class="params">(<span class="keyword">void</span> (* pFunction)(), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DELAY, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> PERIOD)</span>    </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Index = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 首先在队列中找到一个空隙(如果有的话)</span></span><br><span class="line">   <span class="keyword">while</span> ((SCH_tasks_G[Index].pTask != <span class="number">0</span>) &amp;&amp; (Index &lt; SCH_MAX_TASKS))</span><br><span class="line">      &#123;</span><br><span class="line">      Index++;</span><br><span class="line">      &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 是否已经到达队列的结尾 ？？   </span></span><br><span class="line">   <span class="keyword">if</span> (Index == SCH_MAX_TASKS)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 任务队列已满</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_TOO_MANY_TASKS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同时返回错误代码</span></span><br><span class="line">      <span class="keyword">return</span> SCH_MAX_TASKS;  </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 如果能运行到这里，说明任务队列中有空间</span></span><br><span class="line">   SCH_tasks_G[Index].pTask  = pFunction;</span><br><span class="line">     </span><br><span class="line">   SCH_tasks_G[Index].Delay  = DELAY;</span><br><span class="line">   SCH_tasks_G[Index].Period = PERIOD;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[Index].RunMe  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Index; <span class="comment">// 返回任务的位置 (以便以后删除)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Delete_Task()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  从调度器删除任务.  注意：并不从存储器中删除相关的函数。仅仅是不再由调度器调用这个函数 </span></span><br><span class="line"><span class="comment">  参数:   TASK_INDEX - 任务索引.  由 SCH_Add_Task()提供. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回值:  RETURN_ERROR or RETURN_NORMAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>  <span class="title">SCH_Delete_Task</span><span class="params">(<span class="keyword">const</span> tByte TASK_INDEX)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Return_code;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SCH_tasks_G[TASK_INDEX].pTask == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 这里没有任务</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 设置全局错误变量</span></span><br><span class="line">      Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ...同时返回错误代码</span></span><br><span class="line">      Return_code = RETURN_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      Return_code = RETURN_NORMAL;</span><br><span class="line">      &#125;      </span><br><span class="line">   </span><br><span class="line">   SCH_tasks_G[TASK_INDEX].pTask   = <span class="number">0x0000</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Delay   = <span class="number">0</span>;</span><br><span class="line">   SCH_tasks_G[TASK_INDEX].Period  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   SCH_tasks_G[TASK_INDEX].RunMe   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Return_code;       <span class="comment">// 返回状态</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Report_Status()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  用来显示错误代码的简单的函数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个版本将在连接到端口的LED上显示错误代码，</span></span><br><span class="line"><span class="comment">  如果需要的话，可以修改为通过串行连接等方式报告错误。</span></span><br><span class="line"><span class="comment">  错误只在有限的时间内显示(在 1ms 时标间隔时，60000 时标 = 1 分钟 。).</span></span><br><span class="line"><span class="comment">  此后错误代码被复位为0. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这些代码可以很容易的修改为“永远”显示最近的错误。这对于系统可能更为合理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  更加详尽的资料参见第10章。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Report_Status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SCH_REPORT_ERRORS</span></span><br><span class="line">   <span class="comment">// 只在需要报告错误时适用</span></span><br><span class="line">   <span class="comment">// 检查新的错误代码</span></span><br><span class="line">   <span class="keyword">if</span> (Error_code_G != Last_error_code_G)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 假定LED采用负逻辑</span></span><br><span class="line">      Error_port = <span class="number">255</span> - Error_code_G;</span><br><span class="line">      </span><br><span class="line">      Last_error_code_G = Error_code_G;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Error_code_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">60000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">         Error_tick_count_G = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> (Error_tick_count_G != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">if</span> (--Error_tick_count_G == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            Error_code_G = <span class="number">0</span>; <span class="comment">// 复位错误代码</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Go_To_Sleep()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  本调度器在时钟时标之间将进入空闲模式来节省功耗。下一个时钟时标将使处理器返回到正常工作状态。</span></span><br><span class="line"><span class="comment">  注意: 如果这个函数由宏来实现，或简单地将这里的代码粘贴到“调度”函数中，可以有少量的性能改善。</span></span><br><span class="line"><span class="comment">  然而，通过采用函数调用的方式来实现，可以在开发期间更容易的使用Keil硬件模拟器中的“性能分析器”来估计</span></span><br><span class="line"><span class="comment">  调度器的性能。这方面的例子参见第14章。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 如果使用看门狗的话，可能需要禁止这个功能 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *** 根据硬件的需要修改 ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Go_To_Sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SCH_Update  中断调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   这是调度器的中断服务程序.  初始化函数 SCH_Init_T1()中的定时器设置决定了它的调用频率。</span></span><br><span class="line"><span class="comment">   这个版本由定时器1中断触发</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">-*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCH_Update</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   tByte Index;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重装定时器</span></span><br><span class="line">   <span class="comment">// 注意：计算单位为“时标”（不是毫秒）</span></span><br><span class="line">   <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; SCH_MAX_TASKS; Index++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 检测这里是否有任务</span></span><br><span class="line">      <span class="keyword">if</span> (SCH_tasks_G[Index].pTask)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (SCH_tasks_G[Index].Delay == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">// 任务需要运行</span></span><br><span class="line">            SCH_tasks_G[Index].RunMe += <span class="number">1</span>;  <span class="comment">//  &#x27;RunMe&#x27; 标志加1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SCH_tasks_G[Index].Period)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调度定期的任务再次运行</span></span><br><span class="line">               SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//还没有准备好运行，延迟减 1</span></span><br><span class="line">            SCH_tasks_G[Index].Delay -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;         </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SCH_Init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span>  i;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SCH_MAX_TASKS; i++) </span><br><span class="line"> &#123;</span><br><span class="line">SCH_Delete_Task(i);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 复位全局错误变量</span></span><br><span class="line"> <span class="comment">// - SCH_Delete_Task() 将产生一个错误代码 </span></span><br><span class="line"> <span class="comment">//   (因为任务队列是空的)</span></span><br><span class="line"> Error_code_G = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wowocpp/article/details/82887</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://peitianyu.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>注释软件</title>
    <link href="https://peitianyu.github.io/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/"/>
    <id>https://peitianyu.github.io/blog/2021/11/01/%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-11-01T04:30:12.000Z</published>
    <updated>2021-11-01T09:07:34.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://mp.weixin.qq.com/s/F2wN5Bbqqv_3R1gAlA19Pw">几款注释软件推荐</a></p><h1 id="javE"><a href="#javE" class="headerlink" title="javE"></a>javE</h1><p><strong><a href="http://www.jave.de/">http://www.jave.de/</a></strong></p><p>里边的字体,图片生成挺有意思,不过需要装java</p><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><strong><a href="https://josoansi.de/download.php">https://josoansi.de/download.php</a></strong></p><p><img src="https://josoansi.de/images/screenshot128.jpg" alt="Screenshot AACircuit 1.28"></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><a href="http://www.ascii-art.de/">ascii-art</a></p><p>有很多有意思的注释,可知看一下直接复制粘贴,很舒爽</p><p><a href="https://www.codeproject.com/Articles/4514/CodePlotter-1-6-Add-and-edit-diagrams-in-your-code">CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject</a></p><p>类似于”Visio”的一款工具</p><p><img src="https://www.codeproject.com/KB/macros/codeplotter/CodePlotter.jpg" alt="Sample Image - CodePlotter.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/F2wN5Bbqqv_3R1gAlA19Pw&quot;&gt;</summary>
      
    
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/categories/tool/"/>
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>RTOS应用程序稳定</title>
    <link href="https://peitianyu.github.io/blog/2021/10/29/RTOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%A8%B3%E5%AE%9A/"/>
    <id>https://peitianyu.github.io/blog/2021/10/29/RTOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%A8%B3%E5%AE%9A/</id>
    <published>2021-10-29T04:30:12.000Z</published>
    <updated>2021-11-01T12:01:45.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站:"></a>参考网站:</h1><p><a href="https://www.eet-china.com/mp/a69844.html">提高RTOS应用程序稳定可靠的几点技巧-面包板社区 (eet-china.com)</a></p><p><a href="https://blog.csdn.net/weixin_42616791/article/details/108548128?ops_request_misc=%7B%22request_id%22:%22163576619116780366553575%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163576619116780366553575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-108548128.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">RTOS 是如何进行任务划分的？_wenzi嵌入式软件的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35021496/article/details/81035750?ops_request_misc=%7B%22request_id%22:%22163576619116780271563446%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163576619116780271563446&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81035750.pc_search_ecpm_flag&utm_term=+RTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86&spm=1018.2226.3001.4187">UCOS 等 RTOS的任务划分原则（转载整理）_Dr树树的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站:&quot;&gt;&lt;/a&gt;参考网站:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.eet-china.com/mp/a69844.html&quot;&gt;提高RTOS应用程</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="https://peitianyu.github.io/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://peitianyu.github.io/blog/2021/10/29/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-29T04:30:12.000Z</published>
    <updated>2021-10-29T10:23:09.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/baidu_38172402/article/details/95119014?ops_request_misc=%7B%22request_id%22:%22163409375616780261926822%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163409375616780261926822&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-95119014.pc_search_ecpm_flag&utm_term=c%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">c语言回调函数</a></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 函数指针结构体</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OP</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_add)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_sub)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_mul)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*p_div)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">&#125; OP; </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 加减乘除函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADD</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SUB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MUL</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">DIV</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 初始化函数指针</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_op</span><span class="params">(OP *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op-&gt;p_add = ADD;</span><br><span class="line">    op-&gt;p_sub = SUB;</span><br><span class="line">    op-&gt;p_mul = &amp;MUL;</span><br><span class="line">    op-&gt;p_div = &amp;DIV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 库函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_sub_mul_div</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> (*op_func)(<span class="keyword">float</span>, <span class="keyword">float</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*op_func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OP *op = (OP *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(OP)); </span><br><span class="line">    <span class="built_in">init_op</span>(op);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 直接使用函数指针调用函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, (op-&gt;p_add)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_sub)(<span class="number">1.3</span>, <span class="number">2.2</span>), </span><br><span class="line">            (op-&gt;p_mul)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_div)(<span class="number">1.3</span>, <span class="number">2.2</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 调用回调函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADD = %f, SUB = %f, MUL = %f, DIV = %f\n&quot;</span>, </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, ADD), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, SUB), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, MUL), </span><br><span class="line">            <span class="built_in">add_sub_mul_div</span>(<span class="number">1.3</span>, <span class="number">2.2</span>, DIV));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站&quot;&gt;&lt;/a&gt;参考网站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_38172402/article/details/</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>坐标的四种表示方式</title>
    <link href="https://peitianyu.github.io/blog/2021/10/29/%E5%9D%90%E6%A0%87%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F/"/>
    <id>https://peitianyu.github.io/blog/2021/10/29/%E5%9D%90%E6%A0%87%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-29T04:30:12.000Z</published>
    <updated>2021-11-01T09:09:38.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="坐标表示"><a href="#坐标表示" class="headerlink" title="坐标表示"></a>坐标表示</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;坐标表示&quot;&gt;&lt;a href=&quot;#坐标表示&quot; class=&quot;headerlink&quot; title=&quot;坐标表示&quot;&gt;&lt;/a&gt;坐标表示&lt;/h1&gt;</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>局部全局坐标转换</title>
    <link href="https://peitianyu.github.io/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>https://peitianyu.github.io/blog/2021/10/29/%E5%B1%80%E9%83%A8%E5%85%A8%E5%B1%80%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-10-29T04:30:12.000Z</published>
    <updated>2021-10-29T10:24:19.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局部全局坐标转换"><a href="#局部全局坐标转换" class="headerlink" title="局部全局坐标转换"></a>局部全局坐标转换</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="https://i.loli.net/2021/10/29/QfTymrLqs7AG6a2.png" alt="image-20211029181117606.png"></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h2><p><img src="https://i.loli.net/2021/10/29/7ht1yaPc3E26zBF.png" alt="image-20211029180943040.png"></p><h2 id="ROS-中里程计的计算代码理解"><a href="#ROS-中里程计的计算代码理解" class="headerlink" title="ROS 中里程计的计算代码理解"></a>ROS 中里程计的计算代码理解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dt = (current_time - last_time).<span class="built_in">toSec</span>();</span><br><span class="line"><span class="keyword">double</span> delta_x = (vx * <span class="built_in">cos</span>(th) - vy * <span class="built_in">sin</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_y = (vx * <span class="built_in">sin</span>(th) + vy * <span class="built_in">cos</span>(th)) * dt;</span><br><span class="line"><span class="keyword">double</span> delta_th = vth * dt;</span><br><span class="line"></span><br><span class="line">x += delta_x;</span><br><span class="line">y += delta_y;</span><br><span class="line">th += delta_th;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;局部全局坐标转换&quot;&gt;&lt;a href=&quot;#局部全局坐标转换&quot; class=&quot;headerlink&quot; title=&quot;局部全局坐标转换&quot;&gt;&lt;/a&gt;局部全局坐标转换&lt;/h1&gt;&lt;h2 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>STL库</title>
    <link href="https://peitianyu.github.io/blog/2021/10/28/STL/"/>
    <id>https://peitianyu.github.io/blog/2021/10/28/STL/</id>
    <published>2021-10-28T04:30:12.000Z</published>
    <updated>2021-10-28T13:39:17.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%7B%22request_id%22:%22163533629716780357269545%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163533629716780357269545&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81913729.pc_search_ecpm_flag&utm_term=c+++stl&spm=1018.2226.3001.4187">C++中STL用法超详细总结</a></p><p><a href="https://github.com/peitianyu/MyTinySTL.git">MyTinySTL</a></p><h2 id="STL中六大组件："><a href="#STL中六大组件：" class="headerlink" title="STL中六大组件："></a>STL中六大组件：</h2><p><strong>容器（Container）</strong>，是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p><p><strong>迭代器（Iterator）</strong>，提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；<br><strong>算法（Algorithm）</strong>，是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；<br><strong>仿函数（Functor</strong>）<br><strong>适配器（Adaptor）</strong><br><strong>分配器（allocator</strong>）</p><h3 id="2-1-容器"><a href="#2-1-容器" class="headerlink" title="2.1 容器"></a>2.1 容器</h3><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       <strong>Vector</strong>：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>Deque</strong>：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       <strong>List</strong>：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       <strong>Set/Multiset</strong>：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       <strong>Map/Multimap</strong>：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p><p>容器类自动申请和释放内存，无需new和delete操作。</p><h3 id="2-2-STL迭代器"><a href="#2-2-STL迭代器" class="headerlink" title="2.2 STL迭代器"></a>2.2 STL迭代器</h3><p><strong>Iterator</strong>（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p><p><strong>迭代器的作用</strong>：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h3><h4 id="STL中算法大致分为四类："><a href="#STL中算法大致分为四类：" class="headerlink" title="STL中算法大致分为四类："></a>STL中算法大致分为四类：</h4><p><strong>非可变序列算法</strong>：指不直接修改其所操作的容器内容的算法。<br><strong>可变序列算法</strong>：指可以修改它们所操作的容器内容的算法。<br><strong>排序算法</strong>：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。<br><strong>数值算法</strong>：对容器内容进行数值计算。<br>以下对所有算法进行细致分类并标明功能：</p><h4 id="lt-一-gt-查找算法-13个-：判断容器中是否包含某个值"><a href="#lt-一-gt-查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值"></a>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</h4><p>adjacent_find:   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的                                                 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>count:                利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>count_if:            利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>equal_range:     功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。<br>find:                   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的                               一个InputIterator。<br>find_end:          在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一                            个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代                               替等于操作。<br>find_first_of:     在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使                             用了用户自定义操作符。<br>find_if:               使用输入的函数代替等于操作符执行find。<br>lower_bound:   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函                             数使用自定义比较操作。<br>upper_bound:  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志                               一个大于value的值。重载函数使用自定义比较操作。<br>search:              给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位                                 置，查找失败指向last1。重载版本使用自定义的比较操作。<br>search_n:          在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p><h4 id="lt-二-gt-排序和通用算法-14个-：提供元素排序策略"><a href="#lt-二-gt-排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="&lt;二&gt;排序和通用算法(14个)：提供元素排序策略"></a>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</h4><p>inplace_merge:      合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>merge:                    合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>nth_element:          将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重                                    载版本使用自定义的比较操作。<br>partial_sort:            对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>partition:                 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>random_shuffle:    对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>reverse:                  将指定范围内元素重新反序排序。<br>reverse_copy:        与reverse类似，不过将结果写入另一个容器。<br>rotate:                     将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>rotate_copy:           与rotate类似，不过将结果写入另一个容器。<br>sort:                         以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>stable_sort:            与sort类似，不过保留相等元素之间的顺序关系。<br>stable_partition:    与partition类似，不过不保证保留容器中的相对顺序。</p><h4 id="lt-三-gt-删除和替换算法-15个"><a href="#lt-三-gt-删除和替换算法-15个" class="headerlink" title="&lt;三&gt;删除和替换算法(15个)"></a>&lt;三&gt;删除和替换算法(15个)</h4><p>copy:                    复制序列<br>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>iter_swap:           交换两个ForwardIterator的值。<br>remove:               删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和                               remove_if函数。<br>remove_copy:     将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>remove_if:           删除指定范围内输入操作结果为true的所有元素。<br>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>replace:               将指定范围内所有等于vold的元素都用vnew代替。<br>replace_copy:     与replace类似，不过将结果写入另一个容器。<br>replace_if:           将指定范围内所有操作结果为true的元素用新值代替。<br>replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>swap:                   交换存储在两个对象中的值。<br>swap_range:       将指定范围内的元素与另一个序列元素值进行交换。<br>unique:                清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>unique_copy:      与unique类似，不过把结果输出到另一个容器。</p><h4 id="lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合"><a href="#lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合" class="headerlink" title="&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合"></a>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</h4><p>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p><h4 id="lt-五-gt-算术算法-4个"><a href="#lt-五-gt-算术算法-4个" class="headerlink" title="&lt;五&gt;算术算法(4个)"></a>&lt;五&gt;算术算法(4个)</h4><p>accumulate:               iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>partial_sum:               创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>inner_product:           对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p><h4 id="lt-六-gt-生成和异变算法-6个"><a href="#lt-六-gt-生成和异变算法-6个" class="headerlink" title="&lt;六&gt;生成和异变算法(6个)"></a>&lt;六&gt;生成和异变算法(6个)</h4><p>fill:                 将输入值赋给标志范围内的所有元素。<br>fill_n:            将输入值赋给first到first+n范围内的所有元素。<br>for_each:      用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>generate:      连续调用输入的函数来填充指定的范围。<br>generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>transform:    将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p><h4 id="lt-七-gt-关系算法-8个"><a href="#lt-七-gt-关系算法-8个" class="headerlink" title="&lt;七&gt;关系算法(8个)"></a>&lt;七&gt;关系算法(8个)</h4><p>equal:                                  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>includes:                             判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>max:                                     返回两个元素中较大一个。重载版本使用自定义比较操作。<br>max_element:                      返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>min:                                      返回两个元素中较小一个。重载版本使用自定义比较操作。<br>min_element:                       返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>mismatch:                            并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p><h4 id="lt-八-gt-集合算法-4个"><a href="#lt-八-gt-集合算法-4个" class="headerlink" title="&lt;八&gt;集合算法(4个)"></a>&lt;八&gt;集合算法(4个)</h4><p>set_union:                            构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>set_intersection:                 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>set_difference:                    构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用 自定义的比较操作。<br>set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</p><h4 id="lt-九-gt-堆算法-4个"><a href="#lt-九-gt-堆算法-4个" class="headerlink" title="&lt;九&gt;堆算法(4个)"></a>&lt;九&gt;堆算法(4个)</h4><p>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>pop_heap:   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>sort_heap:  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p><h3 id="2-4-仿函数"><a href="#2-4-仿函数" class="headerlink" title="2.4 仿函数"></a>2.4 仿函数</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><pre><code>    仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。</code></pre><p>　　有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。</p><pre><code>   1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。   2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。</code></pre><h4 id="2-4-2-仿函数-functor-在编程语言中的应用"><a href="#2-4-2-仿函数-functor-在编程语言中的应用" class="headerlink" title="2.4.2 仿函数(functor)在编程语言中的应用"></a>2.4.2 仿函数(functor)在编程语言中的应用</h4><p>1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//int sort_function( const void *a, const void *b);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> list[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line">   <span class="built_in">qsort</span>((<span class="keyword">void</span> *)list, <span class="number">5</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(list[<span class="number">0</span>]), sort_function);<span class="comment">//起始地址，个数，元素大小，回调函数 </span></span><br><span class="line">   <span class="keyword">int</span>  x;</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, list[x]);</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">for_each(ia, ia + <span class="number">5</span>, display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-仿函数在STL中的定义"><a href="#2-4-3-仿函数在STL中的定义" class="headerlink" title="2.4.3 仿函数在STL中的定义"></a>2.4.3 仿函数在STL中的定义</h4><p>要使用STL内建的仿函数，必须包含<functional>头文件。而头文件中包含的仿函数分类包括</p><pre><code>1）算术类仿函数    加：plus&lt;T&gt;    减：minus&lt;T&gt;    乘：multiplies&lt;T&gt;    除：divides&lt;T&gt;    模取：modulus&lt;T&gt;    否定：negate&lt;T&gt;</code></pre><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">//120</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>, multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line">cout &lt;&lt; multiplies&lt;<span class="keyword">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">modulus&lt;<span class="keyword">int</span>&gt;  modulusObj;</span><br><span class="line">cout &lt;&lt; <span class="built_in">modulusObj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2）关系运算类仿函数</p><pre><code>           等于：equal_to&lt;T&gt;           不等于：not_equal_to&lt;T&gt;           大于：greater&lt;T&gt;           大于等于：greater_equal&lt;T&gt;           小于：less&lt;T&gt;           小于等于：less_equal&lt;T&gt;          从大到小排序：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3）逻辑运算仿函数</p><pre><code>             逻辑与：logical_and&lt;T&gt;             逻辑或：logical_or&lt;T&gt;             逻辑否：logical_no&lt;T&gt;</code></pre><p>除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结</p><h3 id="2-5-容器适配器"><a href="#2-5-容器适配器" class="headerlink" title="2.5 容器适配器"></a>2.5 容器适配器</h3><p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p><p>什么是容器适配器<br>   ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例        如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出      了栈的行为）。</p><p>容器适配器<br>   要使用适配器，需要加入一下头文件：</p><pre><code>#include &lt;stack&gt;        //stack#include&lt;queue&gt;       //queue、priority_queue</code></pre><p>种类    默认顺序容器    可用顺序容器    说明<br>stack    deque    vector、list、deque<br>queue    deque    list、deque    基础容器必须提供push_front()运算<br>priority_queue    vector    vector、deque    基础容器必须提供随机访问功能<br>定义适配器<br>  1、初始化</p><pre><code>    stack&lt;int&gt; stk(dep);</code></pre><p>  2、覆盖默认容器类型</p><pre><code>   stack&lt;int,vector&lt;int&gt; &gt; stk;</code></pre><p>使用适配器</p><h4 id="2-5-1-stack"><a href="#2-5-1-stack" class="headerlink" title="2.5.1 stack"></a>2.5.1 stack</h4><p>stack<int> s;<br>stack&lt; int, vector<int> &gt; stk;  //覆盖基础容器类型，使用vector实现stk<br>s.empty();  //判断stack是否为空，为空返回true，否则返回false<br>s.size();   //返回stack中元素的个数<br>s.pop();    //删除栈顶元素，但不返回其值<br>s.top();    //返回栈顶元素的值，但不删除此元素<br>s.push(item);   //在栈顶压入新元素item<br>实例：括号匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s)  <span class="comment">//C++11新标准，即遍历一次字符串s</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss.<span class="built_in">push</span>(c);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; ss.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)cout &lt;&lt; <span class="string">&quot;Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;Not Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-queue-amp-priority-queue"><a href="#2-5-2-queue-amp-priority-queue" class="headerlink" title="2.5.2 queue &amp; priority_queue"></a>2.5.2 queue &amp; priority_queue</h4><p>queue<int> q; //priority_queue<int> q;<br>q.empty();  //判断队列是否为空<br>q.size();   //返回队列长度<br>q.push(item);   //对于queue，在队尾压入一个新元素<br>               //对于priority_queue，在基于优先级的适当位置插入新元素</p><p>//queue only:<br>q.front();  //返回队首元素的值，但不删除该元素<br>q.back();   //返回队尾元素的值，但不删除该元素</p><p>//priority_queue only:<br>q.top();    //返回具有最高优先级的元素值，但不删除该元素</p><h2 id="常用容器用法介绍"><a href="#常用容器用法介绍" class="headerlink" title="常用容器用法介绍"></a>常用容器用法介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h5><p>vector():创建一个空vector<br>vector(int nSize):创建一个vector,元素个数为nSize<br>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>vector(const vector&amp;):复制构造函数<br>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p><h5 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h5><p>void push_back(const T&amp; x):向量尾部增加一个元素X<br>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p><h5 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h5><p>iterator erase(iterator it):删除向量中迭代器指向元素<br>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>void pop_back():删除向量中最后一个元素<br>void clear():清空向量中所有元素</p><h5 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h5><p>reference at(int pos):返回pos位置元素的引用<br>reference front():返回首元素的引用<br>reference back():返回尾元素的引用<br>iterator begin():返回向量头指针，指向第一个元素<br>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p><h5 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h5><p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p><h5 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h5><p>int size() const:返回向量中元素的个数<br>int capacity() const:返回当前向量张红所能容纳的最大元素值<br>int max_size() const:返回最大可允许的vector元素数量值</p><h5 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h5><p>void swap(vector&amp;):交换两个同类型向量的数据<br>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p><h5 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h5><p>1.push_back 在数组的最后添加一个数据</p><p>2.pop_back 去掉数组的最后一个数据</p><p>3.at 得到编号位置的数据</p><p>4.begin 得到数组头的指针</p><p>5.end 得到数组的最后一个单元+1的指针</p><p>6．front 得到数组头的引用</p><p>7.back 得到数组的最后一个单元的引用</p><p>8.max_size 得到vector最大可以是多大</p><p>9.capacity 当前vector分配的大小</p><p>10.size 当前使用数据的大小</p><p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p><p>12.reserve 改变当前vecotr所分配空间的大小</p><p>13.erase 删除指针指向的数据项</p><p>14.clear 清空当前的vector</p><p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p><p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p><p>17.empty 判断vector是否为空</p><p>18.swap 与另一个vector交换数据</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>#include &lt; vector&gt;<br>using namespace std;</p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>Vector&lt;类型&gt;标识符<br>Vector&lt;类型&gt;标识符(最大容量)<br>Vector&lt;类型&gt;标识符(最大容量,初始所有值)<br>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值<br>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#3-1-4-1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a>3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//去掉数组最后一个数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)<span class="comment">//size()容器中实际数据个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br><span class="line"></span><br><span class="line">0,1,2,3,4,</span><br></pre></td></tr></table></figure><h5 id="clear-清除容器中所有数据"><a href="#clear-清除容器中所有数据" class="headerlink" title="clear()清除容器中所有数据"></a>clear()清除容器中所有数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">clear</span>();<span class="comment">//清除容器中所以数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sort</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从小到大</span></span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从小到大:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从大到小:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从大到小 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从小到大:</span><br><span class="line">0,1,3,</span><br><span class="line"></span><br><span class="line">从大到小:</span><br><span class="line">3,1,0,</span><br></pre></td></tr></table></figure><p>1.注意 sort 需要头文件 #include <algorithm></p><p>2.如果想 sort 来降序，可重写 sort</p><p>bool compare(int a,int b)<br>{<br>    return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序<br>}<br>int a[20]={2,4,1,23,5,76,0,43,24,65},i;<br>for(i=0;i&lt;20;i++)<br>    cout&lt;&lt; a[i]&lt;&lt; endl;<br>sort(a,a+20,compare);</p><h5 id="访问（直接数组访问-amp-迭代器访问）"><a href="#访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="访问（直接数组访问&amp;迭代器访问）"></a>访问（直接数组访问&amp;迭代器访问）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序访问</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);   </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;直接利用数组：&quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//方法一 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;利用迭代器：&quot;</span> ;</span><br><span class="line">    <span class="comment">//方法二，使用迭代器将容器中数据输出 </span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.<span class="built_in">begin</span>();it!=obj.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接利用数组：0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">利用迭代器：0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h5 id="二维数组两种定义方法（结果一样）"><a href="#二维数组两种定义方法（结果一样）" class="headerlink" title="二维数组两种定义方法（结果一样）"></a>二维数组两种定义方法（结果一样）</h5><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N, vector&lt;<span class="keyword">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">3.2 deque</span><br></pre></td></tr></table></figure><p>所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 </p><p>Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 </p><p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 </p><p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>#include<deque>  // 头文件<br>deque<type> deq;  // 声明一个元素类型为type的双端队列que<br>deque<type> deq(size);  // 声明一个类型为type、含有size个默认值初始化元素的的双端队列que<br>deque<type> deq(size, value);  // 声明一个元素类型为type、含有size个value元素的双端队列que<br>deque<type> deq(mydeque);  // deq是mydeque的一个副本<br>deque<type> deq(first, last);  // 使用迭代器first、last范围内的元素初始化deq</p><h4 id="deque的常用成员函数"><a href="#deque的常用成员函数" class="headerlink" title="deque的常用成员函数"></a>deque的常用成员函数</h4><p>deque<int> deq;<br>deq[ ]：用来访问双向队列中单个的元素。<br>deq.front()：返回第一个元素的引用。<br>deq.back()：返回最后一个元素的引用。<br>deq.push_front(x)：把元素x插入到双向队列的头部。<br>deq.pop_front()：弹出双向队列的第一个元素。<br>deq.push_back(x)：把元素x插入到双向队列的尾部。<br>deq.pop_back()：弹出双向队列的最后一个元素。</p><h4 id="deque的一些特点"><a href="#deque的一些特点" class="headerlink" title="deque的一些特点"></a>deque的一些特点</h4><p>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。<br>可以在内部进行插入和删除操作，但性能不及list。<br>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。<br>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。<br>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。<br>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。<br>deque不支持对容量和内存分配时机的控制。<br>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。<br>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。<br>deque不提供容量操作：capacity()和reverse()，但是vector可以。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;                                  <span class="comment">/*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/</span></span><br><span class="line">q.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">front</span>());    <span class="comment">/*清除第一个元素后输出第一个(6)*/</span></span><br><span class="line">q.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">back</span>());     <span class="comment">/*清除最后一个元素后输出最后一个(7)*/</span></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = q.<span class="built_in">begin</span>(); it != q.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="list定义"><a href="#list定义" class="headerlink" title="list定义"></a>list定义</h4><p>List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件</p><p>#include <list></p><h4 id="list定义和初始化"><a href="#list定义和初始化" class="headerlink" title="list定义和初始化"></a>list定义和初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt;lst1;          //创建空list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lst2(5);       //创建含有5个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst3(3,2);  //创建含有3个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst4(lst2);    //使用lst2初始化lst4</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst5(lst2.begin(),lst2.end());  //同lst4</span><br></pre></td></tr></table></figure><h4 id="list常用操作函数"><a href="#list常用操作函数" class="headerlink" title="list常用操作函数"></a>list常用操作函数</h4><p>Lst1.assign() 给list赋值<br>Lst1.back() 返回最后一个元素<br>Lst1.begin() 返回指向第一个元素的迭代器<br>Lst1.clear() 删除所有元素<br>Lst1.empty() 如果list是空的则返回true<br>Lst1.end() 返回末尾的迭代器<br>Lst1.erase() 删除一个元素<br>Lst1.front() 返回第一个元素<br>Lst1.get_allocator() 返回list的配置器<br>Lst1.insert() 插入一个元素到list中<br>Lst1.max_size() 返回list能容纳的最大元素数量<br>Lst1.merge() 合并两个list<br>Lst1.pop_back() 删除最后一个元素<br>Lst1.pop_front() 删除第一个元素<br>Lst1.push_back() 在list的末尾添加一个元素<br>Lst1.push_front() 在list的头部添加一个元素<br>Lst1.rbegin() 返回指向第一个元素的逆向迭代器<br>Lst1.remove() 从list删除元素<br>Lst1.remove_if() 按指定条件删除元素<br>Lst1.rend() 指向list末尾的逆向迭代器<br>Lst1.resize() 改变list的大小<br>Lst1.reverse() 把list的元素倒转<br>Lst1.size() 返回list中的元素个数<br>Lst1.sort() 给list排序<br>Lst1.splice() 合并两个list<br>Lst1.swap() 交换两个list<br>Lst1.unique() 删除list中相邻重复的元素</p><h4 id="List使用实例"><a href="#List使用实例" class="headerlink" title="List使用实例"></a>List使用实例</h4><h5 id="迭代器遍历list"><a href="#迭代器遍历list" class="headerlink" title="迭代器遍历list"></a>迭代器遍历list</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++)</span><br><span class="line">   &#123;</span><br><span class="line">     cout&lt;&lt;*iter;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h5 id="综合实例1"><a href="#综合实例1" class="headerlink" title="综合实例1"></a>综合实例1</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTINT;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; LISTCHAR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//用LISTINT创建一个list对象</span></span><br><span class="line">LISTINT listOne;</span><br><span class="line"><span class="comment">//声明i为迭代器</span></span><br><span class="line">LISTINT::iterator i;</span><br><span class="line"></span><br><span class="line">listOne.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">listOne.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">listOne.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">listOne.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">listOne.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">listOne.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;listOne.begin()--- listOne.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (i = listOne.<span class="built_in">begin</span>(); i != listOne.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">LISTINT::reverse_iterator ir;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;listOne.rbegin()---listOne.rend():&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (ir = listOne.<span class="built_in">rbegin</span>(); ir != listOne.<span class="built_in">rend</span>(); ir++) &#123;</span><br><span class="line">cout &lt;&lt; *ir &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">accumulate</span>(listOne.<span class="built_in">begin</span>(), listOne.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sum=&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用LISTCHAR创建一个list对象</span></span><br><span class="line">LISTCHAR listTwo;</span><br><span class="line"><span class="comment">//声明i为迭代器</span></span><br><span class="line">LISTCHAR::iterator j;</span><br><span class="line"> </span><br><span class="line">listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">listTwo.<span class="built_in">push_front</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">listTwo.<span class="built_in">push_back</span>(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;listTwo.begin()---listTwo.end():&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (j = listTwo.<span class="built_in">begin</span>(); j != listTwo.<span class="built_in">end</span>(); ++j)</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">j = <span class="built_in">max_element</span>(listTwo.<span class="built_in">begin</span>(), listTwo.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The maximum element in listTwo is: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(*j) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><h5 id="综合实例2"><a href="#综合实例2" class="headerlink" title="综合实例2"></a>综合实例2</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; INTLIST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前向后显示list队列的全部元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_list</span><span class="params">(INTLIST list, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">INTLIST::iterator plist;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The contents of &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (plist = list.<span class="built_in">begin</span>(); plist != list.<span class="built_in">end</span>(); plist++)</span><br><span class="line">cout &lt;&lt; *plist &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试list容器的功能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//list1对象初始为空 </span></span><br><span class="line">INTLIST list1;</span><br><span class="line"><span class="function">INTLIST <span class="title">list2</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">INTLIST <span class="title">list3</span><span class="params">(list2.begin(), --list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个名为i的双向迭代器 </span></span><br><span class="line">INTLIST::iterator i;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"><span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line"><span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">list1.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.push_back(7) and list1.push_back(8):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">list1.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.push_front(6) and list1.push_front(5):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">insert</span>(++list1.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.insert(list1.begin()+1,3,9):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试引用类函数 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.front()=&quot;</span> &lt;&lt; list1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.back()=&quot;</span> &lt;&lt; list1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">pop_front</span>();</span><br><span class="line">list1.<span class="built_in">pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.pop_front() and list1.pop_back():&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">erase</span>(++list1.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.erase(++list1.begin()):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list2.<span class="built_in">assign</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list2.assign(8,1):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.max_size(): &quot;</span> &lt;&lt; list1.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.size(): &quot;</span> &lt;&lt; list1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1.empty(): &quot;</span> &lt;&lt; list1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"><span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1&gt;list3: &quot;</span> &lt;&lt; (list1 &gt; list3) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;list1&lt;list3: &quot;</span> &lt;&lt; (list1 &lt; list3) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">sort</span>();</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">list1.<span class="built_in">splice</span>(++list1.<span class="built_in">begin</span>(), list3);</span><br><span class="line"><span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"><span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。</p><p>C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。</p><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p><h4 id="基本操作函数"><a href="#基本操作函数" class="headerlink" title="基本操作函数"></a>基本操作函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">begin()         返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素</span><br><span class="line"></span><br><span class="line">find()          查找一个元素</span><br><span class="line"></span><br><span class="line">get_allocator() 返回map的配置器</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()          返回map中元素的个数</span><br><span class="line"></span><br><span class="line">swap()           交换两个map</span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//头文件</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; ID_Name;</span><br></pre></td></tr></table></figure><p>// 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; 2015, &quot;Jim&quot; &#125;,</span><br><span class="line">                &#123; 2016, &quot;Tom&quot; &#125;,</span><br><span class="line">                &#123; 2017, &quot;Bob&quot; &#125; &#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。</p><p>二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;::iterator it;</span><br><span class="line">map&lt;int,int&gt; mmap;</span><br><span class="line">const map&lt;int,int&gt; const_mmap;</span><br><span class="line"></span><br><span class="line">it = mmap.begin(); //iterator</span><br><span class="line">mmap.cbegin(); //const_iterator</span><br><span class="line"></span><br><span class="line">const_mmap.begin(); //const_iterator</span><br><span class="line">const_mmap.cbegin(); //const_iterator</span><br></pre></td></tr></table></figure><p>返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h5 id="用insert插入pair数据"><a href="#用insert插入pair数据" class="headerlink" title="用insert插入pair数据"></a>用insert插入pair数据</h5><p>//数据的插入–第一种：用insert函数插入pair数据  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用insert函数插入value-type数据"><a href="#用insert函数插入value-type数据" class="headerlink" title="用insert函数插入value_type数据"></a>用insert函数插入value_type数据</h5><p>//第二种：用insert函数插入value_type数据，下面举例说明  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用insert函数进行多个插入"><a href="#用insert函数进行多个插入" class="headerlink" title="用insert函数进行多个插入"></a>用insert函数进行多个插入</h5><p>insert共有4个重载函数：</p><p>// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败<br>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</p><p>//在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排<br>iterator insert (const_iterator position, const value_type&amp; val);</p><p>// 插入多个<br>void insert (InputIterator first, InputIterator last);</p><p>//c++11开始支持，使用列表插入多个<br>void insert (initializer_list<value_type> il);<br>下面是具体使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入单个值</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">200</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回插入位置以及是否插入成功</span></span><br><span class="line">    std::pair&lt;std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;element &#x27;z&#x27; already existed&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; with a value of &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">300</span>));  <span class="comment">//效率更高</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>, <span class="number">400</span>));  <span class="comment">//效率非最高</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//范围多值插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; anothermap;</span><br><span class="line">    anothermap.<span class="built_in">insert</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 列表形式插入</span></span><br><span class="line">    anothermap.<span class="built_in">insert</span>(&#123; &#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">100</span> &#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">200</span>&#125; &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用数组方式插入数据"><a href="#用数组方式插入数据" class="headerlink" title="用数组方式插入数据"></a>用数组方式插入数据</h5><p>//第三种：用数组方式插入数据，下面举例说明  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[1] = &quot;student_one&quot;;   </span><br><span class="line">    mapStudent[2] = &quot;student_two&quot;;    </span><br><span class="line">    mapStudent[3] = &quot;student_three&quot;;    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br><span class="line"></span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;));</span><br></pre></td></tr></table></figure><p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br></pre></td></tr></table></figure><p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p><p>下面给出完成代码，演示插入成功与否问题</p><p>//验证插入函数的作用效果  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;   </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p> 大家可以用如下程序，看下用数组插入在数据覆盖上的效果</p><p>//验证数组形式插入数据的效果   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_two&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_three&quot;</span>;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="查找、删除、交换"><a href="#查找、删除、交换" class="headerlink" title="查找、删除、交换"></a>查找、删除、交换</h4><p><strong>查找</strong></p><p>// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器<br>// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator<br>iterator find (const key_type&amp; k);<br>const_iterator find (const key_type&amp; k) const;<br> <strong>删除</strong></p><p>// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器<br>iterator erase( iterator pos )</p><p>// 删除一定范围内的元素，并返回一个指向下一元素的迭代器<br>iterator erase( const_iterator first, const_iterator last );</p><p>// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1<br>size_t erase( const key_type&amp; key );</p><p>// 清空map，清空后的size为0<br>void clear();<br><strong>交换</strong> </p><p>// 就是两个map的内容互换<br>void swap( map&amp; other );</p><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>// 查询map是否为空<br>bool empty();</p><p>// 查询map中键值对的数量<br>size_t size();</p><p>// 查询map所能包含的最大键值对数量，和系统和应用库有关。<br>// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了<br>size_t max_size();</p><p>// 查询关键字为key的元素的个数，在map里结果非0即1<br>size_t count( const Key&amp; key ) const; //</p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p><p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。</p><h5 id="小于号-lt-重载"><a href="#小于号-lt-重载" class="headerlink" title="小于号 &lt; 重载"></a>小于号 &lt; 重载</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>      niD;</span><br><span class="line">string   strName;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (tagStudentinfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></span><br><span class="line">&#123;     <span class="comment">//这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </span></span><br><span class="line"><span class="keyword">if</span> (niD &lt; _A.niD) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (niD == _A.niD)</span><br><span class="line"><span class="keyword">return</span> strName.<span class="built_in">compare</span>(_A.strName) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nSize;   <span class="comment">//用学生信息映射分数  </span></span><br><span class="line">map&lt;Studentinfo, <span class="keyword">int</span>&gt;mapStudent;</span><br><span class="line">map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">Studentinfo studentinfo;</span><br><span class="line">studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="仿函数的应用，这个时候结构体中没有直接的小于号重载"><a href="#仿函数的应用，这个时候结构体中没有直接的小于号重载" class="headerlink" title="仿函数的应用，这个时候结构体中没有直接的小于号重载"></a>仿函数的应用，这个时候结构体中没有直接的小于号重载</h5><p>//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>      niD;</span><br><span class="line">string   strName;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Studentinfo <span class="keyword">const</span> &amp;_A, Studentinfo <span class="keyword">const</span> &amp;_B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_A.niD &lt; _B.niD)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (_A.niD == _B.niD)</span><br><span class="line"><span class="keyword">return</span> _A.strName.<span class="built_in">compare</span>(_B.strName) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="comment">//用学生信息映射分数  </span></span><br><span class="line">map&lt;Studentinfo, <span class="keyword">int</span>, sort&gt;mapStudent;</span><br><span class="line">map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">Studentinfo studentinfo;</span><br><span class="line">studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？</p><p>   map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。</p><p>   unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。</p><p>   还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。</p><p>   最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。</p><p>至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。</p><h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>std::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。</p><p>set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p><p>由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。</p><p>　　multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p><p>　　set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。</p><h4 id="set常用成员函数"><a href="#set常用成员函数" class="headerlink" title="set常用成员函数"></a>set常用成员函数</h4><ol><li><p>begin()–返回指向第一个元素的迭代器</p></li><li><p>clear()–清除所有元素</p></li><li><p>count()–返回某个值元素的个数</p></li><li><p>empty()–如果集合为空，返回true</p></li><li><p>end()–返回指向最后一个元素的迭代器</p></li><li><p>equal_range()–返回集合中与给定值相等的上下限的两个迭代器</p></li><li><p>erase()–删除集合中的元素</p></li><li><p>find()–返回一个指向被查找到元素的迭代器</p></li><li><p>get_allocator()–返回集合的分配器</p></li><li><p>insert()–在集合中插入元素</p></li><li><p>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器</p></li><li><p>key_comp()–返回一个用于元素间值比较的函数</p></li><li><p>max_size()–返回集合能容纳的元素的最大限值</p></li><li><p>rbegin()–返回指向集合中最后一个元素的反向迭代器</p></li><li><p>rend()–返回指向集合中第一个元素的反向迭代器</p></li><li><p>size()–集合中元素的数目</p></li><li><p>swap()–交换两个集合变量</p></li><li><p>upper_bound()–返回大于某个值元素的迭代器</p></li><li><p>value_comp()–返回一个用于比较元素间的值的函数</p></li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p> 以下代码涉及的内容：<br>1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？</p><p>2、set容器中，如何让元素类型为自定义类型？</p><p>3、set容器的insert函数的返回值为什么类型？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数CompareSet，在test02使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="comment">//bool operator()(int v1, int v2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    return v1 &lt; v2;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person类，用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; person.mName &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数ComparePerson,用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//名字大的在前面，如果名字相同，年龄大的排前面</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.mName == p2.mName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.mName &gt; p2.mName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//set容器默认从小到大排序</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:10 20 30</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* set的insert函数返回值为一个对组(pair)。</span></span><br><span class="line"><span class="comment">       对组的第一个值first为set类型的迭代器：</span></span><br><span class="line"><span class="comment">       1、若插入成功，迭代器指向该元素。</span></span><br><span class="line"><span class="comment">       2、若插入失败，迭代器指向之前已经存在的元素</span></span><br><span class="line"><span class="comment">       对组的第二个值seconde为bool类型：</span></span><br><span class="line"><span class="comment">       1、若插入成功，bool值为true</span></span><br><span class="line"><span class="comment">       2、若插入失败，bool值为false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == ret.second)</span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果想让set容器从大到小排序，需要给set容</span></span><br><span class="line"><span class="comment">       器提供一个仿函数,本例的仿函数为CompareSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, CompareSet&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:30,20,10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* set元素类型为Person，当set元素类型为自定义类型的时候</span></span><br><span class="line"><span class="comment">       必须给set提供一个仿函数，用于比较自定义类型的大小，</span></span><br><span class="line"><span class="comment">       否则无法通过编译 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;Person,ComparePerson&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Marry&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">36</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multiset容器的insert函数返回值为什么？ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印multiset</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* multiset的insert函数返回值为multiset类型的迭代器，</span></span><br><span class="line"><span class="comment">       指向新插入的元素。multiset允许插入相同的值，因此</span></span><br><span class="line"><span class="comment">       插入一定成功，因此不需要返回bool类型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator iter = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><p>C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。</p><pre><code>    unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:</code></pre><p> 使用unordered_set需要包含#include<unordered_set>头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。</p><p>除此之外unordered_multiset也是一种可选的容器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010183728/article/details/81</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>概率机器人</title>
    <link href="https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://peitianyu.github.io/blog/2021/10/28/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2021-10-28T04:30:12.000Z</published>
    <updated>2021-10-28T12:14:44.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://gaoyichao.com/Xiaotu/?book=probabilistic_robotics&title=index">概率机器人</a></p><h1 id="5-机器人运动模型"><a href="#5-机器人运动模型" class="headerlink" title="5.机器人运动模型"></a>5.机器人运动模型</h1><h2 id="速度模型-概率运动规划"><a href="#速度模型-概率运动规划" class="headerlink" title="速度模型(概率运动规划)"></a>速度模型(概率运动规划)</h2><h3 id="闭式算法"><a href="#闭式算法" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p><h3 id="采样算法"><a href="#采样算法" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/DsfN1nov5VqJuFC.png" alt="5.1.png"></p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><h4 id="精确运动"><a href="#精确运动" class="headerlink" title="精确运动"></a>精确运动</h4><p><img src="https://i.loli.net/2021/10/28/q6Bp1FfriNSYJOm.png" alt="image-20211028195757782.png"></p><h4 id="真实运动"><a href="#真实运动" class="headerlink" title="真实运动"></a>真实运动</h4><p>加入扰动,模型表达为</p><p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p><p>加入噪声,求得概率公式为:</p><p><img src="https://i.loli.net/2021/10/28/dSyQKWDwZokC31L.png" alt="image-20211028200012951.png"></p><h2 id="里程计模型-估计"><a href="#里程计模型-估计" class="headerlink" title="里程计模型(估计)"></a>里程计模型(估计)</h2><p>模型为:</p><p><img src="https://i.loli.net/2021/10/28/SlTo9XeFOgYc5mV.png" alt="image-20211028200122122.png"></p><h3 id="闭式算法-1"><a href="#闭式算法-1" class="headerlink" title="闭式算法"></a>闭式算法</h3><p><img src="https://i.loli.net/2021/10/28/NIADHiMonhT1Kme.png" alt="image-20211028200230307.png"></p><h3 id="采样算法-1"><a href="#采样算法-1" class="headerlink" title="采样算法"></a>采样算法</h3><p><img src="https://i.loli.net/2021/10/28/c48vqLlKwirNEuF.png" alt="image-20211028200258350.png"></p><h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导"></a>数学推导</h3><p>三次转换:</p><p><img src="https://i.loli.net/2021/10/28/mpeJFAc3E2dYTUB.png" alt="image-20211028200511164.png"></p><p>加入噪声:</p><p><img src="https://i.loli.net/2021/10/28/zWb12u97LjVsfEt.png" alt="image-20211028200548403.png"></p><p>求出坐标:</p><p><img src="https://i.loli.net/2021/10/28/pLu9BycOrKq5jJz.png" alt="image-20211028195927994.png"></p><p>求得最终概率:</p><p><img src="https://i.loli.net/2021/10/28/JMKtbz5W2ErdQCO.png" alt="image-20211028200832805.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://gaoyichao.com/Xiaotu/?book=probabilistic_ro</summary>
      
    
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/categories/slam/"/>
    
    
    <category term="slam" scheme="https://peitianyu.github.io/blog/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>cpp学习</title>
    <link href="https://peitianyu.github.io/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/"/>
    <id>https://peitianyu.github.io/blog/2021/10/24/cpp%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-24T04:30:12.000Z</published>
    <updated>2021-10-27T12:02:39.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h1><p><a href="https://github.com/gyshgx868/cpp-tutorial">C++ 教程 (github.com)</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a></p><h1 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h1><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>声明指定类型的常量,此类型不会发生变化.</p><p>比如常用的字符串<code>const char* str</code>,例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>当然也会有常数,常指针等.只需要记住它修饰的是它后边的那个.例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str #值不能改</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *str #值不能改</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> str #修饰的是常数指针,该指针不能修改</span><br></pre></td></tr></table></figure><h2 id="static修饰"><a href="#static修饰" class="headerlink" title="static修饰"></a>static修饰</h2><p>静态变量,在程序的生命周期内保持局部变量的存在,用于保存上一次运行数据,比如计数等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>预处理器,例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7070</span></span><br></pre></td></tr></table></figure><h2 id="extern储存类"><a href="#extern储存类" class="headerlink" title="extern储存类"></a>extern储存类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// support.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个文件之间传递参数.</p><h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p>寄存器局部变量,用于快速访问.因此也意味着最大尺寸只有寄存器尺寸.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>量在创建线程时创建，并在销毁线程时销毁。可以将 thread_local <code>仅应用于数据声明和定义</code>，thread_local <code>不能用于函数声明或定义</code>。thread_local 说明符可以与 static 或 extern 合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first_name[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125; emp;</span><br></pre></td></tr></table></figure><h3 id="（-）点运算符"><a href="#（-）点运算符" class="headerlink" title="（.）点运算符"></a>（.）点运算符</h3><p>下面的代码把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(emp.first_name, &quot;zara&quot;);</span><br></pre></td></tr></table></figure><h3 id="（-gt-）箭头运算符"><a href="#（-gt-）箭头运算符" class="headerlink" title="（-&gt;）箭头运算符"></a>（-&gt;）箭头运算符</h3><p>如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 <strong>first_name</strong> 成员，需要编写如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(p_emp-&gt;first_name, <span class="string">&quot;zara&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符 ? :"></a>条件运算符 ? :</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(y &lt; <span class="number">10</span>)&#123; </span><br><span class="line">   var = <span class="number">30</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   var = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可写为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = (y &lt; <span class="number">10</span>) ? <span class="number">30</span> : <span class="number">40</span>;</span><br></pre></td></tr></table></figure><h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span> (data type)</span><br></pre></td></tr></table></figure><h2 id="指针运算符（-amp-和-）"><a href="#指针运算符（-amp-和-）" class="headerlink" title="指针运算符（&amp; 和 *）"></a>指针运算符（&amp; 和 *）</h2><h3 id="取地址运算符-amp-间接寻址运算符"><a href="#取地址运算符-amp-间接寻址运算符" class="headerlink" title="取地址运算符 &amp; 间接寻址运算符 *"></a>取地址运算符 &amp; 间接寻址运算符 *</h3><p>顾名思义,挺形象的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var;</span><br><span class="line">   <span class="keyword">int</span>  *ptr;</span><br><span class="line">   <span class="keyword">int</span>  val;</span><br><span class="line">   var = <span class="number">3000</span>;</span><br><span class="line">   <span class="comment">// 获取 var 的地址</span></span><br><span class="line">   ptr = &amp;var;</span><br><span class="line">   <span class="comment">// 获取 ptr 的值</span></span><br><span class="line">   val = *ptr;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of var :&quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of ptr :&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of val :&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传参三种方式"><a href="#传参三种方式" class="headerlink" title="传参三种方式"></a>传参三种方式</h2><h3 id="传值、传址、传引用"><a href="#传值、传址、传引用" class="headerlink" title="传值、传址、传引用"></a><strong>传值、传址、传引用</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a*a</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">man</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function">    a</span>=a*a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function">    *a</span>=*a * *a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">uint8_t</span>* *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    *buffer = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>,number=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fun1</span>(a)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">man</span>(b);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cubeByReference</span>(&amp;number);</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>值得注意的是<code>this</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h2 id="数学运算-include-lt-cmath"><a href="#数学运算-include-lt-cmath" class="headerlink" title="数学运算 #include &lt;cmath"></a>数学运算 #include &lt;cmath</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 数字定义</span></span><br><span class="line">   <span class="keyword">short</span>  s = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span>    i = <span class="number">-1000</span>;</span><br><span class="line">   <span class="keyword">long</span>   l = <span class="number">100000</span>;</span><br><span class="line">   <span class="keyword">float</span>  f = <span class="number">230.47</span>;</span><br><span class="line">   <span class="keyword">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 数学运算</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sin(d) :&quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;floor(d) :&quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过time实现的伪随机数"><a href="#通过time实现的伪随机数" class="headerlink" title="通过time实现的伪随机数"></a>通过time实现的伪随机数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="keyword">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setw-函数"><a href="#setw-函数" class="headerlink" title="setw() 函数"></a>setw() 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::setw;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>( <span class="number">7</span> )&lt;&lt; j &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class="line"># 结果</span><br><span class="line">Element        Value</span><br><span class="line">      <span class="number">0</span>          <span class="number">100</span></span><br><span class="line">      <span class="number">1</span>          <span class="number">101</span></span><br><span class="line">      <span class="number">2</span>          <span class="number">102</span></span><br><span class="line">      <span class="number">3</span>          <span class="number">103</span></span><br><span class="line">      <span class="number">4</span>          <span class="number">104</span></span><br><span class="line">      <span class="number">5</span>          <span class="number">105</span></span><br><span class="line">      <span class="number">6</span>          <span class="number">106</span></span><br><span class="line">      <span class="number">7</span>          <span class="number">107</span></span><br><span class="line">      <span class="number">8</span>          <span class="number">108</span></span><br><span class="line">      <span class="number">9</span>          <span class="number">109</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作-include-lt-string"><a href="#字符串操作-include-lt-string" class="headerlink" title="字符串操作 #include &lt;string"></a>字符串操作 #include &lt;string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, s2); <span class="comment">// s2复制到s1</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2); <span class="comment">// s2拼接到s1后边,类似于:string str = str1 + str2;</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);     <span class="comment">// 字符串长度</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2); <span class="comment">// 比较两字符串,相同回0,s1&lt;s2返回小于0,反之,大于0</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch); <span class="comment">// 返回字符ch第一次在s1中出现得位置指针</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2); <span class="comment">// 返回字符串s2在s1中出现的位姿指针</span></span><br><span class="line"><span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">str3 = str1;</span><br><span class="line"><span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line"><span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><h2 id="时间-include-lt-ctime"><a href="#时间-include-lt-ctime" class="headerlink" title="时间 #include &lt;ctime"></a>时间 #include &lt;ctime</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *time)</span></span>; <span class="comment">// 返回当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; <span class="comment">// 返回 day month year hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; <span class="comment">// 返回tm时间结构体</span></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">clock</span><span class="params">(<span class="keyword">void</span>)</span></span>;                <span class="comment">// 该函数返回程序执行起,处理器时钟所使用的时间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">asctime</span> <span class="params">( <span class="keyword">const</span> struct tm * time )</span></span>;<span class="comment">// 返回 day month date hours:minutes:seconds year\n\0</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *time)</span></span>; <span class="comment">// 用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *time)</span></span>;<span class="comment">// 该函数返回日历时间</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span> <span class="params">( <span class="keyword">time_t</span> time2, <span class="keyword">time_t</span> time1 )</span></span>; <span class="comment">// 该函数返回 time1 和 time2 之间相差的秒数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">()</span></span>;<span class="comment">// 该函数可用于格式化日期和时间为指定的格式</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="keyword">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cin、cout、cerr-和-clog-标准输入输出"><a href="#cin、cout、cerr-和-clog-标准输入输出" class="headerlink" title="cin、cout、cerr 和 clog 标准输入输出"></a><strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 标准输入输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cin :一个istream对象,用来从标准输入读取数据。</span><br><span class="line">cout:一个ostream对象，经过缓冲区而直接输出.</span><br><span class="line">cerr:一个ostream对象,写到cerr数据是不缓冲</span><br><span class="line">clog:一个ostream对象,被缓冲的</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="comment">// 使用 Books Book;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 books Book;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;books;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取别名 pin32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> pint32;</span><br><span class="line">pint32 x, y, z;</span><br></pre></td></tr></table></figure><p>结构体指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line"><span class="comment">// 取地址</span></span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line"><span class="comment">// 访问成员</span></span><br><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="c-对象"><a href="#c-对象" class="headerlink" title="c++对象"></a>c++对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 访问修饰符</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 类成员函数 </span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 构造函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="keyword">const</span> Line &amp;obj); <span class="comment">//拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个<code>空间代价换时间的节省</code>。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神:</p><ul><li>1.在内联函数内不允许使用循环语句和开关语句；</li><li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li><li>3.类结构中所在的类说明内部定义的函数是内联函数。</li></ul><p>结论: 一个较为合理的经验准则是, <strong>不要内联超过 10 行的函数</strong>. <strong>谨慎对待析构函数</strong>, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (20,10): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (0,200): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max (100,1010): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p><p><strong>this</strong> 指针的类型可理解为 <strong>Box*</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 实际上就是指针引用结构体成员</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>();</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>类内重调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">         box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">         <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">算术运算符</th><th align="center">+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td align="center">关系运算符</td><td align="center">==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td align="center">逻辑运算符</td><td align="center">||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td align="center">单目运算符</td><td align="center">+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td align="center">自增自减运算符</td><td align="center">++(自增)，–(自减)</td></tr><tr><td align="center">位运算符</td><td align="center">| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td align="center">赋值运算符</td><td align="center">=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td align="center">空间申请与释放</td><td align="center">new, delete, new[ ] , delete[]</td></tr><tr><td align="center">其他运算符</td><td align="center"><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 纯虚数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>头文件:<strong>iostream</strong> 和 <strong>fstream</strong></p><h3 id="读写文件模板"><a href="#读写文件模板" class="headerlink" title="读写文件模板"></a>读写文件模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h3 id="变量动态内存"><a href="#变量动态内存" class="headerlink" title="变量动态内存"></a>变量动态内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure><h3 id="数组动态内存"><a href="#数组动态内存" class="headerlink" title="数组动态内存"></a>数组动态内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pvalue[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] pvalue; </span><br></pre></td></tr></table></figure><h3 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> [] myBoxArray; <span class="comment">// Delete array</span></span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">   pvalue  = new double;   // 为变量请求内存</span><br><span class="line"> </span><br><span class="line">   *pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">   cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   delete pvalue;         // 释放内存</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br><span class="line">name::<span class="built_in">func</span>();  <span class="comment">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">//全特化，由于是全特化，参数都指定了，参数列表故为空。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">int</span> ,<span class="keyword">char</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i,<span class="keyword">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="comment">//由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span><span class="keyword">char</span>,T2&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">char</span> i,T2 j):<span class="built_in">a</span>(j),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;个数偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; <span class="comment">//这是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1*,T2*&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1* i,T2* j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;指针偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1* a;</span><br><span class="line">    T2* b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;<span class="comment">//同理这也是范围上的偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>T1 <span class="keyword">const</span>,T2 <span class="keyword">const</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;const偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">0.1</span>,<span class="number">0.2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; <span class="title">t3</span><span class="params">(<span class="string">&#x27;A&#x27;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>*,<span class="keyword">int</span>*&gt; <span class="title">t4</span><span class="params">(&amp;a,&amp;a)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">int</span>&gt; <span class="title">t5</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)</span></span><br></pre></td></tr></table></figure><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 将x转换为字符串</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line">## 将x,y连接</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT( x, y )  x ## y</span></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br></pre></td></tr></table></figure><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl; <span class="comment">//当前行号</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl; <span class="comment">//当前文件名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl; <span class="comment">//当前年月日</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl; <span class="comment">//当前时分秒</span></span><br></pre></td></tr></table></figure><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalHandler</span><span class="params">( <span class="keyword">int</span> signum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序 </span></span><br><span class="line">   <span class="built_in">exit</span>(signum);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line">    <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">if</span>( i == <span class="number">3</span> )&#123;</span><br><span class="line">          <span class="comment">// 信号抬起</span></span><br><span class="line">          <span class="built_in">raise</span>( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_create</span> (thread, attr, start_routine, arg) </span><br><span class="line"><span class="comment">// 参数:线程指针,线程属性,线程函数,函数参数</span></span><br><span class="line"><span class="comment">// 线程显性退出</span></span><br><span class="line"><span class="built_in">pthread_exit</span> (<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure><h3 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  thread_id;</span><br><span class="line">   <span class="keyword">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">td</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line">rc = <span class="built_in">pthread_create</span>(threadid, <span class="literal">NULL</span>,PrintHello, (<span class="keyword">void</span> *)&amp;td[i]);</span><br></pre></td></tr></table></figure><h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span> (threadid, status) </span><br><span class="line"><span class="built_in">pthread_detach</span> (threadid) </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">    </span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="keyword">void</span> *status;</span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">   <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="keyword">void</span> *)i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线程</span></span><br><span class="line">   <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = <span class="built_in">pthread_join</span>(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector与iterator"><a href="#vector与iterator" class="headerlink" title="vector与iterator"></a>vector与iterator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; title=&quot;参考网址:&quot;&gt;&lt;/a&gt;参考网址:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gyshgx868/cpp-tutorial&quot;&gt;C++ 教程 (</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Socket编程</title>
    <link href="https://peitianyu.github.io/blog/2021/10/20/socket/"/>
    <id>https://peitianyu.github.io/blog/2021/10/20/socket/</id>
    <published>2021-10-20T04:30:12.000Z</published>
    <updated>2021-10-26T06:14:17.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h3><p><a href="https://github.com/peitianyu/TcpIpBook">peitianyu/TcpIpBook: TCP/IP网络编程 (github.com)</a></p><p><a href="https://www.bilibili.com/video/BV1eg411G7pW?from=search&seid=9546660162554024003&spm_id_from=333.337.0.0">TCP/IP网络通信之Socket编程入门_哔哩哔哩_bilibili</a></p><h3 id="套接字操作"><a href="#套接字操作" class="headerlink" title="套接字操作"></a>套接字操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"># 创建套接字</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 分配地址信息</span><br><span class="line">int bind(int sockfd, struct sockaddr* pSockAddr, socklen_t addrLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 设置监听</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 受理连接</span><br><span class="line">int accept(int sockfd, struct sockaddr* pSockAddr, socklen_t* pAddrLen);</span><br><span class="line">//成功时返回文件描述符，失败时返回-1</span><br><span class="line"># 请求连接</span><br><span class="line">int connect(in sockfd, struct sockaddr* pSockAddr, socklen_t sockLen);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int open(const char* path, int flag);</span><br><span class="line">//成功时返回文件描述符， 失败时返回-1</span><br><span class="line"># 关闭文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br><span class="line">//成功时返回0， 失败时返回-1</span><br><span class="line"># 写入文件</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int sockfd, const void* buf, size_t nBytes);</span><br><span class="line">//成功时返回写入的字节数，失败时返回-1</span><br><span class="line"># 读取文件</span><br><span class="line">ssize_t read(int sockfd, void* buf, size_t nBytes);</span><br><span class="line">//成功时返回读到的字节数（若遇到文件结尾则返回0），失败时返回-1</span><br><span class="line"></span><br><span class="line">#include&lt;sys/uio.h&gt;</span><br><span class="line"># 写文件</span><br><span class="line">ssize_t writev(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"># 读文件</span><br><span class="line">ssize_t readv(int sockfd, const struct iovec* iov, int iovcnt);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line"></span><br><span class="line">// TCP</span><br><span class="line">// 发送文件</span><br><span class="line">ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1</span><br><span class="line">// 接收文件</span><br><span class="line">ssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);</span><br><span class="line">//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1</span><br><span class="line">// UDP接收发送</span><br><span class="line">ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回发送的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">ssize_t recvfrom(int sockfd, const void *buff, size_t nbytes, int flags,</span><br><span class="line">           const struct sockaddr *to, socklen_t *addrlen);</span><br><span class="line">//成功时返回接收的字节数，失败时返回-1,参数flags 一般设0</span><br><span class="line">struct iovec</span><br><span class="line">&#123;</span><br><span class="line">    void* iov_base; //缓冲地址</span><br><span class="line">    size_t iov_len; //缓冲大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 断开连接</span><br><span class="line">int shutdown(int sock, int howto);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure><h3 id="套接字的可选项和IO缓冲大小"><a href="#套接字的可选项和IO缓冲大小" class="headerlink" title="套接字的可选项和IO缓冲大小"></a>套接字的可选项和IO缓冲大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">int getsockopt(int sock, int level, int optname,void* optval,socklen_t* optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br><span class="line">int setsockopt(int sock, int level, int optname, void* optval,socklen_t optlen);</span><br><span class="line">//成功时返回0，失败时返回-1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sock = socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">int optval;</span><br><span class="line">socklen_t optlen;</span><br><span class="line">int state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,(void*)&amp;optval, &amp;optlen);</span><br><span class="line"></span><br><span class="line">optval = 1024*3;</span><br><span class="line">optlen = sizeof(optval);</span><br><span class="line">state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,(void*)&amp;optval,optlen);</span><br></pre></td></tr></table></figure><h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><ul><li><code>FD_ZERO(fd_set* fdset)</code>: 将fdset变量的所有位初始化位0</li><li><code>FD_SET(int fd, fd_set* fdset)</code>: 向fdset变量中注册文件描述符fd</li><li><code>FD_CLR(int fd, fd_set* fdset)</code>: 清除fdset变量中的文件描述符fd</li><li><code>FD_ISSET(int fd, fd_set* fdset)</code>: fdset变量中是否存在fd文件描述符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置监视范围及超时</span><br><span class="line">#include&lt;sys/select.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int maxfd, fd_set* readset, </span><br><span class="line">            fd_set* writeset,fd_set* exceptset, </span><br><span class="line">            const struct timeval* timeout</span><br><span class="line">            );</span><br><span class="line">//失败时返回-1，超时返回0，成功时返回发生事件的文件描述符数量</span><br><span class="line"></span><br><span class="line">struct timeval</span><br><span class="line">&#123;</span><br><span class="line">    long tv_sec;</span><br><span class="line">    long tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>maxfd: 监视的文件描述符数量（最大的文件描述符+1）</li><li>readset: 将关注“是否存在待读取数据”的文件描述符存放在readset变量中</li><li>writeset: 将关注”是否可写“的文件描述符存放在writeset变量中</li><li>exceptset: 将关注”是否有异常“的文件描述符放在exceptset变量中 -timeout: 为了防止调用select函数后陷入无限阻塞状态，可以传递超时信息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网址：&quot;&gt;&lt;a href=&quot;#参考网址：&quot; class=&quot;headerlink&quot; title=&quot;参考网址：&quot;&gt;&lt;/a&gt;参考网址：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/peitianyu/TcpIpBook&quot;&gt;peitianyu</summary>
      
    
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://peitianyu.github.io/blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cmake配置模板</title>
    <link href="https://peitianyu.github.io/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/"/>
    <id>https://peitianyu.github.io/blog/2021/10/19/cmake%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-10-19T04:30:12.000Z</published>
    <updated>2021-10-24T05:51:46.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cmake教程"><a href="#Cmake教程" class="headerlink" title="Cmake教程"></a>Cmake教程</h3><h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址:"></a>参考网址:</h4><p><a href="https://www.hahack.com/codes/cmake/">CMake 入门实战 | HaHack</a></p><h3 id="Cmake文件结构"><a href="#Cmake文件结构" class="headerlink" title="Cmake文件结构"></a>Cmake文件结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/cmake# tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build</span><br><span class="line">├── include</span><br><span class="line">│   └── func.h</span><br><span class="line">└── src</span><br><span class="line">    ├── func.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── shell.sh</span><br></pre></td></tr></table></figure><h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于主要在src文件夹下工作，因此在此建一个shell脚本方便编译</span></span><br><span class="line">cd .. &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j &amp;&amp; ./main</span><br></pre></td></tr></table></figure><h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 工程名</span></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake的c++设置</span></span><br><span class="line"><span class="comment"># 告知當前使用的是交叉編譯方式，必須配置</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="string">&quot;arm-linux-gnueabihf-gcc&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="string">&quot;arm-linux-gnueabihf-g++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -Wall -pthread -std=c++11 -fPIC &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.h文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加.cpp文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src SRC_LIST)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;src :$&#123;SRC_LIST&#125; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SRC_LIST&#125;</span> )</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在src文件夹下运行shell.sh</span></span><br><span class="line">./shell</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Cmake教程&quot;&gt;&lt;a href=&quot;#Cmake教程&quot; class=&quot;headerlink&quot; title=&quot;Cmake教程&quot;&gt;&lt;/a&gt;Cmake教程&lt;/h3&gt;&lt;h4 id=&quot;参考网址&quot;&gt;&lt;a href=&quot;#参考网址&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://peitianyu.github.io/blog/2021/10/19/git/"/>
    <id>https://peitianyu.github.io/blog/2021/10/19/git/</id>
    <published>2021-10-19T04:30:12.000Z</published>
    <updated>2021-10-24T05:52:22.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="推送新创建git"><a href="#推送新创建git" class="headerlink" title="推送新创建git"></a>推送新创建git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入本地文件夹</span></span><br><span class="line">cd tool</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line">echo &quot;# tool&quot; &gt;&gt; README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化git</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要上传文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add -A 上传全部</span></span><br><span class="line">git add README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释</span></span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加分支</span></span><br><span class="line">git branch -M main</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加默认远程库</span></span><br><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="推送已存在的库"><a href="#推送已存在的库" class="headerlink" title="推送已存在的库"></a>推送已存在的库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:peitianyu/tool.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="git删除远程库文件"><a href="#git删除远程库文件" class="headerlink" title="git删除远程库文件"></a>git删除远程库文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git --help # 帮助命令</span><br><span class="line">git pull origin master # 将远程仓库里面的项目拉下来</span><br><span class="line">dir # 查看有哪些文件夹</span><br><span class="line">git rm -r --cached yun_app # 删除yun_app文件夹</span><br><span class="line">git commit -m ‘删除了yun_app’ # 提交,添加操作说明</span><br><span class="line">git push -u origin master # 将本次更改更新到github项目上去</span><br></pre></td></tr></table></figure><h3 id="git删除远程分支"><a href="#git删除远程分支" class="headerlink" title="git删除远程分支"></a>git删除远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速创建分支并切换分支 (dev 分支)</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支 ： 如分支名为dev</span></span><br><span class="line">git branch -d dev 会在删除前检查merge状态（其与上游分支或者与head）。</span><br><span class="line">git branch -D dev 它会直接删除,不检查</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git push origin --delete dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理本地不存在的远程分支，如别人删除了dev,但是你本地查看还有，就可以执行该条命令</span></span><br><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 查看分支：git branch</span><br><span class="line"></span><br><span class="line">* 创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">* 删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;推送新创建git&quot;&gt;&lt;a href=&quot;#推送新创建git&quot; class=&quot;headerlink&quot; title=&quot;推送新创建git&quot;&gt;&lt;/a&gt;推送新创建git&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/categories/tool/"/>
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>hugo配置</title>
    <link href="https://peitianyu.github.io/blog/2021/10/19/hugo/"/>
    <id>https://peitianyu.github.io/blog/2021/10/19/hugo/</id>
    <published>2021-10-19T04:30:12.000Z</published>
    <updated>2021-10-24T06:08:31.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git安装与配置"><a href="#git安装与配置" class="headerlink" title="git安装与配置"></a>git安装与配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install git </span><br><span class="line"><span class="meta">#</span><span class="bash">git配置</span></span><br><span class="line">git config --global user.name &quot;zoey&quot;</span><br><span class="line">git config --global user.email &quot;zoey686@163.com&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看设置用户名与密码</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="hugo安装"><a href="#hugo安装" class="headerlink" title="hugo安装"></a>hugo安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo apt install hugo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动安装</span></span><br><span class="line">wget https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.deb</span><br><span class="line">sudo dpkg -i hugo_0.54.0_Linux-64bit.deb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">hugo --help</span><br><span class="line">hugo version</span><br></pre></td></tr></table></figure><h4 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h4><p>新建git文件夹用以git模板等，并在文件夹下新建myblog，用来存放博客页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建git文件夹并git初始化</span></span><br><span class="line">mkdir gitFile  </span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建myblog文件夹用来存放博客页面</span></span><br><span class="line">hugo new site myblog</span><br></pre></td></tr></table></figure><p>myblog下面就会有以下几个文件夹自动生成</p><table><thead><tr><th align="center">文件夹名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">archetypes</td><td align="center">文章开头形式</td></tr><tr><td align="center">content</td><td align="center">内容</td></tr><tr><td align="center">data</td><td align="center">自定义模板</td></tr><tr><td align="center">layouts</td><td align="center">网页模板文件</td></tr><tr><td align="center">static</td><td align="center">存储图片一些其他的资源</td></tr><tr><td align="center">themes</td><td align="center">主题</td></tr><tr><td align="center">config.toml</td><td align="center">配置文件</td></tr></tbody></table><h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>在（<a href="https://themes.gohugo.io/%EF%BC%89%E4%B8%AD%E6%8C%91%E9%80%89%E4%B8%BB%E9%A2%98,%E8%BF%99%E9%87%8C%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFdiary%E4%B8%BB%E9%A2%98%EF%BC%88[Diary">https://themes.gohugo.io/）中挑选主题,这里选择的是diary主题（[Diary</a> | Hugo Themes (gohugo.io)](<a href="https://themes.gohugo.io/themes/hugo-theme-diary/)%EF%BC%89">https://themes.gohugo.io/themes/hugo-theme-diary/)）</a></p><p>例子：（<a href="https://sunua.gitee.io/simonblog/">浅蓝色 (gitee.io)</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载diary主题到themes文件夹下并重命名为diary</span></span><br><span class="line">git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置config.toml文件</span></span><br><span class="line">nano config.toml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">baseURL = &quot;https://peitianyu.github.io/pty_blog.github.io&quot;</span><br><span class="line">DefaultContentLanguage = &quot;zh&quot; # Theme&#x27;s display language, supports: en, fr, zh, zh-hant</span><br><span class="line">languageCode = &quot;zh-hant&quot;</span><br><span class="line">title = &quot;武装带你&quot;</span><br><span class="line">copyright = &quot;This is a customized copyright.&quot;</span><br><span class="line">theme = &quot;diary&quot;</span><br><span class="line"></span><br><span class="line">[markup]</span><br><span class="line">  [markup.highlight]</span><br><span class="line">    codeFences = true</span><br><span class="line">    guessSyntax = false</span><br><span class="line">    hl_Lines = &quot;&quot;</span><br><span class="line">    lineNoStart = 1</span><br><span class="line">    lineNos = false</span><br><span class="line">    lineNumbersInTable = true</span><br><span class="line">    noClasses = true</span><br><span class="line">    style = &quot;perldoc&quot;</span><br><span class="line">    tabWidth = 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enableOpenGraph = true</span><br><span class="line">enableTwitterCards = true</span><br><span class="line">title = &quot;My Blog&quot; </span><br><span class="line">description = &quot;My HomePage Description&quot;  </span><br><span class="line"></span><br><span class="line">[taxonomies]</span><br><span class="line">   ros = &quot;Ros&quot;</span><br><span class="line">   blog = &quot;Blog&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/blog&quot;</span><br><span class="line">name = &quot;Blog&quot;</span><br><span class="line">weight = 1</span><br><span class="line">[[menu.main]]</span><br><span class="line">url = &quot;/ros&quot;</span><br><span class="line">name = &quot;Ros&quot;</span><br><span class="line">weight = 2</span><br></pre></td></tr></table></figure><h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><p>默认主目录文章在content/post下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建文章</span><br><span class="line">hugo new post/my_first_blog.md</span><br><span class="line">#创建文章在需要目录(Archive)下</span><br><span class="line">hugo new posts/my_first_blog.md</span><br><span class="line">cd content/post</span><br><span class="line">nano my_first_blog.md</span><br><span class="line"># 注意将draft参数改为false，否则跳过草稿文件，无法预览</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;my_first_blog&quot;</span><br><span class="line">date: 2021-10-12T10:49:31+08:00</span><br><span class="line">draft : false</span><br><span class="line">---</span><br><span class="line">文本内容</span><br></pre></td></tr></table></figure><p>本地调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo server --theme=blackburn --buildDrafts</span><br></pre></td></tr></table></figure><p>其中 –theme 选项可以指定主题，–buildDrafts 包括标记为草稿<br>然后在浏览器里打开： <a href="http://localhost:1313/">http://localhost:1313</a> 即可访问到你的博客</p><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>如果你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：<code>pty_blog.github.io</code> （<strong>pty_blog替换为你的github用户名的小写</strong>）</p><p>进入仓库，点击<strong>Settings</strong>进入，找到<strong>GitHub Pages</strong>并点击<strong>Check it out here!<strong>，配置</strong>Source</strong>并<strong>save</strong>，会发现绿色框中显现 <code>Your site is published at https://peitianyu.github.io/pty_blog.github.io/</code></p><p>此处<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E4%B9%9F%E6%98%AFconfig.toml%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E8%AE%BE%E7%BD%AEhugo%E7%99%BB%E9%99%86%E7%BD%91%E5%9D%80">https://peitianyu.github.io/pty_blog.github.io/就是我们的网址，也是config.toml文件中设置的网址，设置hugo登陆网址</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的 –baseUrl 一定是https://（Hugo中文文档里为http://），不然你部署后的博客会没有样式！</p><p>可看到根目录下多出 /public文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。然后继续在你的站点根目录执行git 命令，添加远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd public</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:peitianyu/pty_blog.github.io.git</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>然后浏览器里访问：<a href="https://peitianyu.github.io/pty_blog.github.io/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9A%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82">https://peitianyu.github.io/pty_blog.github.io/即可看到刚刚搭建的博客。</a></p><p>发布博客并更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 新建博客markdown文件，并编辑博客内容(文件名为 **.md )</span><br><span class="line">hugo new post/newBlog.md</span><br><span class="line"># 生成静态页面</span><br><span class="line">hugo --theme=diary --buildDrafts --baseUrl=&quot;https://peitianyu.github.io/pty_blog.github.io/&quot;</span><br><span class="line"># 发布</span><br><span class="line">cd public</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;new blog added&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git安装与配置&quot;&gt;&lt;a href=&quot;#git安装与配置&quot; class=&quot;headerlink&quot; title=&quot;git安装与配置&quot;&gt;&lt;/a&gt;git安装与配置&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/categories/tool/"/>
    
    
    <category term="tool" scheme="https://peitianyu.github.io/blog/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>make配置模板</title>
    <link href="https://peitianyu.github.io/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/"/>
    <id>https://peitianyu.github.io/blog/2021/10/19/make%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-10-19T04:30:12.000Z</published>
    <updated>2021-10-24T05:53:25.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="make文件目录"><a href="#make文件目录" class="headerlink" title="make文件目录"></a>make文件目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-49LFJ4NT:/root/make# tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── conf.sh</span><br><span class="line">├── main.cpp</span><br><span class="line">└── shell.sh</span><br></pre></td></tr></table></figure><p>这里使用了shell脚本来实现对于make的编译，由于使用的是<code>wsl</code>在windows下操作导致编码格式含有<code>\r\n</code>，以此有两个shell脚本。</p><h3 id="conf-sh"><a href="#conf-sh" class="headerlink" title="conf.sh"></a>conf.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现对于make的编译与运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [[ $1 == clean ]]; then</span><br><span class="line">        make clean</span><br><span class="line">elif [[ $1 == all ]]; then</span><br><span class="line">        make clean &amp;&amp; make -j8 &amp;&amp; ./main</span><br><span class="line">else</span><br><span class="line">        make -j8 &amp;&amp; ./main</span><br></pre></td></tr></table></figure><h3 id="shell-sh"><a href="#shell-sh" class="headerlink" title="shell.sh"></a>shell.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实现将conf.sh的dos编码转化为unix编码，并执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">dos2unix  conf.sh &amp;&amp; ./conf.sh</span><br></pre></td></tr></table></figure><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动捕捉符合c/c++编译</span></span><br><span class="line"><span class="comment">#指定编译工具</span></span><br><span class="line">CC = gcc</span><br><span class="line">CPP = g++</span><br><span class="line">LINK = g++</span><br><span class="line"></span><br><span class="line">LIBS = -lsqlite3 -lpthread</span><br><span class="line"><span class="comment">#编译.so 必须添加 -fPIC 和 -shared 选项</span></span><br><span class="line">CCFLAGS = -c -g -fPIC</span><br><span class="line">CPPFLAGS = -c -g -fPIC</span><br><span class="line"></span><br><span class="line"><span class="comment">#期望得到的执行文件或动态库.so</span></span><br><span class="line"><span class="comment">#TARGET=libxx.so</span></span><br><span class="line">TARGET=main</span><br><span class="line"></span><br><span class="line">INCLUDES = -I. <span class="comment">#-I../../</span></span><br><span class="line"></span><br><span class="line">CPPFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.cpp文件</span></span><br><span class="line">CFILES = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span><span class="comment">#遍历得到当前目录及上层目录中的所有.c文件</span></span><br><span class="line"></span><br><span class="line">OBJFILE = $(CFILES:.c=.o) $(CPPFILES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJFILE)</span></span><br><span class="line"><span class="comment"># 编译得到 .so 文件用下面的代码</span></span><br><span class="line"><span class="comment">#   $(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@</span></span><br><span class="line"><span class="comment"># 编译得到可执行文件用下面的代码</span></span><br><span class="line">        <span class="variable">$(LINK)</span> <span class="variable">$^</span> <span class="variable">$(LIBS)</span> -Wall -O2 -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(CCFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">        <span class="variable">$(CPP)</span> -o <span class="variable">$@</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> <span class="variable">$(INCLUDES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJFILE)</span></span><br></pre></td></tr></table></figure><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shell</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;make文件目录&quot;&gt;&lt;a href=&quot;#make文件目录&quot; class=&quot;headerlink&quot; title=&quot;make文件目录&quot;&gt;&lt;/a&gt;make文件目录&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://peitianyu.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
